<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
:root {
    --bg-color: #000;
    --panel-bg: rgba(10, 12, 16, 0.96);
    --panel-border: rgba(34, 197, 94, 0.3);
    --text-main: #4ade80;
    --text-muted: #86efac;
    --accent: #22c55e;
    --accent-glow: rgba(34, 197, 94, 0.4);
    --danger: #ef4444;
    --info: #3b82f6; /* Preserved from existing */
    --warn: #f59e0b; /* Preserved from existing */
    --safe-top: env(safe-area-inset-top, 20px);
    --safe-right: env(safe-area-inset-right, 20px);
}
#fps-counter {
    position: fixed;
    top: 10px;
    left: 10px;
    color: var(--text-main);
    font-family: monospace;
    font-size: 14px;
    z-index: 10000; /* Ensure it is above the canvas */
    text-shadow: 0 0 5px var(--accent-glow);
    padding: 2px 5px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    user-select: none;
}
        * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        html, body {
    height: 100%;
    font-family: 'Segoe UI', 'Roboto', monospace;
    background-color: var(--bg-color);
    overscroll-behavior: none;
    overflow: hidden; /* Retained from existing style */
}
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; transform: translateZ(0); -webkit-transform: translateZ(0); }
        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }
        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }
        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }
        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }
        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        #tabTrack { display: inline-flex; width: max-content; }
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }
        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }
        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }
        .accordion-subheader {
            margin-top: 0.75rem; margin-bottom: 0.2rem;
            font-size: 0.85rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 3px;
            padding-left: 0.25rem;
        }
        .info-description {
            font-size: 1.0rem;
            color: var(--text-muted);
            padding: 0.5rem 0.25rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .faq-item {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        .faq-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .faq-question {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }
        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}
/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1.5rem;
    border-radius: 6px;
    margin-top: 1.5rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
    text-align: center;
    margin-bottom: 0.5rem;
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; margin-right: 10px; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: 25%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px; margin-right: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }
        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 10000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }
        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }
        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
        input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }
        /* Color List Styling */
        .color-list-wrapper { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; width: 100%; margin-top: 8px; }
        .color-list-item { position: relative; display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; }
        .color-list-item input[type="color"] { width: 48px; height: 48px; border-width: 2px; }
        .btn-icon-remove {
            position: absolute; top: -6px; right: -6px;
            width: 20px; height: 20px; border-radius: 50%;
            background: #ef4444; color: white; border: 1px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; cursor: pointer; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            line-height: 1; padding-bottom: 2px;
        }
        .btn-icon-add {
            width: 48px; height: 48px; border-radius: 50%;
            border: 2px dashed var(--accent);
            background: rgba(34, 197, 94, 0.1);
            color: var(--accent);
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            line-height: 1; padding-bottom: 3px;
        }
        .btn-icon-add:hover { background: rgba(34, 197, 94, 0.3); transform: scale(1.05); }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }
        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }
        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }
        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        #menuToggle {
    position: fixed;
    top: max(0.75em, var(--safe-top));
    right: max(1.2em, var(--safe-right));
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--panel-border);
    background: rgba(10, 12, 16, 0.6);
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 30;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px); /* Retained from existing style */
    cursor: pointer; /* Retained from existing style */
}
#menuToggle:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 20px var(--accent);
    transform: rotate(30deg);
}
        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
/* --- MODAL UI --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 50;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
    backdrop-filter: blur(5px);
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
    background: var(--panel-bg); border: 1px solid var(--accent);
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
    width: 90%; max-width: 600px;
    border-radius: 8px;
    display: flex; flex-direction: column;
    max-height: 90vh;
}
.modal-header {
    padding: 1rem; border-bottom: 1px solid var(--panel-border);
    display: flex; justify-content: space-between; align-items: center;
    background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
}
.modal-title { font-size: 1.1rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; margin: 0; }
.modal-close { cursor: pointer; color: var(--text-muted); font-size: 1.5rem; line-height: 1; }
.modal-close:hover { color: var(--danger); }
.modal-body { padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; }
.modal-footer {
    padding: 1rem; border-top: 1px solid var(--panel-border);
    display: flex; justify-content: flex-end; gap: 1rem;
}
textarea.char-input {
    width: 100%; height: 100px; background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1); color: var(--text-main);
    padding: 0.5rem; font-family: monospace; font-size: 1rem;
    resize: vertical;
}
textarea.char-input:focus { outline: none; border-color: var(--accent); }
.modal-label { display: block; margin-bottom: 0.5rem; color: #fff; font-size: 0.9rem; font-weight: bold; }
.modal-desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; }
/* --- CHARACTER SELECTOR REFINEMENTS --- */
/* Fix label colors */
.checkbox-row span {
    color: var(--text-main);
    font-size: 0.95rem;
    font-weight: 600;
}
/* Character Grid */
.char-grid-container {
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 10px;
    max-height: 250px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 8px;
    margin-top: 10px;
}
.char-grid-item {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 20px;
    color: var(--text-muted);
    user-select: none;
    transition: all 0.2s;
}
.char-grid-item:hover {
    border-color: var(--accent);
    background: rgba(34, 197, 94, 0.2);
    color: #fff;
}
.char-grid-item.selected {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent-glow);
}
.char-grid-item.empty {
    opacity: 0.3;
    pointer-events: none;
    background: #000;
}
.char-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.scan-status {
    font-size: 0.8rem;
    color: var(--warn);
    margin-top: 5px;
    min-height: 1.2em;
}
</style>
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E">
</head>
<body>
    <div id="fps-counter" style="display: none;">FPS: 60</div>
    <!-- Primary Canvas for Matrix Animation -->
    <canvas id="matrixCanvas" aria-label="Matrix Digital Rain Animation"></canvas>
    <!-- Hidden Bloom Canvas for Layer Effects -->
    <canvas id="bloomCanvas" hidden aria-hidden="true"></canvas>
    <!-- Toggle Button for Opening Settings Menu -->
    <button id="menuToggle" aria-controls="settingsPanel" aria-expanded="false" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03 .66.07 .98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"></path>
        </svg>
    </button>
    <!-- Input for Importing Files -->
    <input type="file" id="importFile" accept=".json" hidden aria-label="Import JSON Configuration" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" hidden aria-label="Import Font Files" />
    <!-- Settings Panel -->
    <aside id="settingsPanel" role="dialog" aria-hidden="true">
        <header id="panelHeader" role="banner">
            <h2 class="panel-title">Settings</h2>
        </header>
        <!-- Navigation Tabs -->
        <nav id="navTabs" role="tablist" aria-label="Settings Navigation"></nav>
        <!-- Content Area -->
        <main id="contentArea">
            <!-- Dynamic content will populate through scripts -->
        </main>
        <!-- Panel Footer -->
        <footer id="panelFooter">
            <p id="globalStatus" class="status-msg"></p>
        </footer>
    </aside>
<script type="x-shader/x-fragment" id="BASETEMPLATE.glsl">
// base_template.glsl
precision highp float;                    // highp for desktop; switch to mediump for mobile if needed
uniform sampler2D uTexture;
uniform vec2      uResolution;            // (width, height)
uniform float     uTime;                  // seconds
uniform vec2      uMouse;                 // normalized [0..1]
uniform float     uParameter;             // UI slider [0..1]
varying vec2      vTexCoord;
void main() {
    vec4 base = texture2D(uTexture, vTexCoord);
    gl_FragColor = base;                  // start from base; 
}
</script>
<script type="x-shader/x-fragment" id="crt_monitor.glsl">
// Name: CRT Monitor
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uParameter;
varying vec2 vTexCoord;
// Change this value to make the lines denser!
// It represents the WIDTH/HEIGHT of one grid cell in pixels.
const float GRID_CELL_SIZE = 2.0; // Lower numbers = lines closer together, but line thickness is proportional
const float LINE_THICKNESS = 0.3;
const vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);
const float GRID_OPACITY = 0.5;
// CRT Color Shift (Chromatic Aberration) Settings
const float SHIFT_AMOUNT = 0.01;       // Magnitude of the color fringe (very small)
// Brightness Boost (Thresholding/Glow) Settings
const float BRIGHTNESS_THRESHOLD = 0.3;  // Only pixels brighter than this will be boosted
const float BRIGHTNESS_BOOST = 1.6;      // How much to multiply bright colors by
// --- Barrel Distortion Settings ---
const float BARREL_DISTORTION_AMOUNT = 1.0; // Controls the bulge magnitude (0.0 to 1.0)
void main() {
    // --- 1. CRT Barrel Distortion (Warp) ---
    // A. Center coordinates: shifts vTexCoord from [0.0, 1.0] to [-0.5, 0.5]
    vec2 centeredCoord = vTexCoord - 0.5;
    // B. Calculate distance squared from center
    // The distortion effect should be stronger in the corners than in the middle.
    // dot(v, v) is a fast way to get length squared (r*r).
    float r2 = dot(centeredCoord, centeredCoord); 
    // C. Calculate the distortion factor
    // The factor must be > 1.0 for a convex (bulging) look. 
    // It's calculated by adding a fraction of the distance (r2) to 1.0.
    float factor = 1.0 + r2 * (BARREL_DISTORTION_AMOUNT * uParameter * 0.25);
    // D. Apply the factor and shift back to 0.0-1.0 range
    // This coordinate will be our base for sampling the warped image.
    vec2 warpedTexCoord = centeredCoord * factor + 0.5;
    // --- Boundary Check ---
    // If the warped coordinate is outside [0.0, 1.0], it's smeared/clipped.
    // The 'any' function checks if any component (x or y) of the boolean vector is true.
    if (any(lessThan(warpedTexCoord, vec2(0.0))) || any(greaterThan(warpedTexCoord, vec2(1.0)))) {
        // If the coordinate is outside the bounds, output black (or transparent)
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return; // Exit the shader immediately to skip all further calculations
    }
    // --- 2. CRT Chromatic Shift (Red/Blue Fringing) ---
    // The centerBias calculation remains based on the original vTexCoord 
    // to keep the color shift aligned with the screen's surface.
    vec2 pixelCoord = vTexCoord * uResolution.xy;
    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;
    vec2 fractionalPart = fract(scaledCoord);
    float centerBias = fractionalPart.x - 0.5; 
    float shiftMagnitude = sin(centerBias * 3.14159265); 
    // Sample the texture three times using the **warpedTexCoord** as the base
    vec2 redCoord   = warpedTexCoord + vec2(-shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);
    vec2 blueCoord  = warpedTexCoord + vec2( shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);
    // Use the base warped coordinate for the green channel
    float red   = texture2D(uTexture, redCoord).r;
    float green = texture2D(uTexture, warpedTexCoord).g; 
    float blue  = texture2D(uTexture, blueCoord).b;
    vec4 finalColor = vec4(red, green, blue, 1.0);
    // --- 3. Static Grid Overlay ---
    // The grid lines are calculated using the original screen coordinate (vTexCoord)
    // which simulates the grid being painted onto the curved glass.
    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);
    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);
    float gridMask = min(verticalLine + horizontalLine, 1.0);
    // Apply the grid
    vec3 blendedColor = mix(finalColor.rgb, GRID_COLOR, gridMask);
    finalColor.rgb = mix(finalColor.rgb, blendedColor, GRID_OPACITY);
    // --- 4. Brightness Boost (Thresholding/Glow Effect) ---
    float brightness = dot(finalColor.rgb, vec3(0.2126, 0.7152, 0.0722));
    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);
    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);
    finalColor.rgb *= finalMultiplier;
    // 5. Output Final Color
    gl_FragColor = finalColor;
}
</script>
<script type="x-shader/x-fragment" id="dirty_LCD.glsl">
// Name: Dirty LCD Monitor
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uParameter;
varying vec2 vTexCoord;
// Change this value to make the lines denser!
// It represents the WIDTH/HEIGHT of one grid cell in pixels.
const float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional
const float LINE_THICKNESS = 0.4;
const vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);
const float GRID_OPACITY = 0.5;
// Adding grain dirtyness to the screen
const float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable
// Random graininess
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
// Boosting Pixel Brightness
const float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted
const float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by
void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec2 pixelCoord = vTexCoord * uResolution.xy;
    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;
    vec2 fractionalPart = fract(scaledCoord);
    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);
    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);
    float gridMask = min(verticalLine + horizontalLine, 1.0);
    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);
    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY);
    // 1. Calculate the final grid-processed color's overall brightness (Luminance).
    float brightness = dot(color.rgb, vec3(0.1126, 0.7152, 0.0522));
    // 2. Determine the boost factor
    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.
    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.
    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);
    // 3. Apply the boost to the color channels.
    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.
    // mix(Color A, Color B, Factor)
    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)
    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)
    float finalMultiplier = mix(uParameter + 1.0, BRIGHTNESS_BOOST, boostFactor * uParameter);
    color.rgb *= finalMultiplier;
    // 5. Calculate static noise    
    float noiseValue = random(vTexCoord);
    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]
    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]
    // * 2.0 expands the range to [-1.0, 1.0]
    float finalNoise = (noiseValue - 0.5) * 2.0;
    // 6. Apply grain to the color
    // We only apply the noise to the Red, Green, and Blue channels (.rgb).
    // The noise value is scaled by the GRAIN_AMOUNT.
    // A negative noise makes the pixel darker, a positive noise makes it brighter.
    color.rgb += finalNoise * GRAIN_AMOUNT;
    // 7. Output final color
    gl_FragColor = color;
}
</script>
<script type="x-shader/x-fragment" id="double_vision.glsl">
// Name: Double Vision
precision mediump float;
// Inputs provided by the application
uniform sampler2D uTexture;
uniform float uTime;
uniform float uParameter;
varying vec2 vTexCoord;
// Configuration for the effect
const float BLUR_SAMPLES = 2.0; // How many times to sample the texture (higher = smoother but slower)
const float BLUR_AMOUNT = 0.0001; // How intense the blur is
void main() {
    // 1. Center the coordinates
    // We shift vTexCoord (0.0 to 1.0) so that the center of the screen is (0.0, 0.0).
    vec2 center = vec2(0.5, 0.5); // The blur's origin point (center of the screen)
    vec2 direction = vTexCoord - center; // Vector pointing from center to the current pixel
    // 2. Initialize the final color
    // We start with a black color (vec4(0.0))
    vec4 finalColor = vec4(0.0);
    // 3. Loop through samples
    for (float i = 0.0; i < BLUR_SAMPLES; i++) {
        // Calculate the current step along the blur ray.
        // The 'mix' function smoothly interpolates (mixes) between two values.
        // It's used here to define a position along the ray from 0.0 (center) to 1.0 (current pixel).
        float step = i / (BLUR_SAMPLES - 1.0);
        // Calculate the new coordinate for this sample.
        // This coordinate is closer to the center than the original vTexCoord.
        vec2 sampleCoord = mix(vTexCoord, center, step * BLUR_AMOUNT * (uParameter * 10.0) * 100.0);
        // --- IMPORTANT LOGIC EXPLAINED BELOW ---
        // 'mix(A, B, t)' returns A*(1-t) + B*t. 
        // We use 'step * BLUR_AMOUNT * 100.0' to control how much to mix towards the center.
        // The factor of 100.0 turns the small BLUR_AMOUNT (e.g., 0.005) into a more usable ratio (e.g., 0.5).
        // Sample the color at the new, shifted coordinate
        vec4 sampledColor = texture2D(uTexture, sampleCoord);
        // Add the sampled color to our final average
        finalColor += sampledColor;
    }
    // 4. Calculate the average color
    // Divide the accumulated colors by the number of samples taken.
    gl_FragColor = finalColor / BLUR_SAMPLES;
}
</script>
<script type="x-shader/x-fragment" id="edge_glow_sobel.glsl">
// Name: Edge Glow (Sobel)
precision highp float;
uniform sampler2D uTexture;
uniform vec2      uResolution;
uniform float     uTime;
uniform vec2      uMouse;
uniform float     uParameter;
varying vec2      vTexCoord;
void main() {
    vec2 uv = vTexCoord;
    vec2 px = 1.0 / uResolution;          // perâ€‘pixel offsets
    // Luma samples
    float tl = dot(texture2D(uTexture, uv + px*vec2(-1,  1)).rgb, vec3(0.2126,0.7152,0.0722));
    float  l = dot(texture2D(uTexture, uv + px*vec2(-1,  0)).rgb, vec3(0.2126,0.7152,0.0722));
    float bl = dot(texture2D(uTexture, uv + px*vec2(-1, -1)).rgb, vec3(0.2126,0.7152,0.0722));
    float  t = dot(texture2D(uTexture, uv + px*vec2( 0,  1)).rgb, vec3(0.2126,0.7152,0.0722));
    float  b = dot(texture2D(uTexture, uv + px*vec2( 0, -1)).rgb, vec3(0.2126,0.7152,0.0722));
    float tr = dot(texture2D(uTexture, uv + px*vec2( 1,  1)).rgb, vec3(0.2126,0.7152,0.0722));
    float  r = dot(texture2D(uTexture, uv + px*vec2( 1,  0)).rgb, vec3(0.2126,0.7152,0.0722));
    float br = dot(texture2D(uTexture, uv + px*vec2( 1, -1)).rgb, vec3(0.2126,0.7152,0.0722));
    float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
    float gy =  tl + 2.0*t + tr - bl - 2.0*b - br;
    float edge = sqrt(gx*gx + gy*gy);
    vec4 base = texture2D(uTexture, uv);
    float glowAmt = mix(0.0, 0.6, uParameter);
    base.rgb += edge * glowAmt;
    gl_FragColor = clamp(base, 0.0, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="film_grain.glsl">
// Name: Dirty Film Grain
precision mediump float;
// Uniforms provided by PostProcessor.js
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform float uParameter;
// Use vTexCoord from Vertex Shader for correct orientation
varying vec2 vTexCoord;
// Shader Configuration
const float GRAIN_AMOUNT = 0.1; // Intensity of the grain (0.0 to 1.0)
const bool ANIMATED = true;      // Whether the grain dances (true) or is static (false)
const float SPEED = 2.2;         // Speed of grain animation
// Random function
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
void main() {
    // Sample the original texture using standard texture coordinates
    vec4 color = texture2D(uTexture, vTexCoord);
    // Calculate noise
    // We can use gl_FragCoord or vTexCoord for noise seed
    float t = ANIMATED ? uTime * SPEED : 0.0;
    // Generate random noise value [-1.0, 1.0]
    float noise = (random(vTexCoord + t) - 0.5) * 2.0;
    // Apply grain
    color.rgb += noise * ((uParameter - 0.1) + GRAIN_AMOUNT);
    // Output final color
    gl_FragColor = color;
}
</script>
<script type="x-shader/x-fragment" id="hue_shift.glsl">
// Name: Hue Shift
precision highp float;
uniform sampler2D uTexture;
uniform vec2      uResolution;
uniform float     uTime;
uniform vec2      uMouse;
uniform float     uParameter;
varying vec2      vTexCoord;
vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);
}
vec3 hsv2rgb(vec3 c){
    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}
void main() {
    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;
    vec3 hsv = rgb2hsv(rgb);
    hsv.x = fract(hsv.x + uTime * 0.05 * (0.2 + 0.8*uParameter));           // animate hue
    hsv.y *= mix(1.0, 0.35, uParameter);                                    // desaturate
    vec3 outc = hsv2rgb(hsv);
    gl_FragColor = vec4(outc, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="mouse_ripple.glsl">
// Name: Mouse Lens Ripple
precision highp float;
uniform sampler2D uTexture;
uniform vec2      uResolution;
uniform float     uTime;
uniform vec2      uMouse;
uniform float     uParameter;
varying vec2      vTexCoord;
void main() {
    vec2 uv = vTexCoord;
    vec2 center = vec2(uMouse.x, 1.0 - uMouse.y);
    float radius = mix(0.02, 0.60, uParameter);
    float dist = distance(uv, center);
    float mask = smoothstep(radius, 0.0, dist);
    // Dynamic ripple offset
    float wave = sin(24.0*dist - 4.0*uTime) * 0.003 * uParameter;
    vec2 dir = normalize(uv - center);
    uv += dir * wave * mask;
    // Mild magnification inside the lens
    float magnify = mix(1.0, 1.15, uParameter);
    uv = mix(uv, center + (uv - center)/magnify, mask);
    gl_FragColor = texture2D(uTexture, uv);
}
</script>
<script type="x-shader/x-fragment" id="pixelate.glsl">
// Name: Pixelate
precision highp float;
uniform sampler2D uTexture;
uniform vec2      uResolution;
uniform float     uTime;
uniform vec2      uMouse;
uniform float     uParameter;
varying vec2      vTexCoord;
void main() {
    float scale = mix(1.0, 0.15, uParameter);      // 1.0 no pixelate; 0.15 heavy
    vec2 grid = floor(vTexCoord * uResolution * scale) / (uResolution * scale);
    vec4 color = texture2D(uTexture, grid);
    gl_FragColor = color;
}
</script>
<script type="x-shader/x-fragment" id="screen_door.glsl">
// Name: Screen Door
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uParameter;
varying vec2 vTexCoord;
// Change this value to make the lines denser!
// It represents the WIDTH/HEIGHT of one grid cell in pixels.
const float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional
const float LINE_THICKNESS = 0.4;
const vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);
const float GRID_OPACITY = 0.5;
// Boosting Pixel Brightness
const float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted
const float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by
void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec2 pixelCoord = vTexCoord * uResolution.xy;
    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;
    vec2 fractionalPart = fract(scaledCoord * uParameter);
    float verticalLine = step(fractionalPart.x, LINE_THICKNESS * uParameter + 0.1);
    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS * uParameter + 0.1);
    float gridMask = min(verticalLine + horizontalLine, 1.0);
    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);
    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY * uParameter);
    // 1. Calculate the final grid-processed color's overall brightness (Luminance).
    float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
    // 2. Determine the boost factor
    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.
    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.
    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);
    // 3. Apply the boost to the color channels.
    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.
    // mix(Color A, Color B, Factor)
    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)
    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)
    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);
    color.rgb *= finalMultiplier;
    gl_FragColor = color;
}
</script>
<script type="x-shader/x-fragment" id="smear_LCDgrid.glsl">
// Name: Vertical Smear + LED Grid
// Vertical Smear (upwards only) + LED Matrix Grid (faded, brightness-aware)
// Uniforms: uTexture, uResolution, uTime, uMouse, uParameter, vTexCoord
// uParameter drives the smear length in pixels: 0.0 = none, 1.0 = MAX_SMEAR_PX
precision mediump float;
uniform sampler2D uTexture;
uniform vec2      uResolution;
uniform float     uTime;
uniform vec2      uMouse;
uniform float     uParameter;
varying vec2      vTexCoord;
// ------------------- Tunables -------------------
// If the smear still goes the wrong way, flip this sign to -1.0.
// +1.0 means "sample from above" when vTexCoord.y increases toward the top.
// -1.0 means "sample from below".
const float Y_SIGN            = +1.0;
const float MAX_SMEAR_PX      = 48.0;   // max smear length (pixels) at uParameter=1
const float SMEAR_DECAY       = 0.30;   // exponential falloff per tap (higher = faster decay)
const int   SMEAR_TAPS_COUNT  = 8;      // unrolled taps count (do not change in code block)
// Smear applies more strongly to bright glyphs.
// Raise or lower the range to taste.
const float SMEAR_LUMA_MIN    = 0.30;   // start applying smear above this luma
const float SMEAR_LUMA_MAX    = 0.85;   // full smear by this luma
// LED grid parameters
const float GRID_SPACING_PX   = 8.0;    // cell size (pixels)
const float GRID_THICKNESS_PX = 1.0;    // seam thickness (pixels)
const float GRID_FADE_MAX     = 0.15;   // max darkening on grid lines
const float GRID_CROSS_GLOW   = 0.02;   // tiny highlight at intersections
const float GRID_LUMA_POWER   = 1.2;    // tie grid visibility to luma (>=1.0 less persistent in dark)
// ------------------- Helpers -------------------
float luma(vec3 c) {
    // Rec.709 luma
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}
// Sample along vertical with Y_SIGN and clamp to [0,1] range.
vec3 sampleVertical(vec2 uv, float offsetPx, vec2 px) {
    float y = clamp(uv.y + Y_SIGN * offsetPx * px.y, 0.0, 1.0);
    return texture2D(uTexture, vec2(uv.x, y)).rgb;
}
// Upward-only smear via unrolled taps for WebGL1 stability.
vec3 smearUp(vec2 uv, float smearLenPx, float brightnessFactor) {
    // brightnessFactor scales how much we mix the smear in (from 0..1)
    vec2  px    = 1.0 / uResolution;
    float stepPx= smearLenPx / float(SMEAR_TAPS_COUNT);
    vec3 accum  = texture2D(uTexture, uv).rgb;
    float wsum  = 1.0;
    // Unrolled 8 taps with exponential weights
    {
        float w1 = exp(-1.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 1.0, px) * w1;
        wsum  += w1;
        float w2 = exp(-2.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 2.0, px) * w2;
        wsum  += w2;
        float w3 = exp(-3.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 3.0, px) * w3;
        wsum  += w3;
        float w4 = exp(-4.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 4.0, px) * w4;
        wsum  += w4;
        float w5 = exp(-5.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 5.0, px) * w5;
        wsum  += w5;
        float w6 = exp(-6.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 6.0, px) * w6;
        wsum  += w6;
        float w7 = exp(-7.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 7.0, px) * w7;
        wsum  += w7;
        float w8 = exp(-8.0 * SMEAR_DECAY);
        accum += sampleVertical(uv, stepPx * 8.0, px) * w8;
        wsum  += w8;
    }
    vec3 smeared = accum / wsum;
    // Mix based on glyph brightness so darker glyphs retain less shadow,
    // matching your observation.
    vec3 base    = texture2D(uTexture, uv).rgb;
    float lum    = luma(base);
    float mixAmt = brightnessFactor * smoothstep(SMEAR_LUMA_MIN, SMEAR_LUMA_MAX, lum);
    return mix(base, smeared, mixAmt);
}
// LED grid mask in pixel space (gl_FragCoord).
// Returns line intensity in 0..1.
float gridMask(vec2 frag) {
    float modX  = mod(frag.x, GRID_SPACING_PX);
    float distX = min(modX, GRID_SPACING_PX - modX);
    float modY  = mod(frag.y, GRID_SPACING_PX);
    float distY = min(modY, GRID_SPACING_PX - modY);
    float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);
    float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);
    return max(lineX, lineY);
}
void main() {
    vec2 uv         = vTexCoord;
    vec4 base4      = texture2D(uTexture, uv);
    vec3 base       = base4.rgb;
    vec2 frag       = gl_FragCoord.xy;
    // Smear length driven by uParameter (pixels)
    float smearLenPx = clamp(uParameter, 0.0, 1.0) * MAX_SMEAR_PX;
    // Smear strength factor (independent of luma ramp)
    float smearStrength = 1.0; // keep 1.0; you can expose a second uniform if desired
    // Upward-only smear with brightness-aware mixing
    vec3 color = smearUp(uv, smearLenPx, smearStrength);
    // LED grid faded by brightness so it is less persistent in dark regions
    float gridI   = gridMask(frag);
    float lum     = pow(luma(color), GRID_LUMA_POWER); // make grid respond more to bright glyphs
    float fadeAmt = GRID_FADE_MAX * lum;               // reduce grid visibility in dark areas
    color *= mix(1.0, 1.0 - fadeAmt, gridI);
    // Tiny intersection glow (also brightness-aware)
    if (GRID_CROSS_GLOW > 0.0) {
        float modX  = mod(frag.x, GRID_SPACING_PX);
        float distX = min(modX, GRID_SPACING_PX - modX);
        float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);
        float modY  = mod(frag.y, GRID_SPACING_PX);
        float distY = min(modY, GRID_SPACING_PX - modY);
        float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);
        color += vec3(GRID_CROSS_GLOW) * (lineX * lineY) * lum;
    }
    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
}
</script>
<script type="x-shader/x-fragment" id="static_grain.glsl">
// Name: Static Grain
precision mediump float;
// Inputs provided by the application
uniform sampler2D uTexture;
uniform float uParameter;
// uniform float uTime; // NOT needed for static grain
varying vec2 vTexCoord;
// Shader Configuration
const float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable
// 1. Random function
// Generates a seemingly random float based on the input coordinate 'st'.
float random(vec2 st) {
    // This uses a "magic" dot product and large number to generate noise.
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
void main() {
    // 2. Sample the original texture
    vec4 color = texture2D(uTexture, vTexCoord);
    // 3. Calculate static noise
    // The key here is to pass only the coordinate (vTexCoord) to the random function.
    // We are NOT using 'uTime', so the result for any given coordinate is always the same.
    float noiseValue = random(vTexCoord);
    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]
    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]
    // * 2.0 expands the range to [-1.0, 1.0]
    float finalNoise = (noiseValue - 0.5) * 2.0;
    // 4. Apply grain to the color
    // We only apply the noise to the Red, Green, and Blue channels (.rgb).
    // The noise value is scaled by the GRAIN_AMOUNT.
    // A negative noise makes the pixel darker, a positive noise makes it brighter.
    color.rgb += finalNoise * (uParameter * 0.5);
    // 5. Output final color
    gl_FragColor = color;
}
</script>
<script type="application/json" id="matrix_conf_v7.7_Presets.json">
{
  "version": "7.7",
  "state": {
    "streamColor": "#65d778",
    "streamPalette": [
      "#1cc427",
      "#4fba64",
      "#7bd279"
    ],
    "paletteBias": 0,
    "tracerColor": "#cfe8ce",
    "fontSize": 33,
    "streamSpeed": 18,
    "releaseInterval": 4,
    "resolution": 1,
    "enableGlyphAtlas": true,
    "smoothingEnabled": false,
    "smoothingAmount": 0.1,
    "showFpsCounter": true,
    "fontFamily": "CustomFont_5e2697679380fc43",
    "fontWeight": "normal",
    "italicEnabled": false,
    "mirrorEnabled": false,
    "variableBrightnessEnabled": true,
    "brightnessVariance": 11,
    "overlapEnabled": true,
    "overlapColor": "#d4f339",
    "overlapDensity": 0.1,
    "overlapTarget": "stream",
    "overlapShimmer": false,
    "dissolveEnabled": false,
    "dissolveMinSize": 20,
    "deteriorationEnabled": false,
    "deteriorationStrength": 3,
    "enableBloom": true,
    "bloomStrength": 4,
    "bloomOpacity": 0.6,
    "tracerGlow": 30,
    "clearAlpha": 0.65,
    "horizontalSpacingFactor": 0.85,
    "verticalSpacingFactor": 0.95,
    "fontOffsetX": 0,
    "fontOffsetY": 0,
    "stretchX": 1,
    "stretchY": 1,
    "decayFadeDurationFrames": 55,
    "streamSpawnCount": 2,
    "eraserSpawnCount": 18,
    "minStreamGap": 2,
    "minEraserGap": 2,
    "holeRate": 0,
    "desyncIntensity": 0.3,
    "eraserStopChance": 0,
    "tracerStopChance": 0,
    "tracerAttackFrames": 0,
    "tracerHoldFrames": 2,
    "tracerReleaseFrames": 8,
    "invertedTracerEnabled": true,
    "invertedTracerChance": 0.1,
    "rotatorEnabled": true,
    "rotatorChance": 0.5,
    "rotatorSyncToTracer": true,
    "rotatorSyncMultiplier": 0.1,
    "rotatorCycleFactor": 20,
    "rotatorCrossfadeFrames": 2,
    "shaderEnabled": true,
    "customShader": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}",
    "pulseEnabled": false,
    "pulseFrequencySeconds": 300,
    "pulseDurationSeconds": 1.2,
    "pulsePreserveSpaces": true,
    "pulseIgnoreTracers": true,
    "pulseDimming": 0.2,
    "pulseBlend": false,
    "pulseWidth": 130,
    "pulseRandomPosition": true,
    "pulseInstantStart": false,
    "pulseCircular": false,
    "clearPulseEnabled": false,
    "clearPulseFrequencySeconds": 235,
    "clearPulseDurationSeconds": 0.7,
    "clearPulsePreserveSpaces": true,
    "clearPulseBlend": false,
    "clearPulseWidth": 190,
    "clearPulseRandomPosition": true,
    "clearPulseInstantStart": false,
    "clearPulseCircular": false,
    "miniPulseEnabled": false,
    "miniPulseFrequencySeconds": 450,
    "miniPulseDurationSeconds": 5,
    "miniPulsePreserveSpaces": true,
    "miniPulseThickness": 100,
    "miniPulseSpawnChance": 0.06,
    "miniPulseSpeed": 16,
    "miniPulseSize": 360,
    "dejaVuEnabled": false,
    "dejaVuFrequencySeconds": 350,
    "dejaVuDurationSeconds": 5,
    "dejaVuMinRectHeight": 1,
    "dejaVuMaxRectHeight": 10,
    "dejaVuHoleBrightness": 0.02,
    "dejaVuRandomizeColors": false,
    "dejaVuIntensity": 0.1,
    "dejaVuBarDurationFrames": 28,
    "dejaVuVarianceFrames": 43,
    "supermanEnabled": false,
    "supermanFrequencySeconds": 290,
    "supermanDurationSeconds": 6,
    "supermanIncludeColors": true,
    "supermanFadeSpeed": 6,
    "supermanGlow": 4,
    "supermanBoltThickness": 5,
    "supermanFlickerRate": 2,
    "supermanWidth": 4,
    "supermanSpawnSpeed": 69,
    "starPowerEnabled": false,
    "starPowerRainbowMode": "char",
    "starPowerSaturation": 100,
    "starPowerIntensity": 51,
    "starPowerGlitter": false,
    "starPowerColorCycle": true,
    "starPowerCycleSpeed": 5,
    "rainbowStreamEnabled": false,
    "rainbowStreamChance": 0.5,
    "rainbowStreamIntensity": 50,
    "firewallEnabled": false,
    "firewallFrequencySeconds": 150,
    "firewallRandomColorEnabled": true,
    "firewallColor": "#00ff00",
    "firewallReverseDurationFrames": 20,
    "firewallEraseDurationFrames": 50,
    "bootSequenceEnabled": false,
    "crashEnabled": false,
    "crashFrequencySeconds": 600,
    "runBothInOrder": false,
    "keyBindings": {
      "Pulse": "p",
      "ClearPulse": "w",
      "MiniPulse": "e",
      "DejaVu": "r",
      "Superman": "t",
      "Firewall": "y",
      "ToggleUI": " ",
      "BootSequence": "b",
      "CrashSequence": "x",
      "BootCrashSequence": "c"
    },
    "hideMenuIcon": true,
    "fontSettings": {
      "MatrixEmbedded": {
        "active": false,
        "useCustomChars": false,
        "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"
      },
      "CustomFont_5e2697679380fc43": {
        "active": true,
        "useCustomChars": true,
        "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy",
        "useAllChars": false
      }
    },
    "deteriorationType": "ghost",
    "tracerSizeIncrease": 1,
    "supermanProb": 4,
    "dejaVuAutoMode": true,
    "clearPulseIgnoreTracers": true,
    "dejaVuPerformanceMode": false,
    "pulseDelayFrames": 60,
    "minGapTypes": 1,
    "rotateDuringFade": true,
    "rotatorDesyncEnabled": true,
    "rotatorDesyncVariance": 60,
    "suppressToasts": false,
    "ttlMinSeconds": 1,
    "ttlMaxSeconds": 8,
    "shaderParameter": 0.14,
    "pulseDelaySeconds": 0.7,
    "starPowerFreq": 100
  },
  "savedPresets": [
    {
      "name": "Trilogy",
      "data": {
        "streamColor": "#65d778",
        "streamPalette": [
          "#29bc62"
        ],
        "paletteBias": 0,
        "tracerColor": "#d9f2f2",
        "fontSize": 25,
        "streamSpeed": 16,
        "releaseInterval": 2,
        "resolution": 1,
        "enableGlyphAtlas": true,
        "smoothingEnabled": true,
        "smoothingAmount": 0.4,
        "showFpsCounter": true,
        "fontFamily": "MatrixEmbedded",
        "fontWeight": "normal",
        "italicEnabled": false,
        "mirrorEnabled": false,
        "variableBrightnessEnabled": true,
        "brightnessVariance": 20,
        "overlapEnabled": false,
        "overlapColor": "#FFD700",
        "overlapDensity": 0.2,
        "overlapTarget": "all",
        "overlapShimmer": false,
        "dissolveEnabled": true,
        "dissolveMinSize": 18,
        "deteriorationEnabled": true,
        "deteriorationStrength": 4,
        "enableBloom": true,
        "bloomStrength": 3,
        "bloomOpacity": 0.35,
        "tracerGlow": 19,
        "clearAlpha": 0.65,
        "horizontalSpacingFactor": 0.7,
        "verticalSpacingFactor": 1,
        "fontOffsetX": 0,
        "fontOffsetY": 6,
        "stretchX": 1,
        "stretchY": 1.2,
        "decayFadeDurationFrames": 23,
        "streamSpawnCount": 6,
        "eraserSpawnCount": 16,
        "minStreamGap": 30,
        "minEraserGap": 30,
        "holeRate": 0.1,
        "desyncIntensity": 0,
        "eraserStopChance": 1,
        "tracerStopChance": 1,
        "tracerAttackFrames": 3,
        "tracerHoldFrames": 0,
        "tracerReleaseFrames": 5,
        "invertedTracerEnabled": true,
        "invertedTracerChance": 0.1,
        "rotatorEnabled": true,
        "rotatorChance": 0.13,
        "rotatorSyncToTracer": true,
        "rotatorSyncMultiplier": 0.5,
        "rotatorCycleFactor": 20,
        "rotatorCrossfadeFrames": 6,
        "shaderEnabled": false,
        "customShader": "// Name: Dirty LCD Monitor\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional\nconst float LINE_THICKNESS = 0.4;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// Adding grain dirtyness to the screen\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// Random graininess\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Boosting Pixel Brightness\nconst float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by\n\n\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord);\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);\n    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY);\n\n\n    // 1. Calculate the final grid-processed color's overall brightness (Luminance).\n    float brightness = dot(color.rgb, vec3(0.1126, 0.7152, 0.0522));\n\n    // 2. Determine the boost factor\n    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.\n    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    \n    // 3. Apply the boost to the color channels.\n    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.\n    // mix(Color A, Color B, Factor)\n    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)\n    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)\n    float finalMultiplier = mix(uParameter + 1.0, BRIGHTNESS_BOOST, boostFactor * uParameter);\n    \n    color.rgb *= finalMultiplier;\n    \n    // 5. Calculate static noise    \n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 6. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * GRAIN_AMOUNT;\n    \n    // 7. Output final color\n    gl_FragColor = color;\n}",
        "pulseEnabled": true,
        "pulseFrequencySeconds": 300,
        "pulseDurationSeconds": 1.2,
        "pulsePreserveSpaces": true,
        "pulseIgnoreTracers": true,
        "pulseDimming": 0.2,
        "pulseBlend": false,
        "pulseWidth": 130,
        "pulseRandomPosition": true,
        "pulseInstantStart": false,
        "pulseCircular": false,
        "clearPulseEnabled": true,
        "clearPulseFrequencySeconds": 235,
        "clearPulseDurationSeconds": 1.1,
        "clearPulsePreserveSpaces": true,
        "clearPulseBlend": false,
        "clearPulseWidth": 190,
        "clearPulseRandomPosition": true,
        "clearPulseInstantStart": false,
        "clearPulseCircular": false,
        "miniPulseEnabled": true,
        "miniPulseFrequencySeconds": 450,
        "miniPulseDurationSeconds": 5,
        "miniPulsePreserveSpaces": true,
        "miniPulseThickness": 100,
        "miniPulseSpawnChance": 0.06,
        "miniPulseSpeed": 16,
        "miniPulseSize": 360,
        "dejaVuEnabled": true,
        "dejaVuFrequencySeconds": 350,
        "dejaVuDurationSeconds": 5,
        "dejaVuMinRectHeight": 1,
        "dejaVuMaxRectHeight": 10,
        "dejaVuHoleBrightness": 0.02,
        "dejaVuRandomizeColors": false,
        "dejaVuIntensity": 0.1,
        "dejaVuBarDurationFrames": 28,
        "dejaVuVarianceFrames": 43,
        "supermanEnabled": true,
        "supermanFrequencySeconds": 290,
        "supermanDurationSeconds": 6,
        "supermanIncludeColors": true,
        "supermanFadeSpeed": 6,
        "supermanGlow": 4,
        "supermanBoltThickness": 5,
        "supermanFlickerRate": 2,
        "supermanWidth": 4,
        "supermanSpawnSpeed": 69,
        "starPowerEnabled": false,
        "starPowerRainbowMode": "char",
        "starPowerSaturation": 100,
        "starPowerIntensity": 51,
        "starPowerGlitter": false,
        "starPowerColorCycle": true,
        "starPowerCycleSpeed": 3,
        "rainbowStreamEnabled": false,
        "rainbowStreamChance": 0.5,
        "rainbowStreamIntensity": 50,
        "firewallEnabled": false,
        "firewallFrequencySeconds": 150,
        "firewallRandomColorEnabled": true,
        "firewallColor": "#00ff00",
        "firewallReverseDurationFrames": 20,
        "firewallEraseDurationFrames": 50,
        "bootSequenceEnabled": false,
        "crashEnabled": false,
        "crashFrequencySeconds": 600,
        "runBothInOrder": false,
        "keyBindings": {
          "Pulse": "p",
          "ClearPulse": "w",
          "MiniPulse": "e",
          "DejaVu": "r",
          "Superman": "t",
          "Firewall": "y",
          "ToggleUI": " ",
          "BootSequence": "b",
          "CrashSequence": "x",
          "BootCrashSequence": "c"
        },
        "hideMenuIcon": true,
        "fontSettings": {
          "MatrixEmbedded": {
            "active": true,
            "useCustomChars": false,
            "customCharacters": ""
          },
          "CustomFont_5e2697679380fc43": {
            "active": false,
            "useCustomChars": true,
            "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•",
            "useAllChars": false
          }
        },
        "deteriorationType": "ghost",
        "tracerSizeIncrease": 1,
        "supermanProb": 4,
        "dejaVuAutoMode": true,
        "clearPulseIgnoreTracers": true,
        "dejaVuPerformanceMode": false,
        "pulseDelayFrames": 60,
        "minGapTypes": 20,
        "rotateDuringFade": false,
        "rotatorDesyncEnabled": false,
        "rotatorDesyncVariance": 0,
        "suppressToasts": false,
        "ttlMinSeconds": 1,
        "ttlMaxSeconds": 8,
        "shaderParameter": 0.58,
        "pulseDelaySeconds": 0.7,
        "starPowerFreq": 100
      }
    },
    {
      "name": "Neo Code",
      "data": {
        "streamColor": "#65d778",
        "streamPalette": [
          "#1cc427",
          "#20a73b",
          "#1a8118"
        ],
        "paletteBias": 0,
        "tracerColor": "#aadaa9",
        "fontSize": 24,
        "streamSpeed": 17,
        "releaseInterval": 4,
        "resolution": 1,
        "enableGlyphAtlas": true,
        "smoothingEnabled": false,
        "smoothingAmount": 0.1,
        "showFpsCounter": true,
        "fontFamily": "CustomFont_5e2697679380fc43",
        "fontWeight": "normal",
        "italicEnabled": false,
        "mirrorEnabled": false,
        "variableBrightnessEnabled": true,
        "brightnessVariance": 20,
        "overlapEnabled": false,
        "overlapColor": "#FFD700",
        "overlapDensity": 0.2,
        "overlapTarget": "all",
        "overlapShimmer": false,
        "dissolveEnabled": false,
        "dissolveMinSize": 18,
        "deteriorationEnabled": false,
        "deteriorationStrength": 4,
        "enableBloom": true,
        "bloomStrength": 4,
        "bloomOpacity": 0.6,
        "tracerGlow": 32,
        "clearAlpha": 0.35,
        "horizontalSpacingFactor": 0.85,
        "verticalSpacingFactor": 0.95,
        "fontOffsetX": 0,
        "fontOffsetY": 0,
        "stretchX": 1,
        "stretchY": 1,
        "decayFadeDurationFrames": 72,
        "streamSpawnCount": 2,
        "eraserSpawnCount": 18,
        "minStreamGap": 2,
        "minEraserGap": 2,
        "holeRate": 0,
        "desyncIntensity": 0.3,
        "eraserStopChance": 0,
        "tracerStopChance": 0,
        "tracerAttackFrames": 0,
        "tracerHoldFrames": 2,
        "tracerReleaseFrames": 8,
        "invertedTracerEnabled": true,
        "invertedTracerChance": 0.1,
        "rotatorEnabled": true,
        "rotatorChance": 1,
        "rotatorSyncToTracer": true,
        "rotatorSyncMultiplier": 0.1,
        "rotatorCycleFactor": 20,
        "rotatorCrossfadeFrames": 2,
        "shaderEnabled": false,
        "customShader": null,
        "pulseEnabled": false,
        "pulseFrequencySeconds": 300,
        "pulseDurationSeconds": 1.2,
        "pulsePreserveSpaces": true,
        "pulseIgnoreTracers": true,
        "pulseDimming": 0.2,
        "pulseBlend": false,
        "pulseWidth": 130,
        "pulseRandomPosition": true,
        "pulseInstantStart": false,
        "pulseCircular": false,
        "clearPulseEnabled": false,
        "clearPulseFrequencySeconds": 235,
        "clearPulseDurationSeconds": 0.7,
        "clearPulsePreserveSpaces": true,
        "clearPulseBlend": false,
        "clearPulseWidth": 190,
        "clearPulseRandomPosition": true,
        "clearPulseInstantStart": false,
        "clearPulseCircular": false,
        "miniPulseEnabled": false,
        "miniPulseFrequencySeconds": 450,
        "miniPulseDurationSeconds": 5,
        "miniPulsePreserveSpaces": true,
        "miniPulseThickness": 100,
        "miniPulseSpawnChance": 0.06,
        "miniPulseSpeed": 16,
        "miniPulseSize": 360,
        "dejaVuEnabled": false,
        "dejaVuFrequencySeconds": 350,
        "dejaVuDurationSeconds": 5,
        "dejaVuMinRectHeight": 1,
        "dejaVuMaxRectHeight": 10,
        "dejaVuHoleBrightness": 0.02,
        "dejaVuRandomizeColors": false,
        "dejaVuIntensity": 0.1,
        "dejaVuBarDurationFrames": 28,
        "dejaVuVarianceFrames": 43,
        "supermanEnabled": false,
        "supermanFrequencySeconds": 290,
        "supermanDurationSeconds": 6,
        "supermanIncludeColors": true,
        "supermanFadeSpeed": 6,
        "supermanGlow": 4,
        "supermanBoltThickness": 5,
        "supermanFlickerRate": 2,
        "supermanWidth": 4,
        "supermanSpawnSpeed": 69,
        "starPowerEnabled": false,
        "starPowerRainbowMode": "char",
        "starPowerSaturation": 100,
        "starPowerIntensity": 51,
        "starPowerGlitter": false,
        "starPowerColorCycle": true,
        "starPowerCycleSpeed": 5,
        "rainbowStreamEnabled": false,
        "rainbowStreamChance": 0.5,
        "rainbowStreamIntensity": 50,
        "firewallEnabled": false,
        "firewallFrequencySeconds": 150,
        "firewallRandomColorEnabled": true,
        "firewallColor": "#00ff00",
        "firewallReverseDurationFrames": 20,
        "firewallEraseDurationFrames": 50,
        "bootSequenceEnabled": false,
        "crashEnabled": false,
        "crashFrequencySeconds": 600,
        "runBothInOrder": false,
        "keyBindings": {
          "Pulse": "p",
          "ClearPulse": "w",
          "MiniPulse": "e",
          "DejaVu": "r",
          "Superman": "t",
          "Firewall": "y",
          "ToggleUI": " ",
          "BootSequence": "b",
          "CrashSequence": "x",
          "BootCrashSequence": "c"
        },
        "hideMenuIcon": true,
        "fontSettings": {
          "MatrixEmbedded": {
            "active": false,
            "useCustomChars": false,
            "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"
          },
          "CustomFont_5e2697679380fc43": {
            "active": true,
            "useCustomChars": true,
            "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy",
            "useAllChars": false
          }
        },
        "deteriorationType": "ghost",
        "tracerSizeIncrease": 1,
        "supermanProb": 4,
        "dejaVuAutoMode": true,
        "clearPulseIgnoreTracers": true,
        "dejaVuPerformanceMode": false,
        "pulseDelayFrames": 60,
        "minGapTypes": 1,
        "rotateDuringFade": true,
        "rotatorDesyncEnabled": true,
        "rotatorDesyncVariance": 60,
        "suppressToasts": false,
        "ttlMinSeconds": 1,
        "ttlMaxSeconds": 8,
        "shaderParameter": 0.08,
        "pulseDelaySeconds": 0.7,
        "starPowerFreq": 100
      }
    },
    {
      "name": "Trinity Code",
      "data": {
        "streamColor": "#65d778",
        "streamPalette": [
          "#1cc427",
          "#4fba64",
          "#7bd279"
        ],
        "paletteBias": 0,
        "tracerColor": "#cfe8ce",
        "fontSize": 33,
        "streamSpeed": 18,
        "releaseInterval": 4,
        "resolution": 1,
        "enableGlyphAtlas": true,
        "smoothingEnabled": false,
        "smoothingAmount": 0.1,
        "showFpsCounter": true,
        "fontFamily": "CustomFont_5e2697679380fc43",
        "fontWeight": "normal",
        "italicEnabled": false,
        "mirrorEnabled": false,
        "variableBrightnessEnabled": true,
        "brightnessVariance": 11,
        "overlapEnabled": true,
        "overlapColor": "#d4f339",
        "overlapDensity": 0.1,
        "overlapTarget": "stream",
        "overlapShimmer": false,
        "dissolveEnabled": false,
        "dissolveMinSize": 20,
        "deteriorationEnabled": false,
        "deteriorationStrength": 3,
        "enableBloom": true,
        "bloomStrength": 4,
        "bloomOpacity": 0.6,
        "tracerGlow": 30,
        "clearAlpha": 0.65,
        "horizontalSpacingFactor": 0.85,
        "verticalSpacingFactor": 0.95,
        "fontOffsetX": 0,
        "fontOffsetY": 0,
        "stretchX": 1,
        "stretchY": 1,
        "decayFadeDurationFrames": 55,
        "streamSpawnCount": 2,
        "eraserSpawnCount": 18,
        "minStreamGap": 2,
        "minEraserGap": 2,
        "holeRate": 0,
        "desyncIntensity": 0.3,
        "eraserStopChance": 0,
        "tracerStopChance": 0,
        "tracerAttackFrames": 0,
        "tracerHoldFrames": 2,
        "tracerReleaseFrames": 8,
        "invertedTracerEnabled": true,
        "invertedTracerChance": 0.1,
        "rotatorEnabled": true,
        "rotatorChance": 0.5,
        "rotatorSyncToTracer": true,
        "rotatorSyncMultiplier": 0.1,
        "rotatorCycleFactor": 20,
        "rotatorCrossfadeFrames": 2,
        "shaderEnabled": true,
        "customShader": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}",
        "pulseEnabled": false,
        "pulseFrequencySeconds": 300,
        "pulseDurationSeconds": 1.2,
        "pulsePreserveSpaces": true,
        "pulseIgnoreTracers": true,
        "pulseDimming": 0.2,
        "pulseBlend": false,
        "pulseWidth": 130,
        "pulseRandomPosition": true,
        "pulseInstantStart": false,
        "pulseCircular": false,
        "clearPulseEnabled": false,
        "clearPulseFrequencySeconds": 235,
        "clearPulseDurationSeconds": 0.7,
        "clearPulsePreserveSpaces": true,
        "clearPulseBlend": false,
        "clearPulseWidth": 190,
        "clearPulseRandomPosition": true,
        "clearPulseInstantStart": false,
        "clearPulseCircular": false,
        "miniPulseEnabled": false,
        "miniPulseFrequencySeconds": 450,
        "miniPulseDurationSeconds": 5,
        "miniPulsePreserveSpaces": true,
        "miniPulseThickness": 100,
        "miniPulseSpawnChance": 0.06,
        "miniPulseSpeed": 16,
        "miniPulseSize": 360,
        "dejaVuEnabled": false,
        "dejaVuFrequencySeconds": 350,
        "dejaVuDurationSeconds": 5,
        "dejaVuMinRectHeight": 1,
        "dejaVuMaxRectHeight": 10,
        "dejaVuHoleBrightness": 0.02,
        "dejaVuRandomizeColors": false,
        "dejaVuIntensity": 0.1,
        "dejaVuBarDurationFrames": 28,
        "dejaVuVarianceFrames": 43,
        "supermanEnabled": false,
        "supermanFrequencySeconds": 290,
        "supermanDurationSeconds": 6,
        "supermanIncludeColors": true,
        "supermanFadeSpeed": 6,
        "supermanGlow": 4,
        "supermanBoltThickness": 5,
        "supermanFlickerRate": 2,
        "supermanWidth": 4,
        "supermanSpawnSpeed": 69,
        "starPowerEnabled": false,
        "starPowerRainbowMode": "char",
        "starPowerSaturation": 100,
        "starPowerIntensity": 51,
        "starPowerGlitter": false,
        "starPowerColorCycle": true,
        "starPowerCycleSpeed": 5,
        "rainbowStreamEnabled": false,
        "rainbowStreamChance": 0.5,
        "rainbowStreamIntensity": 50,
        "firewallEnabled": false,
        "firewallFrequencySeconds": 150,
        "firewallRandomColorEnabled": true,
        "firewallColor": "#00ff00",
        "firewallReverseDurationFrames": 20,
        "firewallEraseDurationFrames": 50,
        "bootSequenceEnabled": false,
        "crashEnabled": false,
        "crashFrequencySeconds": 600,
        "runBothInOrder": false,
        "keyBindings": {
          "Pulse": "p",
          "ClearPulse": "w",
          "MiniPulse": "e",
          "DejaVu": "r",
          "Superman": "t",
          "Firewall": "y",
          "ToggleUI": " ",
          "BootSequence": "b",
          "CrashSequence": "x",
          "BootCrashSequence": "c"
        },
        "hideMenuIcon": true,
        "fontSettings": {
          "MatrixEmbedded": {
            "active": false,
            "useCustomChars": false,
            "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"
          },
          "CustomFont_5e2697679380fc43": {
            "active": true,
            "useCustomChars": true,
            "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy",
            "useAllChars": false
          }
        },
        "deteriorationType": "ghost",
        "tracerSizeIncrease": 1,
        "supermanProb": 4,
        "dejaVuAutoMode": true,
        "clearPulseIgnoreTracers": true,
        "dejaVuPerformanceMode": false,
        "pulseDelayFrames": 60,
        "minGapTypes": 1,
        "rotateDuringFade": true,
        "rotatorDesyncEnabled": true,
        "rotatorDesyncVariance": 60,
        "suppressToasts": false,
        "ttlMinSeconds": 1,
        "ttlMaxSeconds": 8,
        "shaderParameter": 0.14,
        "pulseDelaySeconds": 0.7,
        "starPowerFreq": 100
      }
    }
  ]
}
</script>
<script>
// --- Utils.js ---
const APP_VERSION = "7.7"; // Updated version
// =========================================================================
// 1. CORE UTILITIES / CONSTANTS
// =========================================================================
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a color string (Hex "#RRGGBB" or "rgb(r,g,b)") to an { r, g, b } object.
     * @param {string} input - The color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (input) => {
        if (typeof input !== "string") return { r: 0, g: 255, b: 0 };
        // Handle Hex (6 or 8 digits)
        const hexMatch = input.match(/^#?([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/);
        if (hexMatch) {
            const value = parseInt(hexMatch[1], 16);
            return {
                r: (value >> 16) & 0xFF,
                g: (value >> 8) & 0xFF,
                b: value & 0xFF
            };
        }
        // Handle RGB / RGBA
        const match = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            return {
                r: parseInt(match[1], 10),
                g: parseInt(match[2], 10),
                b: parseInt(match[3], 10)
            };
        }
        // Fallback
        return { r: 0, g: 255, b: 0 }; 
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Packs RGB components into a single 32-bit integer (0xAABBGGRR) for Little Endian (RR GG BB AA in memory).
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @param {number} a - Alpha (0-255), defaults to 255.
     * @returns {number} The packed 32-bit integer.
     */
    packAbgr: (r, g, b, a = 255) => {
        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
    },
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|â½‡ã‚ ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ãƒ„ãƒ†ãƒŠãƒ‹ãƒŒãƒãƒãƒ’ãƒ•ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ©ãƒªãƒ¯ãƒ²ãƒ³',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: 'ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ãƒ„ãƒ†ãƒŠãƒ‹ãƒŒãƒãƒãƒ’ãƒ•ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ©ãƒªãƒ¯ãƒ²ãƒ³',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3
};
    // =========================================================================
    // 1.1 NOTIFICATION SYSTEM 
    // =========================================================================
// --- ConfigurationManager.js ---
class ConfigurationManager {
    constructor() {
        this.storageKey = 'matrix_config_v7.7';
        this.slotsKey = 'matrix_slots_v7.7';
        this.defaults = this._initializeDefaults();
        this.state = { ...this.defaults };
        this.derived = {};
        this.slots = this._loadSlots();
        this.subscribers = [];
        this._previousSmoothingEnabled = undefined;
        this._previousSmoothingAmount = undefined;
        // Keys that affect derived values (safe superset to ensure correctness)
        this._derivedKeys = new Set([
            'streamSpeed',
            'horizontalSpacingFactor',
            'verticalSpacingFactor',
            'rotatorSyncToTracer',
            'rotatorSyncMultiplier',
            'rotatorCycleFactor',
            'tracerAttackFrames',
            'tracerReleaseFrames',
            'tracerHoldFrames',
            'fontSize',
            'brightnessVariance',
            'streamColor',
            'tracerColor',
            'streamPalette',
            'fontFamily',
            'fontWeight',
            'italicEnabled',
            'fontSettings'
        ]);
        this._loadState();
        this.updateDerivedValues();
    }
    // ====================
    // Initialization Helpers
    // ====================
    /**
     * Initializes the default configuration settings.
     * @private
     * @returns {Object} An object containing all default configuration properties.
     */
    _initializeDefaults() {
        return {
            "streamColor": "#65d778",
            "streamPalette": [
              "#29bc62"
            ],
            "paletteBias": 0,
            "tracerColor": "#d9f2f2",
            "fontSize": 25,
            "streamSpeed": 16,
            "releaseInterval": 2,
            "resolution": 1,
            "enableGlyphAtlas": true,
            "smoothingEnabled": false,
            "smoothingAmount": 0.1,
            "showFpsCounter": true,
            "debugEnabled": false,
            "fontFamily": "MatrixEmbedded",
            "fontWeight": "normal",
            "italicEnabled": false,
            "mirrorEnabled": false,
            "variableBrightnessEnabled": true,
            "brightnessVariance": 20,
            "overlapEnabled": false,
            "overlapColor": "#FFD700",
            "overlapDensity": 0.2,
            "overlapTarget": "all",
            "overlapShimmer": false,
            "dissolveEnabled": true,
            "dissolveScalePercent": -20,
            "deteriorationEnabled": true,
            "deteriorationStrength": 4,
            "enableBloom": true,
            "bloomStrength": 4,
            "bloomOpacity": 0.45,
            "tracerGlow": 12,
            "clearAlpha": 0.7,
            "horizontalSpacingFactor": 0.7,
            "verticalSpacingFactor": 1,
            "fontOffsetX": 0,
            "fontOffsetY": 6,
            "stretchX": 1,
            "stretchY": 1.2,
            "decayFadeDurationFrames": 23,
            "streamSpawnCount": 6,
            "eraserSpawnCount": 16,
            "minStreamGap": 30,
            "minEraserGap": 30,
            "minGapTypes": 20,
            "holeRate": 0.1,
            "desyncIntensity": 0,
            "eraserStopChance": 1,
            "tracerStopChance": 1,
            "tracerAttackFrames": 3,
            "tracerHoldFrames": 0,
            "tracerReleaseFrames": 5,
            "invertedTracerEnabled": true,
            "invertedTracerChance": 0.1,
            "rotatorEnabled": true,
            "rotatorChance": 0.13,
            "rotatorSyncToTracer": true,
            "rotatorSyncMultiplier": 0.5,
            "rotatorCycleFactor": 20,
            "rotatorCrossfadeFrames": 6,
            "rotateDuringFade": false,
            "rotatorDesyncEnabled": false,
            "rotatorDesyncVariance": 0,
            "shaderEnabled": false,
            "customShader": null,
            "effectShader": null,
            "shaderParameter": 0,
            "pulseEnabled": true,
            "pulseUseTracerGlow": true,
            "pulseMovieAccurate": false,
            "pulseFrequencySeconds": 300,
            "pulseDelaySeconds": 0.7,
            "pulseDurationSeconds": 1.2,
            "pulsePreserveSpaces": true,
            "pulseIgnoreTracers": true,
            "pulseDimming": 0.2,
            "pulseBlend": false,
            "pulseWidth": 130,
            "pulseRandomPosition": true,
            "pulseInstantStart": false,
            "pulseCircular": false,
            "clearPulseEnabled": true,
            "clearPulseUseTracerGlow": true,
            "clearPulseFrequencySeconds": 235,
            "clearPulseDurationSeconds": 0.7,
            "clearPulsePreserveSpaces": true,
            "clearPulseBlend": false,
            "clearPulseWidth": 190,
            "clearPulseRandomPosition": true,
            "clearPulseInstantStart": false,
            "clearPulseCircular": false,
            "miniPulseEnabled": true,
            "miniPulseUseTracerGlow": true,
            "miniPulseFrequencySeconds": 450,
            "miniPulseDurationSeconds": 5,
            "miniPulsePreserveSpaces": true,
            "miniPulseThickness": 100,
            "miniPulseSpawnChance": 0.06,
            "miniPulseSpeed": 16,
            "miniPulseSize": 360,
            "dejaVuEnabled": true,
            "dejaVuFrequencySeconds": 350,
            "dejaVuDurationSeconds": 5,
            "dejaVuMinRectHeight": 1,
            "dejaVuMaxRectHeight": 10,
            "dejaVuHoleBrightness": 0.02,
            "dejaVuRandomizeColors": false,
            "dejaVuIntensity": 0.1,
            "dejaVuBarDurationFrames": 28,
            "dejaVuVarianceFrames": 43,
            "supermanEnabled": true,
            "supermanFrequencySeconds": 290,
            "supermanDurationSeconds": 6,
            "supermanIncludeColors": true,
            "supermanFadeSpeed": 6,
            "supermanGlow": 4,
            "supermanBoltThickness": 5,
            "supermanFlickerRate": 2,
            "supermanWidth": 4,
            "supermanSpawnSpeed": 69,
            "starPowerEnabled": false,
            "starPowerFreq": 100,
            "starPowerRainbowMode": "char",
            "starPowerSaturation": 100,
            "starPowerIntensity": 51,
            "starPowerGlitter": false,
            "starPowerColorCycle": true,
            "starPowerCycleSpeed": 5,
            "rainbowStreamEnabled": false,
            "rainbowStreamChance": 0.5,
            "rainbowStreamIntensity": 50,
            "firewallEnabled": false,
            "firewallFrequencySeconds": 150,
            "firewallRandomColorEnabled": true,
            "firewallColor": "#00ff00",
            "firewallReverseDurationFrames": 20,
            "firewallEraseDurationFrames": 50,
            "bootSequenceEnabled": false,
            "crashEnabled": false,
            "crashFrequencySeconds": 600,
            "crashDurationSeconds": 30,
            "crashSheetCount": 25,
            "crashSheetSpeed": 1.0,
            "crashSheetOpacity": 0.5,
            "crashStationaryChance": 20,
            "crashFlashDelayMin": 3,
            "crashFlashDelayMax": 6,
            "crashEnableSmith": true,
            "crashEnableSuperman": true,
            "crashEnableFlash": true,
            "runBothInOrder": false,
            "keyBindings": {
              "Pulse": "p",
              "ClearPulse": "w",
              "MiniPulse": "e",
              "DejaVu": "r",
              "Superman": "t",
              "Firewall": "y",
              "ReverseTime": "u",
              "ToggleUI": " ",
              "BootSequence": "b",
              "CrashSequence": "x",
              "BootCrashSequence": "c"
            },
            "hideMenuIcon": true,
            "fontSettings": {
              "MatrixEmbedded": {
                "active": true,
                "useCustomChars": false,
                "customCharacters": ""
              },
              "CustomFont_5e2697679380fc43": {
                "active": false,
                "useCustomChars": true,
                "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•",
                "useAllChars": false
              }
            },
            "deteriorationType": "ghost",
            "tracerSizeIncrease": 1,
            "supermanProb": 4,
            "dejaVuAutoMode": true,
            "clearPulseIgnoreTracers": true,
            "dejaVuPerformanceMode": false,
            "pulseDelayFrames": 60,
            "suppressToasts": false,
            "ttlMinSeconds": 1,
            "ttlMaxSeconds": 8
        };
    }
    /**
     * Deep clone utility to minimize allocations and handle future structuredClone availability.
     * @private
     */
    _deepClone(obj) {
        if (typeof structuredClone === 'function') {
            return structuredClone(obj);
        }
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * Loads configuration slots from local storage.
     * @private
     * @returns {Array<Object>} An array of slot data.
     */
    _loadSlots() {
        try {
            const storedSlots = localStorage.getItem(this.slotsKey);
            if (storedSlots) {
                return JSON.parse(storedSlots);
            }
        } catch (e) {
            console.warn('Failed to load slots:', e);
        }
        // Default slots if not found or error occurs
        return [
            { name: "Trilogy", data: this._deepClone(this.defaults) },
            { name: "Save Slot 2", data: null },
            { name: "Save Slot 3", data: null }
        ];
    }
    /**
     * Saves configuration slots to local storage.
     */
    saveSlots() {
        try {
            localStorage.setItem(this.slotsKey, JSON.stringify(this.slots));
        } catch (e) {
            console.warn('Failed to save slots:', e);
        }
    }
    /**
     * Loads the application state from local storage.
     * @private
     */
    _loadState() {
        try {
            let storedState = localStorage.getItem(this.storageKey);
            // Fallback to previous version if current version not found
            if (!storedState) {
                const legacyKey = 'matrix_config_v7.5';
                storedState = localStorage.getItem(legacyKey);
                if (storedState) {
                    // console.log("Migrating configuration from v7.5");
                }
            }
            if (storedState) {
                const parsed = JSON.parse(storedState);
                delete parsed.customFonts; // Remove unsupported keys if present
                this.state = { ...this.defaults, ...parsed };
                // Migration: Ensure streamPalette exists
                if (!this.state.streamPalette) {
                    this.state.streamPalette = [this.state.streamColor];
                }
                // Migration: Convert eraserStopChance from float to integer if needed
                if (this.state.eraserStopChance > 0 && this.state.eraserStopChance < 1) {
                    this.state.eraserStopChance = Math.round(this.state.eraserStopChance * 100);
                }
                // Clamp to max 25
                if (this.state.eraserStopChance > 25) {
                    this.state.eraserStopChance = 25;
                }
            }
        } catch (e) {
            console.warn('Failed to load configuration:', e);
        }
    }
    /**
     * Saves the current application state to local storage.
     */
    save() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.state));
        } catch (e) {
            console.warn('Failed to save configuration:', e);
        }
    }
    /**
     * Retrieves the value of a specific configuration key.
     * @param {string} key - The key of the configuration setting.
     * @returns {*} The value of the configuration setting.
     */
    get(key) {
        return this.state[key];
    }
    /**
     * Sets the value of a configuration key and triggers updates.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The new value for the setting.
     */
    set(key, value) {
        if (this.state[key] === value) return; // Skip if no change in value
        // Special handling for shaderEnabled
        if (key === 'shaderEnabled') {
            if (value === true) { // Shader is being enabled
                // Store current smoothing values only if they are not already forced
                if (this.state.smoothingEnabled !== false) {
                    this._previousSmoothingEnabled = this.state.smoothingEnabled;
                } else {
                    this._previousSmoothingEnabled = undefined; // No previous value to restore
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this._previousSmoothingAmount = this.state.smoothingAmount;
                } else {
                    this._previousSmoothingAmount = undefined; // No previous value to restore
                }
                // Force smoothing off
                if (this.state.smoothingEnabled !== false) {
                    this.state.smoothingEnabled = false;
                    this.notify('smoothingEnabled');
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this.state.smoothingAmount = 0.1; // Minimum value as per UI definition
                    this.notify('smoothingAmount');
                }
            } else { // Shader is being disabled
                // Restore previous smoothing values if they were stored
                if (this._previousSmoothingEnabled !== undefined && this.state.smoothingEnabled !== this._previousSmoothingEnabled) {
                    this.state.smoothingEnabled = this._previousSmoothingEnabled;
                    this.notify('smoothingEnabled');
                }
                if (this._previousSmoothingAmount !== undefined && this.state.smoothingAmount !== this._previousSmoothingAmount) {
                    this.state.smoothingAmount = this._previousSmoothingAmount;
                    this.notify('smoothingAmount');
                }
                // Clear stored previous values
                this._previousSmoothingEnabled = undefined;
                this._previousSmoothingAmount = undefined;
            }
        }
        // Special handling for fontFamily: Enforce single active font in settings
        if (key === 'fontFamily') {
            const settings = this.state.fontSettings; // Reference current settings
            if (settings && settings[value]) {
                let changed = false;
                // Create a new settings object to trigger reactivity if needed, or mutate copy
                // We'll mutate deeper objects but clone the top level to be safe/clean
                const newSettings = { ...settings };
                for (const fName in newSettings) {
                    if (Object.prototype.hasOwnProperty.call(newSettings, fName)) {
                        const isActive = (fName === value);
                        if (newSettings[fName].active !== isActive) {
                            // Clone the specific font config to avoid mutation side-effects
                            newSettings[fName] = { ...newSettings[fName], active: isActive };
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    this.state.fontSettings = newSettings;
                    this.notify('fontSettings');
                }
            }
        }
        this.state[key] = value; // Update the actual key's value
        // Only recompute derived values when relevant keys change (preserves behavior, improves perf)
        if (this._derivedKeys.has(key) || key === 'ALL') {
            this.updateDerivedValues();
        }
        this.save();
        this.notify(key);
    }
    /**
     * Resets the application state to its default values.
     */
    reset() {
        // Load the "Trilogy" preset (slot 0) after a factory reset
        // This ensures the desired default configuration is applied consistently.
        this.loadFromSlot(0);
        // The loadFromSlot method already calls updateDerivedValues(), save(), and notify('ALL')
    }
    /**
     * Saves the current application state to a specific slot.
     * @param {number} index - The index of the slot (0-2).
     */
    saveToSlot(index) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index] = {
                name: this.slots[index].name,
                data: this._deepClone(this.state) // Deep clone state
            };
            this.saveSlots();
        } else {
            console.warn(`Attempted to save to non-existent slot index: ${index}`);
        }
    }
    /**
     * Loads the application state from a specific slot.
     * @param {number} index - The index of the slot (0-2).
     * @returns {boolean} True if the state was loaded successfully, false otherwise.
     */
    loadFromSlot(index) {
        if (!this.slots[index]?.data) return false; // Use optional chaining for safety
        this.state = { ...this.defaults, ...this.slots[index].data };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
        return true;
    }
    /**
     * Renames a specific configuration slot.
     * @param {number} index - The index of the slot (0-2).
     * @param {string} name - The new name for the slot.
     */
    renameSlot(index, name) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index].name = name;
            this.saveSlots();
        } else {
            console.warn(`Attempted to rename non-existent slot index: ${index}`);
        }
    }
    /**
     * Subscribes a callback function to configuration changes.
     * @param {Function} callback - The function to call when configuration changes.
     */
    subscribe(callback) {
        if (typeof callback === "function") {
            this.subscribers.push(callback);
        }
    }
    /**
     * Notifies all subscribed listeners about a configuration change.
     * @param {string} key - The key of the changed configuration setting.
     */
    notify(key) {
        // Guard each subscriber to prevent one failing listener from breaking the chain
        for (let i = 0; i < this.subscribers.length; i++) {
            const callback = this.subscribers[i];
            try {
                callback(key, this.state);
            } catch (e) {
                console.warn('Subscriber callback failed:', e);
            }
        }
    }
    /**
     * Updates all derived configuration values based on the current state.
     * These are values calculated from base settings for performance or convenience.
     */
    updateDerivedValues() {
        const s = this.state;
        const cycleDuration = 21 - s.streamSpeed;
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const rotatorCycleFrames = s.rotatorSyncToTracer
            ? Math.max(1, Math.floor(cycleDuration / s.rotatorSyncMultiplier))
            : Math.max(10, Math.round(60 - s.rotatorCycleFactor * 2.5));
        // Precompute common color conversions only once
        const streamRgb = Utils.hexToRgb(s.streamColor);
        const tracerRgb = Utils.hexToRgb(s.tracerColor);
        // Palette conversions done once and reused
        const paletteHexes = (s.streamPalette && s.streamPalette.length > 0)
            ? s.streamPalette
            : [s.streamColor];
        const paletteRgbs = new Array(paletteHexes.length);
        for (let i = 0; i < paletteHexes.length; i++) {
            paletteRgbs[i] = Utils.hexToRgb(paletteHexes[i]);
        }
        const paletteColorsStr = paletteRgbs.map(Utils.createRGBString);
        const paletteColorsUint32 = paletteRgbs.map(c => Utils.packAbgr(c.r, c.g, c.b));
        this.derived = {
            cycleDuration,
            safeAttack: Math.min(Math.max(1, s.tracerAttackFrames), cycleDuration),
            safeRelease: Math.min(s.tracerReleaseFrames, cycleDuration),
            holdFrames: Math.max(0, s.tracerHoldFrames),
            maxState: cycleDuration + Math.max(0, s.tracerHoldFrames) + cycleDuration,
            rotatorCycleFrames,
            cellWidth: s.fontSize * hFactor,
            cellHeight: s.fontSize * vFactor,
            varianceMin: 1.0 - s.brightnessVariance / 100,
            streamRgb,
            tracerRgb,
            streamColorStr: Utils.createRGBString(streamRgb),
            paletteRgbs,
            paletteColorsStr,
            paletteColorsUint32,
            streamColorUint32: Utils.packAbgr(streamRgb.r, streamRgb.g, streamRgb.b),
            tracerColorUint32: Utils.packAbgr(tracerRgb.r, tracerRgb.g, tracerRgb.b),
            tracerColorStr: Utils.createRGBString(tracerRgb),
            fontBaseStr: `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
        };
        // Active Fonts Logic
        const fontSettings = s.fontSettings || {};
        const activeFonts = [];
        for (const name in fontSettings) {
            if (!Object.prototype.hasOwnProperty.call(fontSettings, name)) continue;
            const conf = fontSettings[name];
            if (conf && conf.active) {
                let chars;
                if (conf.useCustomChars) {
                    // Respect user's setting, even if empty (clean slate).
                    // Fallback to " " (space) if effectively empty to prevent simulation errors.
                    const clean = (conf.customCharacters || "").replace(/\s+/g, '');
                    chars = clean.length > 0 ? clean : " ";
                } else {
                    // Use Default
                    chars = Utils.CHARS;
                }
                activeFonts.push({ name, chars });
            }
        }
        // Fallback if no fonts are active
        if (activeFonts.length === 0) activeFonts.push({ name: 'MatrixEmbedded', chars: Utils.CHARS });
        this.derived.activeFonts = activeFonts;
    }
}
// =========================================================================
// 3.0 MATRIX GRID
// =========================================================================
// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=";
    // =========================================================================
    // 4.0 STREAM MODE
    // =========================================================================
// --- EffectRegistry.js ---
class EffectRegistry {
            constructor(grid, config) { 
                this.grid = grid; 
                this.config = config; 
                this.effects = []; 
            }
            register(effect) { this.effects.push(effect); }
            trigger(name) { const fx = this.effects.find(e => e.name === name); if(fx) return fx.trigger(); return false; }
            update() { 
                this.grid.clearAllOverrides();
                this.grid.clearAllEffects();
                this.effects.forEach(e => {
                    e.update(); 
                    if (!e.active) return;
                    if (typeof e.applyToGrid === 'function') {
                        e.applyToGrid(this.grid);
                    } else if (typeof e.getOverride === 'function') {
                        this._applyLegacyOverride(e);
                    }
                }); 
            }
            _applyLegacyOverride(e) {
                const indices = e.getActiveIndices();
                const apply = (i) => {
                    const over = e.getOverride(i);
                    if (over) {
                        if (over.solid) {
                            // Parse Color & Alpha
                            let r=0, g=0, b=0, a=255;
                            if (over.bgColor) {
                                // Try Hex first (Utils handles it)
                                if (over.bgColor.startsWith('#')) {
                                    const rgb = Utils.hexToRgb(over.bgColor);
                                    r=rgb.r; g=rgb.g; b=rgb.b;
                                    // Hex alpha not supported by Utils.hexToRgb currently
                                } else {
                                    // Parse rgba()
                                    const match = over.bgColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                                    if (match) {
                                        r = parseInt(match[1]);
                                        g = parseInt(match[2]);
                                        b = parseInt(match[3]);
                                        if (match[4]) a = Math.floor(parseFloat(match[4]) * 255);
                                    }
                                }
                            }
                            // If explicit alpha property exists, use it?
                            // Legacy used bgColor string for solid color.
                            // But over.alpha property might exist too?
                            // Usually solid overrides use bgColor fully.
                            const color = Utils.packAbgr(r, g, b, a);
                            // Store alpha as Float (0..1) for renderer?
                            // CellGrid stores alpha as Float32.
                            // But packAbgr puts alpha in Uint32.
                            // Renderer uses Float32 alpha array.
                            // So we need to set grid.overrideAlphas[i] = a / 255.
                            this.grid.setSolidOverride(i, color, a / 255.0);
                        } else {
                            // Char Override
                            let color = 0xFFFFFFFF; 
                            if (over.color) {
                                 const rgb = Utils.hexToRgb(over.color);
                                 // Alpha from property
                                 const a = over.alpha !== undefined ? over.alpha * 255 : 255;
                                 color = Utils.packAbgr(rgb.r, rgb.g, rgb.b, a);
                            }
                            let fontIdx = 0;
                            if (over.font) {
                                 const activeFonts = this.config.derived.activeFonts;
                                 const idx = activeFonts.findIndex(f => f.name === over.font);
                                 if (idx !== -1) fontIdx = idx;
                            }
                            this.grid.setOverride(i, over.char, color, over.alpha || 1.0, fontIdx, over.glow || 0);
                        }
                    }
                };
                if (indices) {
                    for (const idx of indices) apply(idx);
                } else {
                    const total = this.grid.cols * this.grid.rows;
                    for (let i = 0; i < total; i++) apply(i);
                }
            }
        }
        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; this.active = false; }
            trigger() { return false; }
            update() {}
            getActiveIndices() { return new Set(); }
        }
// --- CellGrid.js ---
// Constants for Cell State and Render Modes
const CELL_STATE = {
    INACTIVE: 0,
    ACTIVE: 1
    // OVERRIDE state is determined by the overrideActive flag
};
const RENDER_MODE = {
    STANDARD: 0, // Mix between Primary and Secondary based on 'mix'
    OVERLAP: 1,  // Visual Overlap (both visible)
    ADDITIVE: 2  // Additive blending (future proofing)
};
const OVERRIDE_MODE = {
    NONE: 0,
    CHAR: 1,
    SOLID: 2
};
class CellGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // --- Core State ---
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.state = null; // Uint8: INACTIVE / ACTIVE
        // --- Primary Layer ---
        this.chars = null;        // Uint16
        this.colors = null;       // Uint32 (0xAABBGGRR) - Current Display Color
        this.baseColors = null;   // Uint32 (0xAABBGGRR) - Target/Stream Color
        this.alphas = null;       // Float32
        this.glows = null;        // Float32
        this.fontIndices = null;  // Uint8
        // --- Secondary Layer (Rotators / Overlaps) ---
        this.secondaryChars = null; // Uint16
        this.secondaryColors = null; // Uint32
        this.secondaryAlphas = null; // Float32
        this.secondaryGlows = null;  // Float32
        this.secondaryFontIndices = null; // Uint8
        // --- Mixing & Rendering ---
        this.mix = null;        // Float32 (0.0 = Primary, 1.0 = Secondary)
        this.renderMode = null; // Uint8 (RENDER_MODE)
        // --- Override Layer (Effects) ---
        this.overrideActive = null; // Uint8 (OVERRIDE_MODE)
        this.overrideChars = null;  // Uint16
        this.overrideColors = null; // Uint32
        this.overrideAlphas = null; // Float32
        this.overrideGlows = null;  // Float32
        this.overrideFontIndices = null; // Uint8
        // --- Passive Layer (Effects) ---
        this.effectActive = null;   // Uint8
        this.effectChars = null;    // Uint16
        this.effectColors = null;   // Uint32
        this.effectAlphas = null;   // Float32
        this.effectGlows = null;    // Float32
        this.effectFontIndices = null; // Uint8
        // --- Simulation Logic Storage ---
        this.types = null;      // Uint8 (Tracer, Rotator, Empty)
        this.decays = null;     // Uint8
        this.ages = null;       // Int32
        this.brightness = null; // Float32
        this.rotatorOffsets = null; // Uint8 (Static noise for desync)
        // Auxiliary
        this.cellLocks = null;  // Uint8 (Prevent updates)
        // Sparse Data (Maps for memory efficiency)
        this.complexStyles = new Map(); // Dynamic styling data
        // Rotator Targets (Dense for GPU upload)
        this.nextChars = null;     // Uint16Array
        this.nextOverlapChars = null; // Uint16Array
    }
    /**
     * Resizes the grid based on new width and height.
     */
    resize(width, height) {
        const d = this.config.derived;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
        if (!d || !d.cellWidth || !d.cellHeight) return;
        const newCols = Math.max(1, (width / d.cellWidth) | 0);
        const newRows = Math.max(1, (height / d.cellHeight) | 0);
        if (newCols !== this.cols || newRows !== this.rows) {
            this._resizeGrid(newCols, newRows);
        }
    }
    getIndex(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return -1;
        return y * this.cols + x;
    }
    // --- Primary Layer Modifiers ---
    setPrimary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.chars[idx] = charStr.charCodeAt(0);
        this.colors[idx] = colorUint32;
        this.alphas[idx] = alpha;
        this.glows[idx] = glow;
        this.fontIndices[idx] = fontIndex;
        this.state[idx] = CELL_STATE.ACTIVE;
        this.activeIndices.add(idx);
    }
    setRotatorTarget(idx, charStr, isSecondary = false) {
        const code = charStr.charCodeAt(0);
        if (isSecondary) {
            this.nextOverlapChars[idx] = code;
        } else {
            this.nextChars[idx] = code;
        }
    }
    getRotatorTarget(idx, isSecondary = false) {
        const code = isSecondary ? this.nextOverlapChars[idx] : this.nextChars[idx];
        return (code > 0) ? String.fromCharCode(code) : null;
    }
    // --- Secondary Layer Modifiers ---
    setSecondary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.secondaryChars[idx] = charStr.charCodeAt(0);
        this.secondaryColors[idx] = colorUint32;
        this.secondaryAlphas[idx] = alpha;
        this.secondaryGlows[idx] = glow;
        this.secondaryFontIndices[idx] = fontIndex;
    }
    // --- Override Layer Modifiers ---
    // This is a 'permanent' or hard override - it directly changes state
    setOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.overrideChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideGlows[idx] = glow;
        this.overrideFontIndices[idx] = fontIndex;
        this.overrideActive[idx] = OVERRIDE_MODE.CHAR;
    }
    // This is a soft override 
    setEffectOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 1;
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Overlay Override (Mixes Effect Char on top of Primary)
    setEffectOverlay(idx, charStr, alpha, fontIndex = 0) {
        this.effectActive[idx] = 2; // 2 = Overlay Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        // Color is assumed White/Global for overlay in simplified shader logic
        // Glow is additive
    }
    // High Priority Override (Ignores Shadows/Masks)
    setHighPriorityEffect(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 4; // 4 = High Priority Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Shadow Overlay (Mixes Black Block on top of Primary)
    setEffectShadow(idx, alpha) {
        this.effectActive[idx] = 3; // 3 = Shadow Mode
        this.effectAlphas[idx] = alpha;
        // Chars/Colors/Fonts ignored for shadow
    }
    setSolidOverride(idx, colorUint32, alpha) {
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideActive[idx] = OVERRIDE_MODE.SOLID;
        // Chars/Glows ignored for Solid
    }
    clearOverride(idx) {
        this.overrideActive[idx] = OVERRIDE_MODE.NONE;
    }
    clearEffectOverride(idx) {
        this.effectActive[idx] = 0;
    }
    clearAllOverrides() {
        if (this.overrideActive) {
            this.overrideActive.fill(0);
        }
    }
    clearAllEffects(){
        if (this.effectActive){
            this.effectActive.fill(0);
        }
    }
    // --- General State Management ---
    clearCell(idx) {
        this.state[idx] = CELL_STATE.INACTIVE;
        this.chars[idx] = 32; // Space
        this.alphas[idx] = 0;
        this.glows[idx] = 0;
        this.mix[idx] = 0;
        this.renderMode[idx] = RENDER_MODE.STANDARD;
        // Clear simulation data
        this.types[idx] = 0;
        this.ages[idx] = 0;
        this.decays[idx] = 0;
        // Also clear secondary to be safe
        this.secondaryChars[idx] = 32;
        this.secondaryAlphas[idx] = 0;
        this.activeIndices.delete(idx);
        // Clear maps
        this.complexStyles.delete(idx);
        this.nextChars[idx] = 0;
        this.nextOverlapChars[idx] = 0;
    }
    getChar(idx) {
        // Helper for simulation reading
        return String.fromCharCode(this.chars[idx]);
    }
    getState(idx){
        // Helper for getting cell state
        return this.state[idx];
    }
    _resizeGrid(newCols, newRows) {
        const total = newCols * newRows;
        // Core
        this.state = new Uint8Array(total);
        // Primary
        this.chars = new Uint16Array(total);
        this.colors = new Uint32Array(total);
        this.baseColors = new Uint32Array(total);
        this.alphas = new Float32Array(total);
        this.glows = new Float32Array(total);
        this.fontIndices = new Uint8Array(total);
        // Secondary
        this.secondaryChars = new Uint16Array(total);
        this.secondaryColors = new Uint32Array(total);
        this.secondaryAlphas = new Float32Array(total);
        this.secondaryGlows = new Float32Array(total);
        this.secondaryFontIndices = new Uint8Array(total);
        // Mix / Mode
        this.mix = new Float32Array(total);
        this.renderMode = new Uint8Array(total);
        // Override
        this.overrideActive = new Uint8Array(total);
        this.overrideChars = new Uint16Array(total);
        this.overrideColors = new Uint32Array(total);
        this.overrideAlphas = new Float32Array(total);
        this.overrideGlows = new Float32Array(total);
        this.overrideFontIndices = new Uint8Array(total);
        // Effects
        this.effectActive = new Uint8Array(total)
        this.effectChars = new Uint16Array(total);
        this.effectColors = new Uint32Array(total);
        this.effectAlphas = new Float32Array(total);
        this.effectFontIndices = new Uint8Array(total);
        this.effectGlows = new Float32Array(total);
        // Simulation
        this.types = new Uint8Array(total);
        this.decays = new Uint8Array(total);
        this.ages = new Int32Array(total);
        this.brightness = new Float32Array(total);
        this.rotatorOffsets = new Uint8Array(total);
        this.cellLocks = new Uint8Array(total);
        // Rotators
        this.nextChars = new Uint16Array(total);
        this.nextOverlapChars = new Uint16Array(total);
        // Environmental Glows (Additive, per frame)
        this.envGlows = new Float32Array(total);
        // Initialize static data
        const activeFonts = this.config.derived ? this.config.derived.activeFonts : null;
        const fallbackChars = "012345789Z:<=>\"*+-._!|";
        for (let i = 0; i < total; i++) {
            this.rotatorOffsets[i] = (Math.random() * 255) | 0;
            // Pre-populate random characters for varied effect snapshots
            let charCode = 32; 
            if (activeFonts && activeFonts.length > 0) {
                const f = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                if (f.chars && f.chars.length > 0) {
                    charCode = f.chars.charCodeAt(Math.floor(Math.random() * f.chars.length));
                }
            } else {
                charCode = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
            this.chars[i] = charCode;
        }
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- BootEffect.js ---
class BootEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry;
        this.name = "BootSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = 3.5; 
        this.originalShader = null; 
        this.originalShaderEnabled = false; 
        this.originalShaderParameter = 0.5; 
    }
    trigger() {
        if (this.active) return false;
        this.originalShaderEnabled = this.c.state.shaderEnabled;
        this.originalShader = this.c.state.customShader;
        this.originalShaderParameter = this.c.state.shaderParameter;
        this.c.set('shaderEnabled', true);
        this.c.set('customShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; // 0.0 to 1.0 over 3.5s
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) {
    return fract(sin(n * 12.9898) * 43758.5453123);
}
float noise(float p) {
    float i = floor(p);
    float f = fract(p);
    return mix(random(i), random(i + 1.0), f * f * (3.0 - 2.0 * f));
}
float sdRoundedBox(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
float vignetteRect(vec2 uv, float margin) {
    vec2 v = smoothstep(0.0, margin, uv) * smoothstep(1.0, 1.0 - margin, uv);
    return v.x * v.y;
}
float smoothstep_custom(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * (3.0 - 2.0 * x);
}
// "Scanner Sheet" with subtle torn edges
// axis: 0 = none, 1 = jagged horizontal edges, 2 = jagged vertical edges
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    // Torn edge effect
    float jagged = 0.0;
    if (axis == 1) {
        jagged = (noise(uv.x * 50.0) - 0.5) * 0.005; 
        pos.y += jagged;
    } else if (axis == 2) {
        jagged = (noise(uv.y * 50.0) - 0.5) * 0.005;
        pos.x += jagged;
    }
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
// Asymmetrical Scanner Scenes (Full Span + Torn Edges)
vec3 getScannerScene(int pattern, vec2 uv) {
    vec3 col = vec3(1.0); 
    // Pattern 0: Split Scan (Full Width)
    if (pattern == 0) {
        float top = scannerSheet(uv, vec2(0.5, 0.75), vec2(1.0, 0.25), 0.02, 1);
        float bot = scannerSheet(uv, vec2(0.5, 0.25), vec2(1.0, 0.25), 0.02, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.6), vec2(1.0, 0.05), 0.01, 1); 
        vec3 cTop = vec3(0.85, 0.9, 0.95);
        vec3 cBot = vec3(1.0);
        col = mix(vec3(0.9), cBot, bot);
        col = mix(col, cTop, top);
        col = mix(col, vec3(0.7), art);
    }
    // Pattern 1: Faded Gradient + Full Height Side Bar
    if (pattern == 1) {
        float grad = smoothstep(0.0, 1.0, uv.y);
        col = vec3(mix(0.6, 1.0, grad));
        float bar = scannerSheet(uv, vec2(0.15, 0.5), vec2(0.08, 1.0), 0.05, 2); 
        col = mix(col, vec3(0.95), bar);
    }
    // Pattern 2: Bottom Bar (Full Width)
    if (pattern == 2) {
        col = vec3(0.85);
        float bar = scannerSheet(uv, vec2(0.5, 0.15), vec2(1.0, 0.15), 0.03, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.85), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), bar);
        col = mix(col, vec3(0.9), art);
    }
    // Pattern 3: Thick Vertical Block (Full Height)
    if (pattern == 3) {
        col = vec3(1.0);
        float side = scannerSheet(uv, vec2(0.9, 0.5), vec2(0.15, 1.0), 0.08, 2);
        float block = scannerSheet(uv, vec2(0.3, 0.5), vec2(0.15, 1.0), 0.01, 2); 
        vec3 blueLeak = vec3(0.7, 0.85, 1.0);
        col = mix(col, blueLeak, side);
        col = mix(col, vec3(0.8), block);
    }
    // Pattern 4: Top Header (Full Width)
    if (pattern == 4) {
        col = vec3(0.95);
        float head = scannerSheet(uv, vec2(0.5, 0.9), vec2(1.0, 0.1), 0.02, 1);
        float bar = scannerSheet(uv, vec2(0.5, 0.1), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), head);
        col = mix(col, vec3(0.85), bar);
    }
    // Pattern 5: Corner Heavy (Full Span components)
    if (pattern == 5) {
        col = vec3(0.9);
        float vStrip = scannerSheet(uv, vec2(0.1, 0.5), vec2(0.15, 1.0), 0.1, 2);
        float hStrip = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.08), 0.02, 1);
        col = mix(col, vec3(1.0), vStrip);
        col = mix(col, vec3(0.8), hStrip);
    }
    // Pattern 6: Wide Horizontal Split (Full Width)
    if (pattern == 6) {
        col = vec3(1.0);
        float mid = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.15), 0.05, 1);
        col = mix(vec3(0.85), vec3(1.0), mid);
    }
    return col;
}
void main() {
    vec4 origColor = texture2D(uTexture, vTexCoord);
    vec2 uv = vTexCoord;
    vec2 p = uv * 2.0 - 1.0;
    float aspect = uResolution.x / uResolution.y;
    p.x *= aspect;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0); 
    // --- TIMING ---
    float t_dot = smoothstep_custom(0.15, 0.25, uParameter);
    float t_v_stretch = smoothstep_custom(0.25, 0.35, uParameter);
    float t_h_stretch = smoothstep_custom(0.35, 0.45, uParameter);
    vec3 whiteLayer = vec3(0.0);
    float whiteAlpha = 0.0;
    if (uParameter < 0.45) {
        if (uParameter > 0.15) {
            float line_thickness = 0.008; 
            float max_height = 2.0; 
            float max_width = 2.0 * aspect;
            float current_radius = line_thickness * t_dot;
            float added_height = mix(0.0, max_height, t_v_stretch * t_v_stretch);
            float added_width = mix(0.0, max_width, t_h_stretch * t_h_stretch);
            float active_radius = mix(current_radius, 0.0, t_h_stretch);
            float d = sdRoundedBox(p, vec2(added_width, added_height), active_radius);
            float glow = 1.0 - smoothstep(0.0, 0.015, d);
            float core = 1.0 - smoothstep(0.0, 0.0005, d);
            whiteAlpha = max(glow, core);
            if (t_h_stretch < 0.1) {
                 float total_h = added_height + active_radius;
                 float v_fade = smoothstep(total_h, total_h * 0.5, abs(p.y));
                 whiteAlpha *= v_fade;
            } else {
                 whiteAlpha = mix(whiteAlpha, 1.0, t_h_stretch);
            }
            whiteLayer = vec3(1.0);
        }
    } else {
        // --- FLASHES ---
        float t_flash_phase = (uParameter - 0.45) / 0.55; 
        float cycle_count = 22.0; 
        float raw_cycle = t_flash_phase * cycle_count;
        float cycle_index = floor(raw_cycle);
        float rnd = random(cycle_index + 123.45); 
        int pattern = int(rnd * 7.0); 
        whiteLayer = getScannerScene(pattern, uv);
        whiteAlpha = 1.0; 
        float fade_out = smoothstep_custom(0.90, 1.0, uParameter);
        whiteAlpha *= (1.0 - fade_out);
    }
    // --- COMPOSITE ---
    // Tighter, less intense vignette
    float border = vignetteRect(uv, 0.01); // 1% margin
    whiteAlpha *= border;
    vec3 background = vec3(0.0);
    if (uParameter > 0.90) {
         background = origColor.rgb;
    }
    finalColor.rgb = mix(background, whiteLayer, whiteAlpha);
    gl_FragColor = finalColor;
}
`); 
        this.c.set('shaderParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        // console.log("BootEffect Triggered");
        return true;
    }
    update() {
        if (!this.active) return;
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        let progress = elapsedTime / this.durationSeconds;
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('customShader', this.originalShader);
            this.c.set('shaderEnabled', this.originalShaderEnabled);
            this.c.set('shaderParameter', this.originalShaderParameter);
            // console.log("BootEffect Finished");
            if (this.c.get('runBothInOrder') && this.registry) {
                this.registry.trigger('CrashSequence');
            }
            return;
        }
        this.c.set('shaderParameter', progress);
    }
    getOverride(i) {
        return null;
    }
}
// --- ClearPulseEffect.js ---
class ClearPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "ClearPulse";
        this.active = false;
        this.origin = { x: 0, y: 0 };
        this.radius = 0;
        this.snap = null;
        this.autoTimer = c.state.clearPulseFrequencySeconds * 60;
        this.renderData = null;
    }
    trigger() {
        if (this.active) return false;
        const total = this.g.cols * this.g.rows;
        const s = this.c.state;
        const d = this.c.derived;
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = "MATRIX";
        // Snapshot colors and fill chars
        this.snap = { 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total),
            colors: new Uint32Array(this.g.colors) 
        };
        for (let i = 0; i < total; i++) {
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                 this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                 this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.clearPulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols * 0.2, this.g.cols * 0.8);
            oy = Utils.randomInt(this.g.rows * 0.2, this.g.rows * 0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.clearPulseWidth && pxDistY < s.clearPulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols / 2);
            oy = Math.floor(this.g.rows / 2);
        }
        this.origin = { x: ox, y: oy };
        this.active = true;
        this.radius = s.clearPulseInstantStart ? s.clearPulseWidth * 2 : 0;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * 60);
        return true;
    }
    update() {
        const s = this.c.state;
        if (!this.active && s.clearPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.clearPulseFrequencySeconds * 60;
        }
        if (!this.active) { this.renderData = null; return; }
        this.radius += this.speed;
        const d = this.c.derived;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        if (this.radius > maxDim + 400) { 
            this.active = false; 
            this.snap = null; 
            this.renderData = null; 
            return; 
        }
        // --- Optimization Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX);
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        const width = s.clearPulseWidth * 2;
        const innerEdge = this.radius - width;
        let ratio = 1;
        if (!s.clearPulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        let minX, maxX, minY, maxY;
        if (s.clearPulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, radiusSq: this.radius*this.radius, innerEdge, innerEdgeSq: innerEdge*innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this.c.state;
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: AABB Check
            const x = i % grid.cols; 
            const y = Math.floor(i / grid.cols);
            const cx = Math.floor(x * d.cellWidth * s.stretchX);
            const cy = Math.floor(y * d.cellHeight * s.stretchY);
            if (cx < rd.minX || cx > rd.maxX || cy < rd.minY || cy > rd.maxY) continue;
            // Inner Hole Check
            if (rd.innerEdge > 0) {
                if (s.clearPulseCircular) {
                    if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                        cy > rd.oy - rd.innerEdge && cy < rd.oy + rd.innerEdge) {
                        const dx = cx - rd.ox; const dy = cy - rd.oy;
                        if ((dx * dx + dy * dy) < rd.innerEdgeSq) continue;
                    }
                } else {
                    const rY = rd.innerEdge / rd.ratio;
                    if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                        cy > rd.oy - rY && cy < rd.oy + rY) {
                        continue;
                    }
                }
            }
            // Distance
            let dist;
            if (s.clearPulseCircular) {
                const dx = cx - rd.ox; const dy = cy - rd.oy;
                dist = Math.sqrt(dx * dx + dy * dy);
            } else {
                const dx = Math.abs(cx - rd.ox);
                const dy = Math.abs(cy - rd.oy);
                dist = Math.max(dx, dy * rd.ratio);
            }
            if (dist < rd.innerEdge || dist > rd.radius) continue;
            // --- Apply Override ---
            const alpha = grid.alphas[i];
            const isGap = (alpha <= 0.01);
            if (s.clearPulsePreserveSpaces && isGap) continue;
            let charCode, fontIdx, color;
            // Use LIVE grid data to prevent freezing
            if (isGap) {
                // For gaps, use the snapshot fill data (or just random, but snapshot is stable)
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
                color = d.streamColorUint32;
            } else {
                charCode = grid.chars[i];
                fontIdx = grid.fontIndices[i];
                color = grid.colors[i];
            }
            const rel = Math.max(0, Math.min(1, (rd.radius - dist) / rd.width));
            // Apply Glow Toggle
            const baseGlow = Math.max(s.tracerGlow, 30 * (1.0 - rel));
            const actualGlow = (s.clearPulseUseTracerGlow) ? baseGlow : 0;
            let finalColor, glow;
            if (!s.clearPulseBlend) {
                // Blend OFF: Solid Tracer Color & Glow
                finalColor = tColorInt;
                grid.setEffectOverride(i, String.fromCharCode(charCode), color, alpha, fontIdx, actualGlow)
            } else {
                // Blend ON: Linear fade across the entire wave
                // Color Blend
                const bR = color & 0xFF;
                const bG = (color >> 8) & 0xFF;
                const bB = (color >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * rel);
                const mG = Math.floor(tG + (bG - tG) * rel);
                const mB = Math.floor(tB + (bB - tB) * rel);
                finalColor = Utils.packAbgr(mR, mG, mB);
            }
            // Solid Alpha 1.0
            grid.setEffectOverride(i, String.fromCharCode(charCode), finalColor, 1.0, fontIdx, actualGlow);
        }
    }
}
// --- CrashEffect.js ---
class CrashEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry; 
        this.name = "CrashSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30; 
        this.originalShader = null;
        this.originalShaderEnabled = false;
        this.originalShaderParameter = 0.5;
        this.originalFade = 0; // To store/restore fade speed
        this.frame = 0;
        this.snapshotOverlay = new Map(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.shadowMap = null;
        this.supermanState = {
            active: false,
            type: 0, 
            cells: new Set(), 
            fadingTriangles: [], // Store active reveal zones
            flickerTimer: 0,
            globalTimer: 0,
            boltId: 0
        };
        this.shaderState = {
            activeId: 0, 
            timer: 0,
            duration: 0
        };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.flashState = {
            active: false,
            timer: 0,
            duration: 40, 
            nextFlash: 60, 
            cycleDuration: 240
        };
        this.MAX_BLACK_LEVEL = 0.5; 
        this.baseBlackLevel = this.MAX_BLACK_LEVEL; 
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
    }
    trigger() {
        if (this.active) return false;
        // Snapshot for Deja Vu bars to respect spaces
        this.snap = {
            alphas: new Float32Array(this.g.alphas),
            chars: new Uint16Array(this.g.chars)
        };
        this.originalShaderEnabled = this.c.state.shaderEnabled;
        this.originalShader = this.c.state.customShader;
        this.originalShaderParameter = this.c.state.shaderParameter;
        // Get Stream Color for the Splash
        const colorStr = this.c.derived.streamColorStr || this.c.defaults.streamColor;
        const rgb = Utils.hexToRgb(colorStr);
        const vec3Color = `vec3(${rgb.r/255.0}, ${rgb.g/255.0}, ${rgb.b/255.0})`;
        this.c.set('shaderEnabled', true);
        this.c.set('customShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; 
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) { return fract(sin(n) * 43758.5453123); }
float rect(vec2 uv, vec2 pos, vec2 size) {
    vec2 d = abs(uv - pos) - size;
    return 1.0 - step(0.0, max(d.x, d.y));
}
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
void main() {
    vec2 uv = vTexCoord;
    float phase_idx = floor(uParameter + 0.001);
    float progress = fract(uParameter); 
    vec4 finalColor = texture2D(uTexture, uv);
    vec3 splashColor = ${vec3Color};
    // --- PHASE 10: SPLASH EFFECT ---
    if (phase_idx == 10.0) {
         float t = progress; 
         float bar = scannerSheet(uv, vec2(0.5, 0.5), vec2(1.0, 0.2), 0.3, 1);
         float flashAlpha = bar * (1.0 - smoothstep(0.0, 0.6, t));
         if (flashAlpha > 0.0) {
            finalColor.rgb += splashColor * flashAlpha * 3.0; 
         }
    }
    // --- PHASE 2: DISTORTION ---
    if (phase_idx == 2.0) {
        vec2 center = vec2(0.5, 0.5);
        vec2 dist = uv - center;
        dist.y *= 0.02; 
        vec4 distColor = texture2D(uTexture, center + dist);
        distColor.rgb *= 1.5;
        float active = 1.0 - ((progress - 0.66) / 0.34);
        if (active > 0.0) finalColor = mix(finalColor, distColor, 0.5 * active);
    }
    // --- PHASE 9: STRETCH ---
    if (phase_idx == 9.0) {
        float sampleX = 0.3;
        vec4 stretchColor = texture2D(uTexture, vec2(sampleX, uv.y));
        float flicker = 0.5 + 0.5 * sin(progress * 30.0); 
        if (abs(uv.x - 0.33) < 0.05) { stretchColor.rgb *= 0.3; }
        stretchColor.rgb *= (1.0 + flicker);
        float alpha = (0.5 + 0.5 * flicker) * (1.0 - progress); 
        finalColor = mix(finalColor, stretchColor, alpha);
    }
    gl_FragColor = finalColor;
}
`);
        this.c.set('shaderParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        this.frame = 0;
        this.snapshotOverlay.clear(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.supermanState = { 
            active: false, 
            type: 0, 
            cells: new Set(), 
            illuminatedCells: new Set(), 
            fadingTriangles: [], // Ensure this is initialized!
            flickerTimer: 0, 
            globalTimer: 0, 
            boltId: 0 
        };
        this.shaderState = { activeId: 0, timer: 0, duration: 0 };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
        this.flashState.active = false;
        this.flashState.nextFlash = 30; 
        this.MAX_BLACK_LEVEL = 0.5;
        this.baseBlackLevel = this.c.get('crashEnableFlash') ? this.MAX_BLACK_LEVEL : 0.0; 
        // Immediate Spawn of all sheets
        const maxSheets = this.c.get('crashSheetCount');
        this.blackSheets = [];
        this._updateBlackSheets(maxSheets); // Force fill
        return true;
    }
    update() {
        if (!this.active) return;
        this.frame++; 
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30;
        const progress = elapsedTime / this.durationSeconds;
        this.sheetFadeVal = Math.min(1.0, this.sheetFadeVal + (1.0 / 45.0));
        const sheetOpacity = this.c.get('crashSheetOpacity');
        this.MAX_BLACK_LEVEL = sheetOpacity; 
        // Trigger End Pulse
        if (progress > 0.92 && !this.endFlashTriggered) {
            this.endFlashTriggered = true;
            if (this.registry) {
                const originalPulseDelay = this.c.get('pulseDelaySeconds');
                const originalPulseMA = this.c.get('pulseMovieAccurate');
                this.c.set('pulseDelaySeconds', 0.1);
                this.c.set('pulseMovieAccurate', true);
                this.registry.trigger('Pulse');
                this.c.set('pulseDelaySeconds', originalPulseDelay);
                this.c.set('pulseMovieAccurate', originalPulseMA);
            }
        }
        // --- END ---
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('customShader', this.originalShader);
            this.c.set('shaderEnabled', this.originalShaderEnabled);
            this.c.set('shaderParameter', this.originalShaderParameter);
            this.snapshotOverlay.clear();
            this.blackSheets = [];
            this.crashBars = [];
            this.supermanState.cells.clear();
            this.supermanState.illuminatedCells.clear();
            this.supermanState.geometry = null;
            return;
        }
        // --- FLASH & FADE LOGIC ---
        const enableFlash = this.c.get('crashEnableFlash');
        if (enableFlash) {
            this.baseBlackLevel = this.MAX_BLACK_LEVEL * this.sheetFadeVal;
            if (this.flashState.active) {
                this.flashState.timer++;
                const p = Math.min(1.0, this.flashState.timer / this.flashState.duration);
                this.c.set('shaderParameter', 10.0 + p);
                if (this.flashState.timer === 1) this.sheetFadeVal = 0.0; 
                if (this.flashState.timer >= this.flashState.duration) {
                    this.flashState.active = false;
                    this.c.set('shaderParameter', 0.0);
                }
            } else {
                this.flashState.nextFlash--;
                if (this.flashState.nextFlash <= 0) this._triggerFlash();
            }
        } else {
            this.baseBlackLevel = 0.0;
            this.c.set('shaderParameter', 0.0);
        }
        // --- SHADERS ---
        if (!this.flashState.active) {
            if (this.shaderState.activeId === 0) {
                 if (Math.random() < 0.01) {
                    const r = Math.random();
                    let id = 0; let dur = 0;
                    if (r < 0.3) { id = 3; dur = 20; } // These IDs need to match shader code or be unused
                    else if (r < 0.6) { id = 9; dur = 30; } // Phase 9 is implemented
                    else { id = 2; dur = 40; } // Phase 2 is implemented
                    if (id === 2 || id === 9) {
                        this.shaderState.activeId = id;
                        this.shaderState.duration = dur;
                        this.shaderState.timer = 0;
                    }
                 }
            } else {
                this.shaderState.timer++;
                if (this.shaderState.timer >= this.shaderState.duration) {
                    this.shaderState.activeId = 0;
                    this.c.set('shaderParameter', 0.0);
                } else {
                    const p = this.shaderState.timer / this.shaderState.duration;
                    this.c.set('shaderParameter', this.shaderState.activeId + p);
                }
            }
        }
        // --- BLACK SHEETS ---
        const maxSheets = this.c.get('crashSheetCount');
        this.sheetState.timer--;
        if (this.sheetState.timer <= 0) {
            this.sheetState.spawning = !this.sheetState.spawning;
            this.sheetState.timer = this.sheetState.spawning ? 400 : 200; 
        }
        // Always call _updateBlackSheets to handle movement/wrapping, even if not spawning
        this._updateBlackSheets(this.sheetState.spawning ? maxSheets : 0);
        if (this.blackSheets.length > maxSheets) this.blackSheets.splice(maxSheets);
        // --- SUPERMAN (Lightning) ---
        if (this.c.get('crashEnableSuperman')) {
            if (this.supermanState.active) {
                this.supermanState.globalTimer--;
                // Update every frame for smooth animation
                this._generateSupermanBolt();
                if (this.supermanState.globalTimer <= 0) {
                    // Transition Active Reveal to Fading
                    if (this.supermanState.activeReveal) {
                        this.supermanState.fadingTriangles.push(this.supermanState.activeReveal);
                        this.supermanState.activeReveal = null;
                    }
                    this.supermanState.active = false;
                    this.supermanState.cells.clear();
                    this.supermanState.geometry = null;
                }
            } else {
                // Random trigger
                if (Math.random() < 0.02) {
                    const type = Math.random() < 0.5 ? 0 : 1; 
                    this._triggerSuperman(type);
                }
            }
        } else {
            this.supermanState.active = false;
        }
        // Update Fading Triangles (Reveals)
        for (let i = this.supermanState.fadingTriangles.length - 1; i >= 0; i--) {
            const t = this.supermanState.fadingTriangles[i];
            t.alpha -= 0.05; // Fade out speed
            if (t.alpha <= 0) {
                this.supermanState.fadingTriangles.splice(i, 1);
            }
        }
        // --- OTHER ELEMENTS ---
        this._updateSnapshots();
        // Update Crash Bars
        for (let i = this.crashBars.length - 1; i >= 0; i--) {
            const b = this.crashBars[i];
            b.age++;
            if (b.age > b.maxAge) {
                this.crashBars.splice(i, 1);
            }
        }
        if (Math.random() < 0.005) this._triggerWhiteBlock(); 
        if (Math.random() < 0.02) this._triggerColumnBurst(); 
        if (this.c.get('crashEnableSmith')) {
            if (!this.smithState.triggered && Math.random() < 0.001) { 
                this._triggerSmith();
            }
            if (this.smithState.active) {
                this.smithState.timer--;
                if (this.smithState.timer <= 0) this.smithState.active = false;
            }
        }
        if (this.registry) {
            if (Math.random() < 0.001) this.registry.trigger('ClearPulse');
        }
    }
    applyToGrid(grid) {
        if (!this.active) return;
        const cols = grid.cols;
        const rows = grid.rows;
        // 1. Black Sheets - GPU HANDLED (Mask Texture)
        // 2. Superman Lightning (Updated)
        if (this.supermanState.active) {
            const tracerColor = this.c.derived.tracerColorUint32;
            // Triangle Reveals are now GPU HANDLED via getReveals() / Shadow Mask Punch-out
            // Render Main Bolt (Foreground)
            if (this.supermanState.cells.size > 0) {
                for (const idx of this.supermanState.cells) {
                    const char = grid.getChar(idx);
                    if (char !== ' ') {
                        // Bolt: Tracer Color, High Glow
                        grid.setHighPriorityEffect(idx, char, tracerColor, 1.0, grid.fontIndices[idx], 1.0);
                    }
                }
            }
        }
        // 3. Crash Bars (Deja Vu Bars) - Updated Logic
        if (this.crashBars.length > 0) {
            const whiteColor = 0xFFFFFFFF; 
            const tR = 255, tG = 255, tB = 255; 
            for (const bar of this.crashBars) {
                // Calculate Fade
                let fade = 1.0;
                if (bar.age < 6) fade = bar.age / 6.0;
                else if (bar.age > bar.maxAge - 20) fade = Math.max(0, (bar.maxAge - bar.age) / 20.0);
                // Logic for Type 2 (Jump)
                let renderY = bar.y;
                if (bar.type === 2) {
                    if (bar.age > 8) renderY = bar.y + 6;
                }
                // Render Blocks function
                const renderBlock = (y, h) => {
                    const limitY = Math.min(rows, y + h);
                    const limitX = Math.min(cols, bar.x + bar.w);
                    for (let r = y; r < limitY; r++) {
                        const rowOffset = r * cols;
                        for (let x = bar.x; x < limitX; x++) {
                            const idx = rowOffset + x;
                            // 1. Alpha Variance (20% spread)
                            const hash = Math.sin(idx * 12.9898 + bar.id) * 43758.5453;
                            const rnd = hash - Math.floor(hash);
                            const variance = (rnd - 0.5) * 0.2; 
                            let barAlpha = Math.min(1.0, Math.max(0, 0.7 + variance)) * fade;
                            if (barAlpha <= 0.01) continue;
                            // 2. Flash in together (Respect Spaces)
                            const liveAlpha = grid.alphas[idx];
                            const liveChar = grid.chars[idx];
                            const liveColor = grid.colors[idx];
                            const fontIdx = grid.fontIndices[idx];
                            let charStr, displayFont;
                            if (liveAlpha > 0.01) {
                                // Use Live Code
                                charStr = String.fromCharCode(liveChar);
                                displayFont = fontIdx;
                            } else if (this.snap && this.snap.alphas[idx] > 0.01) {
                                // Stream segment gap: fill to "flash in together"
                                const charSeed = (idx ^ Math.floor(bar.id)) * 7.123;
                                const charCode = Utils.CHARS.charCodeAt(Math.floor((charSeed - Math.floor(charSeed)) * Utils.CHARS.length));
                                charStr = String.fromCharCode(charCode);
                                displayFont = 0;
                            } else {
                                // Respect permanent spaces/holes
                                continue; 
                            }
                            // 3. Bright White Blending
                            const lR = liveColor & 0xFF; 
                            const lG = (liveColor >> 8) & 0xFF; 
                            const lB = (liveColor >> 16) & 0xFF;
                            const blendWeight = 0.8;
                            const mR = Math.floor(lR + (255 - lR) * blendWeight);
                            const mG = Math.floor(lG + (255 - lG) * blendWeight);
                            const mB = Math.floor(lB + (255 - lB) * blendWeight);
                            const finalColor = Utils.packAbgr(mR, mG, mB);
                            grid.setHighPriorityEffect(idx, charStr, finalColor, 1.0, displayFont, 1.2 * barAlpha); 
                        }
                    }
                };
                // Render based on Type
                if (bar.type === 1) {
                    // Split: Two bars, 10 high, split by 16-18
                    // bar.y is top of first.
                    renderBlock(bar.y, 10);
                    renderBlock(bar.y + 10 + 17, 10);
                } else if (bar.type === 2) {
                    // Jump
                    renderBlock(renderY, bar.h);
                } else {
                    // Standard
                    renderBlock(bar.y, bar.h);
                }
            }
        }
        // 4. Snapshots (Smith)
        for (const [idx, snap] of this.snapshotOverlay) {
             if (snap.alpha <= 0.01) continue;
             const char = snap.char;
             // Snap color is stored as hex string
             const color = Utils.hexToRgb(snap.color);
             const packedColor = Utils.packAbgr(color.r, color.g, color.b);
             grid.setOverride(idx, char, packedColor, snap.alpha, grid.fontIndices[idx], snap.isSmith ? 0 : 8.0);
        }
    }
    _triggerFlash() {
        this.flashState.active = true;
        this.flashState.timer = 0;
        this.flashState.duration = 40; 
        const minS = this.c.get('crashFlashDelayMin');
        const maxS = this.c.get('crashFlashDelayMax');
        this.flashState.nextFlash = (minS + Math.random() * (maxS - minS)) * 60; 
    }
    _updateBlackSheets(maxSheets) {
        // Fill up to maxSheets immediately
        while (this.blackSheets.length < maxSheets) { 
            const grid = this.g;
            // Generate dimensions (4 to 16)
            const w = Utils.randomInt(4, 16);
            const h = Utils.randomInt(4, 16);
            let c = Math.floor(Math.random() * (grid.cols - w));
            let row = Math.floor(Math.random() * (grid.rows - h));
            // Orthogonal Movement Logic
            const speedScale = (Math.random() * 1.5 + 0.5); 
            let dx = 0;
            let dy = 0;
            // Configurable Chance to be stationary
            const stationaryChance = this.c.get('crashStationaryChance') / 100.0;
            if (Math.random() > stationaryChance) {
                const axis = Math.random() < 0.5 ? 'x' : 'y';
                const dir = Math.random() < 0.5 ? 1 : -1;
                dx = axis === 'x' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
                dy = axis === 'y' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
            }
            const maxAlpha = this.c.get('crashSheetOpacity');
            this.blackSheets.push({ 
                c, r: row, w, h,
                posX: c, posY: row, 
                baseDx: dx, 
                baseDy: dy, 
                targetW: w, targetH: h, 
                // Requirement 1: Immediate Spawn (No Fade In)
                currentAlpha: maxAlpha, 
                targetAlpha: maxAlpha, 
                maxAlpha: maxAlpha,
                blur: 0.0
            });
        }
        // Update Position & Wrapping
        for (const s of this.blackSheets) {
            // Update Alpha (Fade Out logic handled by sheetFadeVal globally, but per-sheet fade-in removed)
            s.maxAlpha = this.c.get('crashSheetOpacity') * this.sheetFadeVal;
            s.currentAlpha = s.maxAlpha; 
            // Move
            s.posX += s.baseDx * this.c.get('crashSheetSpeed');
            s.posY += s.baseDy * this.c.get('crashSheetSpeed');
            // Wrapping Logic (Requirement 2)
            if (s.posX > this.g.cols) s.posX -= this.g.cols;
            if (s.posX + s.w < 0) s.posX += this.g.cols;
            if (s.posY > this.g.rows) s.posY -= this.g.rows;
            if (s.posY + s.h < 0) s.posY += this.g.rows;
        }
    }
    // New Generic Interface for Renderer (Requirement 4: Layering/Wrapping Visuals)
    getMasks() {
        if (!this.active) return [];
        const masks = [];
        const cols = this.g.cols;
        const rows = this.g.rows;
        for (const s of this.blackSheets) {
            // Main Body
            masks.push({
                x: s.posX, y: s.posY, w: s.w, h: s.h,
                alpha: s.currentAlpha, blur: s.blur
            });
            // Horizontal Wrapping Ghost
            if (s.posX + s.w > cols) {
                masks.push({
                    x: s.posX - cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posX < 0) {
                 masks.push({
                    x: s.posX + cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
            // Vertical Wrapping Ghost
            if (s.posY + s.h > rows) {
                masks.push({
                    x: s.posX, y: s.posY - rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posY < 0) {
                masks.push({
                    x: s.posX, y: s.posY + rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
        }
        return masks;
    }
    _getFontName(i) {
        const fontIdx = this.g.fontIndices[i];
        const fonts = this.c.derived.activeFonts;
        return (fonts && fonts[fontIdx]) ? fonts[fontIdx].name : this.c.state.fontFamily;
    }
    _triggerSmith() {
        this.smithState.triggered = true;
        this.smithState.active = true;
        this.smithState.timer = 60; 
        const asciiArt = [
            "                                      *##*#*####+                                        ",
            "                                   # @@@%%#%%%%%##*-                                      ",
            "                                  % @%%#*+**+=::=*+-=:                                    ",
            "                                 % @#+                -#                                  ",
            "                                = @#=                  .%                                 ",
            "                                @@#-                   +=                                ",
            "                               = @@%*-:                 + @                                ",
            "                               * @@@#=:.               .+ @                                ",
            "                               * @@@*-                  = @                                ",
            "                               : @@@+-=#@@@@@@@*-+%@@@@@%=                                ",
            "                               -+%%+-*% @@@@@@@.  % @@@%%%%                                ",
            "                              :***%+-:-% @@@@%=   .#%%#*#=                                ",
            "                               :-:*+-:..-++-=     ===-:+:                                ",
            "                                --*#+++=-...-+%###:-===+                                 ",
            "                                 :=**++=--.  :*#*.   :+                                  ",
            "                                   =*+++=-    -===.  .-                                  ",
            "                                   *##**+-+**+.     :-                                   ",
            "                                   **#####**########*                                    ",
            "                                   +*######*+=--.  -*                                    ",
            "                                   +*+*#####********+                                    ",
            "                                   # -++########*#*++ .                                  ",
            "                                 .%*    =*#######*+-  ++                                 ",
            "                              .*#%%#-      =####**    ++=-=.                             ",
            "                         :=+***##%%##        .***     +++=--===--:                       ",
            "                  +++++++++*+*########       :###%    ++++==-+======--                   ",
            "               +***++++++++++****####**      #%**#+    *+++***+====+++++==               ",
            "            =*+*+++++++++++++*%%#*##***+      #**      =++++*++==+********+              ",
            "            %#*++++*++++**+++++*#*#****+      ++*       +++++++++******####*             ",
            "            ###*+++**+++***+++*+++******+     ++*#      -=+++++++*****#%%%##:            ",
            "            ####**+***+++***++#*+++*****+:    =+*##     .=++++==+*****#%%%#%%            ",
            "           -#####******+++****+*++++*****+    =+*##*     =+++===+*#**##%%%#%%-           ",
            "           *%#######***+++*****+*+++++****+   -***#**    =+++===+*#**##%%%% @%%           ",
            "           #%#*###*##***+++*****+#+++++****=  :*#####=   -=++===**#*##%%%%%%%%           ",
            "           #%#*##%##%#**++++****++#+++++***+   =++++++    =++===*#####%%%% @@%%           "
        ];
        const grid = this.g;
        const artHeight = asciiArt.length;
        const artWidth = asciiArt[0].length; // Assuming consistent width or max width
        const startR = Math.floor((grid.rows - artHeight) / 2);
        const startC = Math.floor((grid.cols - artWidth) / 2);
        const endFrame = this.frame + 60;
        for (let r = 0; r < artHeight; r++) {
            const line = asciiArt[r];
            const rowIdx = startR + r;
            if (rowIdx < 0 || rowIdx >= grid.rows) continue;
            for (let c = 0; c < line.length; c++) {
                const char = line[c];
                if (char === ' ') continue; // Skip spaces
                const colIdx = startC + c;
                if (colIdx < 0 || colIdx >= grid.cols) continue;
                const i = rowIdx * grid.cols + colIdx;
                this.snapshotOverlay.set(i, {
                    char: char, 
                    color: this.c.derived.tracerColorStr, 
                    alpha: 1.0, // Full brightness for ASCII art
                    endFrame: endFrame, 
                    isSmith: true
                });
            }
        }
    }
    _getStaticChar(idx) {
        // Deterministic pseudo-random character based on index and current bolt
        // Simple hash: (idx * magic1 + boltId * magic2) % len
        const seed = Math.floor(idx * 137 + this.supermanState.boltId * 997);
        const charSet = Utils.CHARS;
        return charSet[seed % charSet.length];
    }
    _triggerSuperman(type) {
        this.supermanState.active = true;
        this.supermanState.type = type; 
        this.supermanState.globalTimer = 60; // Short duration
        this.supermanState.flickerTimer = 0;
        this.supermanState.boltId = Math.random() * 1000; // Unique ID for this bolt instance
        this._generateSupermanBolt();
    }
    _generateSupermanBolt() {
        const s = this.supermanState;
        s.cells.clear();
        if (!s.geometry) {
            this._initSupermanGeometry();
            // Initialize active reveal for this new bolt
            s.activeReveal = { 
                type: 'strip', 
                trunk: [], 
                branch: [], 
                alpha: 1.0 
            };
        }
        const g = s.geometry;
        // Draw Main Path and capture points
        const trunkPoints = this._drawJaggedLine(g.start.x, g.start.y, g.end.x, g.end.y, s.cells, 2);
        // Update active reveal geometry
        if (s.activeReveal) {
            s.activeReveal.trunk = trunkPoints;
            s.activeReveal.branch = []; // Reset branch
        }
        // Draw Branches
        if (g.branches) {
            for (const b of g.branches) {
                const branchPoints = this._drawJaggedLine(g.split.x, g.split.y, b.x, b.y, s.cells, 1);
                // For the reveal, we only care about the first/longest branch to define the "V" shape
                // If there are multiple, we could potentially handle them, but let's stick to the primary split for the reveal web
                if (s.activeReveal && s.activeReveal.branch.length === 0) {
                    s.activeReveal.branch = branchPoints;
                }
            }
        }
    }
    _initSupermanGeometry() {
        const grid = this.g;
        const s = this.supermanState;
        // 1. Pick Start/End Corners
        const corners = [
            { x: 0, y: 0 }, // TL
            { x: grid.cols - 1, y: 0 }, // TR
            { x: grid.cols - 1, y: grid.rows - 1 }, // BR
            { x: 0, y: grid.rows - 1 } // BL
        ];
        const startIdx = Utils.randomInt(0, 3);
        const endIdx = (startIdx + 2) % 4; // Opposite corner
        const start = corners[startIdx];
        const end = corners[endIdx];
        s.geometry = { start, end };
        // Type 1: Branching
        if (s.type === 1) {
            // Split Point (35-40%)
            const splitT = 0.35 + (Math.random() * 0.05);
            const splitX = Math.floor(start.x + (end.x - start.x) * splitT);
            const splitY = Math.floor(start.y + (end.y - start.y) * splitT);
            s.geometry.split = { x: splitX, y: splitY };
            // Calculate Main Bolt Angle
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const mainAngle = Math.atan2(dy, dx);
            const branches = [];
            const numBranches = Utils.randomInt(1, 3);
            let furthestBranch = null;
            let maxDist = -1;
            // Define adjacent edges for the END corner
            for (let i = 0; i < numBranches; i++) {
                let tx, ty;
                let attempts = 0;
                let valid = false;
                while (!valid && attempts < 10) {
                    attempts++;
                    const useHorizontal = Math.random() < 0.5;
                    if (useHorizontal) {
                        ty = end.y;
                        tx = Utils.randomInt(0, grid.cols - 1);
                    } else {
                        tx = end.x;
                        ty = Utils.randomInt(0, grid.rows - 1);
                    }
                    // Check Angle Constraint (< 50 deg)
                    const bDx = tx - splitX;
                    const bDy = ty - splitY;
                    const branchAngle = Math.atan2(bDy, bDx);
                    let diff = Math.abs(branchAngle - mainAngle);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff; // Normalize to 0..PI
                    const deg = diff * (180 / Math.PI);
                    if (deg < 50) {
                        valid = true;
                    }
                }
                if (valid) {
                    const bPoint = { x: tx, y: ty };
                    branches.push(bPoint);
                    const d = Math.hypot(tx - splitX, ty - splitY);
                    if (d > maxDist) {
                        maxDist = d;
                        furthestBranch = bPoint;
                    }
                }
            }
            s.geometry.branches = branches;
        }
    }
    getReveals() {
        const reveals = [...this.supermanState.fadingTriangles];
        if (this.supermanState.activeReveal) {
            reveals.push(this.supermanState.activeReveal);
        }
        return reveals;
    }
    _drawJaggedLine(x0, y0, x1, y1, set, baseThickness = 1) {
        const points = [];
        // Elastic / Arcing Lightning with Time-Based Animation
        const dist = Math.hypot(x1 - x0, y1 - y0);
        const steps = Math.ceil(dist * 0.8); // High resolution for smooth arcs
        // Perpendicular Vector for displacement
        const dx = x1 - x0;
        const dy = y1 - y0;
        const nx = -dy / dist; // Normalized Perpendicular X
        const ny = dx / dist;  // Normalized Perpendicular Y
        let px = x0;
        let py = y0;
        const time = this.frame * 0.3; 
        const seed = this.supermanState.boltId; 
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            let tx = x0 + dx * t;
            let ty = y0 + dy * t;
            const thickness = baseThickness;
            // Chaotic Displacement
            const arc1 = Math.sin(t * Math.PI + seed + time * 0.5) * 4.0;
            const arc2 = Math.sin(t * Math.PI * 4.0 + seed * 2.0 - time * 1.5) * 2.0;
            const jitter = Math.sin(t * Math.PI * 25.0 + time * 8.0) * 0.8;
            const noise = (Math.random() - 0.5) * 1.2;
            const envelope = Math.sin(t * Math.PI); 
            const displacement = (arc1 + arc2 + jitter + noise) * envelope * 2.0;
            tx += nx * displacement;
            ty += ny * displacement;
            points.push({x: tx, y: ty}); // Capture point
            if (i > 0) {
                this._drawLine(px, py, tx, ty, set, thickness);
            }
            px = tx;
            py = ty;
        }
        return points;
    }
    _drawLine(x0, y0, x1, y1, set, thickness = 1) {
        // Bresenham-like algorithm for connected line
        let x = Math.floor(x0);
        let y = Math.floor(y0);
        const endX = Math.floor(x1);
        const endY = Math.floor(y1);
        const dx = Math.abs(endX - x);
        const dy = Math.abs(endY - y);
        const sx = (x < endX) ? 1 : -1;
        const sy = (y < endY) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            // Apply thickness by adding neighbors
            for (let ox = 0; ox < thickness; ox++) {
                for (let oy = 0; oy < thickness; oy++) {
                    const cx = x + ox;
                    const cy = y + oy;
                    if (cx >= 0 && cx < this.g.cols && cy >= 0 && cy < this.g.rows) {
                        set.add(cy * this.g.cols + cx);
                    }
                }
            }
            if (x === endX && y === endY) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                y += sy;
            }
        }
    }
    _triggerWhiteBlock() {
        const grid = this.g;
        // Random Type: 0, 1, 2
        const type = Math.floor(Math.random() * 3);
        let h = 11;
        if (type === 1) h = 30; // 10 + 17 + 10 approx space needed
        if (type === 2) h = 14; 
        const r = Math.floor(Math.random() * (grid.rows - h));
        const duration = 40; // 6 fade in + 14 linger + 20 fade out
        this.crashBars.push({
            x: 0, 
            y: r,
            w: grid.cols, 
            h: h,
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000,
            type: type
        });
    }
    _triggerColumnBurst() {
        const grid = this.g;
        const col = Math.floor(Math.random() * grid.cols);
        let startRow = Math.floor(Math.random() * (grid.rows / 2)); 
        let height = Math.floor(Math.random() * (grid.rows / 2)) + (grid.rows / 4);
        if (Math.random() < 0.3) { startRow = 0; height = grid.rows; }
        const duration = 8; 
        this.crashBars.push({
            x: col, 
            y: startRow,
            w: 1, 
            h: height,
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000 
        });
    }
    _updateSnapshots() {
        const currentFrame = this.frame; 
        for (const [index, snapshot] of this.snapshotOverlay.entries()) {
            if (currentFrame > snapshot.endFrame) this.snapshotOverlay.delete(index);
            else {
                const rem = snapshot.endFrame - currentFrame;
                if (snapshot.isSmith) { if (rem < 30) snapshot.alpha = rem / 30.0; } 
                else { if (rem < 10) snapshot.alpha = rem / 10.0; }
            }
        }
    }
}
// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); 
        this.name = "DejaVu"; 
        this.active = false; 
        this.autoTimer = c.state.dejaVuFrequencySeconds * 60; 
        this.map = null;
        this.bars = [];
        // Sub-effect states
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Shader State
        this.shaderActive = false;
        this.originalFade = 0;
    }
    trigger() { 
        if(this.active) return false; 
        this.active = true; 
        this.timer = this.c.state.dejaVuDurationSeconds * 60; 
        this.bars = []; 
        this.map = new Uint8Array(this.g.rows); 
        // Reset sub-effects
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Override Stream Fade
        this.originalFade = this.c.get('decayFadeDurationFrames');
        this.c.set('decayFadeDurationFrames', 0);
        // Enable Glitch Shader
        this._enableShader();
        return true; 
    }
    _enableShader() {
        if (this.shaderActive) return;
        const glitchShader = `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
varying vec2 vTexCoord;
float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
void main() {
    vec2 uv = vTexCoord;
    vec4 color = texture2D(uTexture, uv);
    float t = floor(uTime * 15.0);
    if (rand(vec2(t, 1.0)) > 0.95) {
        float ry = rand(vec2(t, 2.0));
        float rh = rand(vec2(t, 3.0)) * 0.15; 
        if (uv.y > ry && uv.y < ry + rh) {
             float shift = (rand(vec2(t, 4.0)) - 0.5) * 0.02;
             float r = texture2D(uTexture, vec2(uv.x + shift + 0.003, uv.y)).r;
             float g = texture2D(uTexture, vec2(uv.x + shift, uv.y)).g;
             float b = texture2D(uTexture, vec2(uv.x + shift - 0.003, uv.y)).b;
             float a = texture2D(uTexture, vec2(uv.x + shift, uv.y)).a;
             color = vec4(r, g, b, a);
             if (rand(vec2(t, 5.0)) > 0.8) {
                float dir = (rand(vec2(t, 6.0)) > 0.5) ? 1.0 : -1.0;
                float jump = dir * (0.03 + rand(vec2(t, 7.0)) * 0.04);
                color = texture2D(uTexture, vec2(uv.x + jump, uv.y));
             }
        }
    }
    gl_FragColor = color;
}
`;
        this.c.set('effectShader', glitchShader);
        this.shaderActive = true;
    }
    _disableShader() {
        if (!this.shaderActive) return;
        this.c.set('effectShader', null);
        this.shaderActive = false;
    }
    update() {
        const s = this.c.state;
        if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
        if(!this.active) return;
        if(this.timer-- <= 0) { 
            this.active = false; 
            this.bars = []; 
            this.map = null; 
            this._disableShader();
            // Restore Fade
            this.c.set('decayFadeDurationFrames', this.originalFade);
            return; 
        }
        this.map.fill(0);
        if(Math.random() < s.dejaVuIntensity) {
            const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); 
            const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
            const duration = s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10);
            this.bars.push({ y, h, age: 0, maxAge: duration });
            if (this.g.glowSystem) {
                this.g.glowSystem.addRect(
                    this.g.cols / 2, y + (h / 2), this.g.cols, h, 2.0, this.c.derived.streamColorUint32, duration, 'linear', 4
                );
            }
        }
        const activeFonts = this.c.derived.activeFonts;
        const glitchCount = Math.max(1, Math.floor(this.g.cols * 0.05));
        const cols = this.g.cols;
        const rows = this.g.rows;
        const randomizeColors = s.dejaVuRandomizeColors;
        for(let i=this.bars.length-1; i>=0; i--) {
            const b = this.bars[i]; 
            b.age++;
            if(b.age > b.maxAge) { this.bars.splice(i, 1); continue; } 
            const limit = Math.min(rows, b.y + b.h);
            for(let r=b.y; r < limit; r++) {
                this.map[r] = 1; 
                for(let k=0; k<glitchCount; k++) {
                    const x = (Math.random() * cols) | 0;
                    const idx = r * cols + x;
                    this.g.mix[idx] = 0; 
                    const fontIdx = (Math.random() * activeFonts.length) | 0;
                    const fontData = activeFonts[fontIdx];
                    if (fontData.chars.length > 0) {
                        const char = fontData.chars[(Math.random() * fontData.chars.length) | 0];
                        let color = this.g.colors[idx];
                        const alpha = this.g.alphas[idx];
                        const glow = this.g.glows[idx];
                        if(randomizeColors) {
                            const h = (Math.random() * 360) | 0;
                            const rgb = Utils.hslToRgb(h, 90, 70);
                            color = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                            this.g.complexStyles.set(idx, { h, s: 90, l: 70, glitched: true });
                            this.g.baseColors[idx] = color;
                        }
                        this.g.setPrimary(idx, char, color, alpha, fontIdx, glow);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            this.vertGlitch.timer--;
            if (this.vertGlitch.timer <= 0) this.vertGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.vertGlitch.active = true;
                this.vertGlitch.timer = 15; 
                this.vertGlitch.width = Utils.randomInt(4, 7);
                this.vertGlitch.srcX = Utils.randomInt(0, this.g.cols - this.vertGlitch.width);
            }
        }
        if (this.doubleGlitch.active) {
            this.doubleGlitch.timer--;
            if (this.doubleGlitch.timer <= 0) this.doubleGlitch.active = false;
        } else {
            if (Math.random() < 0.015) {
                this.doubleGlitch.active = true;
                this.doubleGlitch.timer = Utils.randomInt(5, 15);
                this.doubleGlitch.h = Math.floor(this.g.rows / 3);
                this.doubleGlitch.startY = Utils.randomInt(0, this.g.rows - this.doubleGlitch.h);
                this.doubleGlitch.shiftX = Utils.randomInt(5, 20) * (Math.random() < 0.5 ? 1 : -1);
            }
        }
        if (this.horizGlitch.active) {
            this.horizGlitch.timer--;
            if (this.horizGlitch.timer <= 0) this.horizGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.horizGlitch.active = true;
                this.horizGlitch.timer = Utils.randomInt(5, 10);
                this.horizGlitch.shift = Utils.randomInt(3, 10) * (Math.random() < 0.5 ? 1 : -1);
                this.horizGlitch.flash = Math.random() < 0.5;
                this.horizGlitch.rows = [];
                const count = Utils.randomInt(5, 20);
                for(let i=0; i<count; i++) {
                    this.horizGlitch.rows.push(Utils.randomInt(0, this.g.rows-1));
                }
            }
        }
    }
    applyToGrid(grid) {
        if(!this.active) return;
        if (!this.map) return;
        const s = this.c.state; 
        const d = this.c.derived;
        const cols = grid.cols;
        const tracerColor = d.tracerColorUint32;
        const holeBrightness = s.dejaVuHoleBrightness;
        const activeFonts = d.activeFonts;
        const fallbackFontIdx = 0;
        const fallbackChars = activeFonts[0].chars;
        const timeSeed = Math.floor(Date.now() / 150);
        for (let y = 0; y < grid.rows; y++) {
            if (this.map[y] === 1) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const baseAlpha = grid.alphas[i];
                    const char = grid.getChar(i);
                    const fontIdx = grid.fontIndices[i];
                    if (baseAlpha < 0.01) {
                        if (holeBrightness > 0.01) {
                            if (fallbackChars && fallbackChars.length > 0) {
                                const hash = (i ^ timeSeed) * 2654435761;
                                const rndIdx = (hash & 0x7FFFFFFF) % fallbackChars.length;
                                grid.setOverride(i, fallbackChars[rndIdx], tracerColor, holeBrightness, fallbackFontIdx, 0);
                            } else {
                                grid.setOverride(i, char, tracerColor, holeBrightness, fallbackFontIdx, 0);
                            }
                        }
                    } else {
                        grid.setOverride(i, char, tracerColor, baseAlpha, fontIdx, 0);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            const { srcX, width } = this.vertGlitch;
            for (let y = 0; y < grid.rows; y++) {
                if (this.map[y] !== 1) continue;
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const readX = srcX + (x % width);
                    if (readX >= cols) continue;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor; 
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.doubleGlitch.active) {
            const { startY, h, shiftX } = this.doubleGlitch;
            const endY = Math.min(grid.rows, startY + h);
            for (let y = startY; y < endY; y++) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shiftX;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor;
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.horizGlitch.active) {
            const { rows, shift, flash } = this.horizGlitch;
            for (const r of rows) {
                if (r >= grid.rows) continue;
                const rowOffset = r * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shift;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    let char = grid.getChar(readIdx);
                    let alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    let color = grid.colors[readIdx];
                    let glow = grid.glows[readIdx];
                    const needsRandom = flash || (alpha < 0.1);
                    if (needsRandom && fallbackChars && fallbackChars.length > 0) {
                         const rndIdx = (Math.random() * fallbackChars.length) | 0;
                         char = fallbackChars[rndIdx];
                    }
                    if (flash) {
                        color = 0xFFFFFFFF; 
                        alpha = 1.0;
                        glow = 5.0; 
                    } else {
                         color = tracerColor;
                    }
                    grid.setOverride(i, char, color, alpha, fontIdx, glow);
                }
            }
        }
    }
}
// --- FirewallEffect.js ---
class FirewallEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "Firewall";
        this.active = false;
        this.autoTimer = c.state.firewallFrequencySeconds * 60;
        this.column = -1;
        this.state = 'IDLE'; 
        this.reverseTimer = 0;
        this.eraseTimer = 0;
        this.snapChars = null;
        this.cleanupFrames = 2; // Add a final cleanup buffer frame
        this.shiftCounter = 0;
        this.shiftInterval = 2; // Shift every 2 frames during reversing
        this._firewallRandomColor = null; // Store the random color for a given trigger
    } // Added missing closing brace
    trigger() {
        if (this.active) return false;
        // 1. Pick Random Column
        this.column = Utils.randomInt(1, this.g.cols - 2); 
        this.reverseTimer = this.c.state.firewallReverseDurationFrames; 
        this.eraseTimer = this.c.state.firewallEraseDurationFrames + this.cleanupFrames; // Add buffer
        this.active = true;
        this.state = 'REVERSING';
        // 2. Snapshot the existing code
        this.snapChars = new Uint16Array(this.g.rows);
        for (let y = 0; y < this.g.rows; y++) {
            const idx = this.g.getIndex(this.column, y);
            this.snapChars[y] = this.g.chars[idx];
        }
        // Generate random color once per trigger if enabled
        if (this.c.state.firewallRandomColorEnabled) {
            const randomHue = Utils.randomInt(0, 359);
            this._firewallRandomColor = Utils.hslToRgb(randomHue, 100, 70);
        } else {
            this._firewallRandomColor = null; // Clear if not using random color
        }
        return true;
    }
    update() {
        const s = this.c.state;
        // Auto-trigger logic
        if (!this.active && s.firewallEnabled && this.autoTimer-- <= 0) { 
            this.trigger(); 
            this.autoTimer = s.firewallFrequencySeconds * 60; 
        }
        if (!this.active) { return; }
        if (this.state === 'REVERSING') {
            if (this.reverseTimer-- <= 0) {
                this.state = 'ERASING';
            } else {
                this.shiftCounter++;
                if (this.shiftCounter >= this.shiftInterval) {
                    this._shiftColumnCharsUpwards();
                    this.shiftCounter = 0;
                }
            }
        } else if (this.state === 'ERASING') {
            this.eraseTimer--;
            // If we are in the last two frames (cleanup buffer), ensure the column is empty
            if (this.eraseTimer <= this.cleanupFrames) {
                // Deep clean the column so it is totally empty
                for (let y = 0; y < this.g.rows; y++) {
                    const idx = this.g.getIndex(this.column, y);
                    this.g.clearCell(idx);
                }
            }
            if (this.eraseTimer <= 0) {
                this.active = false;
                this.snapChars = null;
            }
        }
    }
    _shiftColumnCharsUpwards() {
        if (!this.snapChars) return;
        const topChar = this.snapChars[0];
        for (let y = 0; y < this.g.rows - 1; y++) {
            this.snapChars[y] = this.snapChars[y + 1];
        }
        this.snapChars[this.g.rows - 1] = topChar;
    }
    getOverride(i) {
        if (!this.active || this.snapChars === null) return null;
        const x = i % this.g.cols; 
        if (x !== this.column) return null; 
        const y = Math.floor(i / this.g.cols);
        const s = this.c.state;
        const d = this.c.derived;
        const originalChar = String.fromCharCode(this.snapChars[y]);
        // Fix for residual flash: If timer is in cleanup phase, return a transparent block.
        if (this.state === 'ERASING' && this.eraseTimer <= this.cleanupFrames) {
             return { char: '', color: '#000000', alpha: 0.0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
        }
        // --- PHASE 1: REVERSE FLOW ---
        if (this.state === 'REVERSING') {
            const charCode = this.snapChars[y];
            return {
                char: String.fromCharCode(charCode),
                color: d.streamColorStr, // Use stream color
                alpha: 1.0,
                glow: 20,
                size: 2,
                solid: false,
                blend: false
            };
        } 
        // --- PHASE 2: ERASE & FADE ---
        else if (this.state === 'ERASING') {
            const maxT = s.firewallEraseDurationFrames - this.cleanupFrames; // Base duration for fade
            const progress = 1.0 - (this.eraseTimer / maxT);
            // Calculate Alpha for the Fade
            const alpha = Math.max(0, 1.0 - progress);
            if (alpha <= 0.01) return null;
            let finalRgb;
            if (s.firewallRandomColorEnabled) {
                finalRgb = this._firewallRandomColor;
            } else {
                // Use the configured firewall color
                finalRgb = Utils.hexToRgb(s.firewallColor);
            }
            // Create RGBA string so the BLOCK fades
            const rgbaColor = `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${alpha})`;
            return {
                char: originalChar,
                color: rgbaColor, 
                alpha: alpha, 
                glow: 30 * alpha,
                size: 4,
                solid: true, 
                bgColor: rgbaColor, 
                blend: false
            };
        }
        return null;
    }
}
// --- GlowSystem.js ---
class GlowSystem {
    constructor(grid) {
        this.grid = grid;
        this.sources = [];
    }
    /**
     * Adds a transient radial glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} radius - Radius in cells.
     * @param {number} intensity - Peak intensity.
     * @param {number|null} color - Tint color (Uint32).
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential', 'none'.
     */
    add(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.addRadial(x, y, radius, intensity, color, duration, decayFn);
    }
    addRadial(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.sources.push({
            type: 'radial', x, y, radius, intensity, color, 
            duration: Math.max(1, duration), 
            maxDuration: Math.max(1, duration), 
            decayFn, 
            age: 0
        });
    }
    /**
     * Adds a transient rectangular glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} width - Full Width in cells.
     * @param {number} height - Full Height in cells.
     * @param {number} intensity - Peak intensity (inside box).
     * @param {number|null} color - Tint color.
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential'.
     * @param {number} falloff - Soft edge radius outside the box (0 = hard edge).
     */
    addRect(x, y, width, height, intensity, color = null, duration = 0, decayFn = 'linear', falloff = 2) {
        this.sources.push({
            type: 'rect', x, y, w: width, h: height, falloff, intensity, color,
            duration: Math.max(1, duration),
            maxDuration: Math.max(1, duration),
            decayFn,
            age: 0
        });
    }
    update() {
        // Lifecycle Management
        for (let i = this.sources.length - 1; i >= 0; i--) {
            const s = this.sources[i];
            s.age++;
            if (s.age >= s.duration) {
                this.sources.splice(i, 1);
            }
        }
    }
    apply() {
        if (this.sources.length === 0) return;
        const grid = this.grid;
        const cols = grid.cols;
        const rows = grid.rows;
        const gEnvGlows = grid.envGlows;
        const gColors = grid.colors;
        for (const s of this.sources) {
            // Calculate lifecycle intensity
            let currentIntensity = s.intensity;
            if (s.decayFn === 'linear') {
                currentIntensity *= 1.0 - (s.age / s.maxDuration);
            } else if (s.decayFn === 'exponential') {
                const prog = s.age / s.maxDuration;
                currentIntensity *= (1.0 - (prog * prog));
            }
            if (currentIntensity <= 0.01) continue;
            // Determine Bounds
            let minX, maxX, minY, maxY;
            if (s.type === 'rect') {
                const halfW = s.w / 2;
                const halfH = s.h / 2;
                const margin = s.falloff;
                minX = Math.floor(s.x - halfW - margin);
                maxX = Math.ceil(s.x + halfW + margin);
                minY = Math.floor(s.y - halfH - margin);
                maxY = Math.ceil(s.y + halfH + margin);
            } else {
                // Radial
                const r = s.radius;
                minX = Math.floor(s.x - r);
                maxX = Math.ceil(s.x + r);
                minY = Math.floor(s.y - r);
                maxY = Math.ceil(s.y + r);
            }
            // Clamp to grid
            minX = Math.max(0, minX); maxX = Math.min(cols - 1, maxX);
            minY = Math.max(0, minY); maxY = Math.min(rows - 1, maxY);
            for (let cy = minY; cy <= maxY; cy++) {
                for (let cx = minX; cx <= maxX; cx++) {
                    const idx = cy * cols + cx;
                    if (grid.state[idx] === 0) continue; 
                    let boost = 0;
                    if (s.type === 'rect') {
                        // Signed Distance Field logic for Box
                        // distance from center relative to half-size
                        const dx = Math.abs(cx - s.x) - (s.w / 2);
                        const dy = Math.abs(cy - s.y) - (s.h / 2);
                        // dist > 0 means outside. dist <= 0 means inside.
                        // We only care about outside distance for falloff.
                        // Inside is full intensity.
                        const outsideDist = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
                        if (outsideDist <= 0) {
                            boost = currentIntensity; // Inside box
                        } else if (outsideDist < s.falloff) {
                            // Fade out
                            boost = currentIntensity * (1.0 - (outsideDist / s.falloff));
                        }
                    } else {
                        // Radial
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < s.radius) {
                            boost = currentIntensity * (1.0 - (dist / s.radius));
                        }
                    }
                    if (boost > 0.01) {
                        gEnvGlows[idx] += boost;
                        if (s.color !== null) {
                            const blendFactor = Math.min(1.0, boost * 0.5);
                            const cur = gColors[idx];
                            const cR = cur & 0xFF;
                            const cG = (cur >> 8) & 0xFF;
                            const cB = (cur >> 16) & 0xFF;
                            const sR = s.color & 0xFF;
                            const sG = (s.color >> 8) & 0xFF;
                            const sB = (s.color >> 16) & 0xFF;
                            const nR = cR + (sR - cR) * blendFactor;
                            const nG = cG + (sG - cG) * blendFactor;
                            const nB = cB + (sB - cB) * blendFactor;
                            const nA = (cur >> 24) & 0xFF;
                            gColors[idx] = ((nA & 0xFF) << 24) | ((Math.floor(nB) & 0xFF) << 16) | ((Math.floor(nG) & 0xFF) << 8) | (Math.floor(nR) & 0xFF);
                        }
                    }
                }
            }
        }
    }
}
// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "MiniPulse";
        this.active = false;
        this.sessionTimer = 0;
        this.autoTimer = c.state.miniPulseFrequencySeconds * 60;
        this.pulses = [];
        this.renderPulses = [];
    }
    trigger() {
        if (this.active) return false;
        this.active = true;
        this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60;
        this.pulses = [];
        return true;
    }
    update() {
        const s = this.c.state;
        const d = this.c.derived;
        if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.miniPulseFrequencySeconds * 60;
        }
        if (this.active) {
            this.sessionTimer--;
            if (Math.random() < s.miniPulseSpawnChance) {
                this.pulses.push({
                    x: Utils.randomInt(0, this.g.cols),
                    y: Utils.randomInt(0, this.g.rows),
                    r: 0,
                    maxR: s.miniPulseSize,
                    speed: s.miniPulseSpeed
                });
            }
            if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
        }
        this.renderPulses = [];
        for (let i = this.pulses.length - 1; i >= 0; i--) {
            const p = this.pulses[i];
            p.r += p.speed;
            if (p.r > p.maxR + 100) {
                this.pulses.splice(i, 1);
                continue;
            }
            const ox = (p.x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5);
            const oy = (p.y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
            const minX = ox - p.r;
            const maxX = ox + p.r;
            const minY = oy - p.r;
            const maxY = oy + p.r;
            const rSq = p.r * p.r;
            const innerEdge = Math.max(0, p.r - s.miniPulseThickness);
            const innerEdgeSq = innerEdge * innerEdge;
            this.renderPulses.push({
                ox, oy,
                minX, maxX, minY, maxY,
                r: p.r,
                rSq,
                innerEdge,
                innerEdgeSq,
                maxR: p.maxR
            });
        }
    }
    applyToGrid(grid) {
        if (!this.active || this.renderPulses.length === 0) return;
        const s = this.c.state;
        const d = this.c.derived;
        const cW = d.cellWidth * s.stretchX;
        const cH = d.cellHeight * s.stretchY;
        const tracerColor = d.tracerColorUint32;
        // Unpack Tracer Color for blending
        const tR = tracerColor & 0xFF;
        const tG = (tracerColor >> 8) & 0xFF;
        const tB = (tracerColor >> 16) & 0xFF;
        for (const p of this.renderPulses) {
            const startCol = Math.max(0, Math.floor(p.minX / cW));
            const endCol = Math.min(grid.cols, Math.ceil(p.maxX / cW));
            const startRow = Math.max(0, Math.floor(p.minY / cH));
            const endRow = Math.min(grid.rows, Math.ceil(p.maxY / cH));
            for (let y = startRow; y < endRow; y++) {
                const rowOffset = y * grid.cols;
                for (let x = startCol; x < endCol; x++) {
                    const i = rowOffset + x;
                    // Skip empty cells (No scrambling)
                    const baseAlpha = grid.alphas[i];
                    if (baseAlpha <= 0.01) continue;
                    const cx = (x * cW) + (cW * 0.5);
                    const cy = (y * cH) + (cH * 0.5);
                    if (s.pulseCircular !== false) {
                        const dx = cx - p.ox;
                        const dy = cy - p.oy;
                        const distSq = (dx * dx) + (dy * dy);
                        if (distSq > p.rSq || distSq < p.innerEdgeSq) continue;
                    } else {
                        const dist = Math.max(Math.abs(cx - p.ox), Math.abs(cy - p.oy));
                        if (dist > p.r || dist < p.innerEdge) continue;
                    }
                    // Hit!
                    let lifeFade = 1.0;
                    if (p.r > p.maxR) lifeFade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                    if (lifeFade <= 0.01) continue;
                    // Blend Tracer Color -> Stream Color
                    // Ratio: lifeFade. 1.0 = Tracer. 0.0 = Stream.
                    const streamColor = grid.colors[i];
                    const sR = streamColor & 0xFF;
                    const sG = (streamColor >> 8) & 0xFF;
                    const sB = (streamColor >> 16) & 0xFF;
                    const mR = Math.floor(sR + (tR - sR) * lifeFade);
                    const mG = Math.floor(sG + (tG - sG) * lifeFade);
                    const mB = Math.floor(sB + (tB - sB) * lifeFade);
                    const finalColor = Utils.packAbgr(mR, mG, mB);
                    const baseGlow = s.tracerGlow * lifeFade;
                    const glow = (s.miniPulseUseTracerGlow) ? baseGlow : 0;
                    // Override acts as a "Lighting" layer here.
                    // We use existing char and font.
                    // We use existing alpha to preserve fade state.
                    grid.setOverride(i, grid.getChar(i), finalColor, baseAlpha, grid.fontIndices[i], glow);
                }
            }
        }
    }
}
// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); this.name = "Pulse"; 
        this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
        this.snap = null; 
        const s = this._getEffectiveState();
        this.autoTimer = s.pulseFrequencySeconds * 60;
        this.renderData = null; 
    }
    _getEffectiveState() {
        const s = this.c.state;
        if (!s.pulseMovieAccurate) return s;
        // Movie Accurate Overrides
        return {
            ...s,
            pulseFrequencySeconds: 300, 
            pulseDelaySeconds: 1.0,      // Dark delay of 1 second
            pulseDurationSeconds: 1.3,   // Wave expands for 1.3 seconds
            pulseWidth: 150,             // Ignored in MA custom logic but kept for safety
            pulseRandomPosition: false,  // We calculate specific start
            pulseInstantStart: false,
            pulseCircular: false,        // Rectangular
            pulseAspectRatio: 1.6,       // 16:10 Aspect Ratio (Width / Height)
            pulsePreserveSpaces: true,
            pulseIgnoreTracers: true,
            pulseDimming: 0.2,
            pulseBlend: false
        };
    }
    trigger() {
        if(this.active) return false;
        const total = this.g.cols * this.g.rows;
        // Snapshot the current grid state
        this.snap = { 
            chars: new Uint16Array(this.g.chars), 
            fontIndices: new Uint8Array(this.g.fontIndices),
            alphas: new Float32Array(this.g.alphas), 
            colors: new Uint32Array(this.g.colors), 
            tracers: new Uint8Array(total), 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total)
        };
        const d = this.c.derived; const s = this._getEffectiveState(); const holdEnd = d.cycleDuration + d.holdFrames;
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = Utils.CHARS;
        for(let i=0; i<total; i++) {
            // Identify Tracer State
            const type = this.g.types[i]; 
            const age = this.g.ages[i];
            let isTracer = false;
            if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                const at = age - 1; 
                if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                    isTracer = true;
                } 
            }
            this.snap.tracers[i] = isTracer ? 1 : 0; 
            // Generate Fill Char/Font for gaps
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.pulseMovieAccurate) {
             // Find Tracer closest to center
             const cx = Math.floor(this.g.cols / 2);
             const cy = Math.floor(this.g.rows / 2);
             let minDist = 99999999;
             let bestX = cx; 
             let bestY = cy;
             for(let i=0; i<total; i++) {
                 if (this.snap.tracers[i] === 1) {
                     const x = i % this.g.cols;
                     const y = Math.floor(i / this.g.cols);
                     const dx = (x - cx);
                     const dy = (y - cy);
                     const dist = dx*dx + dy*dy;
                     if (dist < minDist) {
                         minDist = dist;
                         bestX = x;
                         bestY = y;
                     }
                 }
             }
             ox = bestX;
             oy = bestY;
        } else if (s.pulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8);
            oy = Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.pulseWidth && pxDistY < s.pulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols/2);
            oy = Math.floor(this.g.rows/2);
        }
        this.origin = {x: ox, y: oy};
        this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelaySeconds * 60; 
        // Radius Init
        if (s.pulseMovieAccurate) {
            // Start very small, allowing Latch logic to handle expansion
            // Inner Hole: 4 wide (2 rad), 3 tall (1.5 rad)
            // Initial Radius must cover at least this hole
            this.radius = 2 * d.cellWidth * s.stretchX; 
        } else {
            this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; 
        }
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * 60);
        return true; 
    }
    update() {
        const s = this._getEffectiveState();
        if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; }
        if(!this.active) { this.renderData = null; return; }
        const d = this.c.derived;
        if(this.state === 'WAITING') { 
            if(--this.timer <= 0) { this.state = 'EXPANDING'; }
        } else {
            const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
            this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * 60);
            this.radius += this.speed; 
            if(this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
        }
        // --- Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); 
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        // Effective ratio for calculation
        let ratio = 1;
        if (s.pulseMovieAccurate) {
             ratio = 1.6; // Locked 16:10
        } else if (!s.pulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        const width = s.pulseWidth * 2; 
        const innerEdge = this.radius - width;
        let minX, maxX, minY, maxY;
        if (s.pulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this._getEffectiveState(); 
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        // ===========================================
        // MOVIE ACCURATE RENDER PATH
        // ===========================================
        if (s.pulseMovieAccurate) {
             const aspect = 1.0; 
             const sideWidth = 7 * d.cellWidth * s.stretchX; 
             const vertWidth = 5 * d.cellHeight * s.stretchY; 
             const fadeSizeSide = 0.5 * d.cellWidth * s.stretchX;
             const fadeSizeVert = 0.5 * d.cellHeight * s.stretchY;
             const initHoleRad = 2 * d.cellWidth * s.stretchX; 
             const maxWaveWidth = sideWidth; 
             let innerB = Math.max(initHoleRad, this.radius - maxWaveWidth);
             let outerB = this.radius;
             const revealFadeLenSide = 2 * d.cellWidth * s.stretchX;
             const revealFadeLenVert = 2 * d.cellHeight * s.stretchY;
             const maxRad = Math.max(grid.cols * d.cellWidth * s.stretchX, grid.rows * d.cellHeight * s.stretchY);
             const delayDist = 3 * d.cellWidth * s.stretchX;
             const r30 = maxRad * 0.30;
             const r40 = maxRad * 0.40; 
             const rHalfRow = Math.floor(grid.rows / 2);
             const progress = this.radius / maxRad;
             for (let i = 0; i < total; i++) {
                 // Common Data Fetch
                 const snAlpha = this.snap.alphas[i];
                 let charCode = this.snap.chars[i];
                 let color = this.snap.colors[i];
                 let fontIdx = this.snap.fontIndices[i];
                 const isTracer = (this.snap.tracers[i] === 1);
                 // Fill gaps from snapshot
                 const isGap = (snAlpha <= 0.01);
                 if (isGap) {
                     charCode = this.snap.fillChars[i];
                     color = d.streamColorUint32;
                     fontIdx = this.snap.fillFonts[i];
                 }
                 if (this.state === 'WAITING') {
                     // 1. Darken Everything
                     if (isTracer) {
                         const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                     } else {
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                     }
                     continue;
                 }
                 // EXPANDING
                 const x = i % grid.cols; 
                 const y = Math.floor(i / grid.cols);
                 const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                 const cy = Math.floor(y * d.cellHeight * s.stretchY);
                 let curLag = 0;
                 if (this.radius >= r30 && this.radius < r30 + delayDist) {
                     if (y >= rHalfRow) {
                         if (y < rHalfRow + 7) {
                             curLag = this.radius - r30;
                         } else if (y >= rHalfRow + 10) {
                             curLag = this.radius - r30;
                         }
                     }
                 }
                 else if (this.radius >= r40 && this.radius < r40 + delayDist) {
                     if (y >= rHalfRow) {
                         curLag = this.radius - r40;
                     }
                 }
                 const localOuter = Math.max(0, outerB - curLag);
                 const localInner = Math.max(0, innerB - curLag);
                 const dx = Math.abs(cx - rd.ox);
                 const dy = Math.abs(cy - rd.oy);
                 const dyScaled = dy * aspect;
                 const dist = Math.max(dx, dyScaled);
                 const isSide = (dx > dyScaled);
                 const fadeSize = isSide ? fadeSizeSide : fadeSizeVert;
                 if (dist > localOuter) {
                     // --- OUTSIDE ---
                     if (curLag > 0 && dist < outerB) {
                         const gapColor = Utils.packAbgr(255, 255, 255); 
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), gapColor, 0.3, fontIdx, 0);
                     } else {
                         if (isTracer) {
                             const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                         } else {
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                         }
                     }
                 } 
                 else if (dist > localInner) {
                     // --- INSIDE WAVE BAND ---
                     const chaos = Math.sin(i * 12.9898) * 43758.5453;
                     const rndVal = chaos - Math.floor(chaos); 
                     if (rndVal < 0.10) {
                         grid.setHighPriorityEffect(i, ' ', 0, 0, 0, 0);
                     } else {
                         // WAVE
                         // 1. Alpha Variance (20% spread: 0.6 +/- 0.1)
                         const chaos2 = Math.sin(i * 78.233) * 43758.5453;
                         const rnd2 = chaos2 - Math.floor(chaos2);
                         const variance = (rnd2 - 0.5) * 0.2; // -0.1 to 0.1
                         let waveAlpha = 0.7 + variance; // Increased base alpha
                         const distFromOuter = localOuter - dist;
                         if (distFromOuter < fadeSize) {
                             waveAlpha *= (distFromOuter / fadeSize);
                         } else if (dist - localInner < fadeSize) {
                             waveAlpha = Math.min(waveAlpha, waveAlpha * ((dist - localInner) / fadeSize));
                         }
                         const liveAlpha = grid.alphas[i];
                         let displayChar, displayFont;
                         let lColor;
                         if (liveAlpha > 0.01) {
                             displayChar = String.fromCharCode(grid.chars[i]);
                             displayFont = grid.fontIndices[i];
                             lColor = grid.colors[i];
                         } else if (this.snap.alphas[i] > 0.01) {
                             // Flash in together: Use snapshot fill for gaps IN ACTIVE STREAMS
                             displayChar = String.fromCharCode(this.snap.fillChars[i]);
                             displayFont = this.snap.fillFonts[i];
                             lColor = 0; 
                         } else {
                             // Respect spaces/holes
                             displayChar = ' ';
                             displayFont = 0;
                             lColor = 0;
                         }
                         // 2. Bright White Blending (0.8 weight for white)
                         const blendWeight = 0.8;
                         const lR = lColor & 0xFF; const lG = (lColor >> 8) & 0xFF; const lB = (lColor >> 16) & 0xFF;
                         const mR = Math.floor(lR + (255 - lR) * blendWeight);
                         const mG = Math.floor(lG + (255 - lG) * blendWeight);
                         const mB = Math.floor(lB + (255 - lB) * blendWeight);
                         const finalColor = Utils.packAbgr(mR, mG, mB);
                         const glow = (s.pulseUseTracerGlow) ? s.tracerGlow * waveAlpha * 1.5 : 0; 
                         grid.setHighPriorityEffect(i, displayChar, finalColor, 1.0, displayFont, glow);
                     }
                 } 
                 else {
                     grid.clearEffectOverride(i);
                 }
             }
             return; // End MA path
        }
        // ===========================================
        // STANDARD PATH (Original Logic)
        // ===========================================
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: Skip if we are waiting (Override whole screen efficiently)
            let dist = 0;
            if (this.state === 'EXPANDING') {
                const x = i % grid.cols; 
                const y = Math.floor(i / grid.cols);
                const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                const cy = Math.floor(y * d.cellHeight * s.stretchY);
                if (s.pulseCircular) {
                    const dx = cx - rd.ox; const dy = cy - rd.oy;
                    dist = Math.sqrt(dx*dx + dy*dy);
                } else {
                    const dx = Math.abs(cx - rd.ox);
                    const dy = Math.abs(cy - rd.oy);
                    dist = Math.max(dx, dy * rd.ratio);
                }
                // 1. HOLE (Inner Edge): Instant Reveal
                if (dist < rd.innerEdge) {
                    grid.clearEffectOverride(i); 
                    continue;
                }
            } else {
                dist = 999999; // Waiting state: effectively infinite distance
            }
            // --- Common Data Fetch ---
            const snAlpha = this.snap.alphas[i];
            let charCode = this.snap.chars[i];
            let fontIdx = this.snap.fontIndices[i];
            let color = this.snap.colors[i];
            const isTracer = (this.snap.tracers[i] === 1);
            const isGap = (snAlpha <= 0.01);
            // Apply Gap Filling (Global)
            if (isGap && !s.pulsePreserveSpaces) {
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
            }
            // 2. BACKGROUND (Dimmed)
            // Condition: Waiting OR Outside Radius
            if (this.state === 'WAITING' || dist > rd.radius) {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else if (isTracer && s.pulseIgnoreTracers) {
                    // Keep original tracer
                    const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                } else {
                    // Dimmed Snapshot
                    if (snAlpha > 0.01 || !s.pulsePreserveSpaces) {
                        grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                    } else {
                        grid.clearEffectOverride(i);
                    }
                }
            } 
            // 3. WAVE BAND (Bright)
            // Condition: We are here because dist >= innerEdge AND dist <= radius
            else {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else {
                    // Calculate relative position (0.0 at outer edge, 1.0 at inner edge)
                    // (radius - dist) is small at edge, large at inner
                    const rel = Math.max(0, Math.min(1, (rd.radius - dist) / (s.pulseWidth * 1.25)));
                    let finalColor = tColorInt;
                    if (s.pulseBlend) {
                        const bR = color & 0xFF;
                        const bG = (color >> 8) & 0xFF;
                        const bB = (color >> 16) & 0xFF;
                        const mR = Math.floor(tR + (bR - tR) * rel);
                        const mG = Math.floor(tG + (bG - tG) * rel);
                        const mB = Math.floor(tB + (bB - tB) * rel);
                        finalColor = Utils.packAbgr(mR, mG, mB);
                    }
                    const glowAmount = (s.pulseUseTracerGlow) ? Math.max(s.tracerGlow, 30 * (1.0 - rel)) : 0;
                    // Force alpha 1.0 for the wave
                    grid.setEffectOverride(i, String.fromCharCode(charCode), finalColor, 1.0 , fontIdx, glowAmount);
                }
            }
        }
    }
}
// --- ReverseEffect.js ---
class ReverseEffect extends AbstractEffect {
    constructor(grid, config, effectRegistry) {
        super(grid, config);
        this.name = "Reverse";
        this.effectRegistry = effectRegistry;
        this.active = false;
        // Sequence phases
        // 0: Idle
        // 1: Slow Down
        // 2: Stop
        // 3: Reverse (Rewind)
        // 4: Reset (Pulse)
        this.phase = 0;
        this.timer = 0;
        // Configuration (Could be moved to ConfigManager later)
        this.durationSlow = 120; // Frames to slow down
        this.durationStop = 60;  // Frames to hold stop
        this.durationRewind = 180; // Frames to rewind
        this.rewindSpeed = -2.0;   // Rewind speed multiplier
        // Store original speed to restore later (though we manipulate timeScale directly)
    }
    trigger() {
        return this.start();
    }
    getOverride(i) {
        return null;
    }
    getActiveIndices() {
        return null;
    }
    start() {
        if (this.active) return false;
        this.active = true;
        this.phase = 1;
        this.timer = 0;
        // Access Simulation System directly via global or passed reference
        // Ideally EffectRegistry should pass simulation, but currently it passes grid/config.
        // We can access it via window.matrix.simulation as a fallback or hack.
        // Or better: The MatrixKernel passes 'effectRegistry' which has 'grid'.
        // Wait, EffectRegistry doesn't store SimulationSystem.
        // Let's assume window.matrix is available as per MatrixKernel.js: "window.matrix = kernel;"
        this.sim = window.matrix ? window.matrix.simulation : null;
        if (!this.sim) {
            console.error("ReverseEffect: SimulationSystem not found.");
            this.active = false;
            return false;
        }
        return true;
    }
    update() {
        if (!this.active || !this.sim) return;
        this.timer++;
        switch (this.phase) {
            case 1: // SLOW DOWN
                {
                    const progress = this.timer / this.durationSlow;
                    // Lerp timeScale from 1.0 to 0.0
                    // Ease out cubic
                    const t = 1.0 - Math.pow(1 - progress, 3); 
                    this.sim.timeScale = 1.0 - t;
                    if (this.timer >= this.durationSlow) {
                        this.sim.timeScale = 0;
                        this.phase = 2;
                        this.timer = 0;
                    }
                }
                break;
            case 2: // STOP (HOLD)
                {
                    this.sim.timeScale = 0;
                    if (this.timer >= this.durationStop) {
                        this.phase = 3;
                        this.timer = 0;
                    }
                }
                break;
            case 3: // REWIND
                {
                    const progress = this.timer / this.durationRewind;
                    // Accelerate rewind? Or constant?
                    // Constant is clearer.
                    // Ramp up rewind speed
                    if (this.timer < 60) {
                        const t = this.timer / 60;
                        this.sim.timeScale = -t * Math.abs(this.rewindSpeed);
                    } else {
                        this.sim.timeScale = this.rewindSpeed;
                    }
                    if (this.timer >= this.durationRewind) {
                        this.phase = 4;
                        this.timer = 0;
                    }
                }
                break;
            case 4: // PULSE RESET
                {
                    // Trigger a massive Clear Pulse
                    if (this.timer === 0) {
                        this.sim.timeScale = 0; // Pause during blast init
                        // Force a ClearPulse manually or via registry
                        // We want a fast, strong pulse.
                        const pulse = this.effectRegistry.get('ClearPulse');
                        if (pulse) {
                            // Override pulse settings for this specific blast?
                            // Difficult without dirtying config. 
                            // Just trigger it and restore speed immediately.
                            pulse.trigger();
                        }
                    }
                    // Quickly restore speed
                    if (this.timer > 30) {
                        this.sim.timeScale = 1.0;
                        this.active = false;
                        this.phase = 0;
                    } else {
                        // Ramp up speed from 0 to 1
                        this.sim.timeScale = this.timer / 30;
                    }
                }
                break;
        }
    }
}
// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.afterimages = new Map(); 
                this.timer = 0;
                this.spawnX = 0;
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this.spawnX = 0;
                this.afterimages.clear();
                this._generateBolt();
                return true; 
            }
            update() {
                const s = this.c.state;
                // Update afterimages (fade out)
                if (this.afterimages.size > 0) {
                    // Fade speed: higher = slower. Default ~20.
                    // 20 -> 0.05 decay. 
                    const decay = 1.0 / Math.max(1, s.supermanFadeSpeed || 20); 
                    for (const [index, alpha] of this.afterimages) {
                        const newAlpha = alpha - decay;
                        if (newAlpha <= 0.01) {
                            this.afterimages.delete(index);
                        } else {
                            this.afterimages.set(index, newAlpha);
                        }
                    }
                }
                if(!this.active && this.afterimages.size === 0) {
                     return;
                }
                if (this.active) {
                    this.timer--;
                    // Spawning logic
                    // Speed 40 ~ crosses screen in roughly 0.5-1s depending on refresh rate.
                    // Factor: Speed 40 -> 0.04 * cols per frame. 
                    // If cols=100, 4 cells/frame. 25 frames total.
                    const speedVal = s.supermanSpawnSpeed || 40;
                    const speedFactor = Math.max(1, speedVal) / 1000; 
                    this.spawnX += (this.g.cols * speedFactor);
                    if (this.spawnX > this.g.cols) this.spawnX = this.g.cols;
                    if (this.timer <= 0) {
                        this.active = false;
                        this.lightningPath.clear();
                        return;
                    }
                    this.flickerTimer++;
                    if (this.flickerTimer >= s.supermanFlickerRate) {
                        this._generateBolt();
                        this.flickerTimer = 0;
                    } else {
                        this._refreshAfterimages();
                    }
                }
            }
            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                let cy = startY;
                const limitX = Math.floor(this.spawnX);
                for (let x = 0; x < this.g.cols; x++) {
                    if (x > limitX) break;
                    // Jitter / Width logic
                    const variance = Math.max(1, s.supermanWidth); 
                    const noise = Utils.randomInt(-variance, variance);
                    // Gentle center pull to keep it on screen but allow jitter
                    const distFromCenter = (this.g.rows / 2) - cy;
                    cy += noise + (distFromCenter * 0.05); 
                    if (cy < 0) cy = 0;
                    if (cy >= this.g.rows) cy = this.g.rows - 1;
                    const thickness = s.supermanBoltThickness; 
                    const halfThick = Math.floor(thickness / 2);
                    for (let dy = -halfThick; dy <= halfThick; dy++) {
                        const thickY = Math.round(cy) + dy;
                        if (thickY >= 0 && thickY < this.g.rows) {
                            const idx = this.g.getIndex(x, thickY);
                            if (idx !== -1) {
                                this.lightningPath.add(idx);
                            }
                        }
                    }
                }
                this._refreshAfterimages();
            }
            _refreshAfterimages() {
                for (const idx of this.lightningPath) {
                    this.afterimages.set(idx, 1.0);
                }
            }
            getOverride(i) {
                if (this.afterimages.has(i)) {
                    const alphaChar = this.g.alphas[i];
                    if (alphaChar <= 0.05) return null;
                    const effectAlpha = this.afterimages.get(i);
                    const s = this.c.state;
                    const fontIdx = this.g.fontIndices[i];
                    const fontName = this.c.derived.activeFonts[fontIdx]?.name || s.fontFamily;
                    return {
                        char: this.g.getChar(i),
                        font: fontName,
                        color: s.supermanIncludeColors ? '#ffffffff' : this.c.derived.streamColorStr, 
                        alpha: effectAlpha, 
                        glow: s.supermanGlow, 
                        size: 1,
                        solid: false, 
                        blend: true 
                    };
                }
                return null;
            }
            getActiveIndices() {
                if ((!this.active && this.afterimages.size === 0)) return new Set();
                return this.afterimages.keys();
            }
        }
    // =========================================================================
    // 7.0 CANVAS RENDERER
    // =========================================================================
// --- GlyphAtlas.js ---
class GlyphAtlas {
    constructor(config, fontName = null, customChars = null) {
        this.config = config;
        this.fontName = fontName;
        this.customChars = customChars;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true });
        // Map character strings to their rect in the atlas
        this.charMap = new Map();
        // Atlas dimensions and cell size
        this.cellSize = 0;
        this.atlasWidth = 0;
        this.atlasHeight = 0;
        // State tracking for updates
        this.currentFont = '';
        this.currentPalette = '';
        this.needsUpdate = true;
        // Pre-calculated half sizes for centering
        this.halfCell = 0;
        // Internal caches for differential updates
        this._lastCols = 0;
        this._lastRows = 0;
        this._lastCharListKey = '';
        // Safety flags
        this.valid = true;
        this.MAX_HEIGHT = 8192; // Common safe limit for mobile/desktop
        // Fast Lookup for Renderer (CharCode -> AtlasID)
        this.codeToId = new Int16Array(65536).fill(-1);
        // Glyph Cache Optimization: Filter unsupported characters
        this.testCanvas = document.createElement('canvas');
        this.testCanvas.width = 20;
        this.testCanvas.height = 20;
        this.testCtx = this.testCanvas.getContext('2d', { willReadFrequently: true });
        this._cachedFilteredChars = null;
        this._cachedFilterKey = '';
        // Lazy Loading State
        this.usedChars = []; // List of characters currently in atlas
        this.capacity = 0;   // Current max characters
        this.minCapacity = 256; // Starting capacity
        this.hasChanges = false;
        this.fontReady = false;
    }
    /**
     * Initializes or updates the atlas configuration.
     * Clears the atlas and resets state to allow lazy loading.
     */
    update() {
        const s = this.config.state;
        const d = this.config.derived;
        // Determine font info (but NOT the full char list anymore for pre-fill)
        const fontFamily = this.fontName || s.fontFamily;
        // Check sizing dependencies
        const maxSize = s.fontSize + s.tracerSizeIncrease;
        const style = s.italicEnabled ? 'italic ' : '';
        const fontBase = `${style}${s.fontWeight} ${maxSize}px ${fontFamily}`;
        const padding = 10 * 2; // Fixed padding, decoupled from tracerGlow
        const paletteStr = d.paletteColorsStr.join(',');
        const fullConfigStr = paletteStr + '|' + s.overlapColor + '|' + fontBase + '|' + padding;
        const isFontReady = document.fonts.check(fontBase);
        if (this.currentFont === fontBase && 
            this.currentPalette === fullConfigStr && 
            this.fontReady === isFontReady && 
            !this.needsUpdate) {
            return;
        }
        // Configuration changed: Reset everything
        this.currentFont = fontBase;
        this.currentPalette = fullConfigStr;
        this.fontReady = isFontReady;
        // If font isn't ready, we force a retry next frame, but we TRY to render anyway (Canvas fallback)
        if (!isFontReady) {
            this.needsUpdate = true;
            // console.warn(`[GlyphAtlas] Font ${fontBase} not ready. Rendering with fallback.`);
        } else {
            this.needsUpdate = false;
        }
        // Reset dynamic state
        // Use a representative string with high/low chars
        this.ctx.font = fontBase;
        const metrics = this.ctx.measureText("Mjg|[]{}()"); 
        // fallback if metrics not supported
        let actualHeight = maxSize;
        if (metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent) {
            actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        } else {
            actualHeight = maxSize * 1.2; // generous fallback
        }
        this.cellSize = Math.ceil(Math.max(maxSize, actualHeight) + padding);
        this.halfCell = this.cellSize / 2;
        // Reset dynamic state
        this.usedChars = [];
        this.charMap.clear();
        this.capacity = this.minCapacity;
        // Initial sizing (empty)
        this._resizeAtlas(d);
    }
    _resizeAtlas(d) {
        // Calculate grid for current capacity
        const cols = Math.ceil(Math.sqrt(this.capacity));
        const rows = Math.ceil(this.capacity / cols);
        this._lastCols = cols;
        this._lastRows = rows;
        const newAtlasWidth = cols * this.cellSize;
        const newAtlasHeight = rows * this.cellSize;
        if (newAtlasHeight > this.MAX_HEIGHT) {
             console.error(`[GlyphAtlas] Texture Limit Exceeded.`);
             this.valid = false;
             return;
        }
        this.valid = true;
        this.atlasWidth = newAtlasWidth;
        this.atlasHeight = newAtlasHeight;
        // Resize Canvas (clears content)
        if (this.canvas.width !== this.atlasWidth || this.canvas.height !== this.atlasHeight) {
            this.canvas.width = this.atlasWidth;
            this.canvas.height = this.atlasHeight;
        } else {
            this.ctx.clearRect(0, 0, this.atlasWidth, this.atlasHeight);
        }
        // Setup Context
        this.ctx.font = this.currentFont;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.ctx.fillStyle = '#FFFFFF';
        // Reset lookup
        this.codeToId.fill(-1);
    }
    /**
     * Adds a character to the atlas if space permits, expanding if necessary.
     */
    addChar(char) {
        if (!this.valid) return null;
        // Check if supported first
        const checkFont = this.currentFont.replace(/\d+px/, '16px'); 
        const sig = this._getCharSignature(checkFont, char);
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        if (!sig || sig === emptySig) {
            // Unsupported, do not add
            return null;
        }
        this.usedChars.push(char);
        if (this.usedChars.length > this.capacity) {
            this._expandAtlas();
        } else {
            // Just draw the new char at the end
            const index = this.usedChars.length - 1;
            this._drawSingleChar(char, index);
        }
        // Return the new mapping
        return this.charMap.get(char);
    }
    _expandAtlas() {
        // Double capacity
        this.capacity *= 2;
        // Re-calculate dimensions and resize canvas
        const oldUsed = [...this.usedChars];
        const d = this.config.derived; 
        this._resizeAtlas(d);
        // Re-add all characters to map and draw them
        this.charMap.clear();
        for (let i = 0; i < oldUsed.length; i++) {
            this._drawSingleChar(oldUsed[i], i);
        }
    }
    _drawSingleChar(char, index) {
        const col = index % this._lastCols;
        const row = (index / this._lastCols) | 0;
        const x = col * this.cellSize + this.halfCell;
        const y = row * this.cellSize + this.halfCell;
        const rect = {
            x: col * this.cellSize,
            y: row * this.cellSize,
            w: this.cellSize,
            h: this.cellSize,
            id: index // Store index for shader lookup
        };
        this.charMap.set(char, rect);
        this.hasChanges = true;
        // Update fast lookup
        const code = char.charCodeAt(0);
        if (code < 65536) {
            this.codeToId[code] = index;
        }
        this.ctx.fillText(char, x, y);
    }
    resetChanges() {
        this.hasChanges = false;
    }
    /**
     * Returns the source coordinates for a character.
     * Lazily adds the character if not present.
     * @param {string} char 
         * @returns {Object|null} Source rect {x,y,w,h} or null
     */
    get(char) {
        const rect = this.charMap.get(char);
        if (rect) return rect;
        // Lazy Load
        return this.addChar(char);
    }
    /**
     * Filters the character list to only include those supported by the font.
     * Caches the result to avoid expensive re-scans.
     */
    _getFilteredChars(rawList, font) {
        // Use a key that includes the font (with size replaced by standard) and the raw list
        // Note: We use the full fontBase as key because if size changes significantly, 
        // we might want to re-check (though unlikely to change support).
        const key = font + '::' + rawList.length + ':' + rawList;
        if (this._cachedFilteredChars !== null && this._cachedFilterKey === key) {
            return this._cachedFilteredChars;
        }
        const filtered = [];
        // Pre-calculate empty signature (tofu)
        // We use a fixed size for checking to avoid large canvas requirements
        const checkFont = font.replace(/\d+px/, '16px'); 
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        for (let i = 0; i < rawList.length; i++) {
            const char = rawList[i];
            const sig = this._getCharSignature(checkFont, char);
            // If signature exists and is different from tofu, it's supported.
            // (We assume space ' ' is either not in list or handled by renderer if empty)
            if (sig && sig !== emptySig) {
                filtered.push(char);
            }
        }
        // If we filtered out everything (e.g. font not loaded yet), 
        // fall back to raw list to avoid complete invisibility, 
        // or return empty string? 
        // Returning empty string means nothing draws.
        // Returning raw list means we might draw boxes.
        // Let's return filtered. If font loads later, update() should be triggered by something?
        // Actually, GlyphAtlas doesn't auto-update on font load unless triggered externally.
        // But usually FontManager triggers a re-render/update.
        this._cachedFilteredChars = (typeof rawList === 'string') ? filtered.join('') : filtered;
        this._cachedFilterKey = key;
        // console.log(`[GlyphAtlas] Filtered chars: ${rawList.length} -> ${filtered.length}`);
        return this._cachedFilteredChars;
    }
    /**
     * Computes a simple pixel sum signature for a character to detect 'tofu'.
     */
    _getCharSignature(font, char) {
        this.testCtx.clearRect(0, 0, 20, 20);
        this.testCtx.font = font;
        this.testCtx.textBaseline = 'middle';
        this.testCtx.textAlign = 'center';
        this.testCtx.fillStyle = '#fff';
        this.testCtx.fillText(char, 10, 10);
        const data = this.testCtx.getImageData(5, 5, 10, 10).data;
        let sum = 0;
        // Check alpha channel
        for(let i = 3; i < data.length; i += 4) {
            sum += data[i];
        }
        return sum;
    }
}
// --- PostProcessor.js ---
class PostProcessor {
    constructor(config) {
        this.config = config;
        this.gl = null;
        this.program = null; // Custom User Shader
        this.effectProgram = null; // System Effect Shader (e.g. Deja Vu)
        this.canvas = document.createElement('canvas'); // Offscreen WebGL canvas
        // Textures
        this.texture = null; // Source Input
        this.intermediateTexture = null; // Output of Pass 1
        // Buffers
        this.positionBuffer = null;
        this.framebuffer = null; // For Pass 1
        this.defaultFragmentShader = `
            precision mediump float;
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uParameter;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = texture2D(uTexture, vTexCoord);
            }
        `;
        this.vertexShaderSource = `
            attribute vec2 aPosition;
            varying vec2 vTexCoord;
            uniform float uFlipY;
            void main() {
                // Map -1..1 to 0..1 for tex coords
                vTexCoord = (aPosition + 1.0) * 0.5;
                if (uFlipY > 0.5) {
                    vTexCoord.y = 1.0 - vTexCoord.y; 
                }
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        this._initWebGL();
    }
    _initWebGL() {
        this.gl = this.canvas.getContext('webgl', { 
            alpha: true, 
            preserveDrawingBuffer: true 
        });
        if (!this.gl) {
            console.warn("WebGL not supported for Post Processing");
            return;
        }
        // Full screen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1
        ]);
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        // Input Texture
        this.texture = this._createTexture();
        // Intermediate Texture (for Pass 1 output)
        this.intermediateTexture = this._createTexture();
        // Framebuffer for Pass 1
        this.framebuffer = this.gl.createFramebuffer();
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.intermediateTexture, 0);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.compileShader(this.config.get('customShader') || this.defaultFragmentShader);
        this.compileEffectShader(this.config.get('effectShader'));
    }
    _createTexture() {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        return tex;
    }
    compileShader(fragSource) {
        this.program = this._compileProgram(fragSource);
    }
    compileEffectShader(fragSource) {
        if (!fragSource) {
            this.effectProgram = null;
            return;
        }
        this.effectProgram = this._compileProgram(fragSource);
    }
    _compileProgram(fragSource) {
        if (!this.gl) return null;
        if (!fragSource) fragSource = this.defaultFragmentShader;
        const createShader = (type, source) => {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                console.warn(type === this.gl.VERTEX_SHADER ? 'Vertex Shader Error' : 'Fragment Shader Error', this.gl.getShaderInfoLog(shader));
                this.gl.deleteShader(shader);
                return null;
            }
            return shader;
        };
        const vs = createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        const fs = createShader(this.gl.FRAGMENT_SHADER, fragSource);
        if (!vs || !fs) return null;
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.warn("Program Link Error", this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    resize(width, height) {
        if (!this.gl) return;
        this.canvas.width = width;
        this.canvas.height = height;
        // Resize textures
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.intermediateTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
    }
    render(sourceCanvas, time, mouseX = 0, mouseY = 0, param = 0.5) {
        if (!this.gl) return;
        // Ensure state is clean before we start
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        // Upload Source to Input Texture
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceCanvas);
        let inputTex = this.texture;
        let flipY = 1.0; // Default: Flip Y for Canvas source
        // PASS 1: Effect Shader (e.g. Deja Vu)
        if (this.effectProgram) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT); // Clear intermediate FBO
            this._drawPass(this.effectProgram, inputTex, time, mouseX, mouseY, param, flipY);
            // Output of Pass 1 becomes Input of Pass 2
            inputTex = this.intermediateTexture;
            flipY = 0.0; // Next pass uses FBO source, no flip needed
        }
        // PASS 2: Custom Shader (Final Post-Process)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null); // Draw to screen (canvas)
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        const prog = this.program || this._compileProgram(this.defaultFragmentShader);
        this._drawPass(prog, inputTex, time, mouseX, mouseY, param, flipY);
    }
    _drawPass(prog, texture, time, mouseX, mouseY, param, flipY) {
        this.gl.useProgram(prog);
        const posLoc = this.gl.getAttribLocation(prog, 'aPosition');
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(posLoc);
        this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        const uTex = this.gl.getUniformLocation(prog, 'uTexture');
        this.gl.uniform1i(uTex, 0);
        const uRes = this.gl.getUniformLocation(prog, 'uResolution');
        this.gl.uniform2f(uRes, this.canvas.width, this.canvas.height);
        const uTime = this.gl.getUniformLocation(prog, 'uTime');
        this.gl.uniform1f(uTime, time);
        const uMouse = this.gl.getUniformLocation(prog, 'uMouse');
        if (uMouse) this.gl.uniform2f(uMouse, mouseX, mouseY);
        const uParam = this.gl.getUniformLocation(prog, 'uParameter');
        if (uParam) this.gl.uniform1f(uParam, param);
        const uFlip = this.gl.getUniformLocation(prog, 'uFlipY');
        if (uFlip) this.gl.uniform1f(uFlip, flipY);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
}
// --- WebGLRenderer.js ---
class WebGLRenderer {
    constructor(canvasId, grid, config, effects) {
        this.cvs = document.getElementById(canvasId);
        // Attempt WebGL2, fallback to WebGL1
        this.gl = this.cvs.getContext('webgl2', { alpha: false, preserveDrawingBuffer: false });
        this.isWebGL2 = !!this.gl;
        if (!this.gl) {
            this.gl = this.cvs.getContext('webgl', { alpha: false, preserveDrawingBuffer: false });
        }
        if (!this.gl) {
            console.error("WebGLRenderer: Hardware acceleration not supported.");
            throw new Error("WebGL not supported");
        }
        // Check for Float Texture Support (for HDR Bloom)
        this.canUseFloat = false;
        if (this.isWebGL2) {
            const ext = this.gl.getExtension('EXT_color_buffer_float');
            if (ext) this.canUseFloat = true;
        } else {
            const ext = this.gl.getExtension('OES_texture_float');
            const extLin = this.gl.getExtension('OES_texture_float_linear');
            if (ext && extLin) this.canUseFloat = true;
        }
        // WebGL1 Extension for Instancing
        if (!this.isWebGL2) {
            const ext = this.gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) {
                console.error("WebGLRenderer: ANGLE_instanced_arrays not supported.");
                throw new Error("WebGL Instancing not supported");
            }
            this.gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
            this.gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
            const vaoExt = this.gl.getExtension('OES_vertex_array_object');
            if(vaoExt) {
                this.gl.createVertexArray = vaoExt.createVertexArrayOES.bind(vaoExt);
                this.gl.bindVertexArray = vaoExt.bindVertexArrayOES.bind(vaoExt);
                this.gl.deleteVertexArray = vaoExt.deleteVertexArrayOES.bind(vaoExt);
            } else {
                 this.gl.createVertexArray = () => null;
                 this.gl.bindVertexArray = () => {}; 
                 this.gl.deleteVertexArray = () => {};
            }
        }
        this.grid = grid;
        this.config = config;
        this.effects = effects;
        this.glyphAtlases = new Map();
        // --- Core WebGL State ---
        this.program = null;       
        this.bloomProgram = null;  
        this.colorProgram = null;  
        this.atlasTexture = null;  
        this.vao = null;           
        // --- Buffers ---
        this.instanceCapacity = 0; 
        this.instanceData = null; 
        this.instanceBuffer = null;
        // --- Framebuffers for Bloom ---
        this.fboA = null; 
        this.fboB = null; 
        this.fboC = null; // New Scratch FBO
        this.texA = null; 
        this.texB = null; 
        this.texC = null; // New Scratch Texture
        this.bloomWidth = 0;
        this.bloomHeight = 0;
        // --- State Tracking ---
        this.w = 0;
        this.h = 0;
        this.needsAtlasUpdate = true;
        this.mouseX = 0.5;
        this.mouseY = 0.5;
        this._setupMouseTracking();
        this._initShaders();
        this._initBuffers();
        this._initBloomBuffers();
        console.log("Rendering Engine: WebGL (v8 CellGrid Optimized Fixed)");
        if (typeof PostProcessor !== 'undefined') {
            this.postProcessor = new PostProcessor(config);
            this.postProcessor.canvas.id = 'shaderCanvas';
            this.postProcessor.canvas.style.position = 'absolute';
            this.postProcessor.canvas.style.top = '0';
            this.postProcessor.canvas.style.left = '0';
            this.postProcessor.canvas.style.zIndex = '2'; 
            this.postProcessor.canvas.style.display = 'none'; 
            if (this.cvs.parentNode) {
                this.cvs.parentNode.insertBefore(this.postProcessor.canvas, this.cvs.nextSibling);
            }
            this.lastShaderSource = null;
            this.lastEffectSource = null;
        }
    }
    dispose() {
        if (this._mouseMoveHandler) window.removeEventListener('mousemove', this._mouseMoveHandler);
        if (this._touchMoveHandler) window.removeEventListener('touchmove', this._touchMoveHandler);
        if (this.postProcessor && this.postProcessor.canvas && this.postProcessor.canvas.parentNode) {
            this.postProcessor.canvas.parentNode.removeChild(this.postProcessor.canvas);
        }
        if (this.gl) {
            if (this.program) this.gl.deleteProgram(this.program);
            if (this.bloomProgram) this.gl.deleteProgram(this.bloomProgram);
            if (this.colorProgram) this.gl.deleteProgram(this.colorProgram);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        }
    }
    _setupMouseTracking() {
        this._mouseMoveHandler = (e) => {
            const rect = this.cvs.getBoundingClientRect();
            this.mouseX = (e.clientX - rect.left) / rect.width;
            this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height);
        };
        this._touchMoveHandler = (e) => {
            if (e.touches.length > 0) this._mouseMoveHandler(e.touches[0]);
        };
        window.addEventListener('mousemove', this._mouseMoveHandler);
        window.addEventListener('touchmove', this._touchMoveHandler, { passive: true });
    }
    _createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    _createProgram(vsSource, fsSource) {
        const vs = this._createShader(this.gl.VERTEX_SHADER, vsSource);
        const fs = this._createShader(this.gl.FRAGMENT_SHADER, fsSource);
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    _initShaders() {
        const version = this.isWebGL2 ? '#version 300 es' : '';
        const attribute = this.isWebGL2 ? 'in' : 'attribute';
        const varying = this.isWebGL2 ? 'out' : 'varying';
        const varyingIn = this.isWebGL2 ? 'in' : 'varying';
        const texture2D = this.isWebGL2 ? 'texture' : 'texture2D';
        const outColor = this.isWebGL2 ? 'out vec4 fragColor;' : '';
        const setFragColor = this.isWebGL2 ? 'fragColor' : 'gl_FragColor';
        // --- SHADOW MASK SHADER ---
        const shadowVS = this.isWebGL2 ? `#version 300 es
            layout(location=0) in vec2 a_quad;
            layout(location=1) in vec4 a_rect;
            layout(location=2) in float a_alpha;
            layout(location=3) in float a_blur;
            uniform vec2 u_gridSize;
            out vec2 v_uv;
            out float v_alpha;
            out float v_blur;
            void main() {
                vec2 size = a_rect.zw;
                vec2 pos = a_rect.xy;
                vec2 worldPos = pos + (a_quad * size);
                vec2 uv = worldPos / u_gridSize;
                gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
                gl_Position.y = -gl_Position.y;
                v_uv = a_quad;
                v_alpha = a_alpha;
                v_blur = a_blur;
            }
        ` : `
            attribute vec2 a_quad;
            attribute vec4 a_rect;
            attribute float a_alpha;
            attribute float a_blur;
            uniform vec2 u_gridSize;
            varying vec2 v_uv;
            varying float v_alpha;
            varying float v_blur;
            void main() {
                vec2 size = a_rect.zw;
                vec2 pos = a_rect.xy;
                vec2 worldPos = pos + (a_quad * size);
                vec2 uv = worldPos / u_gridSize;
                gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
                gl_Position.y = -gl_Position.y;
                v_uv = a_quad;
                v_alpha = a_alpha;
                v_blur = a_blur;
            }
        `;
        const shadowFS = this.isWebGL2 ? `#version 300 es
            precision mediump float;
            in vec2 v_uv;
            in float v_alpha;
            in float v_blur;
            out vec4 fragColor;
            void main() {
                vec2 d = abs(v_uv - 0.5) * 2.0;
                float dist = max(d.x, d.y);
                float edge = 1.0 - smoothstep(1.0 - max(0.001, v_blur), 1.0, dist);
                fragColor = vec4(0.0, 0.0, 0.0, v_alpha * edge);
            }
        ` : `
            precision mediump float;
            varying vec2 v_uv;
            varying float v_alpha;
            varying float v_blur;
            void main() {
                vec2 d = abs(v_uv - 0.5) * 2.0;
                float dist = max(d.x, d.y);
                float edge = 1.0 - smoothstep(1.0 - max(0.001, v_blur), 1.0, dist);
                gl_FragColor = vec4(0.0, 0.0, 0.0, v_alpha * edge);
            }
        `;
        this.shadowProgram = this._createProgram(shadowVS, shadowFS);
        // Optimized Vertex Shader
        const matrixVS = `${version}
            precision mediump float;
            layout(location=0) ${attribute} vec2 a_quad;      // 0..1
            layout(location=1) ${attribute} vec2 a_pos;       // Cell Center X,Y
            layout(location=2) ${attribute} float a_charIdx;  // Char Index
            layout(location=3) ${attribute} vec4 a_color;     // Normalized Color
            layout(location=4) ${attribute} float a_alpha;    // Alpha
            layout(location=5) ${attribute} float a_decay;    // Decay State
            layout(location=6) ${attribute} float a_glow;     // Glow Amount
            layout(location=7) ${attribute} float a_mix;      // Mix Factor
            layout(location=8) ${attribute} float a_nextChar; // Next Char Index
            uniform vec2 u_resolution;
            uniform vec2 u_atlasSize;
            uniform vec2 u_gridSize;
            uniform float u_cellSize;
            uniform float u_cols;
            uniform float u_decayDur;
            uniform vec2 u_stretch;
            uniform float u_mirror;
            uniform float u_dissolveEnabled;
            uniform float u_dissolveScale;
            ${varying} vec2 v_uv;
            ${varying} vec2 v_uv2;
            ${varying} vec4 v_color;
            ${varying} float v_mix;
            ${varying} float v_glow;
            ${varying} float v_prog;
            ${varying} vec2 v_screenUV; // For sampling Shadow Mask
            void main() {
                // Decay Scale Logic
                float scale = 1.0;
                v_prog = 0.0;
                if (a_decay >= 2.0) {
                    v_prog = (a_decay - 2.0) / u_decayDur;
                    if (u_dissolveEnabled > 0.5) {
                        scale = mix(1.0, u_dissolveScale, v_prog);
                    } else {
                        scale = 1.0;
                    }
                }
                // Position Calculation
                vec2 centerPos = (a_quad - 0.5) * u_cellSize * scale;
                vec2 worldPos = a_pos + centerPos;
                // Mirror/Stretch - Pivot around GRID center, not screen center
                vec2 gridCenter = u_gridSize * 0.5;
                worldPos.x = (worldPos.x - gridCenter.x) * u_stretch.x + (u_resolution.x * 0.5);
                worldPos.y = (worldPos.y - gridCenter.y) * u_stretch.y + (u_resolution.y * 0.5);
                if (u_mirror < 0.0) worldPos.x = u_resolution.x - worldPos.x;
                // Clip Space
                vec2 clip = (worldPos / u_resolution) * 2.0 - 1.0;
                clip.y = -clip.y;
                gl_Position = vec4(clip, 0.0, 1.0);
                // Pass Attributes
                v_screenUV = clip * 0.5 + 0.5; // -1..1 -> 0..1
                // v_screenUV.y = 1.0 - v_screenUV.y; // REMOVED: Match Texture Coords (0=Bottom, 1=Top)
                v_color = a_color;
                v_color.a *= a_alpha;
                v_mix = a_mix;
                v_glow = a_glow;
                // UV 1
                float cIdx = a_charIdx;
                float row = floor(cIdx / u_cols);
                float col = mod(cIdx, u_cols);
                vec2 uvBase = vec2(col, row) * u_cellSize;
                v_uv = (uvBase + (a_quad * u_cellSize)) / u_atlasSize;
                // UV 2 (Rotator Target)
                if (a_mix > 0.0) {
                    float cIdx2 = a_nextChar;
                    float row2 = floor(cIdx2 / u_cols);
                    float col2 = mod(cIdx2, u_cols);
                    vec2 uvBase2 = vec2(col2, row2) * u_cellSize;
                    v_uv2 = (uvBase2 + (a_quad * u_cellSize)) / u_atlasSize;
                } else {
                    v_uv2 = v_uv;
                }
            }
        `;
                    // Optimized Fragment Shader
                const matrixFS = `${version}
                    precision mediump float;
                    ${varyingIn} vec2 v_uv;
                    ${varyingIn} vec2 v_uv2;
                    ${varyingIn} vec4 v_color;
                    ${varyingIn} float v_mix;
                    ${varyingIn} float v_glow;
                    ${varyingIn} float v_prog;
                    ${varyingIn} vec2 v_screenUV;
                    uniform sampler2D u_texture;
                    uniform sampler2D u_shadowMask; // <-- New Input
                    uniform float u_time;
                    uniform float u_dissolveEnabled; // 0.0 or 1.0
                    uniform float u_dissolveScale;
                    uniform float u_dissolveSize;
                    uniform float u_deteriorationEnabled;
                    uniform float u_deteriorationStrength;
                    uniform vec2 u_atlasSize;
                    uniform vec4 u_overlapColor;
                    // 0 = Base (Glyphs/Glow), 1 = Shadow
                    uniform int u_passType;
                    ${outColor}
                    // Pseudo-random function
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    // Helper to apply all visual degradations (Dissolve + Ghosting) identically
                    float getProcessedAlpha(vec2 uv) {
                        float a = ${texture2D}(u_texture, uv).a;
                        float ghost1 = 0.0;
                        float ghost2 = 0.0;
                        // Trail Ghosting (Vertical Blur) - Sample first
                        if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                            float blurDist = (u_deteriorationStrength * v_prog) / u_atlasSize.y;
                            ghost1 = ${texture2D}(u_texture, uv + vec2(0.0, blurDist)).a;
                            ghost2 = ${texture2D}(u_texture, uv - vec2(0.0, blurDist)).a;
                        }
                        // Alpha Erosion Dissolve (Burn away from edges)
                        // Apply to MAIN char AND GHOSTS
                        if (u_dissolveEnabled > 0.5 && v_prog > 0.0) {
                            float erosion = v_prog * 1.2; 
                            a = min(a, smoothstep(erosion, erosion + 0.1, a));
                            if (ghost1 > 0.0) ghost1 = min(ghost1, smoothstep(erosion, erosion + 0.1, ghost1));
                            if (ghost2 > 0.0) ghost2 = min(ghost2, smoothstep(erosion, erosion + 0.1, ghost2));
                        }
                        // Combine
                        if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                            a = max(a, max(ghost1, ghost2) * 0.5);
                        }
                        return a;
                    }
                    void main() {
                        // Decode High Priority Signal
                        bool isHighPriority = (v_mix >= 9.5);
                        float useMix = isHighPriority ? v_mix - 10.0 : v_mix;
                        // Sample Shadow Mask
                        float shadow = ${texture2D}(u_shadowMask, v_screenUV).a;
                        // Sample Texture with Effects
                        float tex1 = getProcessedAlpha(v_uv);
                        vec4 baseColor = v_color;
                        float finalAlpha = tex1;
                        if (useMix >= 4.0) {
                            // Overlay Mode (Tracers/Effects)
                            // Use baseColor so tracers follow Stream Color.
                            float ovAlpha = useMix - 4.0;
                            float tex2 = getProcessedAlpha(v_uv2);
                            float effA = tex2 * ovAlpha;
                            // Boost brightness by multiplying (preserves hue better than adding white)
                            vec3 targetColor = baseColor.rgb * 2.0; 
                            baseColor.rgb = mix(baseColor.rgb, targetColor, effA);
                            finalAlpha = max(tex1, effA);
                        } else if (useMix >= 3.0) {
                            // Solid Mode
                            finalAlpha = 1.0;
                        } else if (useMix >= 2.0) {
                            // Overlap Mode
                            // Apply same effects to secondary character
                            float tex2 = getProcessedAlpha(v_uv2);
                            float intersection = tex1 * tex2;
                            // Primary visible, secondary invisible except intersection
                            finalAlpha = tex1; 
                            // If intersecting, use overlap color
                            if (intersection > 0.1) {
                                 baseColor.rgb = u_overlapColor.rgb;
                            }
                        } else if (useMix > 0.0) {
                            // Rotator Mix
                            // For rotator, we might NOT want dissolve/ghosting on the incoming char yet?
                            // Usually rotator happens on active cells (decay=0).
                            // If decay=0, getProcessedAlpha just returns raw alpha. So it's safe.
                            float tex2 = getProcessedAlpha(v_uv2);
                            finalAlpha = mix(tex1, tex2, useMix);
                        }
                        if (finalAlpha < 0.01) discard;
                        // Apply Shadow Darkening
                        // shadow = 0..1 (0=No Shadow, 1=Black)
                        // LAYER PRECEDENCE:
                        // 1. Background Code & Tracers -> Affect by Shadow
                        // 2. High Priority Effects (Lightning) -> Ignore Shadow (v_mix >= 10.0)
                        if (!isHighPriority) {
                            baseColor.rgb *= (1.0 - shadow);
                        }
                        vec4 col = baseColor;
                        // Boost brightness for glow (Bloom trigger)
                        // Multiply by alpha to ensure it fades out with the character
                        if (v_glow > 0.0) {
                            // GLOW logic must also respect shadow for non-high-priority effects!
                            // If shadow is active, the baseColor is darkened.
                            // The GLOW should also be darkened/suppressed.
                            // Otherwise a black char will still emit light.
                            float glowFactor = v_glow;
                            if (!isHighPriority) {
                                glowFactor *= (1.0 - shadow);
                            }
                            col.rgb += (glowFactor * 0.3 * col.a);
                        }
                        ${setFragColor} = vec4(col.rgb, col.a * finalAlpha);
                    }
                `;
                // Fallback for WebGL1
                let finalVS = matrixVS;
                let finalFS = matrixFS;
                if (!this.isWebGL2) {
                     finalVS = `
                        precision mediump float;
                        attribute vec2 a_quad; attribute vec2 a_pos; attribute float a_charIdx; attribute vec4 a_color;
                        attribute float a_alpha; attribute float a_decay; attribute float a_glow; attribute float a_mix; attribute float a_nextChar;
                        uniform vec2 u_resolution; uniform vec2 u_atlasSize; uniform vec2 u_gridSize; uniform float u_cellSize; uniform float u_cols; uniform float u_decayDur;
                        uniform vec2 u_stretch; uniform float u_mirror;
                        varying vec2 v_uv; varying vec2 v_uv2; varying vec4 v_color; varying float v_mix; varying float v_glow; varying float v_prog; varying vec2 v_screenUV;
                        void main() {
                            float scale = 1.0;
                            v_prog = 0.0;
                            if (a_decay >= 2.0) { v_prog = (a_decay - 2.0) / u_decayDur; scale = max(0.1, 1.0 - v_prog); }
                            vec2 centerPos = (a_quad - 0.5) * u_cellSize * scale;
                            vec2 worldPos = a_pos + centerPos;
                            vec2 gridCenter = u_gridSize * 0.5;
                            worldPos.x = (worldPos.x - gridCenter.x) * u_stretch.x + (u_resolution.x * 0.5);
                            worldPos.y = (worldPos.y - gridCenter.y) * u_stretch.y + (u_resolution.y * 0.5);
                            if (u_mirror < 0.0) worldPos.x = u_resolution.x - worldPos.x;
                            vec2 clip = (worldPos / u_resolution) * 2.0 - 1.0; clip.y = -clip.y;
                            gl_Position = vec4(clip, 0.0, 1.0);
                            v_screenUV = clip * 0.5 + 0.5; // v_screenUV.y = 1.0 - v_screenUV.y; // Removed flip
                            v_color = a_color; v_color.a *= a_alpha; v_mix = a_mix; v_glow = a_glow;
                            float cIdx = a_charIdx; float row = floor(cIdx / u_cols); float col = mod(cIdx, u_cols);
                            vec2 uvBase = vec2(col, row) * u_cellSize; v_uv = (uvBase + (a_quad * u_cellSize)) / u_atlasSize;
                            if (a_mix > 0.0) { float cIdx2 = a_nextChar; float row2 = floor(cIdx2 / u_cols); float col2 = mod(cIdx2, u_cols); vec2 uvBase2 = vec2(col2, row2) * u_cellSize; v_uv2 = (uvBase2 + (a_quad * u_cellSize)) / u_atlasSize; } else { v_uv2 = v_uv; }
                        }
                     `;
                     finalFS = `
                        precision mediump float;
                        varying vec2 v_uv; varying vec2 v_uv2; varying vec4 v_color; varying float v_mix; varying float v_glow; varying float v_prog; varying vec2 v_screenUV;
                        uniform sampler2D u_texture; uniform sampler2D u_shadowMask; uniform float u_time; uniform float u_dissolveEnabled; uniform float u_dissolveSize;
                        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        void main() {
                            bool isHighPriority = (v_mix >= 9.5);
                            float useMix = isHighPriority ? v_mix - 10.0 : v_mix;
                            float shadow = texture2D(u_shadowMask, v_screenUV).a;
                            float tex1 = texture2D(u_texture, v_uv).a;
                            float finalAlpha = tex1;
                            if (useMix >= 3.0) { finalAlpha = 1.0; }
                            else if (useMix >= 2.0) { float tex2 = texture2D(u_texture, v_uv2).a; finalAlpha = max(tex1, tex2); }
                            else if (useMix > 0.0) { float tex2 = texture2D(u_texture, v_uv2).a; finalAlpha = mix(tex1, tex2, useMix); }
                            if (u_dissolveEnabled > 0.5 && v_prog > 0.0) {
                                vec2 noiseCoord = floor(gl_FragCoord.xy / max(1.0, u_dissolveSize));
                                float noise = random(noiseCoord);
                                if (noise < v_prog) discard;
                            }
                            if (finalAlpha < 0.01) discard;
                            vec4 col = v_color;
                            if (!isHighPriority) { 
                                col.rgb *= (1.0 - shadow); 
                            }
                            // WebGL1 simplified glow logic - assumes glow attribute handling elsewhere or simplified here
                             if (v_glow > 0.0) {
                                float glowFactor = v_glow;
                                if (!isHighPriority) glowFactor *= (1.0 - shadow);
                                col.rgb += (glowFactor * 0.3 * col.a);
                            }
                            gl_FragColor = vec4(col.rgb, col.a * finalAlpha);
                        }
                     `;
        }
        this.program = this._createProgram(finalVS, finalFS);
        // Keep existing Bloom/Color programs
        const bloomVS = this.isWebGL2 ? `#version 300 es\nlayout(location=0) in vec2 a_position; out vec2 v_uv; void main(){ v_uv=a_position*0.5+0.5; gl_Position=vec4(a_position, 0.0, 1.0); }` : `attribute vec2 a_position; varying vec2 v_uv; void main(){ v_uv=a_position*0.5+0.5; gl_Position=vec4(a_position, 0.0, 1.0); }`;
        const bloomFS = this.isWebGL2 ? `#version 300 es\nprecision mediump float; in vec2 v_uv; uniform sampler2D u_image; uniform bool u_horizontal; uniform float u_weight[5]; uniform float u_spread; uniform float u_opacity; out vec4 fragColor; void main(){ vec2 tex_offset=(1.0/vec2(textureSize(u_image, 0)))*u_spread; vec3 result=texture(u_image, v_uv).rgb*u_weight[0]; if(u_horizontal){ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; } }else{ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; } } fragColor=vec4(result*u_opacity, 1.0); }` : `precision mediump float; varying vec2 v_uv; uniform sampler2D u_image; uniform bool u_horizontal; uniform float u_weight[5]; uniform float u_spread; uniform float u_opacity; uniform vec2 u_texSize; void main(){ vec2 tex_offset=(1.0/u_texSize)*u_spread; vec3 result=texture2D(u_image, v_uv).rgb*u_weight[0]; if(u_horizontal){ for(int i=1; i<5; ++i){ result+=texture2D(u_image, v_uv+vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; result+=texture2D(u_image, v_uv-vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; } }else{ for(int i=1; i<5; ++i){ result+=texture2D(u_image, v_uv+vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; result+=texture2D(u_image, v_uv-vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; } } gl_FragColor=vec4(result*u_opacity, 1.0); }`;
        this.bloomProgram = this._createProgram(bloomVS, bloomFS);
        const colorVS = this.isWebGL2 ? `#version 300 es\nlayout(location=0) in vec2 a_position; void main(){ gl_Position=vec4(a_position, 0.0, 1.0); }` : `attribute vec2 a_position; void main(){ gl_Position=vec4(a_position, 0.0, 1.0); }`;
        const colorFS = this.isWebGL2 ? `#version 300 es\nprecision mediump float; uniform vec4 u_color; out vec4 fragColor; void main(){ fragColor=u_color; }` : `precision mediump float; uniform vec4 u_color; void main(){ gl_FragColor=u_color; }`;
        this.colorProgram = this._createProgram(colorVS, colorFS);
    }
    _initBuffers() {
        const quadVerts = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);
        const screenQuadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
        this.quadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, quadVerts, this.gl.STATIC_DRAW);
        this.screenQuadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, screenQuadVerts, this.gl.STATIC_DRAW);
        // Shadow Instance Buffer (Dynamic)
        this.shadowInstanceBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
        this.shadowInstanceCapacity = 1000;
        // Initial capacity: 1000 sheets * 20 bytes (x,y,w,h,a)
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * 20, this.gl.DYNAMIC_DRAW);
        // Instance buffers will be created in resize()
        this.posBuffer = null;
        this.charBuffer = null;
        this.colorBuffer = null;
        this.alphaBuffer = null;
        this.decayBuffer = null;
        this.glowBuffer = null;
        this.mixBuffer = null;
        this.nextCharBuffer = null;
        // Mapped Arrays (CPU side)
        this.mappedChars = null;
        this.mappedNextChars = null;
    }
    _initBloomBuffers() {
        this.fboA = this.gl.createFramebuffer(); this.texA = this.gl.createTexture();
        this.fboB = this.gl.createFramebuffer(); this.texB = this.gl.createTexture();
        this.fboC = this.gl.createFramebuffer(); this.texC = this.gl.createTexture();
        // Shadow Mask FBO
        this.shadowMaskFbo = this.gl.createFramebuffer(); 
        this.shadowMaskTex = this.gl.createTexture();
    }
    _configureFramebuffer(fbo, tex, width, height) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fbo);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        let internalFormat = this.gl.RGBA;
        let type = this.gl.UNSIGNED_BYTE;
        if (this.canUseFloat) {
            if (this.isWebGL2) {
                internalFormat = this.gl.RGBA16F;
                type = this.gl.HALF_FLOAT;
            } else {
                type = this.gl.FLOAT; // WebGL1 usually requires FLOAT for OES_texture_float
            }
        }
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, internalFormat, width, height, 0, this.gl.RGBA, type, null);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, tex, 0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
    handleFontChange() { this.glyphAtlases.clear(); this.needsAtlasUpdate = true; }
    handleAppearanceChange() { this.needsAtlasUpdate = true; }
    updateSmoothing() { 
        const s = this.config.state.smoothingEnabled ? this.config.state.smoothingAmount : 0; 
        this.cvs.style.filter = `blur(${s}px)`; 
    }
    resize() {
        const s = this.config.state;
        const d = this.config.derived;
        const scale = s.resolution;
        this.handleAppearanceChange();
        this.w = window.innerWidth;
        this.h = window.innerHeight;
        // Fix: Explicitly set CSS size to match window, independent of buffer resolution
        this.cvs.style.width = `${this.w}px`;
        this.cvs.style.height = `${this.h}px`;
        const pw = Math.floor(this.w * scale);
        const ph = Math.floor(this.h * scale);
        if (this.cvs.width !== pw || this.cvs.height !== ph) {
            this.cvs.width = pw; this.cvs.height = ph; this.gl.viewport(0, 0, pw, ph);
        }
        if (this.fboWidth !== pw || this.fboHeight !== ph) {
            this.fboWidth = pw; this.fboHeight = ph;
            this.bloomWidth = Math.floor(pw * 0.5); this.bloomHeight = Math.floor(ph * 0.5);
            if (pw > 0 && ph > 0) {
                this._configureFramebuffer(this.fboA, this.texA, this.fboWidth, this.fboHeight);
                this._configureFramebuffer(this.fboB, this.texB, this.bloomWidth, this.bloomHeight);
                this._configureFramebuffer(this.fboC, this.texC, this.bloomWidth, this.bloomHeight);
                // Shadow Mask (Matches Render Resolution)
                this._configureFramebuffer(this.shadowMaskFbo, this.shadowMaskTex, this.fboWidth, this.fboHeight);
            }
        }
        if (this.postProcessor) { this.postProcessor.resize(pw, ph); this.postProcessor.canvas.style.width = `${this.w}px`; this.postProcessor.canvas.style.height = `${this.h}px`; }
        // --- Resize Buffers ---
        const totalCells = this.grid.cols * this.grid.rows;
        // Helper to recreate buffer
        const ensureBuf = (buf, size, drawType = this.gl.DYNAMIC_DRAW) => {
             if (buf) this.gl.deleteBuffer(buf);
             const newBuf = this.gl.createBuffer();
             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, newBuf);
             this.gl.bufferData(this.gl.ARRAY_BUFFER, size, drawType);
             return newBuf;
        };
        // Static Position Buffer
        this.posBuffer = ensureBuf(this.posBuffer, totalCells * 8, this.gl.STATIC_DRAW); // 2 floats * 4 bytes
        const posData = new Float32Array(totalCells * 2);
        const cw = d.cellWidth; const ch = d.cellHeight;
        const xOff = s.fontOffsetX; const yOff = s.fontOffsetY;
        for (let i = 0; i < totalCells; i++) {
             const col = i % this.grid.cols;
             const row = Math.floor(i / this.grid.cols);
             posData[i*2] = col * cw + cw * 0.5 + xOff;
             posData[i*2+1] = row * ch + ch * 0.5 + yOff;
        }
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, posData);
        // Dynamic Buffers
        this.charBuffer = ensureBuf(this.charBuffer, totalCells * 2); // Uint16
        this.colorBuffer = ensureBuf(this.colorBuffer, totalCells * 4); // Uint32 (RGBA)
        this.alphaBuffer = ensureBuf(this.alphaBuffer, totalCells * 4); // Float32
        this.decayBuffer = ensureBuf(this.decayBuffer, totalCells); // Uint8
        this.glowBuffer = ensureBuf(this.glowBuffer, totalCells * 4); // Float32
        this.mixBuffer = ensureBuf(this.mixBuffer, totalCells * 4); // Float32
        this.nextCharBuffer = ensureBuf(this.nextCharBuffer, totalCells * 2); // Uint16
        // Mapped Arrays
        this.mappedChars = new Uint16Array(totalCells);
        this.mappedNextChars = new Uint16Array(totalCells);
        // Upload Buffers (CPU merging for overrides/effects)
        this.uploadColors = new Uint32Array(totalCells);
        this.uploadAlphas = new Float32Array(totalCells);
        this.uploadDecays = new Uint8Array(totalCells); // Decays usually don't have overrides but safe to copy
        this.uploadGlows = new Float32Array(totalCells);
        this.uploadMix = new Float32Array(totalCells);
        this._setupVAO();
    }
    _setupVAO() {
        if (this.vao) this.gl.deleteVertexArray(this.vao);
        this.vao = this.gl.createVertexArray();
        this.gl.bindVertexArray(this.vao);
        // 0: Quad (Vertex)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        // 1: Pos (Static Instance)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.enableVertexAttribArray(1);
        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(1, 1);
        // 2: CharIdx (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.enableVertexAttribArray(2);
        this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(2, 1);
        // 3: Color (Dynamic Instance, Uint32 -> Vec4 Normalized)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.enableVertexAttribArray(3);
        this.gl.vertexAttribPointer(3, 4, this.gl.UNSIGNED_BYTE, true, 0, 0);
        this.gl.vertexAttribDivisor(3, 1);
        // 4: Alpha (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.enableVertexAttribArray(4);
        this.gl.vertexAttribPointer(4, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(4, 1);
        // 5: Decay (Dynamic Instance, Uint8 -> Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.enableVertexAttribArray(5);
        this.gl.vertexAttribPointer(5, 1, this.gl.UNSIGNED_BYTE, false, 0, 0);
        this.gl.vertexAttribDivisor(5, 1);
        // 6: Glow (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.enableVertexAttribArray(6);
        this.gl.vertexAttribPointer(6, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(6, 1);
        // 7: Mix (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.enableVertexAttribArray(7);
        this.gl.vertexAttribPointer(7, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(7, 1);
        // 8: NextChar (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.enableVertexAttribArray(8);
        this.gl.vertexAttribPointer(8, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(8, 1);
        this.gl.bindVertexArray(null);
    }
    _drawFullscreenTexture(texture, opacity, blurAmt) {
        if (!this.bloomProgram) return;
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [1.0, 0.0, 0.0, 0.0, 0.0];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), 1);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    _runBlur(sourceTex, horizontal, strength, width, height, opacity = 1.0) {
        if (!this.bloomProgram) return;
        this.gl.disable(this.gl.BLEND);
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, sourceTex);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), strength);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), horizontal ? 1 : 0);
        if (!this.isWebGL2) {
             this.gl.uniform2f(this.gl.getUniformLocation(this.bloomProgram, 'u_texSize'), width, height);
        }
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    render(frame) {
        if (!this.posBuffer || this.fboWidth === 0) return; 
        const { state: s, derived: d } = this.config;
        const grid = this.grid;
        const activeFonts = d.activeFonts;
        const gl = this.gl;
        gl.enable(gl.BLEND);
        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        // --- ATLAS UPDATE ---
        const font = activeFonts[0];
        if (!font) return;
        let atlas = this.glyphAtlases.get(font.name);
        if (!atlas) {
            atlas = new GlyphAtlas(this.config, font.name, font.chars);
            this.glyphAtlases.set(font.name, atlas);
        } else {
            atlas.fontName = font.name; 
        }
        if (this.needsAtlasUpdate || atlas.needsUpdate) atlas.update();
        if (!atlas.glTexture) {
            atlas.glTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
            atlas.resetChanges();
        } else if (atlas.hasChanges) {
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
            atlas.resetChanges();
        }
        this.needsAtlasUpdate = false;
        // --- MERGE & MAP ---
        const totalCells = grid.cols * grid.rows;
        if (this.mappedChars.length !== totalCells) return;
        const gChars = grid.chars;
        const gNext = grid.nextChars;
        const gSecChars = grid.secondaryChars;
        const gColors = grid.colors;
        const gAlphas = grid.alphas;
        const gDecays = grid.decays;
        const gGlows = grid.glows;
        const gMix = grid.mix;
        const gMode = grid.renderMode;
        const gEnvGlows = grid.envGlows;
        const ovActive = grid.overrideActive;
        const ovChars = grid.overrideChars;
        const ovColors = grid.overrideColors;
        const ovAlphas = grid.overrideAlphas;
        const ovGlows = grid.overrideGlows;
        const effActive = grid.effectActive;
        const effChars = grid.effectChars;
        const effColors = grid.effectColors;
        const effAlphas = grid.effectAlphas;
        const effGlows = grid.effectGlows;
        const lookup = atlas.codeToId;
        const mChars = this.mappedChars;
        const mNext = this.mappedNextChars;
        const uColors = this.uploadColors;
        const uAlphas = this.uploadAlphas;
        const uDecays = this.uploadDecays;
        const uGlows = this.uploadGlows;
        const uMix = this.uploadMix;
        const mapChar = (c) => {
            if (c <= 32) return 0;
            let id = lookup[c];
            if (id === -1) {
                const rect = atlas.addChar(String.fromCharCode(c));
                id = rect ? rect.id : 0;
            }
            return id;
        };
        for (let i = 0; i < totalCells; i++) {
            // PRIORITY 1: PASSIVE EFFECT (Pulse, etc.)
            if (effActive && effActive[i]) {
                if (effActive[i] === 3) {
                    // SHADOW MODE
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = gColors[i];
                    uAlphas[i] = 1.0; // Force full alpha, let ovAlpha handle opacity
                    uDecays[i] = gDecays[i];
                    uGlows[i] = 0.0; // Disable glow for shadowboxes
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 5.0 + eAlpha; 
                    mNext[i] = 0;
                    continue;
                }
                if (effActive[i] === 2) {
                    // OVERLAY MODE: Draw Sim + White Effect
                    // 1. Load Simulation
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = gColors[i];
                    uAlphas[i] = gAlphas[i];
                    uDecays[i] = gDecays[i];
                    uGlows[i] = gGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    // 2. Load Effect
                    mNext[i] = mapChar(effChars[i]);
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 4.0 + eAlpha; 
                    continue;
                }
                if (effActive[i] === 4) {
                    // HIGH PRIORITY OVERRIDE (Superman/Lightning)
                    // Behaves like Standard Override but sets Mix >= 10.0 to signal "Ignore Shadow"
                    mChars[i] = mapChar(effChars[i]);
                    uColors[i] = effColors[i];
                    uAlphas[i] = effAlphas[i];
                    uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    uDecays[i] = 0; 
                    uMix[i] = 10.0; // Signal Value
                    mNext[i] = 0;
                    continue;
                }
                // STANDARD OVERRIDE (Replace)
                mChars[i] = mapChar(effChars[i]);
                uColors[i] = effColors[i];
                uAlphas[i] = effAlphas[i];
                uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                // Force "Solid" render behavior for effects to prevent simulation fading
                uDecays[i] = 0; 
                uMix[i] = 0.0; // Treat as solid/override in shader
                mNext[i] = 0;
                continue; 
            }
            // PRIORITY 2: HARD OVERRIDE (Deja Vu, Firewall, etc.)
            // These usually indicate a logic change or interruption.
            const ov = ovActive[i];
            if (ov) {
                if (ov === 2) { // SOLID
                    mChars[i] = 0;
                    mNext[i] = 0;
                    uMix[i] = 3.0; // Trigger SOLID mode in shader
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = (gEnvGlows ? gEnvGlows[i] : 0);
                } else { // CHAR
                    mChars[i] = mapChar(ovChars[i]);
                    const mode = gMode[i];
                    if (mode === 1) { // OVERLAP
                        mNext[i] = mapChar(gSecChars[i]);
                        uMix[i] = 2.0; 
                    } else {
                        mNext[i] = 0;
                        uMix[i] = 0;
                    }
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = ovGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                }
                continue;
            }
            // PRIORITY 3: STANDARD SIMULATION
            const c = gChars[i];
            mChars[i] = mapChar(c);
            uColors[i] = gColors[i];
            uAlphas[i] = gAlphas[i];
            uDecays[i] = gDecays[i];
            uGlows[i] = gGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
            const mode = gMode[i];
            if (mode === 1) { // OVERLAP
                mNext[i] = mapChar(gSecChars[i]);
                uMix[i] = 2.0; 
            } else {
                const mix = gMix[i];
                uMix[i] = mix;
                if (mix > 0) {
                    mNext[i] = mapChar(gNext[i]);
                } else {
                    mNext[i] = 0;
                }
            }
        }
        if (atlas.hasChanges) {
             this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
             this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
             atlas.resetChanges();
        }
        // --- UPLOAD ---
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mChars);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uColors);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uAlphas);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uDecays);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uGlows);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uMix);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mNext);
        // --- SHADOW MASK PASS ---
        // Render Shadow Masks from Effects (Generic)
        if (this.fboWidth > 0 && this.fboHeight > 0) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.shadowMaskFbo);
            this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
            this.gl.colorMask(true, true, true, true); // Ensure writes are enabled
            this.gl.clearColor(0, 0, 0, 0); 
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            // Collect Masks from All Active Effects
            let masks = [];
            if (this.effects) {
                 // Support both Array and Map structures for EffectRegistry
                 const effectList = (Array.isArray(this.effects.effects)) 
                    ? this.effects.effects 
                    : (this.effects.effects instanceof Map) 
                        ? Array.from(this.effects.effects.values()) 
                        : (typeof this.effects.get === 'function' && typeof this.effects.getAll === 'function') // Handle registry with getters
                            ? this.effects.getAll() // Assuming a getAll exists, or fallback to iterating specific known effects if not
                            : []; 
                 // If getAll doesn't exist, we might need to rely on the Map iterator if effects.effects is private.
                 // However, let's assume standard iteration is possible.
                 // Fallback: If effects.effects is a Map, use values().
                 const iterable = (this.effects.effects instanceof Map) ? this.effects.effects.values() : effectList;
                 for (const effect of iterable) {
                     if (effect.active) {
                         // Check for CrashEffect legacy support or new Generic Interface
                         if (effect.name === 'CrashSequence' && effect.blackSheets) {
                             // Legacy/Specific Support for CrashEffect
                             for (const s of effect.blackSheets) {
                                 masks.push({
                                     x: s.posX, y: s.posY, w: s.w, h: s.h,
                                     alpha: s.currentAlpha * s.maxAlpha,
                                     blur: (s.blur !== undefined) ? s.blur : 0.0 // Default to 0 for Crash
                                 });
                             }
                         }
                         // Future Generic Interface: getMasks()
                         if (typeof effect.getMasks === 'function') {
                             const effectMasks = effect.getMasks();
                             if (Array.isArray(effectMasks)) {
                                 masks.push(...effectMasks);
                             }
                         }
                     }
                 }
            }
            if (masks.length > 0 && this.shadowInstanceBuffer) {
                this.gl.useProgram(this.shadowProgram);
                // Upload Instance Data (x, y, w, h, alpha, blur) - 6 floats
                const count = masks.length;
                if (!this.shadowData || this.shadowData.length < count * 6) {
                    this.shadowData = new Float32Array(count * 6 * 2); 
                }
                const data = this.shadowData;
                for (let i=0; i<count; i++) {
                    const m = masks[i];
                    data[i*6+0] = m.x;
                    data[i*6+1] = m.y;
                    data[i*6+2] = m.w;
                    data[i*6+3] = m.h;
                    data[i*6+4] = m.alpha;
                    data[i*6+5] = (m.blur !== undefined) ? m.blur : 0.2; // Default blur if missing
                }
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // 6 floats * 4 bytes = 24 bytes per instance
                const stride = 24;
                if (count > this.shadowInstanceCapacity) {
                     this.shadowInstanceCapacity = Math.max(count, this.shadowInstanceCapacity * 2);
                     this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * stride, this.gl.DYNAMIC_DRAW);
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                } else {
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                }
                // Setup Attributes
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // a_rect (vec4)
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, stride, 0);
                this.gl.vertexAttribDivisor(1, 1);
                // a_alpha (float)
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 1, this.gl.FLOAT, false, stride, 16);
                this.gl.vertexAttribDivisor(2, 1);
                // a_blur (float)
                this.gl.enableVertexAttribArray(3);
                this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, stride, 20);
                this.gl.vertexAttribDivisor(3, 1);
                this.gl.uniform2f(this.gl.getUniformLocation(this.shadowProgram, 'u_gridSize'), grid.cols, grid.rows);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, count);
                this.gl.vertexAttribDivisor(1, 0);
                this.gl.vertexAttribDivisor(2, 0);
                this.gl.vertexAttribDivisor(3, 0);
                this.gl.disableVertexAttribArray(1);
                this.gl.disableVertexAttribArray(2);
                this.gl.disableVertexAttribArray(3);
            }
            // --- REVEAL PUNCH-OUT PASS (Subtract Alpha) ---
            // Only necessary if we have drawn shadows
            if (typeof masks !== 'undefined' && masks && masks.length > 0 && this.effects) {
                let crash = null;
                // Locate CrashEffect
                if (Array.isArray(this.effects.effects)) {
                     crash = this.effects.effects.find(e => e.name === 'CrashSequence');
                } else if (this.effects.effects instanceof Map) {
                     crash = this.effects.effects.get('CrashSequence');
                } else if (typeof this.effects.get === 'function') {
                     crash = this.effects.get('CrashSequence');
                }
                if (crash && crash.active && typeof crash.getReveals === 'function') {
                    const reveals = crash.getReveals();
                    if (reveals.length > 0) {
                        // Use Color Program to draw fading triangles
                        this.gl.useProgram(this.colorProgram);
                        // Punch-out blend mode: DestAlpha = DestAlpha * (1 - SrcAlpha)
                        // Src = (0,0,0, RevealAlpha)
                        this.gl.blendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_ALPHA);
                        if (!this.revealBuffer) {
                            this.revealBuffer = this.gl.createBuffer();
                        }
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.revealBuffer);
                        // Enable Position Attribute (Location 0 in colorProgram)
                        this.gl.enableVertexAttribArray(0);
                        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                        const cols = grid.cols;
                        const rows = grid.rows;
                        // Buffer for batching vertices
                        // Estimate size: 50 reveals * 100 segments * 6 verts * 2 coords = ~60k floats
                        // Just allocate dynamically per frame or reuse a large buffer.
                        // For simplicity/safety in this refactor, let's process per reveal and use bufferData.
                        for (const r of reveals) {
                            const alpha = r.alpha;
                            if (alpha <= 0.01) continue;
                            this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), 0, 0, 0, alpha);
                            let vertices = null;
                            if (r.type === 'strip' && r.trunk && r.branch) {
                                // Draw Triangle Strip between Trunk and Branch
                                const len = Math.min(r.trunk.length, r.branch.length);
                                if (len < 2) continue;
                                // 2 triangles per segment * (len-1) segments * 3 verts * 2 coords
                                const data = new Float32Array((len - 1) * 6 * 2);
                                let ptr = 0;
                                for (let i = 0; i < len - 1; i++) {
                                    // Points in Grid Space
                                    const t1 = r.trunk[i];
                                    const t2 = r.trunk[i+1];
                                    const b1 = r.branch[i];
                                    const b2 = r.branch[i+1];
                                    // Convert to Clip Space
                                    // X: 0..cols -> -1..1
                                    // Y: 0..rows -> 1..-1 (Inverted)
                                    const ax = (t1.x / cols) * 2.0 - 1.0; const ay = 1.0 - (t1.y / rows) * 2.0;
                                    const bx = (t2.x / cols) * 2.0 - 1.0; const by = 1.0 - (t2.y / rows) * 2.0;
                                    const cx = (b1.x / cols) * 2.0 - 1.0; const cy = 1.0 - (b1.y / rows) * 2.0;
                                    const dx = (b2.x / cols) * 2.0 - 1.0; const dy = 1.0 - (b2.y / rows) * 2.0;
                                    // Triangle 1: t1, t2, b1
                                    data[ptr++] = ax; data[ptr++] = ay;
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                    // Triangle 2: t2, b2, b1
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = dx; data[ptr++] = dy;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                }
                                vertices = data;
                            } 
                            // Legacy/Fallback Triangle support (if needed, though we moved to strip)
                            else if (r.p1 && r.p2 && r.p3) {
                                const x1 = (r.p1.x / cols) * 2.0 - 1.0; const y1 = 1.0 - (r.p1.y / rows) * 2.0;
                                const x2 = (r.p2.x / cols) * 2.0 - 1.0; const y2 = 1.0 - (r.p2.y / rows) * 2.0;
                                const x3 = (r.p3.x / cols) * 2.0 - 1.0; const y3 = 1.0 - (r.p3.y / rows) * 2.0;
                                vertices = new Float32Array([x1, y1, x2, y2, x3, y3]);
                            }
                            if (vertices) {
                                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
                                this.gl.drawArrays(this.gl.TRIANGLES, 0, vertices.length / 2);
                            }
                        }
                    }
                }
            }
        }
        // --- DRAW ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA);
        this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
        // 1. Trail Fade (Draw Black Quad)
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        if (this.colorProgram) {
            this.gl.useProgram(this.colorProgram);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
            this.gl.enableVertexAttribArray(0); 
            this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
            this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), 0, 0, 0, s.clearAlpha);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        // 2. Draw Cells
        this.gl.useProgram(this.program);
        // Uniforms
        this.gl.uniform2f(this.gl.getUniformLocation(this.program, 'u_resolution'), this.w, this.h);
        this.gl.uniform2f(this.gl.getUniformLocation(this.program, 'u_atlasSize'), atlas.canvas.width, atlas.canvas.height);
        // Calculate Grid Size in Pixels for Centering
        const gridPixW = grid.cols * d.cellWidth;
        const gridPixH = grid.rows * d.cellHeight;
        this.gl.uniform2f(this.gl.getUniformLocation(this.program, 'u_gridSize'), gridPixW, gridPixH);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_cellSize'), atlas.cellSize);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_cols'), atlas._lastCols);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_decayDur'), s.decayFadeDurationFrames);
        this.gl.uniform2f(this.gl.getUniformLocation(this.program, 'u_stretch'), s.stretchX, s.stretchY);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_mirror'), s.mirrorEnabled ? -1.0 : 1.0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'u_texture'), 0);
        // Bind Shadow Mask
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.shadowMaskTex);
        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'u_shadowMask'), 1);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_time'), performance.now() / 1000.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_dissolveEnabled'), s.dissolveEnabled ? 1.0 : 0.0);
        // Target Scale: 1.0 + percent/100. e.g. -20% -> 0.8
        const percent = s.dissolveScalePercent !== undefined ? s.dissolveScalePercent : -20;
        const dissolveScale = s.dissolveEnabled ? (1.0 + (percent / 100.0)) : 1.0;
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_dissolveScale'), dissolveScale);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_dissolveSize'), s.dissolveMinSize || 1.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_deteriorationEnabled'), s.deteriorationEnabled ? 1.0 : 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_deteriorationStrength'), s.deteriorationStrength);
        // Pass Overlap Color
        const ovRgb = Utils.hexToRgb(s.overlapColor || "#FFD700");
        this.gl.uniform4f(this.gl.getUniformLocation(this.program, 'u_overlapColor'), ovRgb.r/255.0, ovRgb.g/255.0, ovRgb.b/255.0, 1.0);
        this.gl.bindVertexArray(this.vao);
        // Ensure blending is enabled for the main draw
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        // Draw Main Pass
        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, totalCells);
        this.gl.bindVertexArray(null);
        // --- POST PROCESS (Bloom) ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        const blurAmt = s.smoothingEnabled ? s.smoothingAmount : 0;
        this._drawFullscreenTexture(this.texA, 1.0, blurAmt);
        if (s.enableBloom) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
            this.gl.viewport(0, 0, this.bloomWidth, this.bloomHeight);
            let spread = s.bloomStrength * 1.0; 
            this._runBlur(this.texA, true, spread, this.fboWidth, this.fboHeight); 
            const iterations = 3;
            for (let i = 0; i < iterations; i++) {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboC);
                this._runBlur(this.texB, false, spread, this.bloomWidth, this.bloomHeight);
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
                this._runBlur(this.texC, true, spread, this.bloomWidth, this.bloomHeight);
            }
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE); 
            this._drawFullscreenTexture(this.texB, s.bloomOpacity, 0);
        }
        if (this.postProcessor) {
            const customSource = s.shaderEnabled ? s.customShader : null;
            const effectSource = s.effectShader;
            // Compile Custom Shader if changed
            if (customSource !== this.lastShaderSource) {
                this.postProcessor.compileShader(customSource);
                this.lastShaderSource = customSource;
            }
            // Compile Effect Shader if changed
            if (effectSource !== this.lastEffectSource) {
                this.postProcessor.compileEffectShader(effectSource);
                this.lastEffectSource = effectSource;
            }
            const isActive = (s.shaderEnabled && customSource) || effectSource;
            if (isActive) {
                const param = s.shaderParameter !== undefined ? s.shaderParameter : 0.5;
                this.postProcessor.render(this.cvs, performance.now() / 1000, this.mouseX, this.mouseY, param);
                if (this.postProcessor.canvas.style.display === 'none') {
                    this.postProcessor.canvas.style.display = 'block';
                    this.cvs.style.opacity = '0'; 
                }
            } else {
                if (this.postProcessor.canvas.style.display !== 'none') {
                    this.postProcessor.canvas.style.display = 'none';
                    this.cvs.style.opacity = '1';
                }
            }
        }
    }
}
// --- SimulationSystem.js ---
class SimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.streamManager = new StreamManager(grid, config);
        this.glowSystem = new GlowSystem(grid);
        this.grid.glowSystem = this.glowSystem; // Expose to Effects via Grid
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.timeScale = 1.0;
    }
    update(frame) {
        this.streamManager.update(frame, this.timeScale);
        this._manageOverlapGrid(frame);
        this._updateCells(frame);
        // Apply Glows (Additive)
        if (this.grid.envGlows) this.grid.envGlows.fill(0);
        this.glowSystem.update();
        this.glowSystem.apply();
        if (this.grid.cellLocks) {
            this.grid.cellLocks.fill(0);
        }
    }
    _manageOverlapGrid(frame) {
        const s = this.config.state;
        if (!s.overlapEnabled) {
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                if (this.grid.secondaryChars && typeof this.grid.secondaryChars.fill === 'function') {
                    this.grid.secondaryChars.fill(32); 
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = s.overlapDensity;
        const ovRgb = Utils.hexToRgb(s.overlapColor);
        const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
        const setOverlapChar = (i) => {
            let fIdx;
            if (this.grid.types[i] === CELL_TYPE.EMPTY) {
                fIdx = Math.floor(Math.random() * numFonts);
            } else {
                fIdx = this.grid.fontIndices[i];
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            let code = 32;
            if (chars && chars.length > 0) {
                const r = Math.floor(Math.random() * chars.length);
                code = chars[r].charCodeAt(0);
            }
            this.grid.secondaryChars[i] = code;
            this.grid.secondaryColors[i] = ovColor;
        };
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            const N = this.grid.secondaryChars.length;
            for (let i = 0; i < N; i++) {
                // If cell is overridden (e.g. Pulse Freeze), do not change secondary char
                if (this.grid.overrideActive[i] !== 0) continue;
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.secondaryChars[i] = 32; 
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _updateCells(frame) {
        const s = this.config.state;
        const d = this.config.derived;
        const grid = this.grid;
        for (const idx of grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const grid = this.grid;
        if (grid.cellLocks && grid.cellLocks[idx] === 1) return;
        // If an effect is overriding this cell, pause simulation updates (Freeze)
        if (grid.overrideActive[idx] !== 0) return;
        const decay = grid.decays[idx];
        if (decay === 0) return;
        let age = grid.ages[idx];
        if (age > 0) {
            age = this._incrementAge(age, d.maxState);
            grid.ages[idx] = age;
        }
        // --- TRACER COLOR FADE ---
        // Transitions from Tracer Color -> Stream Color based on Age
        // Only apply if NOT decaying (Erasers trigger decay)
        if (decay < 2 && (grid.types[idx] === CELL_TYPE.TRACER || grid.types[idx] === CELL_TYPE.ROTATOR)) {
            const attack = s.tracerAttackFrames;
            const hold = s.tracerHoldFrames;
            const release = s.tracerReleaseFrames;
            const tracerColor = d.tracerColorUint32;
            const baseColor = grid.baseColors[idx];
            let ratio = 0; // 0 = Tracer, 1 = Base
            // Age 1..Attack: Fade In (Alpha handles this, color stays Tracer)
            // Attack..Attack+Hold: Hold Tracer Color
            // Attack+Hold..End: Fade to Stream Color
            const activeAge = age - 1;
            if (activeAge > attack + hold) {
                if (release > 0) {
                    ratio = Math.min(1.0, (activeAge - (attack + hold)) / release);
                } else {
                    ratio = 1.0;
                }
            }
            if (ratio >= 1.0) {
                grid.colors[idx] = baseColor;
                grid.glows[idx] = 0; // Remove glow after transition
            } else if (ratio > 0) {
                // Blend
                const tR = tracerColor & 0xFF;
                const tG = (tracerColor >> 8) & 0xFF;
                const tB = (tracerColor >> 16) & 0xFF;
                const bR = baseColor & 0xFF;
                const bG = (baseColor >> 8) & 0xFF;
                const bB = (baseColor >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * ratio);
                const mG = Math.floor(tG + (bG - tG) * ratio);
                const mB = Math.floor(tB + (bB - tB) * ratio);
                grid.colors[idx] = Utils.packAbgr(mR, mG, mB);
                grid.glows[idx] = s.tracerGlow * (1.0 - ratio);
            } else {
                // Hold Tracer
                grid.colors[idx] = tracerColor;
                grid.glows[idx] = s.tracerGlow;
            }
        }
        // Handle Rotator
        // Allow rotator to finish its transition (mix > 0) even if subsequently disabled
        if ((s.rotatorEnabled || grid.mix[idx] > 0) && grid.types[idx] === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        // Handle Dynamic Colors (Effects)
        if (grid.complexStyles.has(idx)) {
            const style = grid.complexStyles.get(idx);
            if (style.cycle) {
                const newHue = (style.h + style.speed) % 360;
                style.h = newHue; 
                const rgb = Utils.hslToRgb(newHue, style.s, style.l);
                grid.colors[idx] = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
            }
        }
        // Handle Decay / Alpha
        if (decay >= 2) {
            // Ensure trails are Stream Color, not Tracer Color
            // BUT: If it's a cycling effect (StarPower), the baseColor is outdated. 
            // The effect logic above keeps grid.colors updated, so we shouldn't overwrite it.
            let useBase = true;
            if (grid.complexStyles.has(idx)) {
                const style = grid.complexStyles.get(idx);
                if (style.cycle) useBase = false;
            }
            if (useBase) {
                if (decay === 2) { // First frame of decay
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                } else {
                    // Also enforce it in case we missed frame 2 (unlikely but safe)
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                }
            } else {
                // For cycling effects, just kill the glow
                grid.glows[idx] = 0;
            }
            grid.decays[idx]++;
            const newDecay = grid.decays[idx];
            if (this._shouldDecay(idx, newDecay, s.decayFadeDurationFrames)) {
                grid.clearCell(idx);
                return;
            }
            grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, s.decayFadeDurationFrames);
        } else {
            grid.alphas[idx] = this._calculateAlpha(idx, age, decay, s.decayFadeDurationFrames);
        }
    }
    _incrementAge(age, maxState) {
        return age + 1;
    }
    _handleRotator(idx, frame, s, d) {
        const grid = this.grid;
        const mix = grid.mix[idx]; 
        const decay = grid.decays[idx];
        if (mix > 0) {
            this._progressRotator(idx, mix, s.rotatorCrossfadeFrames);
        } else if (s.rotatorEnabled && (decay === 1 || (s.rotateDuringFade && decay > 1))) {
            this._cycleRotator(idx, frame, s.rotatorCrossfadeFrames, d.rotatorCycleFrames, s);
        }
    }
    _progressRotator(idx, currentMix, crossfadeFrames) {
        const grid = this.grid;
        const step = 1.0 / Math.max(1, crossfadeFrames);
        const newMix = currentMix + step;
        if (newMix >= 1.0) {
            const target = grid.getRotatorTarget(idx, false); 
            if (target) {
                grid.chars[idx] = target.charCodeAt(0);
                if (this.config.state.overlapEnabled) {
                    const ovTarget = grid.getRotatorTarget(idx, true);
                    if (ovTarget) {
                        grid.secondaryChars[idx] = ovTarget.charCodeAt(0);
                    }
                }
            }
            grid.mix[idx] = 0;
            // Clear rotator targets
            grid.nextChars[idx] = 0;
            grid.nextOverlapChars[idx] = 0;
        } else {
            grid.mix[idx] = newMix;
        }
    }
    _cycleRotator(idx, frame, crossfadeFrames, cycleFrames, s) {
        const grid = this.grid;
        let effectiveCycle = cycleFrames;
        if (s.rotatorDesyncEnabled) {
            const variancePercent = s.rotatorDesyncVariance / 100;
            const maxVariance = cycleFrames * variancePercent;
            const offsetNorm = (grid.rotatorOffsets[idx] / 127.5) - 1.0;
            effectiveCycle = Math.max(1, Math.round(cycleFrames + (offsetNorm * maxVariance)));
        }
        if (frame % effectiveCycle === 0) {
            const fontIdx = grid.fontIndices[idx];
            const activeFonts = this.config.derived.activeFonts;
            const fontData = activeFonts[fontIdx] || activeFonts[0];
            const charSet = fontData.chars;
            const nextChar = this._getUniqueChar(grid.getChar(idx), charSet);
            const nextCode = nextChar.charCodeAt(0);
            let nextOvCode = 0;
            if (this.config.state.overlapEnabled) {
                const curOv = String.fromCharCode(grid.secondaryChars[idx]);
                const nextOv = this._getUniqueChar(curOv, charSet);
                nextOvCode = nextOv.charCodeAt(0);
            }
            if (crossfadeFrames <= 1) {
                grid.chars[idx] = nextCode;
                if (nextOvCode) grid.secondaryChars[idx] = nextOvCode;
            } else {
                grid.mix[idx] = 0.01; 
                grid.setRotatorTarget(idx, nextChar, false);
                if (nextOvCode) {
                    grid.setRotatorTarget(idx, String.fromCharCode(nextOvCode), true);
                }
            }
        }
    }
    _getUniqueChar(exclude, charSet) {
        if (!charSet) charSet = Utils.CHARS;
        if (charSet.length <= 1) return charSet[0];
        let char;
        let attempts = 0;
        do {
            char = charSet[Math.floor(Math.random() * charSet.length)];
            attempts++;
        } while (char === exclude && attempts < 10);
        return char;
    }
    _shouldDecay(idx, decay, fadeDurationFrames) {
        return decay > fadeDurationFrames + 2;
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        const s = this.config.state;
        const b = this.grid.brightness[idx];
        // Fading OUT
        if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            // Use power curve for smoother perceived fade (starts fading sooner)
            const fade = Math.pow(Math.max(0, 1.0 - ratio), 2.0);
            return 0.95 * fade * b;
        }
        // Fading IN
        const attack = s.tracerAttackFrames;
        if (age <= attack && attack > 0) {
            return 0.95 * (age / attack) * b;
        }
        // Standard State
        return 0.95 * b;
    }
}
// --- StreamManager.js ---
class StreamManager {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.activeStreams = [];
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.modes = this._initializeModes(config);
        this.nextSpawnFrame = 0;
        // Reusable columns pool to avoid per-spawn allocation
        this._columnsPool = new Array(this.grid.cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    resize(cols) {
        this.lastStreamInColumn = new Array(cols).fill(null);
        this.lastEraserInColumn = new Array(cols).fill(null);
        this.activeStreams = [];
        // Rebuild columns pool
        this._columnsPool = new Array(cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    update(frame, timeScale) {
        // Keep columns arrays in sync with grid size if changed (safety check)
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            this.resize(this.grid.cols);
        }
        if (timeScale > 0) {
            this._manageStreams(frame, timeScale);
        } else if (timeScale < 0) {
            this._processActiveStreams(frame, timeScale);
        }
        // If timeScale == 0, pause
    }
    _manageStreams(frame, timeScale) {
        const { state: s, derived: d } = this.config;
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2;
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        this._processActiveStreams(frame, timeScale);
    }
    _spawnStreams(s, d) {
        const columns = this._columnsPool;
        // Fisher-Yates Shuffle
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
                if (this.grid.decays[spawnIdx] > 0) {
                    isTopBlocked = true;
                }
            }
            const lastStream = this.lastStreamInColumn[col];
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true);
                eraserCount--;
                continue; 
            } 
            else if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false);
                streamCount--;
                continue; 
            }
        }
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        if (!lastStream || !lastStream.active) return true;
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        const lastStream = this.lastStreamInColumn[col];
        if (lastStream && lastStream.active && !lastStream.isEraser) {
            if (lastStream.y <= minGapTypes) return false;
        }
        return true;
    }
    _processActiveStreams(frame, timeScale) {
        const grid = this.grid;
        const rows = grid.rows;
        const cellLocks = grid.cellLocks;
        const decays = grid.decays;
        if (Math.abs(timeScale) < 0.01) return;
        const isReverse = timeScale < 0;
        const speedMult = Math.abs(timeScale);
        for (let i = this.activeStreams.length - 1; i >= 0; i--) {
            const stream = this.activeStreams[i];
            if (!stream.active) {
                this.activeStreams.splice(i, 1);
                continue;
            }
            const headIdx = grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && cellLocks && cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.tickTimer -= speedMult;
            if (stream.tickTimer > 0) {
                continue; 
            }
            stream.tickTimer = stream.tickInterval;
            if (isReverse) {
                stream.y--;
                if (stream.y < -5) {
                    stream.active = false;
                    continue;
                }
                this._writeHead(stream, frame);
            } else {
                // Drop-off logic
                if (stream.isEraser) {
                    const stopChance = this.config.state.eraserStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                } else {                    
                    const stopChance = this.config.state.tracerStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                    const nextY = stream.y + 1;
                    if (nextY < rows) {
                        const nextIdx = grid.getIndex(stream.x, nextY);
                        if (nextIdx !== -1 && decays[nextIdx] > 0) {
                            stream.active = false;
                            continue; 
                        }
                    }
                } 
                stream.age++;
                if (stream.age >= stream.visibleLen) {
                    this._handleStreamCompletion(stream);
                    continue;
                }
                if (stream.y < stream.len) {
                    stream.y++;
                    this._writeHead(stream, frame);
                }
            }
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        if (!stream.isEraser) {
            this._spawnStreamAt(stream.x, true);
        }
    }
    _spawnStreamAt(x, forceEraser) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _initializeStream(x, forceEraser, s) {
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        let tickInterval = baseTick;
        if (s.desyncIntensity > 0) {
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            tickInterval = Math.max(1, baseTick + offset);
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsUint32?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval,
            tickTimer: 0
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        stream.visibleLen = this.grid.rows + 20; 
        return stream;
    }
    _initializeTracerStream(stream, s) {
        stream.len = this.grid.rows + 10; 
        stream.visibleLen = this.grid.rows * 4; 
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        const decays = this.grid.decays;
        if (decays[idx] >= 2) return;
        if (decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            decays[idx] = 2;
        } else {
            this.grid.clearCell(idx);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const s = this.config.state;
            const d = this.config.derived;
            const grid = this.grid;
            const cellType = s.rotatorEnabled && Math.random() < s.rotatorChance
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            grid.types[idx] = cellType;
            grid.ages[idx] = 1;
            grid.decays[idx] = 1;
            grid.mix[idx] = 0; // Reset Rotator/Mix Progress
            grid.renderMode[idx] = RENDER_MODE.STANDARD;
            grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = d.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const charStr = charSet[Math.floor(Math.random() * charSet.length)];
            // Resolve Color
            let colorUint32;
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                // Complex Style (Effect)
                grid.complexStyles.set(idx, style);
                // Convert style to color immediately
                if (style.h !== undefined) {
                    const rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    colorUint32 = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                } else {
                     // Fallback
                     colorUint32 = d.tracerColorUint32;
                }
            } else {
                grid.complexStyles.delete(idx);
                // Standard Color
                if (Math.random() < s.paletteBias) {
                    const pLen = d.paletteColorsUint32?.length || 1;
                    colorUint32 = d.paletteColorsUint32[Math.floor(Math.random() * pLen)];
                } else {
                    colorUint32 = d.paletteColorsUint32[stream.pIdx] || d.paletteColorsUint32[0];
                }
            }
            // Brightness / Alpha
            const b = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            grid.brightness[idx] = b;
            // Set Primary (Visual = Tracer Color initially)
            const tracerColor = d.tracerColorUint32;
            grid.setPrimary(idx, charStr, tracerColor, b, stream.fontIndex, s.tracerGlow);
            grid.baseColors[idx] = colorUint32; // Store Stream Color for fade target
            // Handle Overlap (Secondary)
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                const overlapChar = charSet[Math.floor(Math.random() * charSet.length)];
                // For overlaps, we usually use the same color? Or Overlap Color?
                // Previously, renderer used `overlapColor` from config for overlaps.
                // But now CellGrid stores the color.
                // We should resolve Overlap Color here.
                const ovRgb = Utils.hexToRgb(s.overlapColor);
                const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
                grid.setSecondary(idx, overlapChar, ovColor, b, stream.fontIndex, s.tracerGlow);
                grid.renderMode[idx] = RENDER_MODE.OVERLAP;
            }
        } else {
            this.grid.clearCell(idx);
        }
    }
}
// --- StreamModes.js ---
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        let hue;
        if (state.starPowerRainbowMode === 'char') {
            hue = (frame + (stream.x * 10)) % 360; // Character-based hue
        } else {
            // Full Stream Mode: Sync hue start time so they cycle together
            // If cycling is enabled, offset the base hue by the current frame * speed
            hue = stream.baseHue;
            if (state.starPowerColorCycle) {
                 hue = (hue + (frame * state.starPowerCycleSpeed)) % 360;
            }
        }
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed, state.starPowerGlitter);
    }
    _createStyle(hue, saturation, lightness, cycle, speed, glitter) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, glitter, isEffect: true };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, glitter: false, isEffect: true };
    }
}
    // =========================================================================
    // 5.0 SIMULATION SYSTEM 
    // =========================================================================
// --- CharacterSelectorModal.js ---
class CharacterSelectorModal {
    constructor(config, fontManager, notificationMgr) {
        this.config = config;
        this.fonts = fontManager;
        this.notifications = notificationMgr;
        this.dom = null;
        this.currentFont = null;
        // Canvas for glyph detection
        this.scanCanvas = document.createElement('canvas');
        this.scanCanvas.width = 20;
        this.scanCanvas.height = 20;
        this.scanCtx = this.scanCanvas.getContext('2d', { willReadFrequently: true });
        // Subscribe to config changes for fontSettings
        this.config.subscribe((key) => this._handleConfigChange(key));
    }
    show() {
        if (!this.dom) {
            this._createDOM();
        }
        this._refreshFontList();
        const currentFamily = this.config.get('fontFamily');
        const isKnown = this.fonts.loadedFonts.some(f => f.name === currentFamily) || currentFamily === 'MatrixEmbedded';
        this.currentFont = isKnown ? currentFamily : 'MatrixEmbedded';
        if (this.dom.fontSelect.querySelector(`option[value="${this.currentFont}"]`)) {
            this.dom.fontSelect.value = this.currentFont;
        } else {
             this.currentFont = 'MatrixEmbedded';
             this.dom.fontSelect.value = 'MatrixEmbedded';
        }
        this._loadFontSettings(this.currentFont);
        this.dom.overlay.classList.add('visible');
    }
    hide() {
        if (this.dom) {
            this.dom.overlay.classList.remove('visible');
        }
    }
    _handleConfigChange(key) {
        if (key === 'fontSettings' && this.dom && this.dom.overlay.classList.contains('visible')) {
            // If font settings changed while modal is open, reload current font settings to refresh UI
            this._loadFontSettings(this.currentFont);
        }
    }
    _createDOM() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        const content = document.createElement('div');
        content.className = 'modal-content';
        // Header
        const header = document.createElement('div');
        header.className = 'modal-header';
        header.innerHTML = '<h3 class="modal-title">Manage Characters</h3><div class="modal-close">Ã—</div>';
        header.querySelector('.modal-close').onclick = () => this.hide();
        // Body
        const body = document.createElement('div');
        body.className = 'modal-body';
        // 1. Font Selector
        const fontRow = document.createElement('div');
        fontRow.innerHTML = '<label class="modal-label">Select Font to Edit</label>';
        this.fontSelect = document.createElement('select');
        this.fontSelect.onchange = (e) => this._loadFontSettings(e.target.value);
        fontRow.appendChild(this.fontSelect);
        body.appendChild(fontRow);
        // 2. Active Toggle
        const activeRow = document.createElement('div');
        activeRow.className = 'checkbox-row';
        activeRow.innerHTML = '<span>Include in Rain</span><input type="checkbox" id="fontActiveToggle">';
        activeRow.querySelector('input').onchange = (e) => this._updateSetting('active', e.target.checked);
        this.activeToggle = activeRow.querySelector('input');
        body.appendChild(activeRow);
        // 3. Custom Chars Toggle
        const customToggleRow = document.createElement('div');
        customToggleRow.className = 'checkbox-row';
        customToggleRow.innerHTML = '<span>Use Custom Characters</span><input type="checkbox" id="fontCustomToggle">';
        customToggleRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useCustomChars', e.target.checked);
            this._toggleInputs(e.target.checked);
        };
        this.customToggle = customToggleRow.querySelector('input');
        body.appendChild(customToggleRow);
        // 4. Use All Characters Toggle
        const useAllRow = document.createElement('div');
        useAllRow.className = 'checkbox-row';
        useAllRow.innerHTML = '<span>Auto-Detect All Characters</span><input type="checkbox" id="fontUseAllToggle">';
        useAllRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useAllChars', e.target.checked);
            this._handleUseAll(e.target.checked);
        };
        this.useAllToggle = useAllRow.querySelector('input');
        body.appendChild(useAllRow);
        this.scanStatus = document.createElement('div');
        this.scanStatus.className = 'scan-status';
        body.appendChild(this.scanStatus);
        // 5. Visual Picker
        const pickerGroup = document.createElement('div');
        pickerGroup.innerHTML = '<label class="modal-label">Visual Selector</label><div class="modal-desc">Click characters to add/remove them. Empty boxes are unsupported by this font.</div>';
        this.charGrid = document.createElement('div');
        this.charGrid.className = 'char-grid-container';
        pickerGroup.appendChild(this.charGrid);
        body.appendChild(pickerGroup);
        // 6. Manual Input (Fallback)
        const inputGroup = document.createElement('div');
        inputGroup.innerHTML = '<label class="modal-label">Manual Input</label>';
        this.charInput = document.createElement('textarea');
        this.charInput.className = 'char-input';
        this.charInput.placeholder = 'Or paste characters here...';
        this.charInput.oninput = (e) => {
            this._updateSetting('customCharacters', e.target.value);
            this._updateGridSelection();
        };
        inputGroup.appendChild(this.charInput);
        body.appendChild(inputGroup);
        // Footer
        const footer = document.createElement('div');
        footer.className = 'modal-footer';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'action-btn btn-info';
        saveBtn.textContent = 'Done';
        saveBtn.style.width = 'auto';
        saveBtn.onclick = () => this.hide();
        footer.appendChild(saveBtn);
        content.append(header, body, footer);
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        this.dom = { overlay, fontSelect: this.fontSelect };
    }
    _refreshFontList() {
        this.fontSelect.innerHTML = '';
        const fonts = [
            { name: 'MatrixEmbedded', display: 'Matrix Custom Code (Default)' },
            ...this.fonts.loadedFonts.filter(f => !f.isEmbedded)
        ];
        fonts.forEach(f => {
            const opt = document.createElement('option');
            opt.value = f.name;
            opt.textContent = f.display || f.name;
            this.fontSelect.appendChild(opt);
        });
    }
    _loadFontSettings(fontName) {
        this.currentFont = fontName;
        const allSettings = this.config.get('fontSettings') || {};
        if (!allSettings[fontName]) {
             allSettings[fontName] = { active: false, useCustomChars: false, useAllChars: false, customCharacters: "" };
        }
        const settings = allSettings[fontName];
        this.activeToggle.checked = settings.active;
        this.customToggle.checked = settings.useCustomChars;
        this.useAllToggle.checked = settings.useAllChars;
        this.charInput.value = settings.customCharacters || "";
        this._toggleInputs(settings.useCustomChars);
        // If Use All is checked, run the scan logic visually but don't overwrite if not needed
        // Ideally we only run scan if useAllChars is TRUE.
        if (settings.useCustomChars) {
            if (settings.useAllChars) {
                this._handleUseAll(true); // Will re-scan and disable inputs
            } else {
                this._renderGrid(); // Just render grid for manual selection
            }
        }
    }
    _toggleInputs(enabled) {
        const opacity = enabled ? 1 : 0.5;
        this.useAllToggle.disabled = !enabled;
        this.useAllToggle.parentElement.style.opacity = opacity;
        // If "Use All" is checked, specific inputs are disabled regardless of "Use Custom"
        const allChecked = this.useAllToggle.checked;
        const manualEnabled = enabled && !allChecked;
        this.charInput.disabled = !manualEnabled;
        this.charInput.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.pointerEvents = manualEnabled ? 'auto' : 'none';
        if (enabled && !allChecked) {
            this._renderGrid();
        }
    }
    async _handleUseAll(checked) {
        if (!checked) {
            this._toggleInputs(true); // Re-enable manual inputs
            this.scanStatus.textContent = '';
            return;
        }
        this.charInput.disabled = true;
        this.charInput.style.opacity = 0.5;
        this.charGrid.style.opacity = 0.5;
        this.charGrid.style.pointerEvents = 'none';
        this.scanStatus.textContent = 'Scanning font for all valid glyphs...';
        // Yield to UI render
        await new Promise(r => setTimeout(r, 50));
        const validChars = this._scanForChars(this.currentFont);
        this.charInput.value = validChars;
        this._updateSetting('customCharacters', validChars);
        this.scanStatus.textContent = `Scan complete. Found ${validChars.length} characters.`;
        this._renderGrid(); // Visual confirmation
    }
    _scanForChars(fontName) {
        const ranges = [
            [33, 126], // Basic Latin
            [161, 255], // Latin-1
            [1024, 1279], // Cyrillic
            [913, 969], // Greek
            [5792, 5887], // Runic
            [12353, 12447], // Hiragana
            [12448, 12543], // Katakana
            [65377, 65439] // Halfwidth Katakana
        ];
        let valid = "";
        // Get "tofu" or empty signature
        const emptySig = this._getCharSignature(fontName, '\uFFFF');
        const spaceSig = this._getCharSignature(fontName, ' ');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(fontName, char);
                // If distinct from empty/tofu, it's valid
                if (sig && sig !== emptySig && sig !== spaceSig) {
                    valid += char;
                }
            }
        }
        return valid;
    }
    _getCharSignature(fontName, char) {
        this.scanCtx.clearRect(0, 0, 20, 20);
        this.scanCtx.font = `16px "${fontName}"`;
        this.scanCtx.textBaseline = 'middle';
        this.scanCtx.textAlign = 'center';
        this.scanCtx.fillStyle = '#fff';
        this.scanCtx.fillText(char, 10, 10);
        // Get pixel data hash-ish
        const data = this.scanCtx.getImageData(5, 5, 10, 10).data; // Sample center 10x10
        let sum = 0;
        for(let i=3; i<data.length; i+=4) { // check alpha only
            sum += data[i];
        }
        return sum; // simple sum signature
    }
    _renderGrid() {
        this.charGrid.innerHTML = '';
        // Define grid ranges (subset of scan ranges for visual sanity)
        const ranges = [
            [33, 126], // ASCII
            [12448, 12543] // Katakana
        ];
        const currentSet = new Set(this.charInput.value.split(''));
        const emptySig = this._getCharSignature(this.currentFont, '\uFFFF');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(this.currentFont, char);
                // If valid glyph
                if (sig && sig !== emptySig) {
                    const el = document.createElement('div');
                    el.className = 'char-grid-item';
                    el.textContent = char;
                    el.style.fontFamily = this.currentFont;
                    if (currentSet.has(char)) el.classList.add('selected');
                    el.onclick = () => {
                        if (this.useAllToggle.checked) return; // Locked
                        this._toggleChar(char);
                        el.classList.toggle('selected');
                    };
                    this.charGrid.appendChild(el);
                }
            }
        }
    }
    _toggleChar(char) {
        let val = this.charInput.value;
        if (val.includes(char)) {
            val = val.replace(char, '');
        } else {
            val += char;
        }
        this.charInput.value = val;
        this._updateSetting('customCharacters', val);
    }
    _updateGridSelection() {
        const currentSet = new Set(this.charInput.value.split(''));
        Array.from(this.charGrid.children).forEach(el => {
            if (currentSet.has(el.textContent)) el.classList.add('selected');
            else el.classList.remove('selected');
        });
    }
    _updateSetting(key, value) {
        if (!this.currentFont) return;
        const allSettings = { ...this.config.get('fontSettings') };
        if (!allSettings[this.currentFont]) {
            allSettings[this.currentFont] = {};
        }
        allSettings[this.currentFont][key] = value;
        this.config.set('fontSettings', allSettings);
    }
}
// --- FontManager.js ---
class FontManager {
  constructor(config, notificationMgr) {
    this.config = config;
    this.notifications = notificationMgr;
    // IndexedDB
    this.dbName = 'MatrixFontDB';
    this.storeName = 'fonts';
    this.db = null;
    // Runtime font bookkeeping
    this.loadedFonts = [];     // { name, display, isEmbedded, mimeType?, data? }
    this.subscribers = [];
    this.embeddedFontName = 'MatrixEmbedded';
    // Internal: promises to prevent duplicate loads per face
    this._facePromises = new Map(); // key: fontName -> Promise<void>
    this._defaultCanvasPx = 20;     // used for document.fonts.load exact-size readiness
    this._loadTimeoutMs = 8000;     // defensive timeout for font loads
    // Listen for config resets to re-inject custom font entries
    this.config.subscribe((key) => this._onConfigChange(key));
  }
  _onConfigChange(key) {
    if (key === 'ALL' || key === 'fontSettings') {
        // Re-ensure all loaded fonts exist in the new settings
        this.loadedFonts.forEach(f => {
            this._ensureFontConfig(f.name);
        });
    }
  }
  /** Initialize: inject embedded font (if present) + open DB + load stored fonts. */
  async init() {
    if (typeof DEFAULT_FONT_DATA === 'string' && DEFAULT_FONT_DATA.length > 50) {
      await this.injectEmbeddedFont();
    }
    try {
      await this._openDB();
      await this._loadFontsFromDB();
    } catch (error) {
      console.warn('Font DB Error:', error);
    }
  }
  /** Subscribe to changes in loadedFonts. */
  subscribe(callback) {
    this.subscribers.push(callback);
  }
  /** Notify subscribers. */
  _notify() {
    this.subscribers.forEach(cb => cb(this.loadedFonts));
  }
  /** Ensure config entry exists for a font. */
  _ensureFontConfig(fontName) {
    const settings = { ...this.config.get('fontSettings') };
    if (!settings[fontName]) {
      settings[fontName] = {
        active: false,
        useCustomChars: false,
        customCharacters: ""
      };
      this.config.set('fontSettings', settings);
    }
  }
  /**
   * Inject embedded default Matrix font (data: URI or base64) if not yet loaded.
   * Uses FontFace + document.fonts to ensure readiness.
   */
  async injectEmbeddedFont() {
    const isFontInjected = this.loadedFonts.some(f => f.name === this.embeddedFontName);
    if (isFontInjected) return;
    const ok = await this._registerFontFace({
      name: this.embeddedFontName,
      // DEFAULT_FONT_DATA is expected to be a data: URL (e.g., data:font/woff2;base64,...)
      // If it's raw base64, wrap as data:font/woff2;base64,<data>
      // Otherwise, provide a normal URL to a woff2 file.
      sourceUrl: DEFAULT_FONT_DATA,
      // Hint the format since data URLs donâ€™t carry a MIME header you can inspect easily.
      formatHint: "format('woff2')",
      canvasPx: this._defaultCanvasPx
    });
    if (ok) {
      this.loadedFonts.push({
        name: this.embeddedFontName,
        display: 'The Matrix Custom Code',
        isEmbedded: true
      });
      // Ensure default font is active/configured
      const settings = { ...this.config.get('fontSettings') };
      if (!settings[this.embeddedFontName]) {
        settings[this.embeddedFontName] = {
          active: true,
          useCustomChars: false,
          customCharacters: ""
        };
        this.config.set('fontSettings', settings);
      }
    }
  }
  /**
   * Programmatic font registration using FontFace.
   * Replaces the old <style>@font-face</style> injection.
   *
   * @param {Object} opts
   *  - name: string (family)
   *  - sourceUrl: string (Blob URL, data: URL, or http(s) URL)
   *  - formatHint: string e.g. "format('woff2')" (optional but recommended)
   *  - weight/style/stretch/unicodeRange: CSS descriptors (optional)
   *  - canvasPx: number (exact size youâ€™ll use for canvas metrics readiness)
   *  - preload: boolean (inject <link rel="preload"> if sourceUrl is http(s))
   */
  async _registerFontFace(opts) {
    const {
      name,
      sourceUrl,
      formatHint,
      weight = '400',
      style = 'normal',
      stretch = 'normal',
      unicodeRange,
      canvasPx = this._defaultCanvasPx,
      preload = false
    } = opts;
    // De-dupe: once per family
    if (this._facePromises.has(name)) {
      return this._facePromises.get(name);
    }
    const task = (async () => {
      // (Optional) preload for http(s) sources
      if (preload && /^https?:/.test(sourceUrl)) {
        this._injectPreload(sourceUrl);
      }
      // src string (programmatic FontFace supports url()+format())
      const src = formatHint ? `url("${sourceUrl}") ${formatHint}` : `url("${sourceUrl}")`;
      const descriptors = { weight, style, stretch };
      if (unicodeRange) descriptors.unicodeRange = unicodeRange;
      const face = new FontFace(name, src, descriptors);
      // Defensive timeout so we never hang the animation pipeline.
      const timeout = new Promise((_, rej) =>
        setTimeout(() => rej(new Error(`Font load timeout: ${name}`)), this._loadTimeoutMs)
      );
      // Load the font bytes & parse the face
      await Promise.race([face.load(), timeout]);
      // Register with the document
      document.fonts.add(face);
      // Ensure exact face+size is available for canvas metrics
      await document.fonts.load(`${canvasPx}px "${name}"`);
      await document.fonts.ready;
      return true;
    })().catch(err => {
      console.warn(`[FontManager] Failed to load "${name}"`, err);
      return false;
    });
    this._facePromises.set(name, task);
    return task;
  }
  /** Preload helper to avoid late discovery & double fetch. */
  _injectPreload(href) {
    const existing = document.querySelector(`link[rel="preload"][as="font"][href="${href}"]`);
    if (existing) return;
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'font';
    link.href = href;
    link.type = 'font/woff2';
    link.crossOrigin = 'anonymous'; // critical for font preloads to be reusable from cache
    document.head.appendChild(link);
  }
  /**
   * Legacy wrapper: Keep method name for compatibility.
   * Internally routes to FontFace registration.
   *
   * @param {string} name    - family name
   * @param {string} url     - Blob URL / data URL / http(s)
   * @param {string} format  - e.g., "format('woff2')"
   */
  async _injectCSS(name, url, format) {
    return this._registerFontFace({ name, sourceUrl: url, formatHint: format, canvasPx: this._defaultCanvasPx });
  }
  /** Open/create IndexedDB store. */
  async _openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onupgradeneeded = event => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'name' });
        }
      };
      request.onsuccess = event => {
        this.db = event.target.result;
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /** Load stored fonts: register faces + ensure readiness, then notify. */
  async _loadFontsFromDB() {
    return new Promise(resolve => {
      if (!this.db) return resolve();
      const txn = this.db.transaction(this.storeName, 'readonly');
      const store = txn.objectStore(this.storeName);
      store.getAll().onsuccess = async event => {
        const storedFonts = event.target.result || [];
        // Keep only embedded font in runtime list; reload DB fonts fresh
        this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
        await Promise.all(storedFonts.map(async (font) => {
          this.loadedFonts.push(font);
          this._ensureFontConfig(font.name);
          const type = font.mimeType || (font.data && font.data.type) || 'font/woff2';
          const format = this._getFormatFromType(type);
          const blobUrl = URL.createObjectURL(font.data);
          const ok = await this._registerFontFace({
            name: font.name,
            sourceUrl: blobUrl,
            formatHint: format,
            canvasPx: this._defaultCanvasPx
          });
          // Once registered and ready, we can revoke the blob URL to free memory
          // (the face is now owned by document.fonts).
          try { URL.revokeObjectURL(blobUrl); } catch (_) {}
          if (!ok) {
            console.warn(`Font "${font.name}" failed to register from DB`);
          }
        }));
        this._notify();
        resolve();
      };
    });
  }
  /** Map MIME -> format() hint for @font-face / FontFace src. */
  _getFormatFromType(mimeType = '') {
    const mt = mimeType.toLowerCase();
    if (mt.includes('woff2')) return "format('woff2')";
    if (mt.includes('woff'))  return "format('woff')";
    if (mt.includes('opentype') || mt.includes('otf')) return "format('opentype')";
    return "format('truetype')";
  }
  /**
   * Import a custom font file: hash, persist in DB, register via FontFace, notify.
   * Keeps your existing external behavior but ensures readiness & object URL cleanup.
   */
  importFont(file) {
    const reader = new FileReader();
    reader.onload = async event => {
      const arrayBuffer = event.target.result;
      const blob = new Blob([arrayBuffer], { type: file.type });
      let fontName;
      try {
        const hash = await Utils.computeSHA256(arrayBuffer);
        fontName = `CustomFont_${hash.substring(0, 16)}`;
      } catch (e) {
        console.warn("Hashing failed, falling back to timestamp", e);
        fontName = `CustomFont_${Date.now()}`;
      }
      const record = {
        name: fontName,
        display: file.name,
        data: blob,
        mimeType: file.type
      };
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.put(record).onsuccess = async () => {
        const format = this._getFormatFromType(file.type);
        // Register via FontFace & ensure ready
        const blobUrl = URL.createObjectURL(blob);
        const ok = await this._registerFontFace({
          name: fontName,
          sourceUrl: blobUrl,
          formatHint: format,
          canvasPx: this._defaultCanvasPx
        });
        try { URL.revokeObjectURL(blobUrl); } catch (_) {}
        this.loadedFonts.push(record);
        this._ensureFontConfig(fontName);
        // If desired, auto-activate imported font (kept as comment to preserve your behavior)
        const settings = { ...this.config.get('fontSettings') };
        settings[fontName].active = true;
        this.config.set('fontSettings', settings);
        if (ok) {
          this.config.set('fontFamily', fontName);
          this._notify();
          this.notifications.show(`Imported: ${file.name}`, 'success');
        } else {
          this.notifications.show(`Import failed: ${file.name}`, 'error');
        }
      };
      txn.onerror = () => {
        this.notifications.show('Database Write Failed', 'error');
      };
    };
    reader.readAsArrayBuffer(file);
  }
  /**
   * Delete by font id/name.
   * Note: FontFace entries registered in document.fonts canâ€™t be explicitly â€œremovedâ€,
   * but removing config, style tags (legacy), and revoking Blob URLs (handled above)
   * prevents leaks and stops future use.
   */
  deleteFont(id) {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.delete(id).onsuccess = () => {
        // Remove legacy style tag (if any)
        document.getElementById(`style-${id}`)?.remove();
        this.loadedFonts = this.loadedFonts.filter(font => font.name !== id);
        // Deactivate in config to prevent rendering issues
        const settings = { ...this.config.get('fontSettings') };
        if (settings[id]) {
          settings[id].active = false;
          this.config.set('fontSettings', settings);
        }
        if (this.config.state.fontFamily === id) {
          this.config.set('fontFamily', this.config.defaults.fontFamily);
        }
        this._notify();
        resolve();
      };
    });
  }
  /** Clear DB + keep only embedded runtime fonts. */
  deleteAllFonts() {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.clear().onsuccess = () => {
        // Remove any legacy <style> tags
        this.loadedFonts
          .filter(font => !font.isEmbedded)
          .forEach(font => document.getElementById(`style-${font.name}`)?.remove());
        // Keep only embedded fonts
        this.loadedFonts = this.loadedFonts.filter(font => font.isEmbedded);
        this._notify();
        resolve();
      };
    });
  }
  // ---------- Canvas helpers (optional but handy) ----------
  /**
   * Build a safe canvas font shorthand string for metrics & drawing.
   * @param {string} family
   * @param {number} sizePx
   * @param {string} weight
   * @param {string} style
   * @param {string} fallbackStack
   */
  buildCanvasFont({ family, sizePx = this._defaultCanvasPx, weight = '400', style = 'normal', fallbackStack = 'monospace' } = {}) {
    // e.g. "normal 400 20px 'MatrixEmbedded', monospace"
    return `${style} ${weight} ${sizePx}px '${family}', ${fallbackStack}`;
  }
  /**
   * Ensure a specific family is ready for the given canvas size before drawing.
   * (Useful if you change sizes dynamically.)
   */
  async ensureReadyForCanvasSize(family, sizePx = this._defaultCanvasPx) {
    await document.fonts.load(`${sizePx}px "${family}"`);
       await document.fonts.ready;
  }
}
    // =========================================================================
    // 9.0 UI MANAGER
    // =========================================================================
// --- NotificationManager.js ---
class NotificationManager {
    constructor(config) {
        this.config = config;
        this.container = document.getElementById('toast-container') || this._createContainer();
    }
    /**
     * Creates and initializes the toast container if it doesn't exist.
     * @returns {HTMLElement} The toast container DOM element.
     */
    _createContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.setAttribute('aria-live', 'polite'); // Accessibility: Announce updates to screen readers.
        container.setAttribute('role', 'status'); // Accessibility: Define the type of content the container holds.
        document.body.appendChild(container);
        return container;
    }
    /**
     * Displays a notification with the specified message and type.
     * @param {string} message - The message to display in the notification.
     * @param {string} [type='info'] - The type of the notification ('info', 'success', 'error', etc.).
     * @param {number} [duration=3000] - The duration (in milliseconds) for the notification to be visible.
     */
    show(message, type = 'info', duration = 3000) {
        if (this.config && this.config.state && this.config.state.suppressToasts) return;
        // Create the notification element.
        const toast = this._createToast(message, type);
        // Ensure the container is attached.
        if (!document.body.contains(this.container)) {
            document.body.appendChild(this.container);
        }
        // Add the notification to the container and apply the "visible" class for animation.
        this.container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        // Set timers for hiding and removing the notification.
        this._scheduleToastRemoval(toast, duration);
    }
    /**
     * Creates an individual toast element.
     * @private
     * @param {string} message - The message to display.
     * @param {string} type - The type of the notification.
     * @returns {HTMLElement} The toast DOM element.
     */
    _createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast-msg toast-${type}`;
        toast.textContent = message;
        toast.setAttribute('role', 'alert'); // Accessibility: Specify that this is an alert message.
        return toast;
    }
    /**
     * Schedules the removal of the notification after the specified duration.
     * Handles smooth animation states before removing the DOM element.
     * @private
     * @param {HTMLElement} toast - The toast element to remove.
     * @param {number} duration - How long the toast remains visible.
     */
    _scheduleToastRemoval(toast, duration) {
        setTimeout(() => {
            // Trigger fade-out animation by removing the "visible" class.
            toast.classList.remove('visible');
            // Remove the toast element from the DOM after the animation completes.
            setTimeout(() => toast.remove(), 300); // Matches CSS animation transition time.
        }, duration);
    }
}
    // =========================================================================
    // 2.0 CONFIGURATION MANAGER 
    // =========================================================================
// --- UIManager.js ---
class UIManager {
    constructor(c, effects, fonts, notificationMgr, charSelector) {
        // Core dependencies and state
        this.c = c;
        this.effects = effects; // Renamed from this.eff for clarity, consistency
        this.fonts = fonts;
        this.notifications = notificationMgr;
        this.charSelector = charSelector;
        this.dom = this._initializeDOM();
        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 };
        this.ignoreNextClick = false; // Retain existing logic for drag/click distinction
        this.isKeyBindingActive = false; // Flag to suspend global key inputs
        this.defs = this._generateDefinitions();
        // Event subscriptions
        this.c.subscribe((key, state) => this.refresh(key));
        this.fonts.subscribe(() => this.refresh('fontFamily'));
        // Initialization
        this.init();
    }
    /**
     * Establish initial DOM structure using expected selectors and IDs.
     * @private
     */
    _initializeDOM() {
        return {
            panel: document.getElementById('settingsPanel'),
            toggle: document.getElementById('menuToggle'),
            tabs: document.getElementById('navTabs'),
            content: document.getElementById('contentArea'),
            tooltip: document.getElementById('ui-tooltip') || this._createTooltip(),
            keyTrap: document.getElementById('ui-key-trap') || this._createKeyTrap(),
            track: null, // Initialized later in init
        };
    }
    /**
     * Create invisible input trap for key binding.
     * @private
     */
    _createKeyTrap() {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'ui-key-trap';
        // Ensure element is rendered but invisible/unobtrusive
        input.style.position = 'fixed';
        input.style.top = '0';
        input.style.left = '0';
        input.style.width = '1px';
        input.style.height = '1px';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        input.style.zIndex = '-1';
        input.setAttribute('aria-hidden', 'true');
        document.body.appendChild(input);
        return input;
    }
    /**
     * Create the tooltip element and attach to the DOM.
     * @private
     */
    _createTooltip() {
        const tooltip = document.createElement('div');
        tooltip.id = 'ui-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
    }
    /**
     * Generate all UI component definitions for settings dynamically.
     * This method orchestrates the gathering of definitions from category-specific methods.
     * @private
     */
    _generateDefinitions() {
        return [
            ...this._generateGlobalSettings(),
            // APPEARANCE TAB
            ...this._generateAppearanceSettings(),
            // BEHAVIOR TAB
            ...this._generateBehaviorSettings(),
            // FX TAB
            ...this._generateFXSettings(),
            // SYSTEM TAB
            ...this._generateSystemTab()
        ];
    }
    /**
     * Generates definitions for the 'Global' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateGlobalSettings() {
        return [
            { cat: 'Global', type: 'accordion_header', label: 'Code Basics' },
            { cat: 'Global', id: 'streamPalette', type: 'color_list', label: 'Code Colors', max: 3 },
            { cat: 'Global', id: 'paletteBias', type: 'range', label: 'Color Mix', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'% Mix', description: "Left: Solid Streams. Right: Random Characters. Middle: Blend." },
            { cat: 'Global', id: 'tracerColor', type: 'color', label: 'Tracer Color', description: "The head of the stream that writes the code to the screen" },
            { cat: 'Global', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, step: 1, unit: 'px' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20, step: 1 },
            { cat: 'Global', id: 'showFpsCounter', type: 'checkbox', label: 'Show FPS Counter', description: "Displays the current frames-per-second in the top-left corner." },
            { cat: 'Global', id: 'debugEnabled', type: 'checkbox', label: 'Enable Debug Messages', description: "Enables verbose console logging and additional metrics." },
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing', dep: '!shaderEnabled', description: 'Anti-aliasing is automatically disabled when a custom shader is in use.' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: ['smoothingEnabled', '!shaderEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'Appearance' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateAppearanceSettings() {
        return [
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Customization' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Manage Character Sets', action: 'manageCharacters', class: 'btn-info' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' }, // Main Accordion Header
            { cat: 'Appearance', type: 'accordion_subheader', label: 'General' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Allows for brightness variance when characters are written' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Stream Trails' },
            { cat: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 180, unit:'fr' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolving Stream Trails' }, 
            { cat: 'Appearance', id: 'dissolveScalePercent', type: 'range', label: 'Dissolve Scale', min: -100, max: 100, unit: '%', dep: 'dissolveEnabled', description: 'Percentage size change during dissolve. Negative values shrink, positive values grow.' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Trail Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghosting Offset', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Character Overlap' },
            { cat: 'Appearance', id: 'overlapEnabled', type: 'checkbox', label: 'Enable Overlap' },
            { cat: 'Appearance', id: 'overlapColor', type: 'color', label: 'Overlap Color', dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapDensity', type: 'range', label: 'Overlap Density', min: 0.1, max: 1.0, step: 0.1, dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapTarget', type: 'select', label: 'Overlap Target', options: [{label:'Streams Only',value:'stream'},{label:'All Characters',value:'all'}], dep: 'overlapEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.0, max: 1.0, step: 0.01, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -100, max: 100, unit: 'px' },
            { cat: 'Appearance', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -100, max: 100, unit: 'px' },
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        ];
    }
    /**
     * Generates definitions for the 'Behavior' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateBehaviorSettings() {
        return [
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'releaseInterval', type: 'range', label: 'Event Timer', description: "For synchronized events (like tracer release) this is the interval between events.", min: 1, max: 10, step: 1 },
            { cat: 'Behavior', id: 'desyncIntensity', type: 'range', label: 'Tracer Desync', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', description: "Varies the speed and release timing of tracers. 0% is uniform sync." },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Between Erasers', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minGapTypes', type: 'range', label: 'Min Gap Between Types', min: 1, max: 100, unit: 'px', description: "Minimum space between tracer types, preventing short streams" },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps in Code Stream', min: 0, max: 0.5, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Tracers'},
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1, description: "Maximum number of tracers released per-cycle" },
            { cat: 'Behavior', id: 'tracerStopChance', type: 'range', label: 'Tracer Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for a tracer to randomly stop, leaving a hanging stream.'},
            { cat: 'Behavior', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Erasers'},
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, description: "Invisible tracers that start erasing code" },
            { cat: 'Behavior', id: 'eraserStopChance', type: 'range', label: 'Eraser Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for an eraser to randomly stop, leaving a hanging stream.' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Inverted Tracers'},
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Tracers that only write occassional characters" },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Frequency', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 1.0, step: 0.01, dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: "Lock the rotator change to the cycles that move the tracers" },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotateDuringFade', type: 'checkbox', label: 'Rotate during fade', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncEnabled', type: 'checkbox', label: 'Desynchronize Rotators', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncVariance', type: 'range', label: 'Desync Variance', min: 0, max: 100, unit: '%', dep: ['rotatorEnabled', 'rotatorDesyncEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'FX' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateFXSettings() {
        return [
            { cat: 'Effects', type: 'header', label: 'Movie Effects' }, // Using header for main section
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'Effects', id: 'pulseMovieAccurate', type: 'checkbox', label: 'Movie Accurate', dep: 'pulseEnabled', description: "Enables movie-accurate timing and visuals, disabling custom controls." },
            { cat: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDelaySeconds', type: 'range', label: 'Delay', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Preserve Tracer Glow', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDimming', type: 'range', label: 'Initial Dim Amount', min: 0.0, max: 1.0, step: 0.05, dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Start at a full square" },
            { cat: 'Effects', id: 'pulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_header', label: 'Clear Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Clear Pulse Now', action: 'clearpulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'clearPulseEnabled', type: 'checkbox', label: 'Enable Clear Pulse' },
            { cat: 'Effects', id: 'clearPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'clearPulseEnabled', description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'clearPulseEnabled', description: "Start at a full square" },
            { cat: 'Effects', id: 'clearPulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: 'clearPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse Storm' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Storm Now', action: 'minipulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'Effects', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseThickness', type: 'range', label: 'Wave Width', min: 10, max: 150, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSize', type: 'range', label: 'Blast Size Max', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Deja Vu' },
            { cat: 'Effects', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'Effects', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'Effects', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMinRectHeight', type: 'range', label: 'Minimum Thickness', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Maximum Thickness', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuHoleBrightness', type: 'range', label: 'Intensity', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Enable Color Writing', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuIntensity', type: 'range', label: 'Flash Frequency', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Length', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Length Variance', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Superman' },
            { cat: 'Effects', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'Effects', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman Effects' },
            { cat: 'Effects', id: 'supermanFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanIncludeColors', type: 'checkbox', label: 'Additional Glow', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFadeSpeed', type: 'range', label: 'Fade Duration', min: 5, max: 60, dep: 'supermanEnabled', description: 'Higher values mean trails last longer.' },
            { cat: 'Effects', id: 'supermanGlow', type: 'range', label: 'Voltage Glow', min: 1, max: 10, dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 10, step: 1, dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'Effects', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 10, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'Effects', id: 'supermanSpawnSpeed', type: 'range', label: 'Bolt Speed', min: 10, max: 100, dep: 'supermanEnabled', description: 'Speed from left to right' },
            { cat: 'Effects', type: 'accordion_header', label: 'Boot/Crash' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Boot Sequence' },
            { cat: 'Effects', id: 'bootSequenceEnabled', type: 'checkbox', label: 'Start Code with Boot' },
            { cat: 'Effects', type: 'button', label: 'Trigger Boot Now', action: 'boot', class: 'btn-warn' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Sequence' },
            { cat: 'Effects', id: 'crashEnabled', type: 'checkbox', label: 'Enable Crash', warning: "Photosensitivity Warning: Enabling this effect will cause pulsing lights and strobing effects that could be disruptive to those more sensitive to flashing lights. Please be aware of the impact this may have to those around you." },
            { cat: 'Effects', id: 'crashFrequencySeconds', type: 'range', label: 'Frequency', min: 60, max: 600, step: 10, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashDurationSeconds', type: 'range', label: 'Duration', min: 5, max: 120, step: 5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Visuals', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetCount', type: 'range', label: 'Shadowbox Density', min: 0, max: 200, step: 1, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetSpeed', type: 'range', label: 'Shadowbox Speed', min: 0.1, max: 3.0, step: 0.1, dep: 'crashEnabled', transform: v=>v+'x' },
            { cat: 'Effects', id: 'crashSheetOpacity', type: 'range', label: 'Shadowbox Opacity', min: 0.0, max: 1.0, step: 0.01, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashStationaryChance', type: 'range', label: 'Shadowbox Movement Level', min: 0, max: 100, unit: '%', invert: true, dep: 'crashEnabled', description: "How likely a shadow box is to move when spawned." },
            { cat: 'Effects', id: 'crashFlashDelayMin', type: 'range', label: 'Flash Delay Min', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashFlashDelayMax', type: 'range', label: 'Flash Delay Max', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Features', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableSmith', type: 'checkbox', label: 'Enable Agent Smith', description: "Randomly introduces agent Smith within the crash. Subtle.", dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableSuperman', type: 'checkbox', label: 'Enable Code Bolts', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableFlash', type: 'checkbox', label: 'Enable Flash/Fade', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'button', label: 'Trigger Crash Now', action: 'crash', class: 'btn-danger' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Macros' },
            { cat: 'Effects', id: 'runBothInOrder', type: 'checkbox', label: 'Run Both in Order', description: 'Automatically triggers the Crash sequence after the Boot sequence completes.' },
            { cat: 'Effects', type: 'button', label: 'Trigger Sequence Now', action: 'boot_crash_sequence', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Special Effects' }, // Header for Special Effects
            { cat: 'Effects', type: 'accordion_header', label: 'Star Power' },
            { cat: 'Effects', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'Effects', id: 'starPowerFreq', type: 'range', label: 'Frequency', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerGlitter', type: 'checkbox', label: 'Glitter', dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamChance', type: 'range', label: 'Frequency', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Effects', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Firewall Anomaly' }, 
            { cat: 'Effects', type: 'button', label: 'Trigger Firewall Now', action: 'firewall', class: 'btn-info' },
            { cat: 'Effects', id: 'firewallEnabled', type: 'checkbox', label: 'Enable Firewall Effects' },
            { cat: 'Effects', id: 'firewallFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 300, step: 10, unit: 's', dep: 'firewallEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'firewallEnabled' },
            { cat: 'Effects', id: 'firewallRandomColorEnabled', type: 'checkbox', label: 'Random Color', dep: 'firewallEnabled' },
            { cat: 'Effects', id: 'firewallColor', type: 'color', label: 'Firewall Color', dep: ['firewallEnabled', '!firewallRandomColorEnabled'] },
            { cat: 'Effects', id: 'firewallReverseDurationFrames', type: 'range', label: 'Reverse Duration', min: 5, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the code reverses before erasure.' },
            { cat: 'Effects', id: 'firewallEraseDurationFrames', type: 'range', label: 'Erase Flash Duration', min: 10, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the column flashes white/red before clearing.' },
            { cat: 'Effects', type: 'accordion_header', label: 'Time Manipulation' },
            { cat: 'Effects', type: 'button', label: 'Trigger Reverse Time', action: 'reverse_time', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Post Processing' },
            { cat: 'Effects', type: 'accordion_header', label: 'Shader' },
            { cat: 'Effects', type: 'info_description', id: 'currentShaderNameDisplay', text: 'Loaded: No shader.' },
            { cat: 'Effects', id: 'shaderEnabled', type: 'checkbox', label: 'Enable Custom Shader' },
            { cat: 'Effects', id: 'shaderParameter', type: 'range', label: 'Shader Parameter', min: 0.0, max: 1.0, step: 0.01, dep: 'shaderEnabled', description: "A generic 0.0-1.0 value passed to the shader as 'uParameter'." },
            { cat: 'Effects', type: 'button', label: 'Import Fragment Shader (.glsl)', action: 'importShader', class: 'btn-info', dep: 'shaderEnabled' },
            { cat: 'Effects', type: 'info_description', text: 'Uniforms provided: uTexture (sampler2D), uTime (float), uResolution (vec2), uMouse (vec2), uParameter (float). Output to gl_FragColor.', dep: 'shaderEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'System' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateSystemTab() {
        return [
            { cat: 'System', type: 'accordion_header', label: 'Configuration' },
            { cat: 'System', type: 'slot', idx: 0, id: 'slot_0' },
            { cat: 'System', type: 'slot', idx: 1, id: 'slot_1' },
            { cat: 'System', type: 'slot', idx: 2, id: 'slot_2' },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
            { cat: 'System', id: 'hideMenuIcon', type: 'checkbox', label: 'Hide Settings Icon', description: 'Hover your mouse over the top right or press the Toggle UI Panel keybind to show' },
            { cat: 'System', id: 'suppressToasts', type: 'checkbox', label: 'Suppress Toast Messages', description: 'Disable pop-up notifications at the bottom of the screen.' },
            { cat: 'System', type: 'accordion_header', label: 'Key Bindings' },
            { cat: 'System', type: 'info_description', text: 'Click a button to assign a new key. Press Backspace or Delete to clear.' },
            { cat: 'System', type: 'keybinder', id: 'BootSequence', label: 'Boot Animation' },
            { cat: 'System', type: 'keybinder', id: 'CrashSequence', label: 'Crash Animation' },
            { cat: 'System', type: 'keybinder', id: 'BootCrashSequence', label: 'Boot to Crash' },
            { cat: 'System', type: 'keybinder', id: 'Pulse', label: 'Pulse' },
            { cat: 'System', type: 'keybinder', id: 'ClearPulse', label: 'Clear Pulse' },
            { cat: 'System', type: 'keybinder', id: 'MiniPulse', label: 'Pulse Storm' },
            { cat: 'System', type: 'keybinder', id: 'DejaVu', label: 'Deja Vu' },
            { cat: 'System', type: 'keybinder', id: 'Superman', label: 'Superman' },
            { cat: 'System', type: 'keybinder', id: 'Firewall', label: 'Firewall' },
            { cat: 'System', type: 'keybinder', id: 'ReverseTime', label: 'Reverse Time' },
            { cat: 'System', type: 'keybinder', id: 'ToggleUI', label: 'Toggle UI Panel' },
            { cat: 'System', type: 'accordion_header', label: 'System Reset' },
            { cat: 'System', type: 'info_description', text: 'Clears the current font cache, and resets all font entries to default' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' },
            { cat: 'System', type: 'accordion_subheader', label: 'Frequently Asked Questions' },
            { cat: 'System', type: 'faq_item', question: 'What is this?', answer: 'This is a highly customizable Matrix Digital Rain simulation built with HTML5 Canvas and JavaScript.' },
            { cat: 'System', type: 'faq_item', question: 'How do I change the code?', answer: 'Use the settings panel on the right side of the screen to customize various aspects like colors, speeds, and effects.' },
            { cat: 'System', type: 'faq_item', question: 'Can I use my own font?', answer: 'Yes, go to the "Appearance" tab, under "Character Customization" you can import your own TTF or OTF font file.' },
            { cat: 'System', type: 'faq_item', question: 'Why is it sometimes slow?', answer: 'Performance depends on your device and settings. Try reducing "Resolution Scale" or disabling some effects under the "Effects" tab.' },
            { cat: 'System', type: 'faq_item', question: 'Is this more AI slop?', answer: 'Yes and no. LLM\'s were definitely used to make this, but the person who programmed it is a real person, and much of the code was hand-written, not just \'vibe coded\'. It\'s not perfect, but it\'s being slowly improved.' },
            { cat: 'System', type: 'faq_item', question: 'How do I leave feedback or suggestions on your app?', answer: 'Feel free to reach out via github! I\'m definitely open to ideas and suggestions.' }
        ];
    }
    /**
     * Initialize the events, tabs, and UI components.
     */
    init() {
        // Toggle button for the settings panel
        this.dom.toggle.onclick = () => this.togglePanel();
        // Create and populate tabs and content containers
        this._setupTabs();
        // Update footer version
        document.getElementById('globalStatus').textContent = `Matrix Code v${APP_VERSION}`;
        // Initialize File Input Handlers
        this._setupFileHandlers();
        // Handle tab dragging and horizontal scrolling
        this._setupTabScroll();
        // Refresh UI
        this.refresh('ALL');
    }
    /**
     * Toggles the settings panel visibility.
     */
    togglePanel() {
        const isOpen = this.dom.panel.classList.toggle('open');
        this.dom.panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
        this.dom.toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
    /**
     * Sets up the tabs and their corresponding content containers.
     * Creates category tabs and assigns content containers to each.
     * @private
     */
    _setupTabs() {
        this.dom.track = document.createElement('div'); // Initialize track here
        this.dom.track.id = 'tabTrack';
        this.dom.tabs.appendChild(this.dom.track);
        const categories = [...new Set(this.defs.map(def => def.cat))];
        const tabContentContainers = {}; // Mapping of category -> content container div
        // Create tabs and attach event handlers
        categories.forEach((category, index) => {
            const tabButton = this._createTabButton(category, index === 0);
            this.dom.track.appendChild(tabButton);
            // Create corresponding content container for the tab
            const contentContainer = this._createTabContentContainer(category, index === 0);
            this.dom.content.appendChild(contentContainer);
            tabContentContainers[category] = contentContainer;
        });
        // Populate tab content
        this._populateTabContent(tabContentContainers);
    }
    /**
     * Creates a tab button element for a category.
     * @private
     * @param {string} category - The category name for the tab.
     * @param {boolean} isActive - Whether the tab should be active by default.
     * @returns {HTMLElement} The created tab button element.
     */
    _createTabButton(category, isActive) {
        const button = document.createElement('button');
        button.className = `tab-btn ${isActive ? 'active' : ''}`;
        button.textContent = category;
        button.onclick = () => this._handleTabClick(category, button);
        return button;
    }
    /**
     * Handles when a tab is clicked and activates the corresponding tab content.
     * @private
     * @param {string} category - The category associated with the clicked tab.
     * @param {HTMLElement} button - The clicked tab button element.
     */
    _handleTabClick(category, button) {
        // Use this.scrollState.dragDistance for distinguishing drag from click
        if (this.scrollState.dragDistance > 3) {
            this.scrollState.dragDistance = 0; // Reset for next interaction
            return; 
        }
        // Deactivate all tabs and their content
        this.dom.tabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.dom.content.querySelectorAll('.tab-content-group').forEach(content => content.classList.remove('active'));
        // Activate selected tab and content
        button.classList.add('active');
        document.getElementById(`tab-content-${category}`).classList.add('active');
    }
    /**
     * Creates a tab content container for a given category.
     * @private
     * @param {string} category - The category name for the content container.
     * @param {boolean} isActive - Whether the content container should be active by default.
     * @returns {HTMLElement} The created tab content container element.
     */
    _createTabContentContainer(category, isActive) {
        const container = document.createElement('div');
        container.className = `tab-content-group ${isActive ? 'active' : ''}`;
        container.id = `tab-content-${category}`;
        return container;
    }
    /**
     * Populates tabs with content, including accordions and controls.
     * @private
     * @param {Object} tabContentContainers - A map of category names to their content container elements.
     */
    _populateTabContent(tabContentContainers) {
        let currentAccordionBody = null;
        let lastCat = null;
        this.defs.forEach(def => {
            const container = tabContentContainers[def.cat];
            if (!container) return;
            // Reset accordion context when switching tabs/categories
            if (def.cat !== lastCat) {
                currentAccordionBody = null;
                lastCat = def.cat;
            }
            // Handle Accordion Headers (Start new accordion)
            if (def.type === 'accordion_header') {
                currentAccordionBody = this._createAccordion(container, def.label);
                return;
            } 
            // Handle Accordion Subheaders
            else if (def.type === 'accordion_subheader') {
                if (currentAccordionBody) {
                    const el = this.renderControl(def);
                    if (el) currentAccordionBody.appendChild(el);
                }
                return;
            }
            // Handle Section Headers (Break out of accordion)
            // Exception: CAUTION ZONE remains inside for special handling below
            if (def.type === 'header' && def.label !== 'CAUTION ZONE') {
                currentAccordionBody = null;
                const el = this.renderControl(def);
                if (el) container.appendChild(el);
                return;
            }
            // Handle Controls
            if (currentAccordionBody) {
                // Special handling for CAUTION ZONE inside an accordion
                if (def.cat === 'System' && def.label === 'CAUTION ZONE' && def.type === 'header') {
                    const cautionZoneDiv = document.createElement('div');
                    cautionZoneDiv.className = 'caution-zone';
                    const headerEl = this.renderControl(def);
                    cautionZoneDiv.appendChild(headerEl);
                    currentAccordionBody.appendChild(cautionZoneDiv);
                } else {
                    if (def.caution) return; // Skip caution items here, handled separately
                    const controlElement = this.renderControl(def);
                    if (controlElement) currentAccordionBody.appendChild(controlElement);
                }
            } else {
                // Orphan controls (outside any accordion) - e.g. top level buttons or headers
                const controlElement = this.renderControl(def);
                if (controlElement) container.appendChild(controlElement);
            }
        });
        // Post-process: Insert Factory Reset into the created Caution Zone
        const factoryResetDef = this.defs.find(d => d.action === 'reset' && d.caution);
        if (factoryResetDef) {
            const cautionZoneDiv = this.dom.content.querySelector('.caution-zone');
            if (cautionZoneDiv) {
                const controlElement = this.renderControl(factoryResetDef);
                if (controlElement) cautionZoneDiv.appendChild(controlElement);
            }
        }
    }
    /**
     * Creates an accordion section with a header and a container for controls.
     * @private
     * @param {HTMLElement} tabContentGroup - The parent container for the accordion.
     * @param {string} label - The label for the accordion header.
     * @returns {HTMLElement} The body element of the created accordion where controls can be appended.
     */
    _createAccordion(tabContentGroup, label) {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.innerHTML = `
            ${label}
            <span class="accordion-icon">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </span>
        `;
        const body = document.createElement('div');
        body.className = 'accordion-content';
        header.onclick = () => this._toggleAccordion(header, body, tabContentGroup);
        accordionItem.appendChild(header);
        accordionItem.appendChild(body);
        tabContentGroup.appendChild(accordionItem);
        // Default open logic: REMOVED per user request
        // const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
        // if (accordionsInTab.length === 1) { 
        //     body.classList.add('open');
        //     header.classList.add('active');
        //     header.querySelector('.accordion-icon').classList.add('rotated');
        // }
        return body;
    }
    /**
     * Toggles the visibility of an accordion section and manages sibling accordions.
     * @private
     * @param {HTMLElement} header - The header element of the accordion.
     * @param {HTMLElement} body - The body element of the accordion.
     * @param {HTMLElement} group - The parent group containing all accordions (tabContentGroup).
     */
    _toggleAccordion(header, body, group) {
        const isOpen = body.classList.contains('open');
        // Close other accordions in the group
        group.querySelectorAll('.accordion-content').forEach(siblingBody => {
            siblingBody.classList.remove('open');
            siblingBody.previousElementSibling?.classList.remove('active');
            siblingBody.previousElementSibling?.querySelector('.accordion-icon')?.classList.remove('rotated');
        });
        // Toggle the current accordion
        if (isOpen) {
            body.classList.remove('open');
            header.classList.remove('active');
            header.querySelector('.accordion-icon')?.classList.remove('rotated');
        } else {
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon')?.classList.add('rotated');
        }
    }
    /**
     * Setup input handlers for font and config import.
     * @private
     */
    _setupFileHandlers() {
        document.getElementById('importFile').onchange = e => this._handleConfigImport(e);
        document.getElementById('importFontFile').onchange = e => this._handleFontImport(e);
        // Add shader input
        const shaderInput = document.createElement('input');
        shaderInput.type = 'file';
        shaderInput.id = 'importShaderFile';
        shaderInput.accept = '.glsl,.frag,.txt';
        shaderInput.style.display = 'none';
        document.body.appendChild(shaderInput);
        shaderInput.onchange = e => this._handleShaderImport(e);
    }
    /**
     * Handles the import of a shader file.
     * @private
     */
    _handleShaderImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const source = ev.target.result;
            this.c.set('customShader', source);
            this.notifications.show('Shader Imported', 'success');
            event.target.value = '';
        };
        reader.readAsText(file);
    }
    /**
     * Updates the slot name inputs from the current configuration.
     */
    updateSlotNames() {
        if (this.c.slots) {
            this.c.slots.forEach((slot, i) => {
                const slotInput = document.getElementById(`slot-input-${i}`);
                if (slotInput) {
                    slotInput.value = slot.name;
                }
            });
        }
    }
    /**
     * Handles the import of a JSON configuration file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleConfigImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                // Merge loaded config with defaults to ensure all properties exist
                this.c.state = { ...this.c.defaults, ...data.state };
                // Handle Saved Presets
                if (data.savedPresets) {
                    this.c.slots = data.savedPresets;
                    this.c.saveSlots();
                    this.updateSlotNames(); // Force update immediately
                }
                this.c.updateDerivedValues();
                this.c.save();
                this.c.notify('ALL');
                this.notifications.show('Configuration Loaded', 'success');
            } catch (error) {
                console.error("Error loading config:", error);
                this.notifications.show('Invalid Configuration File', 'error');
            }
            event.target.value = ''; // Reset input value to allow re-importing the same file
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a custom font file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleFontImport(event) {
        const file = event.target.files[0];
        if (file) this.fonts.importFont(file);
        event.target.value = ''; // Reset input value
    }
    /**
     * Set up drag and scroll functionality for tabs.
     * @private
     */
    _setupTabScroll() {
        const tabs = this.dom.tabs;
        tabs.addEventListener('mousedown', e => this._startDrag(e));
        tabs.addEventListener('mouseleave', () => this._stopDrag());
        tabs.addEventListener('mouseup', () => this._stopDrag());
        tabs.addEventListener('mousemove', e => this._doDrag(e));
        // Ensure overflow handling matches standard behavior for wheel support
        tabs.style.overflowX = 'auto'; 
        tabs.style.overscrollBehaviorX = 'contain';
        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
        tabs.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaX) >= Math.abs(e.deltaY)) {
                return;
            }
            if (e.deltaY !== 0) {
                // preventDefault stops the browser "back" gesture or vertical page scroll
                e.preventDefault(); 
                tabs.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }
    /**
     * Initiates the drag operation for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse down event.
     */
    _startDrag(e) {
        if (e.button !== 0) return; // Only respond to primary click (left mouse button)
        this.scrollState.isDown = true;
        this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft;
        this.scrollState.scrollLeft = this.dom.tabs.scrollLeft;
        this.scrollState.dragDistance = 0;
        this.ignoreNextClick = false; // Reset flag
        this.dom.tabs.style.cursor = 'grabbing';
    }
    /**
     * Stops the drag operation for tab scrolling.
     * @private
     */
    _stopDrag() {
        this.scrollState.isDown = false;
        this.dom.tabs.style.cursor = 'grab';
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Handles the drag movement for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse move event.
     */
    _doDrag(e) {
        if (!this.scrollState.isDown) return;
        e.preventDefault(); // Prevent text highlighting during drag
        const x = e.pageX - this.dom.tabs.offsetLeft;
        const walk = (x - this.scrollState.startX) * 1.5; // Multiplier for faster scrolling
        this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk;
        this.scrollState.dragDistance = Math.abs(x - this.scrollState.startX); // Update based on actual movement
        if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; // Set flag if dragged enough to be considered a drag
    }
    /**
     * Retrieves the list of available fonts, including embedded and custom fonts.
     * @private
     * @returns {Array<Object>} An array of font objects suitable for select options.
     */
    _getFonts() {
        return [
            ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true}))
        ];
    }
    /**
     * Updates the UI list of custom fonts (used in the font manager section).
     * @param {HTMLElement} el - The DOM element to populate with the font list.
     */
    updateFontList(el) {
        el.innerHTML = '';
        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
            const div = document.createElement('div');
            div.className = 'font-item';
            div.innerHTML = `<span class="font-name">${f.display}</span>`;
            const btn = document.createElement('div');
            btn.className = 'font-delete-btn';
            btn.innerHTML = 'Ã—';
            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
            div.appendChild(btn);
            el.appendChild(div);
        });
    }
    /**
     * Displays a tooltip with a given text near a target element.
     * @param {string} text - The text to display in the tooltip.
     * @param {HTMLElement} target - The element relative to which the tooltip should be positioned.
     */
    showTooltip(text, target) {
        this.dom.tooltip.textContent = text;
        this.dom.tooltip.classList.add('visible');
        const rect = target.getBoundingClientRect();
        const tipRect = this.dom.tooltip.getBoundingClientRect();
        let top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        let left = rect.left - tipRect.width - 12; // Default to left of target
        // Adjust position if it goes off-screen
        if (top < 10) top = 10;
        if (left < 10) left = rect.right + 12; // Move to right if it's too far left
        this.dom.tooltip.style.top = `${top}px`;
        this.dom.tooltip.style.left = `${left}px`;
    }
    /**
     * Hides the currently displayed tooltip.
     */
    hideTooltip() {
        this.dom.tooltip.classList.remove('visible');
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Updates the text/state of a specific keybinder button.
     * @param {string} id - The ID of the keybinding action (e.g., 'Pulse').
     */
    updateKeyBinderVisuals(id) {
        const btn = document.getElementById(`btn-key-${id}`);
        if (!btn) return;
        const def = this.defs.find(d => d.id === id);
        if (!def) return;
        const bindings = this.c.get('keyBindings') || {};
        const rawKey = bindings[id] || 'None';
        const displayKey = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
        btn.textContent = `${def.label}: [ ${displayKey} ]`;
        btn.className = 'action-btn btn-info'; // Reset class
    }
    /**
     * Creates a styled label group for a UI control, optionally including an info icon with a tooltip.
     * @param {Object} def - The definition object for the UI control.
     * @returns {HTMLElement} The created label group DOM element.
     */
    createLabelGroup(def) {
        const group = document.createElement('div');
        group.className = 'control-label-group';
        const text = document.createElement('span');
        text.textContent = def.label;
        group.appendChild(text);
        if (def.description) {
            const icon = document.createElement('span');
            icon.className = 'info-icon';
            icon.textContent = '?';
            const show = (e) => this.showTooltip(def.description, e.target);
            icon.onmouseenter = show;
            icon.onmouseleave = () => this.hideTooltip();
            // Handle touch events for mobile tooltips
            icon.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                if (this.dom.tooltip.classList.contains('visible')) { 
                    this.hideTooltip(); 
                } else { 
                    show(e); 
                    // Automatically hide tooltip after a short delay on touch devices
                    setTimeout(() => this.hideTooltip(), 3000); 
                } 
            });
            group.appendChild(icon);
        }
        return group;
    }
    /**
     * Renders the content of a color list control into the provided wrapper.
     * @private
     * @param {HTMLElement} wrapper - The container element.
     * @param {Object} def - The control definition.
     */
    _renderColorList(wrapper, def) {
        wrapper.innerHTML = '';
        const palette = this.c.get(def.id) || ["#00FF00"];
        palette.forEach((color, idx) => {
            const item = document.createElement('div');
            item.className = 'color-list-item';
            const cInput = document.createElement('input');
            cInput.type = 'color';
            cInput.value = color;
            // Optimisation: Update state directly on input to allow dragging without re-render
            cInput.oninput = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.state[def.id] = newP; // Direct state mutation
                this.c.updateDerivedValues(); // Force derived update for live preview
            };
            // Commit change on release
            cInput.onchange = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.set(def.id, newP); // Triggers save and refresh
            };
            item.appendChild(cInput);
            if (palette.length > 1 && idx > 0) {
                const delBtn = document.createElement('div');
                delBtn.className = 'btn-icon-remove';
                delBtn.textContent = 'Ã—';
                delBtn.onclick = () => {
                    const newP = this.c.get(def.id).filter((_, i) => i !== idx);
                    this.c.set(def.id, newP);
                    this._renderColorList(wrapper, def);
                    this.refresh('streamPalette');
                };
                item.appendChild(delBtn);
            }
            wrapper.appendChild(item);
        });
        if (palette.length < (def.max || 3)) {
            const addBtn = document.createElement('div');
            addBtn.className = 'btn-icon-add';
            addBtn.textContent = '+';
            addBtn.onclick = () => {
                const newP = [...this.c.get(def.id), "#ffffff"];
                this.c.set(def.id, newP);
                this._renderColorList(wrapper, def);
                this.refresh('streamPalette');
            };
            wrapper.appendChild(addBtn);
        }
    }
    /**
     * Dynamically renders a UI control element based on its definition.
     * @param {Object} def - The definition object for the control.
     * @returns {HTMLElement|null} The created control element, or null if it's an accordion header.
     */
    renderControl(def) {
        if (def.type === 'accordion_header') { return null; }
        if (def.type === 'accordion_subheader') {
            const el = document.createElement('div');
            el.className = 'accordion-subheader';
            el.textContent = def.label;
            if(def.dep) el.setAttribute('data-dep', JSON.stringify(def.dep));
            return el;
        }
        if (def.type === 'header') {
            const el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; return el;
        }
        if (def.type === 'about_content') {
            const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
            const logoChar = Utils.getRandomKatakanaChar();
            const initialColor = this.c.get('streamColor');
            const initialSvgDataUrl = Utils.generateGlyphSVG(logoChar, initialColor, 48, this.c.get('fontFamily'));
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <img id="matrixLogo" src="${initialSvgDataUrl}" alt="Matrix Logo" style="height: 48px; width: 48px; margin-right: 10px;"/>
                    <h3 style="margin:0; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                </div>
                <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
            return div;
        }
        if (def.type === 'info_description') {
            const div = document.createElement('div');
            div.className = 'info-description';
            div.textContent = def.text;
            if (def.id) div.id = `in-${def.id}`;
            return div;
        }
        if (def.type === 'faq_item') {
            const container = document.createElement('div');
            container.className = 'faq-item';
            const question = document.createElement('div');
            question.className = 'faq-question';
            question.textContent = def.question;
            const answer = document.createElement('div');
            answer.className = 'faq-answer';
            answer.textContent = def.answer;
            container.appendChild(question);
            container.appendChild(answer);
            return container;
        }
        const row = document.createElement('div');
        if (def.type === 'button') {
            const btn = document.createElement('button'); btn.className = `action-btn ${def.class||'btn-info'}`; btn.textContent = def.label; btn.id = `btn-${def.action}`; btn.name = def.action; btn.onclick = () => this.handleAction(def.action); row.appendChild(btn);
        } else if (def.type === 'slot') {
            row.className = 'slot-container';
            const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[def.idx].name; inp.id = `slot-input-${def.idx}`; inp.name = `slot_name_${def.idx}`; inp.onchange = e => this.c.renameSlot(def.idx, e.target.value);
            inp.onfocus = e => e.target.value = '';
            const grp = document.createElement('div'); grp.className = 'slot-btn-group';
            const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${def.idx}`; save.onclick = () => { this.c.saveToSlot(def.idx); this.notifications.show(`Saved Slot ${def.idx+1}`, 'success'); };
            const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${def.idx}`; load.onclick = () => { if(this.c.loadFromSlot(def.idx)) this.notifications.show(`Loaded Slot ${def.idx+1}`, 'success'); };
            grp.append(save, load); row.append(inp, grp);
        } else if (def.type === 'font_list') {
            row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
        } else {
            row.className = def.type === 'checkbox' ? 'checkbox-row' : 'control-row';
            const labelGroup = this.createLabelGroup(def);
            if(def.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
            if(!def.hideValue && def.type === 'range') { const valDisp = document.createElement('span'); valDisp.id = `val-${def.id}`; hdr.appendChild(valDisp); } row.appendChild(hdr); } 
                else { row.appendChild(labelGroup); }
            let inp;
            if(def.type === 'range') { 
                inp = document.createElement('input'); 
                inp.type = 'range'; 
                inp.min=def.min; 
                inp.max=def.max; 
                if(def.step) inp.step=def.step; 
                let isTouching = false;
                inp.value = def.invert ? (def.max+def.min)-this.c.get(def.id) : this.c.get(def.id);                            
                inp.oninput = e => { 
                    if (isTouching) return; // Block native updates during touch interaction
                    const v = parseFloat(e.target.value); 
                    let actual = def.invert ? (def.max+def.min)-v : v; 
                    // Dynamic precision based on step
                    const step = def.step || 1;
                    const decimals = (step.toString().split('.')[1] || '').length;
                    if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                    this.c.set(def.id, actual); 
                    const disp = document.getElementById(`val-${def.id}`); 
                    if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                }; 
                let startX = 0;
                let startY = 0;
                let startValue = 0;
                let isHorizontalDrag = false;
                inp.addEventListener('touchstart', e => {
                    isTouching = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(e.target.value);
                    isHorizontalDrag = false;
                    // Prevent "jump to tap" visually
                    requestAnimationFrame(() => {
                        inp.value = startValue;
                    });
                }, { passive: false });
                inp.addEventListener('touchmove', e => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    const dx = x - startX;
                    const dy = y - startY;
                    if (!isHorizontalDrag && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 5) {
                        isHorizontalDrag = true;
                    }
                    if (isHorizontalDrag) {
                        e.preventDefault(); 
                        const rect = inp.getBoundingClientRect();
                        const relativeX = Math.min(Math.max(0, x - rect.left), rect.width);
                        const percent = relativeX / rect.width;
                        const min = parseFloat(def.min);
                        const max = parseFloat(def.max);
                        let newVal = min + (percent * (max - min));
                        // Dynamic precision based on step
                        const step = parseFloat(def.step || 1);
                        newVal = Math.round(newVal / step) * step;
                        if (newVal < min) newVal = min;
                        if (newVal > max) newVal = max;
                        inp.value = newVal;
                        let actual = def.invert ? (max+min)-newVal : newVal; 
                        const decimals = (step.toString().split('.')[1] || '').length;
                        if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                        this.c.set(def.id, actual); 
                        const disp = document.getElementById(`val-${def.id}`); 
                        if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                    }
                }, { passive: false });
                inp.addEventListener('touchend', () => {
                    isTouching = false;
                    isHorizontalDrag = false;
                });
            }
            else if(def.type === 'color') { 
                const w = document.createElement('div'); 
                w.className = 'color-wrapper'; 
                inp = document.createElement('input'); 
                inp.type = 'color'; 
                inp.value = this.c.get(def.id); 
                inp.id = `in-${def.id}`; 
                inp.name = def.id; 
                inp.oninput = e => { 
                    this.c.state[def.id] = e.target.value; 
                    this.c.updateDerivedValues(); // Force derived update for live preview
                }; 
                inp.onchange = e => { this.c.set(def.id, e.target.value); }; // Commit and refresh
                w.appendChild(inp); row.appendChild(w); 
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`; 
                return row; 
            }
            else if(def.type === 'color_list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'color-list-wrapper';
                wrapper.id = `in-${def.id}`;
                this._renderColorList(wrapper, def);
                row.appendChild(wrapper);
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`;
                return row;
            }
            else if(def.type === 'keybinder') {
                const btn = document.createElement('button');
                // Initial text setup
                const rawKey = (this.c.get('keyBindings') || {})[def.id] || 'None';
                const initialDisplay = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
                btn.className = 'action-btn btn-info';
                btn.id = `btn-key-${def.id}`;
                btn.textContent = `${def.label}: [ ${initialDisplay} ]`;
                btn.onclick = () => {
                    this.isKeyBindingActive = true; 
                    btn.textContent = `${def.label}: [ Press Key... ]`;
                    btn.classList.remove('btn-info');
                    btn.classList.add('btn-warn');
                    // Focus trap to isolate input from global listeners
                    this.dom.keyTrap.focus();
                    const handler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        let newKey = e.key;
                        // Handle special keys
                        if (newKey === 'Backspace' || newKey === 'Delete') {
                            newKey = null;
                        } else if (newKey.length === 1) {
                            newKey = newKey.toLowerCase();
                        }
                        // Save config
                        try {
                            const bindings = { ...this.c.get('keyBindings') };
                            if (newKey) {
                                bindings[def.id] = newKey;
                            } else {
                                delete bindings[def.id];
                            }
                            this.c.set('keyBindings', bindings); // Triggers refresh() -> updateKeyBinderVisuals()
                        } catch (err) {
                            console.error("Failed to save keybinding:", err);
                            btn.textContent = "Error Saving";
                        }
                        // Cleanup
                        this.dom.keyTrap.blur();
                        this.isKeyBindingActive = false;
                        // Force immediate visual update just in case refresh is delayed
                        this.updateKeyBinderVisuals(def.id);
                    };
                    this.dom.keyTrap.addEventListener('keydown', handler, { once: true });
                };
                row.appendChild(btn);
                return row;
            }
            else if(def.type === 'checkbox') { 
                inp = document.createElement('input'); 
                inp.type = 'checkbox'; 
                inp.checked = this.c.get(def.id); 
                inp.onchange = e => { 
                    if(e.target.checked && def.warning) alert(def.warning);
                    this.c.set(def.id, e.target.checked); 
                }; 
                row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; 
            }
            else if(def.type === 'select') { inp = document.createElement('select'); (typeof def.options === 'function' ? def.options() : def.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(def.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(def.id, e.target.value); }
            row.appendChild(inp);
            if(def.id) { inp.id = `in-${def.id}`; inp.name = def.id; }
            if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`;
        }
        return row;
    }
    /**
     * Handles UI actions triggered by buttons or other interactive elements.
     * @param {string} action - The action identifier.
     */
    handleAction(action) {
        if(action === 'reset' && confirm('Reset all settings?')) this.c.reset();
        if(action === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts().then(() => this.notifications.show('Cache Cleared', 'success'));
        if(action === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state, savedPresets:this.c.slots}, `matrix_conf_v${APP_VERSION}.json`);
        if(action === 'import') document.getElementById('importFile').click();
        if(action === 'importFont') document.getElementById('importFontFile').click();
        if(action === 'importShader') document.getElementById('importShaderFile').click();
        if(action === 'manageCharacters') this.charSelector.show();
        if(action === 'boot') { if(this.effects.trigger('BootSequence')) this.notifications.show('Boot Sequence Initiated', 'success'); else this.notifications.show('Boot Sequence Active...', 'info'); }
        if(action === 'crash') { if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger'); else this.notifications.show('Crash Sequence Active...', 'info'); }
        if(action === 'boot_crash_sequence') {
            if(this.effects.trigger('BootSequence')) {
                this.notifications.show('Boot Sequence Initiated', 'success');
                setTimeout(() => {
                    if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger');
                }, 4000);
            } else {
                this.notifications.show('Sequence Active...', 'info');
            }
        }
        if(action === 'pulse') { if(this.effects.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
        if(action === 'clearpulse') { if(this.effects.trigger('ClearPulse')) this.notifications.show('Clear Pulse Triggered', 'success'); else this.notifications.show('Clear Pulse active...', 'info'); }
        if(action === 'minipulse') { if(this.effects.trigger('MiniPulse')) this.notifications.show('Pulse Storm Triggered', 'success'); else this.notifications.show('Pulse Storm active...', 'info'); }
        if(action === 'dejavu') { if(this.effects.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
        if(action === 'superman') { if(this.effects.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
        if(action === 'firewall') { if(this.effects.trigger('Firewall')) this.notifications.show('Firewall Breach Detected', 'danger'); else this.notifications.show('Firewall active...', 'info'); }
        if(action === 'reverse_time') { if(this.effects.trigger('ReverseEffect')) this.notifications.show('Time Reversal Initiated', 'success'); else this.notifications.show('Temporal anomaly detected...', 'info'); }
    }
    /**
     * Refreshes the UI to reflect current configuration settings.
     * @param {string} key - The specific configuration key to refresh, or 'ALL' to refresh all controls.
     */
    refresh(key) {
        try {
            if(key === 'ALL') { 
                this.defs.forEach(d => { if(d.id) this.refresh(d.id); }); 
                // Refresh Slot Names
                this.updateSlotNames();
                this.refresh('fontFamily'); // Special refresh for font list
                this.dom.content.querySelectorAll('.accordion-content').forEach(accordionBody => {
                    const allDepRows = accordionBody.querySelectorAll('[data-dep]');
                    allDepRows.forEach(row => {
                        try {
                            const depRule = JSON.parse(row.getAttribute('data-dep')); 
                            const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                            let conditionsMet = true;
                            for (let rule of rules) { 
                                let target = rule; 
                                let expected = true; 
                                if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                                const actual = !!this.c.get(target); 
                                if (actual !== expected) { conditionsMet = false; break; } 
                            }
                            if(conditionsMet) row.classList.remove('control-disabled'); 
                            else row.classList.add('control-disabled');
                        } catch(e) { console.warn("Error processing dependency row:", e); }
                    });
                });
                return; 
            }
            if (key === 'keyBindings') {
                this.defs.filter(d => d.type === 'keybinder').forEach(d => this.refresh(d.id));
                return;
            }
                        if (key === 'fontFamily' || key === 'fontSettings') { // Now also refreshes on fontSettings changes
                            const sel = document.getElementById('in-fontFamily');
                            if(sel) { 
                                sel.innerHTML = ''; 
                                this._getFonts().forEach(o => { 
                                    const opt = document.createElement('option'); 
                                    opt.value = o.value; 
                                    opt.textContent = o.label; 
                                    if(o.custom) opt.className = 'custom-font-opt'; 
                                    if(this.c.get('fontFamily') === o.value) opt.selected = true; 
                                    sel.appendChild(opt); 
                                }); 
                            }
                            const list = document.getElementById('fontListUI'); 
                            if (list) this.updateFontList(list); 
                            // Update logo and favicon when font family or settings change, re-randomize char
                            const currentPrimaryColor = this.c.get('streamPalette')[0]; // Use primary palette color
                            const logo = document.getElementById('matrixLogo');
                            if (logo) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                logo.src = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 48, this.c.get('fontFamily'));
                            }
                            const favicon = document.getElementById('favicon');
                            if (favicon) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                favicon.href = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                            }
                            return;
                        }
                        // Removed the separate `if (key === 'streamColor')` block as its functionality
                        // is now handled by the 'streamPalette' block, and this 'fontFamily'/'fontSettings' block.
                        // ... the rest of the refresh method ...
                        if (key === 'customShader' || key === 'shaderEnabled' || key === 'ALL') {
                            const shaderNameDisplay = document.getElementById('in-currentShaderNameDisplay');
                if (shaderNameDisplay) {
                    let name = 'No shader loaded.';
                    const customShaderSource = this.c.get('customShader');
                    const shaderEnabled = this.c.get('shaderEnabled');
                    if (shaderEnabled && customShaderSource) {
                        // 1. Try to find a name metadata tag in the first 500 chars
                        // Matches "// Name: My Shader" or "// Shader: My Shader" case-insensitive
                        const nameMatch = customShaderSource.substring(0, 500).match(/^\s*\/\/\s*(?:Name|Shader|Title):\s*(.+)$/im);
                        if (nameMatch && nameMatch[1]) {
                            name = nameMatch[1].trim();
                        } 
                        // 2. Fallback: Check if it's standard code
                        else if (customShaderSource.trim().startsWith('precision')) {
                            name = 'Custom Shader (No Name)';
                        }
                        // 3. Fallback: If it doesn't look like code (maybe it really is a path?)
                        else if (customShaderSource.length < 200 && (customShaderSource.includes('/') || customShaderSource.includes('\\'))) {
                             const parts = customShaderSource.split(/[\/\\]/);
                             name = parts[parts.length - 1];
                        }
                        else {
                             name = 'Custom Shader';
                        }
                    } else if (shaderEnabled) {
                         name = 'Unnamed/Default Shader'; 
                    }
                    shaderNameDisplay.textContent = `Loaded: ${name}`;
                }
            }
            if (key === 'streamPalette') {
                 const palette = this.c.get('streamPalette');
                 const biasRow = document.getElementById('row-paletteBias');
                 if (biasRow) {
                     if (palette && palette.length > 1) {
                         biasRow.classList.remove('control-disabled');
                     } else {
                         biasRow.classList.add('control-disabled');
                     }
                 }
                 // Update UI Elements based on primary color
                 if (palette && palette.length > 0) {
                     const color = palette[0];
                     // Update Settings Wheel
                     const toggle = this.dom.toggle;
                     if (toggle) {
                         toggle.style.setProperty('--accent', color);
                         toggle.style.borderColor = color;
                         // toggle.style.color = color; // Removed to allow CSS hover override
                         toggle.style.boxShadow = `0 0 5px ${color}40`; // Subtle glow using hex alpha
                     }
                     // Update Logo & Favicon
                     const logo = document.getElementById('matrixLogo');
                     if (logo) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        logo.src = Utils.generateGlyphSVG(randomChar, color, 48, this.c.get('fontFamily'));
                     }
                     const favicon = document.getElementById('favicon');
                     if (favicon) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        favicon.href = Utils.generateGlyphSVG(randomChar, color, 32, this.c.get('fontFamily'));
                     }
                 }
            }
            if (key === 'hideMenuIcon' || key === 'ALL') {
                const shouldHide = this.c.get('hideMenuIcon');
                const toggleBtn = this.dom.toggle;
                // Clear any existing listeners/timeouts
                if (this._menuIconTimeout) clearTimeout(this._menuIconTimeout);
                if (this._menuMouseMoveHandler) {
                    document.removeEventListener('mousemove', this._menuMouseMoveHandler);
                    this._menuMouseMoveHandler = null;
                }
                if (shouldHide) {
                    toggleBtn.style.transition = 'opacity 0.5s ease-in-out, transform 0.3s ease';
                    const showIcon = () => {
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.pointerEvents = 'auto';
                        clearTimeout(this._menuIconTimeout);
                        // Hide again after 1s of no activity near it? 
                        // Or just 1s after showing? The prompt says "hide itself after one second".
                        this._menuIconTimeout = setTimeout(() => {
                            // Only hide if panel is CLOSED
                            if (!this.dom.panel.classList.contains('open')) {
                                toggleBtn.style.opacity = '0';
                                toggleBtn.style.pointerEvents = 'none';
                            }
                        }, 1000);
                    };
                    // Initial hide after delay
                    showIcon(); 
                    // Hot-zone detection
                    this._menuMouseMoveHandler = (e) => {
                        // Top right corner hot-zone (100x100px)
                        const isHotZone = (e.clientX > window.innerWidth - 100) && (e.clientY < 100);
                        if (isHotZone || this.dom.panel.classList.contains('open')) {
                            showIcon();
                        }
                    };
                    document.addEventListener('mousemove', this._menuMouseMoveHandler);
                } else {
                    // Reset to always visible
                    toggleBtn.style.opacity = '1';
                    toggleBtn.style.pointerEvents = 'auto';
                }
            }
            if(key) {
                // Keybinder Refresh Logic
                if (document.getElementById(`btn-key-${key}`)) {
                    this.updateKeyBinderVisuals(key);
                }
                const inp = document.getElementById(`in-${key}`);
                if(inp) { 
                    const def = this.defs.find(d=>d.id===key); 
                    if(def) { 
                        const val = this.c.get(key); 
                        if(def.type === 'checkbox') inp.checked = val; 
                        else if(def.type === 'color_list') this._renderColorList(inp, def);
                        else if(def.type === 'range') { 
                            inp.value = def.invert ? (def.max+def.min)-val : val; 
                            const disp = document.getElementById(`val-${key}`); 
                            if(disp) {
                                let displayVal = val;
                                if (!def.transform && typeof val === 'number') {
                                    const step = def.step || 1;
                                    const decimals = (step.toString().split('.')[1] || '').length;
                                    displayVal = parseFloat(val.toFixed(decimals));
                                }
                                disp.textContent = def.transform ? def.transform(val) : displayVal + (def.unit || ''); 
                            }
                        } else {
                            inp.value = val;
                        }
                    } 
                }
            }
            // Update dependents
            this.dom.content.querySelectorAll(`[data-dep*="${key}"]`).forEach(row => {
                try {
                    const depRule = JSON.parse(row.getAttribute('data-dep')); 
                    const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                    let conditionsMet = true;
                    for (let rule of rules) { 
                        let target = rule; 
                        let expected = true; 
                        if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                        const actual = !!this.c.get(target); 
                        if (actual !== expected) { conditionsMet = false; break; } 
                    }
                    if(conditionsMet) row.classList.remove('control-disabled'); 
                    else row.classList.add('control-disabled');
                } catch(e) { console.warn("Error processing dependency row:", e); }
            });
        } catch(e) { console.warn("UI Refresh Error:", e); }
    }
}
    // =========================================================================
    // 10.0 MATRIX KERNEL
    // =========================================================================
// --- MatrixKernel.js ---
class MatrixKernel {
    constructor() {
        // Initialize core components
        this._initializeManagers();
        this._initializeEffects();
        // Frame handling and rendering variables
        this.frame = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.timestep = 1000 / 60;
        this._effectTimers = {}; // Initialize map for effect timers
        this._supermanTimer = 0; // Initialize Superman effect timer (will be managed in _effectTimers)
        this._setupResizeListener();
        this._setupInputListener();
        // FPS tracking variables
        this.lastFrameTime = 0; // Tracks time of the previous frame
        this.fpsHistory = []; // Used for simple FPS smoothing
        this.fpsDisplayElement = null; // Holds reference to the HTML element
        // Configuration subscription for dynamic updates
        this._setupConfigSubscriptions();
    }
    async initAsync() {
        // Asynchronous initialization steps
        await this._initializeRendererAndUI();
        // Perform the initial resize setup and start the loop
        this._resize();
        requestAnimationFrame((time) => this._loop(time));
        this.fpsDisplayElement = document.getElementById('fps-counter');
        // Trigger Boot Sequence on startup if enabled
        if (this.config.get('bootSequenceEnabled')) {
            // Short delay to ensure everything is ready
            setTimeout(() => {
                this.effectRegistry.trigger('BootSequence');
            }, 100);
        }
    }
    /**
     * Initializes core managers (Notification, Config, Grid, Simulation, EffectRegistry).
     * @private
     */
    _initializeManagers() {
        this.config = new ConfigurationManager();
        this.notifications = new NotificationManager(this.config);
        this.grid = new CellGrid(this.config);
        this.simulation = new SimulationSystem(this.grid, this.config);
        this.effectRegistry = new EffectRegistry(this.grid, this.config);
    }
    /**
     * Registers all active visual effects with the EffectRegistry.
     * @private
     */
    _initializeEffects() {
        const effects = [
            PulseEffect,
            ClearPulseEffect,
            MiniPulseEffect,
            DejaVuEffect,
            SupermanEffect,
            FirewallEffect,
            ReverseEffect,
            BootEffect,
            CrashEffect
        ];
        effects.forEach((EffectClass) => {
            if (EffectClass === CrashEffect || EffectClass === BootEffect || EffectClass === ReverseEffect) {
                this.effectRegistry.register(new EffectClass(this.grid, this.config, this.effectRegistry));
            } else {
                this.effectRegistry.register(new EffectClass(this.grid, this.config));
            }
        });
    }
    /**
     * Initializes the CanvasRenderer, FontManager, and UIManager.
     * @private
     */
    async _initializeRendererAndUI() {
        if (typeof WebGLRenderer !== 'undefined') {
             this.renderer = new WebGLRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
        } else {
             console.error("WebGLRenderer not found. Application cannot start.");
             this.notifications.show("Critical Error: WebGL Renderer missing.", "error");
             return;
        }
        this.fontMgr = new FontManager(this.config, this.notifications);
        this.charSelector = new CharacterSelectorModal(this.config, this.fontMgr, this.notifications);
        this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications, this.charSelector);
        // Subscribe to font changes to invalidate rendering caches
        this.fontMgr.subscribe(() => {
            if (this.renderer) {
                this.renderer.handleFontChange();
            }
        });
        // Initialize font manager and await its completion
        await this.fontMgr.init();
        // Safety: Reset Shader State on Reload
        if (this.config.get('shaderEnabled')) {
            this.config.set('shaderEnabled', false);
            this.config.set('customShader', null);
        }
    }
    /**
     * Sets up a debounced window resize listener.
     * @private
     */
    _setupResizeListener() {
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this._resize(), 100); // Debounce resize events
        });
    }
    /**
     * Sets up the global input listener for key bindings.
     * @private
     */
    _setupInputListener() {
        window.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field or text area
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Ignore if in key binding mode (Double check flag)
            if (this.ui && this.ui.isKeyBindingActive) return;
            // Ignore if modifier keys are pressed (unless we want to support them later)
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            const bindings = this.config.state.keyBindings || {};
            const key = e.key.toLowerCase();
            for (const [action, boundKey] of Object.entries(bindings)) {
                if (boundKey && boundKey.toLowerCase() === key) {
                    if (action === 'ToggleUI') {
                        this.ui.togglePanel();
                    } else if (action === 'BootSequence' || action === 'CrashSequence') { 
                        this.effectRegistry.trigger(action);
                        this.notifications.show(`${action} Triggered`, 'success');
                    }
                    else {
                        if (this.effectRegistry.trigger(action)) {
                            this.notifications.show(`${action} Triggered`, 'success');
                        }
                    }
                    // Prevent default action only if we matched a binding
                    e.preventDefault();
                    return;
                }
            }
        });
    }
    /**
     * Sets up subscriptions to configuration changes that trigger UI or rendering updates.
     * @private
     */
    _setupConfigSubscriptions() {
        const resizeTriggers = new Set([
            'resolution',
            'stretchX',
            'stretchY',
            'fontSize',
            'horizontalSpacingFactor',
            'verticalSpacingFactor',
            'fontOffsetX',
            'fontOffsetY'
        ]);
        const smoothingTriggers = new Set([
            'smoothingEnabled',
            'smoothingAmount'
        ]);
        const atlasTriggers = new Set([
            'fontWeight',
            'italicEnabled',
            'tracerSizeIncrease',
            'tracerGlow',
            'overlapColor',
            'streamPalette',
            'tracerColor'
        ]);
        this.config.subscribe((key) => {
            // Resize the canvas and grid on resolution-related changes
            if (resizeTriggers.has(key) || key === 'ALL') {
                this._resize();
            }
            // Update renderer when smoothing settings change
            if (smoothingTriggers.has(key)) {
                this.renderer.updateSmoothing();
            }
            // Update Atlas if appearance changes (WebGL optimization)
            if ((atlasTriggers.has(key) || key === 'ALL') && this.renderer && this.renderer.handleAppearanceChange) {
                this.renderer.handleAppearanceChange();
            }
            const autoEffects = [
                { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
                { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
                { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
                { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
                { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
                { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' },
                { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
            ];
            autoEffects.forEach(effect => {
                if ((key === effect.enabledKey && this.config.state[effect.enabledKey]) || key === 'ALL') {
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                } else if (key === effect.enabledKey && !this.config.state[effect.enabledKey]) {
                    // If an effect is specifically disabled, remove its timer
                    delete this._effectTimers[effect.effectName];
                }
            });
        });
    }
    /**
     * Resizes the grid and renderer dimensions based on current window size and configuration.
     * @private
     */
    _resize() {
        this.grid.resize(
            window.innerWidth / this.config.state.stretchX,
            window.innerHeight / this.config.state.stretchY
        );
        this.renderer.resize();
    }
    /**
     * The main animation loop, handling updates and rendering.
     * Uses a fixed timestep for consistent simulation speed.
     * @private
     * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
     */
    _loop(time) {
    // 1. Calculate Delta and FPS
    const now = performance.now();
    const deltaFPS = now - this.lastFrameTime;
    this.lastFrameTime = now;
    if (deltaFPS > 0 && this.config.state.showFpsCounter) {
        const fps = 1000 / deltaFPS;
        // Simple 30-frame smoothing
        this.fpsHistory.push(fps);
        if (this.fpsHistory.length > 30) {
            this.fpsHistory.shift();
        }
        const smoothedFps = this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            // 2. Update Display
            if (this.fpsDisplayElement) {
                let text = `FPS: ${Math.round(smoothedFps)}`;
                if (this.config.state.debugEnabled) {
                     if (performance.memory) {
                         const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                         text += ` | Mem: ${used}MB`;
                     }
                     if (this.grid && this.grid.activeIndices) {
                         text += ` | Cells: ${this.grid.activeIndices.length}`;
                     }
                }
                this.fpsDisplayElement.textContent = text;
                this.fpsDisplayElement.style.display = 'block';
            }
        } else if (this.fpsDisplayElement) {
            // Hide the counter if the setting is disabled
            this.fpsDisplayElement.style.display = 'none';
        }
        // Start main rendering loop
        if (!this.lastTime) this.lastTime = time;
        const delta = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += delta;
        while (this.accumulator >= this.timestep) {
            this._updateFrame();
            this.accumulator -= this.timestep;
        }
        this.renderer.render(this.frame);
        requestAnimationFrame((nextTime) => this._loop(nextTime));
    }
    /**
     * Updates the simulation logic for a single frame.
     * @private
     */
    _updateFrame() {
        this.frame++;
        this.effectRegistry.update();
        this.simulation.update(this.frame);
        const autoEffects = [
            { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
            { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
            { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
            { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
            { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
            { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' },
            { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
        ];
        autoEffects.forEach(effect => {
            if (this.config.state[effect.enabledKey]) {
                if (!this._effectTimers[effect.effectName]) {
                    // Initialize timer with randomization if not already set
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
                this._effectTimers[effect.effectName]--;
                if (this._effectTimers[effect.effectName] <= 0) {
                    this.effectRegistry.trigger(effect.effectName);
                    // Reset timer with randomization
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5);
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
            } else {
                // If effect is disabled, ensure its timer is reset or cleared
                if (this._effectTimers[effect.effectName]) {
                    delete this._effectTimers[effect.effectName];
                }
            }
        });
    }
}
// Initialize the MatrixKernel on DOMContentLoaded
window.addEventListener('DOMContentLoaded', async () => {
    const kernel = new MatrixKernel();
    // Expose kernel and config globally for debugging/console access
    window.matrix = kernel;
    window.config = kernel.config;
    await kernel.initAsync();
    kernel.lastFrameTime = performance.now(); // Set initial time
});
</script>
    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>