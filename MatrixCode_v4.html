<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Digital Rain v4.0 - Optimized</title>
    <style>
        /* --- CSS RESET & BASE --- */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(17, 24, 39, 0.95);
            --panel-border: rgba(4, 120, 87, 0.5);
            --text-main: #4ade80;
            --text-muted: #6ee7b7;
            --accent: #10b981;
            --danger: #ef4444;
            --info: #3b82f6;
            --disabled: #374151;
        }
        body { overflow: hidden; background-color: var(--bg-color); margin: 0; font-family: monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        /* Ensure Main Canvas is behind UI */
        #matrixCanvas { z-index: 1; }

        /* --- UI PANEL --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; width: 30rem;
            background-color: var(--panel-bg); backdrop-filter: blur(4px);
            box-shadow: -20px 0 30px rgba(0,0,0,0.5); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s ease-in-out;
            display: grid; grid-template-columns: 10rem 1fr; grid-template-rows: auto 1fr auto;
            border-left: 1px solid var(--panel-border); font-size: 0.875rem;
        }
        #settingsPanel.open { transform: translateX(0); }
        
        /* --- SECTIONS --- */
        #panelHeader { grid-column: 1 / 3; padding: 1.5rem; border-bottom: 1px solid rgba(6,95,70,0.5); }
        #navTabs { grid-column: 1 / 2; background: rgba(17,24,39,0.8); border-right: 1px solid rgba(6,95,70,0.5); overflow-y: auto; }
        #contentArea { grid-column: 2 / 3; padding: 1rem 1.5rem; overflow-y: auto; }
        #panelFooter { grid-column: 1 / 3; padding: 1rem 1.5rem; border-top: 1px solid rgba(6,95,70,0.5); display: flex; gap: 0.5rem; justify-content: flex-end; }

        /* --- COMPONENTS --- */
        .tab-btn { width: 100%; padding: 0.75rem 1rem; text-align: left; color: var(--text-main); background: none; border: none; cursor: pointer; transition: 0.2s; }
        .tab-btn:hover { background: rgba(4,120,87,0.2); }
        .tab-btn.active { background: rgba(4,120,87,0.4); color: #d1fae5; border-left: 4px solid var(--accent); }
        
        .control-group { display: none; }
        .control-group.active { display: block; }
        
        .control-row { margin-bottom: 1.5rem; }
        .control-header { display: flex; justify-content: space-between; color: var(--text-muted); margin-bottom: 0.5rem; cursor: help; }
        
        input[type="range"] { width: 100%; height: 0.5rem; background: #374151; border-radius: 0.5rem; appearance: none; accent-color: var(--accent); }
        input[type="color"] { width: 100%; height: 2.5rem; border: 1px solid var(--panel-border); border-radius: 0.5rem; background: none; padding: 0; cursor: pointer; }
        input[type="checkbox"] { width: 1.25rem; height: 1.25rem; accent-color: var(--accent); cursor: pointer; }
        input[type="file"] { display: none; }
        
        .slot-container { display: flex; gap: 0.125rem; align-items: center; margin-bottom: 1.0rem; }
        .slot-name-input { 
            flex: 0 0 25%; background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); 
            color: var(--text-main); padding: 0.5rem; border-radius: 0.25rem; font-family: monospace; 
        }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }

        .action-btn { width: 100%; padding: 0.75rem; border-radius: 0.5rem; font-weight: bold; cursor: pointer; color: white; transition: 0.2s; border: 1px solid transparent; margin-bottom: 0.5rem; }
        .btn-sm { padding: 0.5rem; width: auto; margin-bottom: 0; font-size: 0.75rem; }
        .btn-default { background: rgba(4, 120, 87, 0.8); }
        .btn-default:hover { background: rgba(6, 95, 70, 0.9); }
        .btn-info { background: rgba(59, 130, 246, 0.5); border-color: rgba(37, 99, 235, 0.5); }
        .btn-info:hover { background: rgba(37, 99, 235, 0.7); }
        .btn-danger { background: rgba(185, 28, 28, 0.5); border-color: rgba(239, 68, 68, 0.5); }
        .btn-danger:hover { background: rgba(220, 38, 38, 0.7); }
        .btn-disabled { background: var(--disabled); color: #9ca3af; cursor: not-allowed; border-color: transparent; }

        .status-msg { font-size: 0.75rem; margin-top: 0.5rem; text-align: center; min-height: 1.2em; }
        .status-success { color: var(--text-main); }
        .status-error { color: var(--danger); }
        
        #menuToggle { position: fixed; top: 1rem; right: 1rem; z-index: 30; padding: 0.75rem; color: var(--text-main); background: rgba(17,24,39,0.5); border: 1px solid var(--panel-border); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        #menuToggle:hover { background: rgba(31,41,55,0.7); }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <canvas id="bloomCanvas" style="display:none;"></canvas>

    <button id="menuToggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0-.33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l-.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
    </button>

    <input type="file" id="importFile" accept=".json" />

    <div id="settingsPanel">
        <div id="panelHeader"><h2 style="margin:0; color:var(--text-main);">Digital Rain v4.0</h2></div>
        <div id="navTabs"></div>
        <div id="contentArea"></div>
        <div id="panelFooter">
            <div id="globalStatus" class="status-msg"></div>
        </div>
    </div>

    <script>
        /**
         * ==========================================
         * 1. CORE UTILITIES & CONSTANTS
         * ==========================================
         */
        const APP_VERSION = "4.0";
        const Utils = {
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomFloat: (min, max) => Math.random() * (max - min) + min,
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } 
                              : { r: 0, g: 255, b: 0 };
            },
            // Updated to take pre-calculated string for performance
            rgbaString: (rgbStr, a) => `rgba(${rgbStr},${a})`,
            CHARS: 'カサタナハヤラワキシチニヒミリウクヌフムケセテメオコソホヲ01245789:+=<>.*',
            getRandomChar: () => Utils.CHARS.charAt(Math.floor(Math.random() * Utils.CHARS.length)),
            getUniqueChar: (exclude) => {
                let c; do { c = Utils.getRandomChar(); } while (c === exclude); return c;
            },
            downloadJson: (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        };

        /**
         * ==========================================
         * 2. CONFIGURATION MANAGER (State Management)
         * ==========================================
         */
        class ConfigurationManager {
            constructor() {
                this.storageKey = 'matrix_config_v4_0'; 
                this.slotsKey = 'matrix_slots_v1';
                
                this.defaults = this._getDefaults();
                this.state = { ...this.defaults };
                this.slots = this._loadSlots();
                this.subscribers = [];
                this.load();
                this.updateDerivedValues();
            }

            _getDefaults() {
                return {
                    // Appearance
                    streamColor: '#05ff2f', streamSpeed: 15, trailGlow: 28, clearAlpha: 0.90,
                    streamMinLength: 30, streamMaxLength: 140, holeRate: 0.15,
                    decayDelayRows: 40, decayFadeDurationFrames: 36,
                    
                    // Brightness
                    variableBrightnessEnabled: true, brightnessVariance: 25,

                    // Tracers
                    tracerColor: '#ffffff', tracerSizeIncrease: 4, tracerGlow: 15,
                    tracerFadeInFrames: 1, tracerColorFadeFrames: 1,
                    invertedTracerEnabled: true, invertedTracerChance: 0.20,

                    // Rotators
                    rotatorChance: 0.125, rotatorCycleFactor: 15, rotatorCrossfadeFrames: 8,
                    
                    // Layout
                    fontSize: 24, cellSpacingFactor: 0.95, horizontalSpacingFactor: 1.15,
                    
                    // Effects
                    pulseEnabled: true, pulseFrequencySeconds: 180, pulseDelayFrames: 60, 
                    pulseDurationSeconds: 1.5, pulsePreserveSpaces: true, pulseRandomPosition: true,

                    // Performance (New in v4.0)
                    enableBloom: false, bloomStrength: 2
                };
            }

            _loadSlots() {
                try {
                    const stored = localStorage.getItem(this.slotsKey);
                    if (stored) return JSON.parse(stored);
                } catch (e) { console.error("Slots load failed", e); }
                return Array(5).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null }));
            }

            saveSlotsToStorage() {
                try { localStorage.setItem(this.slotsKey, JSON.stringify(this.slots)); } catch (e) {}
            }

            load() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) this.state = { ...this.defaults, ...JSON.parse(stored) };
                } catch (e) { console.error("Load failed", e); }
            }

            save() {
                try { localStorage.setItem(this.storageKey, JSON.stringify(this.state)); } catch (e) {}
            }

            get(key) { return this.state[key]; }

            set(key, value) {
                this.state[key] = value;
                if (key === 'streamMinLength') this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
                if (key === 'streamMaxLength') this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
                
                this.updateDerivedValues();
                this.save();
                this.notifySubscribers(key);
            }

            reset() {
                this.state = { ...this.defaults };
                this.updateDerivedValues();
                this.save();
                this.notifySubscribers('ALL');
            }

            saveToSlot(index) {
                if(index < 0 || index >= 5) return;
                this.slots[index] = { name: this.slots[index].name, data: JSON.parse(JSON.stringify(this.state)) };
                this.saveSlotsToStorage();
            }

            loadFromSlot(index) {
                if(index < 0 || index >= 5 || !this.slots[index].data) return false;
                this.state = { ...this.defaults, ...this.slots[index].data };
                this.updateDerivedValues();
                this.save();
                this.notifySubscribers('ALL');
                return true;
            }

            renameSlot(index, newName) {
                if(index < 0 || index >= 5) return;
                this.slots[index].name = newName;
                this.saveSlotsToStorage();
            }

            getExportData() {
                return { version: APP_VERSION, timestamp: new Date().toISOString(), state: this.state };
            }

            validateAndLoadImport(jsonString) {
                try {
                    const data = JSON.parse(jsonString);
                    if (!data || !data.state) throw new Error("Invalid file.");
                    const cleanState = { ...this.state };
                    Object.keys(this.defaults).forEach(key => {
                        if (Object.prototype.hasOwnProperty.call(data.state, key)) cleanState[key] = data.state[key];
                    });
                    this.state = cleanState;
                    this.updateDerivedValues();
                    this.save();
                    this.notifySubscribers('ALL');
                    return { success: true, message: `Imported settings (v${data.version || '?'})` };
                } catch (e) {
                    return { success: false, message: e.message };
                }
            }

            updateDerivedValues() {
                const s = this.state;
                const sRgb = Utils.hexToRgb(s.streamColor);
                const tRgb = Utils.hexToRgb(s.tracerColor);
                
                this.derived = {
                    writingCycles: 21 - s.streamSpeed,
                    rotatorCycleFrames: Math.max(10, Math.round(60 - (s.rotatorCycleFactor * 2.5))),
                    streamRgb: sRgb,
                    tracerRgb: tRgb,
                    // OPTIMIZATION: Cache the string representation to avoid unnecessary string concatenation in render loop
                    streamRgbStr: `${sRgb.r},${sRgb.g},${sRgb.b}`,
                    tracerRgbStr: `${tRgb.r},${tRgb.g},${tRgb.b}`,
                    cellWidth: s.fontSize / s.horizontalSpacingFactor,
                    cellHeight: (s.fontSize / s.horizontalSpacingFactor) * s.cellSpacingFactor,
                    varianceMin: 1.0 - (s.brightnessVariance / 100)
                };
            }

            subscribe(cb) { this.subscribers.push(cb); }
            notifySubscribers(key) { this.subscribers.forEach(cb => cb(key, this.state)); }
        }

        /**
         * ==========================================
         * 3. GRID SYSTEM
         * ==========================================
         */
        class Cell {
            constructor() {
                this.char = Utils.getRandomChar();
                this.nextChar = Utils.getRandomChar();
                this.state = 0; 
                this.decayAge = 0; 
                this.isRotator = false;
                this.rotationProgress = 0;
                this.brightnessFactor = null;
            }
            
            resetBrightness(config) {
                if (!config.state.variableBrightnessEnabled) {
                    this.brightnessFactor = 1.0;
                } else if (this.brightnessFactor === null) {
                    this.brightnessFactor = Utils.randomFloat(config.derived.varianceMin, 1.0);
                }
            }
        }

        class ColumnStream {
            constructor(xIndex, gridManager) {
                this.x = xIndex;
                this.gm = gridManager;
                this.y = -1;
                this.timer = 0;
                this.active = false;
                this.delay = Utils.randomInt(20, 500);
                this.written = 0;
                this.length = 0;
                this.holes = new Set();
                this.decayY = -1;
                this.decayStarted = false;
                this.isInverted = false; 
            }

            prepare() {
                const s = this.gm.config.state;
                const maxHead = s.streamMaxLength;
                this.length = Utils.randomInt(Math.min(s.streamMinLength, maxHead), maxHead);
                if (this.length < this.gm.rows) this.length = Math.min(this.gm.rows + Utils.randomInt(1,10), maxHead);
                
                this.holes.clear();
                for(let i=0; i<this.length; i++) if(Math.random() < s.holeRate) this.holes.add(i);

                this.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
                this.written = 0;
                if (!this.isInverted) while(this.written < this.length && this.holes.has(this.written)) this.written++;
                
                this.active = true;
                this.y = -1;
                this.delay = 0;
                this.decayY = -1 - s.decayDelayRows;
                this.decayStarted = false;
            }

            update(frame) {
                if (!this.active) {
                    if (this.delay > 0) this.delay--;
                    return;
                }
                const s = this.gm.config.state;
                const d = this.gm.config.derived;
                this.timer++;

                if (this.written >= s.decayDelayRows && !this.decayStarted) {
                    this.decayY = this.y - s.decayDelayRows;
                    this.decayStarted = true;
                }

                if (this.timer % d.writingCycles === 0) {
                    this.stepHead(s);
                    if (this.decayStarted) this.stepTail();
                    this.timer = 0;
                }

                if (this.decayStarted && this.decayY >= this.gm.rows) {
                    this.active = false;
                    this.delay = Utils.randomInt(50, 150);
                }
            }

            stepHead(s) {
                if (this.written >= this.length) return;
                this.y++;
                if (this.y >= 0 && this.y < this.gm.rows) {
                    const isHole = this.holes.has(this.written);
                    const shouldDraw = this.isInverted ? isHole : !isHole;
                    const cell = this.gm.getCell(this.x, this.y);
                    
                    if (shouldDraw) {
                        cell.state = 1;
                        cell.decayAge = 1;
                        cell.char = cell.nextChar;
                        cell.nextChar = Utils.getUniqueChar(cell.char);
                        cell.isRotator = Math.random() < s.rotatorChance;
                        cell.brightnessFactor = null; 
                    } else {
                        cell.state = 0;
                        cell.decayAge = 0; 
                    }
                }
                this.written++;
            }

            stepTail() {
                this.decayY++;
                if (this.decayY >= 0 && this.decayY < this.gm.rows) {
                    const cell = this.gm.getCell(this.x, this.decayY);
                    if (cell.decayAge === 1) cell.decayAge = 2; 
                }
            }
        }

        class GridManager {
            constructor(config) {
                this.config = config;
                this.grid = [];
                this.streams = [];
                this.cols = 0;
                this.rows = 0;
                this.releaseTimer = 0;
            }

            resize(width, height) {
                const d = this.config.derived;
                const newCols = Math.floor(width / d.cellWidth);
                const newRows = Math.floor(height / d.cellHeight);
                if (newCols !== this.cols || newRows !== this.rows) this.initGrid(newCols, newRows);
            }

            initGrid(cols, rows) {
                this.cols = cols;
                this.rows = rows;
                this.grid = new Array(rows).fill(null).map(() => new Array(cols).fill(null).map(() => new Cell()));
                this.streams = new Array(cols).fill(null).map((_, i) => new ColumnStream(i, this));
            }

            getCell(x, y) { return (y >= 0 && y < this.rows && x >= 0 && x < this.cols) ? this.grid[y][x] : null; }

            update(frame) {
                if (this.releaseTimer <= 0) {
                    const available = this.streams.filter(s => !s.active && s.delay <= 0);
                    available.sort(() => Math.random() - 0.5); 
                    let count = 4; 
                    for(const s of available) {
                        if(count-- <= 0) break;
                        let clear = true;
                        for(let y=0; y < Math.min(this.rows, 40); y++) {
                            if(this.grid[y][s.x].decayAge > 0) { clear = false; break; }
                        }
                        if(clear) s.prepare(); else s.delay = 20; 
                    }
                    this.releaseTimer = this.config.derived.writingCycles * 5;
                } else {
                    this.releaseTimer--;
                }

                this.streams.forEach(s => s.update(frame));

                const s = this.config.state;
                const d = this.config.derived;
                const cyclePhase = frame % d.rotatorCycleFrames;
                const crossfadeStart = d.rotatorCycleFrames - s.rotatorCrossfadeFrames;

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.grid[y][x];
                        if (cell.state > 0) { if (++cell.state > d.writingCycles) cell.state = 0; }
                        if (cell.decayAge >= 2) { if (++cell.decayAge > s.decayFadeDurationFrames + 2) cell.decayAge = 0; }

                        if (cell.isRotator && (cell.state > 0 || cell.decayAge === 1)) {
                            const safe = y === 0 || this.grid[y-1][x].decayAge < 2;
                            if (cyclePhase === crossfadeStart && cell.rotationProgress === 0 && safe) {
                                cell.rotationProgress = 1;
                                cell.nextChar = Utils.getUniqueChar(cell.char);
                            } else if (cell.rotationProgress > 0) {
                                cell.rotationProgress++;
                                if (cell.rotationProgress > s.rotatorCrossfadeFrames) {
                                    cell.char = cell.nextChar;
                                    cell.nextChar = Utils.getUniqueChar(cell.char);
                                    cell.rotationProgress = 0;
                                }
                            }
                        }
                        cell.resetBrightness(this.config);
                    }
                }
            }
        }

        /**
         * ==========================================
         * 4. EFFECT SYSTEM
         * ==========================================
         */
        class BaseEffect {
            constructor(config, gridManager) { this.config = config; this.gm = gridManager; this.active = false; }
            trigger() {}
            update(frame) {}
            getRenderMode(x, y) { return 'LIVE'; } 
            getOverrideData(x, y) { return null; } 
        }

        class PulseEffect extends BaseEffect {
            constructor(config, gm) {
                super(config, gm);
                this.snapshot = [];
                this.state = 'IDLE'; 
                this.timer = 0;
                this.radius = 0;
                this.origin = {x:0, y:0};
                this.speed = 0;
                this.autoTimer = 0;
                this.resetAutoTimer();
            }

            resetAutoTimer() {
                const s = this.config.state;
                if(s.pulseEnabled) {
                    const base = s.pulseFrequencySeconds * 60;
                    this.autoTimer = base + Utils.randomInt(0, base/2);
                }
            }

            trigger() {
                if(this.active) return;
                const s = this.config.state;
                this.snapshot = new Array(this.gm.rows).fill(0).map(() => new Array(this.gm.cols));
                for(let y=0; y<this.gm.rows; y++) {
                    for(let x=0; x<this.gm.cols; x++) {
                        const cell = this.gm.getCell(x,y);
                        this.snapshot[y][x] = {
                            char: cell.char,
                            isEmpty: (cell.state === 0 && cell.decayAge === 0),
                            color: RendererHelpers.getCellColor(cell, this.config, 0.25) 
                        };
                    }
                }
                this.origin = s.pulseRandomPosition 
                    ? { x: Utils.randomInt(this.gm.cols*0.2, this.gm.cols*0.8), y: Utils.randomInt(this.gm.rows*0.2, this.gm.rows*0.8) }
                    : { x: Math.floor(this.gm.cols/2), y: Math.floor(this.gm.rows/2) };

                const maxDist = Math.max(Math.max(this.origin.x, this.gm.cols-this.origin.x), Math.max(this.origin.y, this.gm.rows-this.origin.y));
                const duration = Math.max(1, s.pulseDurationSeconds * 60);
                this.speed = (maxDist + 10) / duration;

                this.active = true;
                this.state = 'WAITING';
                this.timer = s.pulseDelayFrames;
                this.radius = 0;
            }

            update(frame) {
                const s = this.config.state;
                if(!this.active && s.pulseEnabled) { if(--this.autoTimer <= 0) { this.trigger(); this.resetAutoTimer(); } }
                if(!this.active) return;

                if(this.state === 'WAITING') {
                    if(--this.timer <= 0) this.state = 'EXPANDING';
                } else if (this.state === 'EXPANDING') {
                    this.radius += this.speed;
                    const maxDim = Math.max(this.gm.cols, this.gm.rows);
                    if(this.radius > maxDim * 1.5) { this.active = false; this.snapshot = []; this.state = 'IDLE'; }
                }
            }

            getRenderMode(x, y) {
                if(!this.active) return 'LIVE';
                if(this.state === 'WAITING') return 'FROZEN';
                const dist = Math.max(Math.abs(x - this.origin.x), Math.abs(y - this.origin.y)); 
                if(dist > this.radius) return 'FROZEN';
                if(dist > this.radius - 6) return 'OVERRIDE'; 
                return 'LIVE'; 
            }

            getOverrideData(x, y) {
                if(this.config.state.pulsePreserveSpaces && this.snapshot[y][x].isEmpty) return null; 
                const cell = this.gm.getCell(x,y);
                const d = this.config.derived;
                return {
                    char: cell.char,
                    color: Utils.rgbaString(d.tracerRgbStr, 1.0),
                    glow: this.config.state.tracerGlow * 1.5,
                    shadowColor: this.config.state.tracerColor,
                    sizeMod: this.config.state.tracerSizeIncrease
                };
            }
            getFrozenData(x, y) { return this.snapshot[y][x]; }
        }

        class EffectSystem {
            constructor(config, gm) {
                this.effects = [new PulseEffect(config, gm)];
                this.activeEffect = null;
            }
            update(frame) {
                let active = null;
                this.effects.forEach(eff => { eff.update(frame); if (eff.active) active = eff; });
                this.activeEffect = active;
            }
            triggerPulse() { this.effects[0].trigger(); }
            getActive() { return this.activeEffect; }
        }

        /**
         * ==========================================
         * 5. RENDERER (Optimized)
         * ==========================================
         */
        const RendererHelpers = {
            getCellColor: (cell, config, opacityMult = 1.0) => {
                const s = config.state;
                const d = config.derived;
                let rgbStr = d.streamRgbStr;
                let a = 0;

                if (cell.state > 0) {
                    rgbStr = d.tracerRgbStr;
                    const fadeIn = Math.max(1, s.tracerFadeInFrames);
                    const colorFadeStart = d.writingCycles - s.tracerColorFadeFrames;
                    
                    if (cell.state <= fadeIn) {
                        a = cell.state / fadeIn;
                    } else if (cell.state >= colorFadeStart) {
                        const progress = (cell.state - colorFadeStart) / Math.max(1, d.writingCycles - colorFadeStart);
                        // Complex blend - cannot use pre-calc string easily for the transition frames, but fine for others
                        const r = Math.round(d.tracerRgb.r + (d.streamRgb.r - d.tracerRgb.r) * progress);
                        const g = Math.round(d.tracerRgb.g + (d.streamRgb.g - d.tracerRgb.g) * progress);
                        const b = Math.round(d.tracerRgb.b + (d.streamRgb.b - d.tracerRgb.b) * progress);
                        return `rgba(${r},${g},${b},${opacityMult})`;
                    } else {
                        a = 1.0;
                    }
                } 
                else if (cell.decayAge === 1) a = 0.95;
                else if (cell.decayAge >= 2) {
                    a = 0.95 * (1 - ((cell.decayAge - 2) / s.decayFadeDurationFrames));
                }

                if (a <= 0) return 'rgba(0,0,0,0)';
                if(cell.brightnessFactor) a *= cell.brightnessFactor;
                return Utils.rgbaString(rgbStr, Math.max(0, a * opacityMult));
            }
        };

        class CanvasRenderer {
            constructor(canvasId, config, gridManager, effectSystem) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d', { alpha: false }); 
                this.config = config;
                this.gm = gridManager;
                this.effects = effectSystem;
                
                // Bloom specific
                this.bloomCanvas = document.getElementById('bloomCanvas');
                this.bloomCtx = this.bloomCanvas.getContext('2d', { alpha: true });

                // Batches to reduce state switching
                this.batches = {
                    trails: [],
                    tracers: [],
                    overrides: [],
                    frozen: []
                };

                this.width = 0; this.height = 0;
                window.addEventListener('resize', () => this.resize());
                this.resize();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.ctx.textBaseline = 'middle';
                this.ctx.textAlign = 'center';
                
                // Bloom canvas can be smaller for performance and increased blurriness
                const scale = 0.25; 
                this.bloomCanvas.width = this.width * scale;
                this.bloomCanvas.height = this.height * scale;
                this.bloomCtx.scale(scale, scale);
                this.bloomCtx.textBaseline = 'middle';
                this.bloomCtx.textAlign = 'center';

                this.gm.resize(this.width, this.height);
            }

            render() {
                const s = this.config.state;
                const d = this.config.derived;
                const bloomEnabled = s.enableBloom;

                // 1. CLEAR & BACKGROUND
                this.ctx.fillStyle = `rgba(0, 0, 0, ${s.clearAlpha})`;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                if (bloomEnabled) {
                    this.bloomCtx.clearRect(0, 0, this.width, this.height);
                }

                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.translate(-this.width, 0);

                // Bloom canvas needs same transform
                if(bloomEnabled) {
                    this.bloomCtx.save();
                    this.bloomCtx.scale(-1, 1);
                    this.bloomCtx.translate(-this.width, 0);
                }

                // 2. GATHER BATCHES (Iteration Pass)
                // We clear arrays but keep the objects to reduce GC pressure (simplified here as re-assignment)
                this.batches.trails = [];
                this.batches.tracers = [];
                this.batches.overrides = [];
                this.batches.frozen = [];

                const effect = this.effects.getActive();

                for (let y = 0; y < this.gm.rows; y++) {
                    const yPos = y * d.cellHeight + d.cellHeight/2;
                    for (let x = 0; x < this.gm.cols; x++) {
                        const xPos = x * d.cellWidth + d.cellWidth/2;
                        
                        // Determine what to draw
                        const mode = effect ? effect.getRenderMode(x, y) : 'LIVE';

                        if (mode === 'FROZEN') {
                            const data = effect.getFrozenData(x, y);
                            if (data && !data.isEmpty) this.batches.frozen.push({x: xPos, y: yPos, c: data.char, col: data.color});
                        }
                        else if (mode === 'OVERRIDE') {
                            const data = effect.getOverrideData(x, y);
                            if (data) this.batches.overrides.push({x: xPos, y: yPos, c: data.char, col: data.color, g: data.glow, sc: data.shadowColor, sz: data.sizeMod});
                        }
                        else {
                            const cell = this.gm.getCell(x, y);
                            if (cell.state > 0 || cell.decayAge > 0) {
                                // Logic for rotator crossfade (draws twice in one spot, so handle immediately or complex batch)
                                // Optimization: Handle simple cases in batch, handle rotators directly?
                                // Let's simplify: Treat rotator crossfade as just two draws. 
                                if (cell.isRotator && cell.rotationProgress > 0) {
                                    const prog = cell.rotationProgress / s.rotatorCrossfadeFrames;
                                    // 1. Old Char (Fading Out)
                                    this.batches.trails.push({
                                        x: xPos, y: yPos, c: cell.char, 
                                        col: RendererHelpers.getCellColor(cell, this.config, 1.0 - prog)
                                    });
                                    // 2. New Char (Fading In)
                                    this.batches.trails.push({
                                        x: xPos, y: yPos, c: cell.nextChar, 
                                        col: RendererHelpers.getCellColor(cell, this.config, prog)
                                    });
                                } else {
                                    const isHead = cell.state > 0;
                                    const color = RendererHelpers.getCellColor(cell, this.config);
                                    if(isHead) this.batches.tracers.push({x: xPos, y: yPos, c: cell.char, col: color});
                                    else this.batches.trails.push({x: xPos, y: yPos, c: cell.char, col: color});
                                }
                            }
                        }
                    }
                }

                // 3. EXECUTE DRAWING (Batch Pass)
                const baseFont = `bold ${s.fontSize}px 'Inter', monospace`;
                const largeFont = `bold ${s.fontSize + s.tracerSizeIncrease}px 'Inter', monospace`;

                // -- A. FROZEN LAYER --
                if(this.batches.frozen.length > 0) {
                    this.ctx.font = baseFont;
                    this.ctx.shadowBlur = 0; // Frozen is flat
                    this.batches.frozen.forEach(item => {
                        this.ctx.fillStyle = item.col;
                        this.ctx.fillText(item.c, item.x, item.y);
                    });
                }

                // -- B. TRAILS (The Bulk) --
                if(this.batches.trails.length > 0) {
                    this.ctx.font = baseFont;
                    
                    // If Bloom is enabled, we DON'T use CPU shadowBlur (huge perf gain)
                    // If Bloom is disabled, we use the specific trailGlow
                    this.ctx.shadowBlur = bloomEnabled ? 0 : s.trailGlow;
                    this.ctx.shadowColor = s.streamColor;

                    this.batches.trails.forEach(item => {
                        this.ctx.fillStyle = item.col;
                        this.ctx.fillText(item.c, item.x, item.y);
                    });
                }

                // -- C. TRACERS (The Brights) --
                if(this.batches.tracers.length > 0) {
                    const useFont = largeFont;
                    
                    // Main Canvas Draw
                    this.ctx.font = useFont;
                    this.ctx.shadowBlur = bloomEnabled ? 0 : s.tracerGlow;
                    this.ctx.shadowColor = s.tracerColor;
                    
                    this.batches.tracers.forEach(item => {
                        this.ctx.fillStyle = item.col;
                        this.ctx.fillText(item.c, item.x, item.y);
                    });

                    // Bloom Canvas Draw (Only if enabled)
                    if(bloomEnabled) {
                        this.bloomCtx.font = useFont;
                        this.bloomCtx.shadowBlur = 0; // The blur comes from upscaling, not shadow
                        this.batches.tracers.forEach(item => {
                            this.bloomCtx.fillStyle = item.col;
                            this.bloomCtx.fillText(item.c, item.x, item.y);
                        });
                        // Add overrides to bloom too
                        this.batches.overrides.forEach(item => {
                            this.bloomCtx.font = `bold ${s.fontSize + item.sz}px 'Inter', monospace`;
                            this.bloomCtx.fillStyle = item.col;
                            this.bloomCtx.fillText(item.c, item.x, item.y);
                        });
                    }
                }

                // -- D. OVERRIDES (Pulse Effect) --
                if(this.batches.overrides.length > 0) {
                    this.batches.overrides.forEach(item => {
                        this.ctx.font = `bold ${s.fontSize + item.sz}px 'Inter', monospace`;
                        this.ctx.shadowBlur = bloomEnabled ? 0 : item.g;
                        this.ctx.shadowColor = item.sc;
                        this.ctx.fillStyle = item.col;
                        this.ctx.fillText(item.c, item.x, item.y);
                    });
                }

                this.ctx.restore(); // Restore main canvas
                if(bloomEnabled) this.bloomCtx.restore(); // Restore bloom canvas

                // 4. COMPOSITE BLOOM
                if(bloomEnabled) {
                    this.ctx.save();
                    this.ctx.globalCompositeOperation = 'lighter'; // Additive blending
                    // Draw the small bloom canvas stretched over the main one
                    // We draw it slightly larger or offset if needed, but direct stretch works for "Bloom"
                    this.ctx.filter = `blur(${s.bloomStrength}px)`; // Optional extra GPU blur on the layer
                    this.ctx.drawImage(this.bloomCanvas, 0, 0, this.width, this.height);
                    this.ctx.restore();
                }
            }
        }

        /**
         * ==========================================
         * 6. UI MANAGER
         * ==========================================
         */
        class UIManager {
            constructor(config, effectSystem) {
                this.config = config;
                this.effects = effectSystem;
                this.elements = {
                    panel: document.getElementById('settingsPanel'),
                    toggle: document.getElementById('menuToggle'),
                    tabs: document.getElementById('navTabs'),
                    content: document.getElementById('contentArea'),
                    globalStatus: document.getElementById('globalStatus'),
                    fileInput: document.getElementById('importFile')
                };
                
                this.defs = [
                    { category: 'Appearance', id: 'streamColor', type: 'color', label: 'Stream Color', desc: 'Sets the primary color of the code trails.' },
                    { category: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', desc: 'Toggles random brightness variations for individual characters.' },
                    { category: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled', desc: 'How much dimmer characters can randomly be (0-90%).' },
                    { category: 'Appearance', id: 'streamSpeed', type: 'range', label: 'Speed', min: 1, max: 20, desc: 'Controls how fast the characters fall.' },
                    { category: 'Appearance', id: 'streamMinLength', type: 'range', label: 'Min Length', min: 10, max: 300, desc: 'The minimum length of a code trail.' },
                    { category: 'Appearance', id: 'streamMaxLength', type: 'range', label: 'Max Length', min: 10, max: 300, desc: 'The maximum length of a code trail.' },
                    { category: 'Appearance', id: 'holeRate', type: 'range', label: 'Hole Rate', min: 0, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', desc: 'The percentage of gaps (black spaces) within a code trail.' },
                    { category: 'Appearance', id: 'decayDelayRows', type: 'range', label: 'Eraser Start Delay', min: 5, max: 200, desc: 'Length of the trail before fading starts.' },
                    { category: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Eraser Fade Speed', min: 1, max: 120, unit:'fr', desc: 'How quickly the characters fade out once the eraser starts.' },

                    { category: 'Tracers', id: 'tracerColor', type: 'color', label: 'Tracer Color', desc: 'The color of the leading character (and the Pulse effect).' },
                    { category: 'Tracers', id: 'tracerSizeIncrease', type: 'range', label: 'Size Boost', min: 0, max: 20, unit:'px', desc: 'How much larger the leading character is compared to the trail.' },
                    { category: 'Tracers', id: 'tracerGlow', type: 'range', label: 'Glow', min: 0, max: 50, unit:'px', desc: 'The intensity of the blur/glow around the leading character.' },
                    { category: 'Tracers', id: 'tracerFadeInFrames', type: 'range', label: 'Fade In Speed', min: 0, max: 10, unit: 'fr', desc: 'How many frames it takes for a new tracer to reach full brightness.' },
                    { category: 'Tracers', id: 'tracerColorFadeFrames', type: 'range', label: 'Color Fade Speed', min: 0, max: 20, unit: 'fr', desc: 'How many frames it takes for the tracer white to fade into the stream color.' },
                    { category: 'Tracers', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Enable Inverted', desc: 'Enables a special tracer type that writes characters only where gaps would be.' },
                    { category: 'Tracers', id: 'invertedTracerChance', type: 'range', label: 'Inverted Chance', min: 0.05, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', dep: 'invertedTracerEnabled', desc: 'Percentage of new streams that start as inverted tracers.' },

                    { category: 'Rotators', id: 'rotatorChance', type: 'range', label: 'Chance', min: 0, max: 0.2, step: 0.01, transform: v=>(v*100).toFixed(1)+'%', desc: 'Probability that a character will randomly change over time.' },
                    { category: 'Rotators', id: 'rotatorCycleFactor', type: 'range', label: 'Speed Factor', min: 1, max: 20, desc: 'How frequently rotators change their character.' },
                    
                    { category: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulse', desc: 'Enables the random screen-freeze and pulse effect.' },
                    { category: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, unit: 's', dep: 'pulseEnabled', desc: 'Minimum time between automatic pulses.' },
                    { category: 'Effects', id: 'pulseDelayFrames', type: 'range', label: 'Delay', min: 0, max: 180, unit: 'fr', dep: 'pulseEnabled', desc: 'How long the screen stays frozen before the pulse expands.' },
                    { category: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 5, step: 0.5, unit: 's', dep: 'pulseEnabled', desc: 'How long the pulse wave takes to cross the screen.' },
                    { category: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled', desc: 'If checked, the pulse wave will not light up empty black spaces.' },
                    { category: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Position', dep: 'pulseEnabled', desc: 'If checked, the pulse starts at a random location instead of the center.' },

                    { category: 'Layout', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 60, unit: 'px', onUpdate: 'layout', desc: 'The base size of the text.' },
                    { category: 'Layout', id: 'horizontalSpacingFactor', type: 'range', label: 'H-Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout', desc: 'Horizontal distance between columns.' },
                    { category: 'Layout', id: 'cellSpacingFactor', type: 'range', label: 'V-Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout', desc: 'Vertical distance between characters.' },
                
                    // Performance Tab (New)
                    { category: 'Performance', id: 'enableBloom', type: 'checkbox', label: 'Enable Bloom Effect', desc: 'Switches to a post-processing glow method. Much faster for high resolution/density, but looks slightly different.' },
                    { category: 'Performance', id: 'bloomStrength', type: 'range', label: 'Bloom Blur', min: 0, max: 10, unit: 'px', dep: 'enableBloom', desc: 'Additional blur radius applied to the bloom layer.' },

                    // Save Slots
                    { category: 'Presets', id: 'slot0', type: 'slot', index: 0, label: 'Slot 1' },
                    { category: 'Presets', id: 'slot1', type: 'slot', index: 1, label: 'Slot 2' },
                    { category: 'Presets', id: 'slot2', type: 'slot', index: 2, label: 'Slot 3' },
                    { category: 'Presets', id: 'slot3', type: 'slot', index: 3, label: 'Slot 4' },
                    { category: 'Presets', id: 'slot4', type: 'slot', index: 4, label: 'Slot 5' },

                    // Export/Import
                    { category: 'Presets', id: 'btnExport', type: 'button', label: 'Export Settings', btnClass: 'btn-info', action: 'export', desc: 'Download current settings as a JSON file.' },
                    { category: 'Presets', id: 'btnImport', type: 'button', label: 'Import Settings', btnClass: 'btn-default', action: 'import', desc: 'Load settings from a JSON file.' },
                    
                    // Debugging
                    { category: 'Debugging', id: 'btnTriggerPulse', type: 'button', label: 'Trigger Pulse', btnClass: 'btn-info', action: 'pulse', desc: 'Manually triggers the Pulse effect immediately.' },
                    { category: 'Debugging', id: 'btnForceReset', type: 'button', label: 'Factory Reset', btnClass: 'btn-danger', action: 'reset', desc: 'Resets all settings to defaults.' },
                ];

                this.init();
            }

            init() {
                this.elements.toggle.addEventListener('click', () => this.elements.panel.classList.toggle('open'));
                this.elements.fileInput.addEventListener('change', (e) => this.handleImport(e));
                this.buildTabs();
                this.config.subscribe((key, state) => this.refreshUI(key, state));
            }

            buildTabs() {
                const categories = [...new Set(this.defs.map(d => d.category))];
                let first = true;
                categories.forEach(cat => {
                    const btn = document.createElement('button');
                    btn.className = `tab-btn ${first ? 'active' : ''}`;
                    btn.textContent = cat;
                    btn.onclick = () => this.switchTab(cat, btn);
                    this.elements.tabs.appendChild(btn);

                    const container = document.createElement('div');
                    container.className = `control-group ${first ? 'active' : ''}`;
                    container.id = `group-${cat}`;
                    
                    this.defs.filter(d => d.category === cat).forEach(def => container.appendChild(this.createControl(def)));

                    if(cat === 'Layout') {
                        const applyBtn = document.createElement('button');
                        applyBtn.className = 'action-btn btn-default';
                        applyBtn.textContent = 'Apply Layout Changes';
                        applyBtn.onclick = () => window.dispatchEvent(new Event('resize'));
                        container.appendChild(applyBtn);
                    }
                    this.elements.content.appendChild(container);
                    first = false;
                });
            }

            switchTab(cat, btn) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.control-group').forEach(g => g.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`group-${cat}`).classList.add('active');
            }

            createControl(def) {
                if (def.type === 'button') {
                    const btn = document.createElement('button');
                    btn.className = `action-btn ${def.btnClass || 'btn-default'}`;
                    btn.textContent = def.label;
                    if(def.desc) btn.title = def.desc;
                    btn.onclick = () => this.handleAction(def.action);
                    return btn;
                }
                if (def.type === 'slot') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'control-row';
                    const header = document.createElement('div');
                    header.className = 'control-header';
                    header.textContent = `Save Slot ${def.index + 1}`;
                    wrapper.appendChild(header);
                    const container = document.createElement('div');
                    container.className = 'slot-container';
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.className = 'slot-name-input';
                    nameInput.value = this.config.slots[def.index].name;
                    nameInput.onchange = (e) => this.config.renameSlot(def.index, e.target.value);
                    const saveBtn = document.createElement('button');
                    saveBtn.className = 'action-btn btn-sm btn-info';
                    saveBtn.textContent = 'SAVE';
                    saveBtn.onclick = () => {
                        this.config.saveToSlot(def.index);
                        this.refreshUI('ALL', this.config.state); 
                        this.showStatus(`Saved to ${this.config.slots[def.index].name}`, 'success');
                    };
                    const loadBtn = document.createElement('button');
                    const isEmpty = !this.config.slots[def.index].data;
                    loadBtn.className = `action-btn btn-sm ${isEmpty ? 'btn-disabled' : 'btn-default'}`;
                    loadBtn.textContent = 'LOAD';
                    loadBtn.disabled = isEmpty;
                    loadBtn.onclick = () => {
                        if(this.config.loadFromSlot(def.index)) this.showStatus(`Loaded ${this.config.slots[def.index].name}`, 'success');
                    };
                    container.append(nameInput, saveBtn, loadBtn);
                    wrapper.appendChild(container);
                    return wrapper;
                }
                const wrapper = document.createElement('div');
                wrapper.className = 'control-row';
                wrapper.dataset.id = def.id;
                if(def.desc) wrapper.title = def.desc;
                const header = document.createElement('div');
                header.className = 'control-header';
                const label = document.createElement('label');
                label.textContent = def.label;
                const valueDisplay = document.createElement('span');
                valueDisplay.id = `val-${def.id}`;
                header.append(label, valueDisplay);
                wrapper.appendChild(header);
                const input = document.createElement('input');
                input.type = def.type;
                input.id = `in-${def.id}`;
                if (def.type === 'range') { input.min = def.min; input.max = def.max; if(def.step) input.step = def.step; }
                const currVal = this.config.get(def.id);
                if(def.type === 'checkbox') input.checked = currVal; else input.value = currVal;
                input.oninput = (e) => {
                    let val = def.type === 'checkbox' ? e.target.checked : e.target.value;
                    if(def.type === 'range') val = parseFloat(val);
                    this.config.set(def.id, val);
                    this.updateDisplayValue(def, val, valueDisplay);
                };
                wrapper.appendChild(input);
                this.updateDisplayValue(def, currVal, valueDisplay);
                if(def.dep) wrapper.style.display = this.config.get(def.dep) ? 'block' : 'none';
                return wrapper;
            }

            updateDisplayValue(def, val, el) {
                if(def.type === 'checkbox') el.textContent = val ? 'ON' : 'OFF';
                else if(def.transform) el.textContent = def.transform(val);
                else el.textContent = val + (def.unit || '');
            }

            refreshUI(key, state) {
                if(key === 'ALL') { this.elements.content.innerHTML = ''; this.elements.tabs.innerHTML = ''; this.buildTabs(); return; }
                const def = this.defs.find(d => d.id === key);
                if(def && def.type !== 'button' && def.type !== 'slot') {
                    const input = document.getElementById(`in-${key}`);
                    const display = document.getElementById(`val-${key}`);
                    if(input) { if(def.type === 'checkbox') input.checked = state[key]; else input.value = state[key]; }
                    if(display) this.updateDisplayValue(def, state[key], display);
                }
                this.defs.forEach(d => {
                    if(d.dep === key) {
                        const el = document.querySelector(`.control-row[data-id="${d.id}"]`);
                        if(el) el.style.display = state[key] ? 'block' : 'none';
                    }
                });
            }

            handleAction(action) {
                if (action === 'pulse') this.effects.triggerPulse();
                else if (action === 'reset') { if(confirm("Are you sure you want to reset?")) this.config.reset(); }
                else if (action === 'export') {
                    const data = this.config.getExportData();
                    Utils.downloadJson(data, `matrix_rain_v${data.version}_${Date.now()}.json`);
                    this.showStatus("Exported successfully.", "success");
                } 
                else if (action === 'import') this.elements.fileInput.click();
            }

            handleImport(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = this.config.validateAndLoadImport(e.target.result);
                    this.showStatus(result.message, result.success ? "success" : "error");
                    this.elements.fileInput.value = '';
                };
                reader.readAsText(file);
            }

            showStatus(msg, type) {
                this.elements.globalStatus.textContent = msg;
                this.elements.globalStatus.className = `status-msg status-${type}`;
                setTimeout(() => { this.elements.globalStatus.textContent = ''; }, 4000);
            }
        }

        // --- MAIN ---
        const config = new ConfigurationManager();
        const grid = new GridManager(config);
        const effects = new EffectSystem(config, grid);
        const renderer = new CanvasRenderer('matrixCanvas', config, grid, effects);
        new UIManager(config, effects);

        let frame = 0;
        function loop() {
            frame++;
            grid.update(frame);
            effects.update(frame);
            renderer.render();
            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>
</html>