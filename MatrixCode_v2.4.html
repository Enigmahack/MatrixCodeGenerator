<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refactored Digital Rain Simulation v2.3 (Variable Brightness)</title>
    
    <style>
        /* Base Styles */
        body {
            overflow: hidden;
            background-color: #000; 
            margin: 0; 
        }
        canvas {
            display: block;
        }

        /* --- Settings Panel Grid Layout --- */
        #settingsPanel {
            position: fixed; 
            top: 0;
            right: 0;
            height: 100vh; 
            width: 30rem; 
            background-color: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(4px); 
            box-shadow: -20px 0 30px rgba(0, 0, 0, 0.5); 
            z-index: 20; 
            transform: translateX(100%); 
            transition: transform 0.3s ease-in-out; 
            
            display: grid;
            grid-template-columns: 10rem 1fr;
            grid-template-rows: auto 1fr auto; 
            
            font-family: monospace; 
            font-size: 0.875rem; 
            border-left: 1px solid rgba(4, 120, 87, 0.5); 
        }
        #settingsPanel:not(.translate-x-full) {
            transform: translateX(0);
        }

        /* --- Panel Sections --- */
        #panelHeader {
            grid-column: 1 / 3;
            padding: 1.5rem 1.0rem 1rem 1.5rem;
            border-bottom: 1px solid rgba(6, 95, 70, 0.5);
        }
        
        #navTabs {
            grid-column: 1 / 2;
            padding: 0.5rem 0 1rem 0;
            background-color: rgba(17, 24, 39, 0.8);
            border-right: 1px solid rgba(6, 95, 70, 0.5);
            overflow-y: auto;
        }
        
        #contentArea {
            grid-column: 2 / 3;
            padding: 1rem 1.5rem;
            overflow-y: auto;
        }

        #panelFooter {
            grid-column: 1 / 3;
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(6, 95, 70, 0.5);
        }

        /* --- Tab Styling --- */
        .tab-button {
            width: 100%;
            padding: 0.75rem 1rem;
            text-align: left;
            color: #4ade80; 
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            font-size: 0.875rem;
        }

        .tab-button:hover {
            background-color: rgba(4, 120, 87, 0.2);
        }

        .tab-button.active {
            background-color: rgba(4, 120, 87, 0.4);
            color: #d1fae5; 
            font-weight: bold;
            border-left: 4px solid #10b981;
        }
        
        /* --- Content Styling --- */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* --- Control Styles (GRID ALIGNMENT) --- */
        .control-header {
            display: grid;
            grid-template-columns: 1fr auto; 
            align-items: center;
            width: 100%;
            color: #6ee7b7; /* text-green-300 */
        }
        
        .slider-width-fixed {
            width: 200px;
            max-width: 100%;
            display: block !important; 
            margin-left: auto !important;
            margin-right: auto !important;
        }
        
        .text-width-centered {
            width: 200px; 
            margin-left: auto; 
            margin-right: auto;
        }
        
        /* Other essential styles */
        #menuButton {
            position: fixed; 
            top: 1rem; 
            right: 1rem; 
            z-index: 30; 
            padding: 0.75rem; 
            color: #4ade80; 
            border-radius: 9999px; 
            border: 1px solid rgba(4, 120, 87, 0.5); 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            transition: all 150ms ease-in-out; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(17, 24, 39, 0.5); 
        }
        #menuButton:hover { 
            background-color: rgba(31, 41, 55, 0.7); 
        }

        .text-xl { font-size: 1.25rem; }
        .font-bold { font-weight: 700; }
        .text-green-400 { color: #4ade80; } 
        .text-green-100 { color: #d1fae5; } 
        .text-green-300 { color: #6ee7b7; }
        .space-y-6 > * + * { margin-top: 1.5rem; }
        
        #resetButton {
            width: 100%;
            padding: 0.5rem 1rem;
            background-color: rgba(185, 28, 28, 0.5);
            color: #fff;
            border-radius: 0.5rem;
            border: 1px solid rgba(239, 68, 68, 0.5);
            transition: background-color 0.15s;
        }
        #resetButton:hover { 
            background-color: rgba(220, 38, 38, 0.7); 
        }
        
        /* Apply Button Style */
        .apply-layout-button {
            width: 100%;
            padding: 0.75rem 1rem;
            margin-top: 1.5rem;
            background-color: rgba(4, 120, 87, 0.8);
            color: #fff;
            font-weight: bold;
            border-radius: 0.5rem;
            border: 1px solid rgba(6, 95, 70, 1.0);
            transition: background-color 0.15s;
        }
        .apply-layout-button:hover {
            background-color: rgba(6, 95, 70, 0.9);
        }


        /* Slider/Color Picker Specific Styles */
        .range-lg { height: 0.5rem; background-color: #374151; border-radius: 0.5rem; }
        .accent-green-500 { accent-color: #10b981; }
        .color-picker-input {
            height: 3rem; 
            border: 1px solid rgba(4, 120, 87, 0.5); 
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: transparent;
            appearance: none;
            padding: 0;
            overflow: hidden; 
        }
        .color-picker-input::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-input::-webkit-color-swatch { border: none; border-radius: 0.4rem; }
        .color-picker-input::-moz-color-swatch { border: none; border-radius: 0.4rem; }
        
        .bg-green-700\/50 { background-color: rgba(4, 120, 87, 0.5); }
        
        /* Checkbox specific styles */
        .control-checkbox {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0.5rem 0; 
        }

        .toggle-switch-input {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: #10b981;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-black">
    <canvas id="matrixCanvas"></canvas>

    <button id="menuButton" class="fixed top-4 right-4 z-30 p-3">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0-.33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l-.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </button>
    
    <div id="settingsPanel" class="translate-x-full">
        
        <div id="panelHeader">
            <h2 class="text-xl font-bold text-green-400">Digital Rain Settings</h2>
        </div>
        
        <div id="navTabs">
            </div>

        <div id="contentArea">
            <div id="controlsContainer">
                </div>
        </div>

        <div id="panelFooter">
            <button id="resetButton">
                Reset to Default Settings
            </button>
        </div>
    </div>

    <script>
        // --- DEBUG FLAGS ---
        const SINGLE_STREAM_DEBUG = false; 
        
        // --- Fixed Constants ---
        const ROTATOR_FADE_FRAMES = 10; 
        const STORAGE_KEY = 'matrixRainSettingsV2.3'; // Updated storage key for changes
        const MIN_CLEAR_ROWS_FOR_START = 40; 
        const CHARS = 'カサタナハヤラワキシチニヒミリウクヌフムケセテメオコソホヲ01245789:+=<>.*';
        const CHARS_LENGTH = CHARS.length; 
        
        // --- Proportional Scaling Constant ---
        const BASE_FONT_SIZE = 36;
        const BASE_TRACER_SIZE_INCREASE = 8;
        const TRACER_SIZE_RATIO = BASE_TRACER_SIZE_INCREASE / BASE_FONT_SIZE;

        // --- Settings Configuration ---
        const DEFAULT_SETTINGS = {
            streamSpeed: 14,              
            tracerSizeIncrease: 8,        
            tracerGlow: 20,              
            trailGlow: 28,                
            streamMaxLength: 140,         
            streamMinLength: 50,          
            decayDelayRows: 40,           
            decayFadeDurationFrames: 36,  
            holeRate: 0.15,               
            rotatorChance: 0.125,         
            rotatorCycleFactor: 15,       
            rotatorCrossfadeFrames: 8, 
            streamColor: '#00ff00',       
            tracerColor: '#ffffff', 
            clearAlpha: 0.90, 
            tracerFadeInFrames: 3,         
            tracerColorFadeFrames: 5,
            fontSize: 24,                 
            cellSpacingFactor: 0.95,      
            horizontalSpacingFactor: 1.15, 
            
            // --- NEW: Variable Brightness Settings ---
            variableBrightnessEnabled: false,
            brightnessVariance: 15, // Default variance is 15% (range 85% to 100%)
        };
        
        const CONTROL_DEFINITIONS = [
            // --- Code Appearance ---
            { id: 'streamColor', label: 'Code Color', type: 'color', category: 'Code Appearance', description: 'Sets the primary color of the main code trails.' }, 
            { 
                id: 'variableBrightnessEnabled', 
                label: 'Variable Brightness', 
                type: 'checkbox', 
                category: 'Code Appearance', 
                description: 'If enabled, the code trail characters will have slightly varied brightness.' 
            },
            { 
                id: 'brightnessVariance', 
                label: 'Variance', 
                type: 'range', 
                min: 5, 
                max: 90, 
                step: 5, 
                unit: '%', 
                transform: val => Math.round(val) + '%', 
                category: 'Code Appearance', 
                description: 'The maximum percentage by which the brightness of a character can be reduced. (e.g., 15% variance means brightness ranges from 85% to 100%.)',
                dependency: 'variableBrightnessEnabled' // Custom property for conditional display
            },
            { id: 'streamSpeed', label: 'Code Speed', type: 'range', min: 1, max: 20, step: 1, unit: '', transform: val => Math.round(val), category: 'Code Appearance', description: 'Controls how fast the characters move down the screen. Higher is faster (1-20).' },
            { id: 'trailGlow', label: 'Code Blur', type: 'range', min: 0, max: 30, step: 1, unit: 'px', transform: val => Math.round(val) + 'px', category: 'Code Appearance', description: 'Controls the blur and glow effect around the main code trail.' }, 
            { 
                id: 'clearAlpha', 
                label: 'Blur Transparency', 
                type: 'range', 
                min: 0.00, 
                max: 1.0,  
                step: 0.01, 
                unit: '', 
                transform: val => val.toFixed(2), 
                category: 'Code Appearance',
                description: 'Determines how quickly the old characters fade away. Lower values increase the visible trail blur.'
            },
            { id: 'streamMinLength', label: 'Min Code Length', type: 'range', min: 10, max: 300, step: 10, unit: '', transform: val => Math.round(val), category: 'Code Appearance', description: 'The shortest stream of characters that can start on the screen (in rows).' },
            { id: 'streamMaxLength', label: 'Max Code Length', type: 'range', min: 10, max: 300, step: 10, unit: '', transform: val => Math.round(val), category: 'Code Appearance', description: 'The longest stream of characters that can start on the screen (in rows).' },
            { 
                id: 'decayDelayRows', 
                label: 'Code Eraser Delay', 
                type: 'range', 
                min: 1, 
                max: 250, 
                step: 1, 
                unit: '', 
                transform: val => Math.round(val), 
                category: 'Code Appearance',
                description: 'The distance (in rows) the bright tracer travels before the fading trail starts.' 
            },
            { 
                id: 'decayFadeDurationFrames', 
                label: 'Code Fade Duration', 
                type: 'range', 
                min: 1, 
                max: 120, 
                step: 1, 
                unit: ' frames', 
                transform: val => Math.round(val) + ' frames', 
                category: 'Code Appearance',
                description: 'How long characters take to completely fade out after the eraser trail starts.' 
            },
            { id: 'holeRate', label: 'Blank Spaces Rate', type: 'range', min: 0.05, max: 0.5, step: 0.05, unit: '', transform: val => (val * 100).toFixed(0) + '%', category: 'Code Appearance', description: 'The chance that a spot in the stream will be blank instead of a character.' }, 
            
            // --- Tracers ---
            { id: 'tracerColor', label: 'Lead Tracer Color', type: 'color', category: 'Tracers', description: 'Sets the color of the bright leading character (the "tracer").' }, 
            { id: 'tracerSizeIncrease', label: 'Tracer Bold Size', type: 'range', min: 0, max: 20, step: 1, unit: 'px', transform: val => Math.round(val) + 'px', category: 'Tracers', description: 'How much larger the leading character is compared to the rest of the stream.' },
            { id: 'tracerGlow', label: 'Tracer Blur', type: 'range', min: 0, max: 50, step: 5, unit: 'px', transform: val => Math.round(val) + 'px', category: 'Tracers', description: 'Controls the blur and glow effect specifically for the leading character.' }, 
            { id: 'tracerFadeInFrames', label: 'Tracer Fade-in Time', type: 'range', min: 1, max: 10, step: 1, unit: ' frames', transform: val => Math.round(val) + ' frames', category: 'Tracers', description: 'Frames it takes for the tracer to reach full brightness.' },
            { id: 'tracerColorFadeFrames', label: 'Tracer Fade-to-Color Time', type: 'range', min: 1, max: 20, step: 1, unit: ' frames', transform: val => Math.round(val) + ' frames', category: 'Tracers', description: 'Duration over which the tracer fades from white to the stream color.' }, 
            
            // --- Rotators ---
            { id: 'rotatorChance', label: 'Rotator Chance', type: 'range', min: 0, max: 0.2, step: 0.005, unit: '', transform: val => (val * 100).toFixed(1) + '%', category: 'Rotators', description: 'The probability that a character will randomly change to a different character over time.' },
            { 
                id: 'rotatorCycleFactor', 
                label: 'Rotator Cycle Speed', 
                type: 'range', 
                min: 1, 
                max: 20, 
                step: 1, 
                unit: '', 
                transform: val => {
                    const calculatedFrames = Math.round(60 - (val * 2.5));
                    const finalFrames = Math.max(ROTATOR_FADE_FRAMES, calculatedFrames);
                    return `Every ${finalFrames} frames`;
                },
                category: 'Rotators',
                description: 'The frequency at which the rotator characters will attempt to change to a new symbol.'
            },
            { 
                id: 'rotatorCrossfadeFrames', 
                label: 'Crossfade Duration', 
                type: 'range', 
                min: 1, 
                max: 30, 
                step: 1, 
                unit: ' frames', 
                transform: val => Math.round(val) + ' frames', 
                category: 'Rotators',
                description: 'How long the new character takes to smoothly fade in over the old character.'
            },
            
            // --- Layout ---
            { id: 'fontSize', label: 'Font Size', type: 'range', min: 10, max: 50, step: 1, unit: 'px', transform: val => Math.round(val) + 'px', category: 'Layout', description: 'Sets the pixel height of the displayed characters. Affects grid density.' },
            { 
                id: 'horizontalSpacingFactor', 
                label: 'Horizontal Spacing', 
                type: 'range', 
                min: 0.5, 
                max: 1.5, 
                step: 0.05, 
                unit: ' Factor', 
                transform: val => val.toFixed(2), 
                category: 'Layout', 
                description: 'Controls the horizontal gap between streams. Lower values increase stream density.' 
            },
            { 
                id: 'cellSpacingFactor', 
                label: 'Vertical Spacing', 
                type: 'range', 
                min: 0.8, 
                max: 1.5, 
                step: 0.01, 
                unit: ' Factor', 
                transform: val => val.toFixed(2), 
                category: 'Layout', 
                description: 'Controls the vertical gap between characters. Lower values increase trail density.' 
            },
        ];
        
        const categoryOrder = ['Code Appearance', 'Tracers', 'Rotators', 'Layout'];


        // --- Global State ---
        let currentSettings = {};
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        
        let totalRows = 0;
        let totalCols = 0;
        let frameCounter = 0; 
        
        let matrixManager = null; 

        // --- Utility Functions ---
        
        const getRandomChar = () => CHARS.charAt(Math.floor(Math.random() * CHARS_LENGTH));
        const getUniqueRandomChar = (excludeChar) => {
            let newChar;
            do {
                newChar = getRandomChar();
            } while (newChar === excludeChar);
            return newChar;
        };
        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        function hexToRgb(hex) {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 255, b: 0 };
        }

        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(currentSettings));
            } catch (error) {
                console.error('Could not save settings to localStorage:', error);
            }
        }

        function loadSettings() {
            try {
                const storedSettings = localStorage.getItem(STORAGE_KEY);
                if (storedSettings) {
                    const loaded = JSON.parse(storedSettings);
                    currentSettings = { ...DEFAULT_SETTINGS, ...loaded };
                } else {
                    currentSettings = { ...DEFAULT_SETTINGS };
                }
            } catch (error) {
                console.error('Could not load settings from localStorage. Using defaults.', error);
                currentSettings = { ...DEFAULT_SETTINGS };
            }
        }

        /** Synchronizes tracerSizeIncrease proportionally to newFontSize */
        function syncTracerSize(newFontSize) {
            const newTracerSize = Math.round(newFontSize * TRACER_SIZE_RATIO);
            currentSettings.tracerSizeIncrease = newTracerSize;
            
            // Update the control panel display
            const tracerDef = CONTROL_DEFINITIONS.find(d => d.id === 'tracerSizeIncrease');
            if (tracerDef) {
                const tracerInput = document.getElementById('tracerSizeIncrease');
                const tracerValueSpan = document.getElementById('tracerSizeIncreaseValue');
                if (tracerInput && tracerValueSpan) {
                    tracerInput.value = newTracerSize; 
                    updateValueDisplay(tracerDef, newTracerSize, tracerInput, tracerValueSpan); 
                }
            }
        }
        
        /** Calculates derived settings and applies global canvas properties. */
        function applySettings(settings) {
            const oldWritingCycles = settings.WRITING_CYCLES;
            
            // --- 1. Calculate New Derived Settings ---
            settings.WRITING_CYCLES = 21 - settings.streamSpeed; 
            
            let calculatedRotatorFrames = Math.round(60 - (settings.rotatorCycleFactor * 2.5));
            settings.ROTATOR_CHANGE_CYCLE = Math.max(ROTATOR_FADE_FRAMES, calculatedRotatorFrames);

            settings.MAX_STREAM_HEAD_LENGTH = settings.streamMaxLength;
            settings.TRAIL_LENGTH_ROWS = settings.decayDelayRows;
            settings.FADE_OUT_DURATION = settings.decayFadeDurationFrames; 
            
            // --- LAYOUT CALCULATIONS (ONLY CALCULATION) ---
            settings.FONT_SIZE = settings.fontSize; 
            settings.CELL_WIDTH = settings.FONT_SIZE / settings.horizontalSpacingFactor; 
            settings.CELL_HEIGHT = settings.CELL_WIDTH * settings.cellSpacingFactor; 
            
            settings.MAX_RELEASES_PER_TICK = 4;
            settings.RELEASE_INTERVAL_ROWS = 5;
            settings.RELEASE_INTERVAL_FRAMES = settings.WRITING_CYCLES * settings.RELEASE_INTERVAL_ROWS; 
            
            // --- OPTIMIZATION: Cache RGB values ---
            settings.streamRgb = hexToRgb(settings.streamColor);
            settings.tracerRgb = hexToRgb(settings.tracerColor);
            
            // --- 2. Apply Global Canvas Styles (General appearance/speed) ---
            ctx.shadowColor = settings.streamColor;
            ctx.font = `bold ${settings.FONT_SIZE}px 'Inter', monospace`; 
            
            // --- 3. Synchronize Elements (Non-Layout changes) ---
            if (matrixManager) {
                // This updates speed/color/length settings without grid change
                matrixManager.updateActiveElements(oldWritingCycles); 
                matrixManager.settings = settings; 
            }

            saveSettings(); 
        }

        // --- Cell, Stream, MatrixManager Classes ---
        class Cell { 
            constructor() {
                this.char = getRandomChar(); 
                this.nextChar = getRandomChar(); 
                this.state = 0; 
                this.decayAge = 0; 
                this.isRotator = false; 
                this.rotationProgress = 0; 
                this.brightnessFactor = undefined; // NEW: Stores static brightness for the cell's lifetime
            }

            age(settings) { 
                if (this.state > 0 && this.state < settings.WRITING_CYCLES) {
                    this.state++;
                } else if (this.state === settings.WRITING_CYCLES) {
                    this.state = 0; 
                }

                if (this.decayAge >= 2 && this.decayAge <= settings.FADE_OUT_DURATION + 1) {
                    this.decayAge++;
                } else if (this.decayAge > settings.FADE_OUT_DURATION + 1) {
                    this.decayAge = 0; 
                    this.brightnessFactor = undefined; // Reset factor when fully dead
                }
                // Rotator logic handled in MatrixManager.ageGrid to coordinate the crossfade cycle
            }
        }


        class Stream { 
            constructor(xIndex, manager) { 
                this.xIndex = xIndex;
                this.manager = manager; 
                this.yIndex = -1; 
                this.framesSinceAdvance = 0; 
                this.writtenCount = 0;
                this.isActive = false; 
                this.delayCounter = randomInt(20, 500);
                this.framesSinceLastActivity = 0; 
                this.length = 0; 
                this.trailPattern = this.generateTrailPattern(); 
                this.decayYIndex = -1; 
                this.decayFramesSinceAdvance = 0;
                this.isDecayTracerInitialized = false;
            }
            generateTrailPattern() { 
                const settings = this.manager.settings;
                const userMinLength = settings.streamMinLength;
                const userMaxLength = settings.MAX_STREAM_HEAD_LENGTH;
                const minBound = Math.min(userMinLength, userMaxLength);
                const maxBound = userMaxLength;
                const screenHeight = this.manager.totalRows;
                let streamLength = randomInt(minBound, maxBound);
                const requiredMinLengthToClearScreen = screenHeight;
                if (streamLength < requiredMinLengthToClearScreen) {
                    const requiredLengthWithBuffer = requiredMinLengthToClearScreen + randomInt(1, 10);
                    streamLength = Math.min(requiredLengthWithBuffer, maxBound);
                }
                this.length = streamLength;
                const trailIndices = new Set();
                for (let i = 0; i < this.length; i++) {
                    if (Math.random() > settings.holeRate) {
                        trailIndices.add(i);
                    }
                }
                return trailIndices;
            }
            resetForNextRun() { 
                this.yIndex = -1;
                this.trailPattern = this.generateTrailPattern(); 
                this.isActive = false; 
                this.framesSinceAdvance = 0; 
                this.writtenCount = 0;
                this.delayCounter = randomInt(100, 300); 
                this.decayYIndex = -1;
                this.decayFramesSinceAdvance = 0;
                this.isDecayTracerInitialized = false; 
            }
            start() { 
                this.yIndex = -1; 
                this.writtenCount = 0;
                this.trailPattern = this.generateTrailPattern(); 
                this.consumeLeadingHoles(); 
                this.isActive = true; 
                this.delayCounter = 0;
                this.framesSinceLastActivity = 0;
            }
            consumeLeadingHoles() { 
                while (this.writtenCount < this.length && !this.trailPattern.has(this.writtenCount)) {
                    this.writtenCount++;
                }
            }
            checkAndReset() { 
                if (!this.isActive) return false;
                const totalRows = this.manager.totalRows;
                const headOffScreen = this.yIndex >= totalRows;
                const writingComplete = (this.writtenCount >= this.length);
                if (this.isDecayTracerInitialized) {
                    const decayOffScreen = (this.decayYIndex >= totalRows); 
                    if (decayOffScreen) {
                        this.resetForNextRun();
                        return true;
                    }
                } else {
                    if (writingComplete && headOffScreen) {
                        this.resetForNextRun();
                        return true;
                    }
                }
                return false;
            }
            update() { 
                if (SINGLE_STREAM_DEBUG && this.xIndex !== 0) return;
                if (this.checkAndReset()) return; 
                const settings = this.manager.settings;
                if (!this.isActive) {
                    this.framesSinceLastActivity++; 
                    if (this.delayCounter > 0) {
                        this.delayCounter--;
                    }
                    return; 
                }
                if (this.isActive) {
                    this.framesSinceAdvance++;
                    this.decayFramesSinceAdvance++;
                    const isDecayDelayReached = this.writtenCount >= settings.TRAIL_LENGTH_ROWS;
                    if (!this.isDecayTracerInitialized && isDecayDelayReached) {
                        this.decayYIndex = this.yIndex - settings.TRAIL_LENGTH_ROWS;
                        this.isDecayTracerInitialized = true;
                    }
                    if (this.isDecayTracerInitialized && this.framesSinceAdvance % settings.WRITING_CYCLES === 0) {
                        this.decayYIndex++;
                        const dy = this.decayYIndex;
                        const x = this.xIndex;
                        if (dy >= 0 && dy < this.manager.totalRows) {
                            const cell = this.manager.grid[dy][x];
                            if (cell.decayAge === 1) { 
                                cell.decayAge = 2; 
                            }
                        }
                    }
                    if (this.framesSinceAdvance % settings.WRITING_CYCLES === 0) {
                        this.framesSinceAdvance = 0; 
                        const isWritingContent = this.writtenCount < this.length; 
                        this.yIndex++; 
                        const y = this.yIndex;
                        const x = this.xIndex;
                        const isCharAtY = isWritingContent && this.trailPattern.has(this.writtenCount); 
                        if (y >= 0 && y < this.manager.totalRows) {
                            const cell = this.manager.grid[y][x];
                            const skipPersistentTrail = settings.TRAIL_LENGTH_ROWS > this.length;
                            if (isCharAtY) {
                                cell.state = 1; 
                                cell.decayAge = skipPersistentTrail ? 2 : 1; 
                                cell.char = cell.nextChar;
                                cell.nextChar = getUniqueRandomChar(cell.char); 
                                cell.isRotator = Math.random() < settings.rotatorChance;
                                cell.brightnessFactor = undefined; // Ensure new cell gets a new brightness factor
                            } else {
                                if (cell.decayAge > 0) {
                                   cell.decayAge = 2; 
                                }
                                cell.state = 0; 
                            }
                        }
                        if (isWritingContent) { 
                            this.writtenCount++; 
                        }
                    }
                }
            }
        }


        class MatrixManager { 
            constructor(settings, totalRows, totalCols) { 
                this.settings = settings;
                this.totalRows = totalRows;
                this.totalCols = totalCols;
                this.grid = [];
                this.streams = [];
                this.timeToNextRelease = 0; 
                this.releasesLeftInCurrentTick = { value: 0 }; 
                this.frameCounter = 0; 
                this.initializeGrid();
                this.initializeStreams();
            }
            initializeGrid() { 
                this.grid = [];
                for (let y = 0; y < this.totalRows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.totalCols; x++) {
                        this.grid[y][x] = new Cell(); 
                    }
                }
            }
            initializeStreams() { 
                this.streams = [];
                for (let x = 0; x < this.totalCols; x++) {
                    this.streams.push(new Stream(x, this)); 
                }
                this.timeToNextRelease = 0; 
            }
            updateActiveElements(oldWritingCycles) { 
                this.streams.forEach(stream => {
                    if (!stream.isActive && oldWritingCycles !== undefined && oldWritingCycles > 0) {
                        const cycleRatio = this.settings.WRITING_CYCLES / oldWritingCycles;
                        stream.delayCounter = Math.max(1, Math.round(stream.delayCounter * cycleRatio));
                    }
                    stream.length = randomInt(this.settings.streamMinLength, this.settings.MAX_STREAM_HEAD_LENGTH); 
                });
            }
            isColumnClearForStart(xIndex) { 
                const checkRows = Math.min(this.totalRows, MIN_CLEAR_ROWS_FOR_START);
                if (this.totalRows === 0) return true;
                for (let y = 0; y < checkRows; y++) {
                    if (this.grid[y][xIndex].decayAge > 0) {
                        return false;
                    }
                }
                return true;
            }
            updateFrame(currentFrameCounter) { 
                this.frameCounter = currentFrameCounter; 
                const settings = this.settings;
                if (this.timeToNextRelease > 0) {
                    this.timeToNextRelease--;
                } else {
                    this.releasesLeftInCurrentTick.value = settings.MAX_RELEASES_PER_TICK;
                    this.timeToNextRelease = settings.RELEASE_INTERVAL_FRAMES;
                }
                this.streams.forEach(stream => {
                    stream.update(); 
                });
                if (this.releasesLeftInCurrentTick.value > 0) {
                    let readyStreams = this.streams.filter(s => !s.isActive && s.delayCounter <= 0);
                    readyStreams.sort((a, b) => {
                        const priorityDiff = b.framesSinceLastActivity - a.framesSinceLastActivity;
                        if (priorityDiff !== 0) { return priorityDiff; }
                        return Math.random() - 0.5;
                    });
                    let startedCount = 0;
                    for (const stream of readyStreams) {
                        if (startedCount >= this.releasesLeftInCurrentTick.value) break;
                        if (this.isColumnClearForStart(stream.xIndex)) {
                            stream.start(); 
                            startedCount++;
                        } else {
                             stream.delayCounter = randomInt(50, 150); 
                        }
                    }
                    this.releasesLeftInCurrentTick.value -= startedCount;
                }
                this.ageGrid(this.frameCounter);
            }
            ageGrid(frameCounter) { 
                const settings = this.settings;
                const rotationCyclePeriod = settings.ROTATOR_CHANGE_CYCLE; 
                const cyclePhase = frameCounter % rotationCyclePeriod;
                const flickerStartPhase = rotationCyclePeriod - settings.rotatorCrossfadeFrames; 
                
                for (let y = 0; y < this.totalRows; y++) {
                    for (let x = 0; x < this.totalCols; x++) {
                        const cell = this.grid[y][x];
                        
                        let cellAboveIsFading = false;
                        if (y > 0) {
                            if (this.grid[y - 1][x].decayAge >= 2) { 
                                cellAboveIsFading = true;
                            }
                        }
                        
                        if (cell.isRotator) {
                            const rotationDuration = settings.rotatorCrossfadeFrames;
                            if (cell.rotationProgress === 0) {
                                const isTrailActiveAndBright = cell.state > 0 || cell.decayAge === 1;
                                if (cyclePhase === flickerStartPhase && isTrailActiveAndBright && !cellAboveIsFading) {
                                    cell.rotationProgress = 1; 
                                    
                                    // *** FIX FOR ROTATOR CYCLE: Only set the NEXT target character. ***
                                    // The visible character (cell.char) is the old one, and drawGrid uses cell.nextChar
                                    // as the new character to fade in.
                                    cell.nextChar = getUniqueRandomChar(cell.char); 
                                }
                            } else {
                                cell.rotationProgress++;
                                if (cell.rotationProgress > rotationDuration) {
                                    // When crossfade finishes, the new character becomes the permanent cell.char.
                                    cell.char = cell.nextChar; 
                                    
                                    // Then, reset and prepare for the next rotation cycle.
                                    cell.nextChar = getUniqueRandomChar(cell.char); 
                                    cell.rotationProgress = 0; 
                                }
                            }
                        }
                    }
                }
                
                // Age all cells after handling rotations
                for (let y = 0; y < this.totalRows; y++) {
                    for (let x = 0; x < this.totalCols; x++) {
                        this.grid[y][x].age(settings); 
                    }
                }
            }
        }


        // --- Rendering Logic (updated getCharColor) ---

        function getCharColor(cell, finalOpacityMod = 1.0) { 
            const settings = currentSettings;
            
            // --- NEW BRIGHTNESS VARIANCE LOGIC ---
            let varianceMod = 1.0;
            if (settings.variableBrightnessEnabled) {
                // Calculate min opacity based on variance percentage (e.g., 15% variance -> 0.85 min opacity)
                const variance = settings.brightnessVariance / 100;
                const minOpacity = 1.0 - variance; 
                
                const isActiveOrFading = cell.state > 0 || cell.decayAge === 1;

                if (isActiveOrFading) {
                    // Initialize or reuse a static brightness factor for the cell's lifespan
                    if (typeof cell.brightnessFactor !== 'number') {
                        // Math.random() generates a static-per-cell-lifespan modifier between minOpacity and 1.0
                        cell.brightnessFactor = minOpacity + (Math.random() * variance);
                    }
                }
                
                if (typeof cell.brightnessFactor === 'number') {
                    varianceMod = cell.brightnessFactor;
                }
            } else {
                // Ensure factor is ignored if feature is disabled (though it should be reset by Cell.age)
                cell.brightnessFactor = undefined; 
            }
            // --- END NEW BRIGHTNESS VARIANCE LOGIC ---


            const combinedOpacityMod = finalOpacityMod * varianceMod;
            let currentOpacity = 0;
            let finalRgb = { r: 0, g: 0, b: 0 };


            if (cell.state > 0) {
                // Tracer Head Logic
                const streamRgb = settings.streamRgb;
                const tracerRgb = settings.tracerRgb; 
                finalRgb = { r: tracerRgb.r, g: tracerRgb.g, b: tracerRgb.b };
                const FADE_IN_END = settings.tracerFadeInFrames;
                const COLOR_TRANSITION_START = settings.WRITING_CYCLES - settings.tracerColorFadeFrames;
                const trailStartOpacity = 0.95;

                if (cell.state <= FADE_IN_END) { 
                    const safeFadeIn = Math.max(1, FADE_IN_END);
                    currentOpacity = cell.state / safeFadeIn; 
                } else if (cell.state >= COLOR_TRANSITION_START && cell.state <= settings.WRITING_CYCLES) {
                    const transitionDuration = settings.WRITING_CYCLES - COLOR_TRANSITION_START;
                    const safeDuration = Math.max(1, transitionDuration); 
                    let transitionFactor = (cell.state - COLOR_TRANSITION_START) / safeDuration; 
                    transitionFactor = Math.min(1.0, Math.max(0.0, transitionFactor)); 
                    const r = Math.round(tracerRgb.r + (streamRgb.r - tracerRgb.r) * transitionFactor);
                    const g = Math.round(tracerRgb.g + (streamRgb.g - tracerRgb.g) * transitionFactor);
                    const b = Math.round(tracerRgb.b + (streamRgb.b - tracerRgb.b) * transitionFactor);
                    finalRgb = { r, g, b };
                    currentOpacity = 1.0 - ((1.0 - trailStartOpacity) * transitionFactor);
                } else { 
                    currentOpacity = 1.0;
                }

                return `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${currentOpacity * combinedOpacityMod})`;
            }

            if (cell.decayAge === 1) { 
                // Persistent Trail Logic
                finalRgb = settings.streamRgb;
                currentOpacity = 0.95;
                return `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${currentOpacity * combinedOpacityMod})`;
            }

            if (cell.decayAge >= 2) { 
                // Fading Trail Logic
                finalRgb = settings.streamRgb;
                const fadeAge = cell.decayAge - 2; 
                const fadeDuration = settings.FADE_OUT_DURATION;
                let finalOpacity = 0.95 * (1 - (fadeAge / fadeDuration));
                finalOpacity = Math.max(0, finalOpacity);
                currentOpacity = finalOpacity;
                return `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${currentOpacity * combinedOpacityMod})`;
            }

            return 'rgba(0, 0, 0, 0)'; 
        }

        function drawChar(char, x, y, currentFontSize, cell, finalOpacityMod = 1.0) {
            const settings = currentSettings;
            const xCenter = x * settings.CELL_WIDTH + settings.CELL_WIDTH / 2;
            
            let yAdjustment = 0;
            yAdjustment = (settings.CELL_HEIGHT - settings.FONT_SIZE) / 2; 

            const yCenter = y * settings.CELL_HEIGHT + settings.FONT_SIZE - yAdjustment;
            
            ctx.font = `bold ${currentFontSize}px 'Inter', monospace`; 

            let finalColor = getCharColor(cell, finalOpacityMod);
            ctx.fillStyle = finalColor;

            ctx.fillText(char, xCenter, yCenter);
        }

        function drawGrid() { 
            const settings = currentSettings;
            const grid = matrixManager.grid; 
            
            // PASS 1: Trail and Fading Cells
            ctx.shadowBlur = settings.trailGlow;
            let currentFontSize = settings.FONT_SIZE;
            
            for (let y = 0; y < totalRows; y++) {
                for (let x = 0; x < totalCols; x++) {
                    const cell = grid[y][x];
                    
                    // Don't draw the tracer head in this pass
                    if (cell.state > 0) continue; 

                    // Rotator crossfade logic
                    if (cell.isRotator && cell.decayAge > 0 && cell.rotationProgress > 0) {
                        const rotationDuration = settings.rotatorCrossfadeFrames;
                        const progress = cell.rotationProgress;
                        const fadeProgress = Math.min(1.0, progress / rotationDuration);
                        const oldCharOpacityMod = Math.max(0.0, 1.0 - fadeProgress); 
                        drawChar(cell.char, x, y, currentFontSize, cell, oldCharOpacityMod);
                        const newCharOpacityMod = Math.min(1.0, fadeProgress); 
                        drawChar(cell.nextChar, x, y, currentFontSize, cell, newCharOpacityMod);
                        continue; 
                    }
                    
                    if (cell.decayAge > 0) {
                        drawChar(cell.char, x, y, currentFontSize, cell, 1.0);
                    }
                }
            }

            // PASS 2: Tracer Heads (Drawn over everything else, no opacity mods needed here)
            ctx.shadowBlur = settings.tracerGlow;

            for (let y = 0; y < totalRows; y++) {
                for (let x = 0; x < totalCols; x++) {
                    const cell = grid[y][x];
                    
                    if (cell.state > 0) {
                        currentFontSize = settings.FONT_SIZE + settings.tracerSizeIncrease; 
                        drawChar(cell.char, x, y, currentFontSize, cell, 1.0); // Pass 1.0 to ensure the tracer is always max opacity (as per Matrix standard)
                    }
                }
            }
            ctx.shadowBlur = 0;
        }


        // --- Initialization and Animation Loop ---

        function reinitializeOnLayoutChange() {
             // 1. CRITICAL FIX: Update the canvas context font property FIRST.
            currentSettings.FONT_SIZE = currentSettings.fontSize; 
            ctx.font = `bold ${currentSettings.FONT_SIZE}px 'Inter', monospace`; 
            
             // 2. Calculate the new derived layout settings
            currentSettings.CELL_WIDTH = currentSettings.FONT_SIZE / currentSettings.horizontalSpacingFactor; 
            currentSettings.CELL_HEIGHT = currentSettings.CELL_WIDTH * currentSettings.cellSpacingFactor; 

            // 3. Recalculate grid dimensions to fill the canvas
            totalCols = Math.floor(canvas.width / currentSettings.CELL_WIDTH);
            totalRows = Math.floor(canvas.height / currentSettings.CELL_HEIGHT);
            
            // 4. Re-initialize the manager (New grid, new streams, new cell sizes)
            matrixManager = new MatrixManager(currentSettings, totalRows, totalCols);
            
            // 5. Update drawing context
            ctx.shadowColor = currentSettings.streamColor;
            
            saveSettings();
        }

        function initializeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // This function is only called on initial load and window resize.
            
            // Ensure FONT_SIZE property is correctly set before dimension calculation
            currentSettings.FONT_SIZE = currentSettings.fontSize; 
            ctx.font = `bold ${currentSettings.FONT_SIZE}px 'Inter', monospace`; 

            // Recalculate cell sizes based on current settings
            currentSettings.CELL_WIDTH = currentSettings.FONT_SIZE / currentSettings.horizontalSpacingFactor; 
            currentSettings.CELL_HEIGHT = currentSettings.CELL_WIDTH * currentSettings.cellSpacingFactor; 

            // Recalculate grid dimensions to fill the canvas
            totalCols = Math.floor(canvas.width / currentSettings.CELL_WIDTH);
            totalRows = Math.floor(canvas.height / currentSettings.CELL_HEIGHT);
            
            // Only re-initialize the manager if dimensions actually changed or if it's the first run
            if (!matrixManager || matrixManager.totalRows !== totalRows || matrixManager.totalCols !== totalCols) {
                matrixManager = new MatrixManager(currentSettings, totalRows, totalCols);
            } else {
                matrixManager.settings = currentSettings; 
            }
            
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle'; 
            ctx.shadowColor = currentSettings.streamColor; 
        }
        
        function animate() { 
            const settings = currentSettings;
            frameCounter++; 
            
            ctx.fillStyle = 'rgba(0, 0, 0, ' + settings.clearAlpha + ')'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            matrixManager.updateFrame(frameCounter);

            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);

            drawGrid(); 
            
            ctx.restore(); 

            requestAnimationFrame(animate);
        }
        
        // --- Control Panel Logic ---
        const panel = document.getElementById('settingsPanel');
        const menuButton = document.getElementById('menuButton');
        const resetButton = document.getElementById('resetButton');
        const navTabs = document.getElementById('navTabs');
        const controlsContainer = document.getElementById('controlsContainer');
        
        // Dependency helper function
        function toggleDependencyControl(dependencyId, dependencyValue) {
            const dependentControls = CONTROL_DEFINITIONS.filter(d => d.dependency === dependencyId);
            dependentControls.forEach(def => {
                const controlElement = document.getElementById(`${def.id}-container`);
                if (controlElement) {
                    controlElement.style.display = dependencyValue ? 'flex' : 'none';
                }
            });
        }

        // Min/Max Stream Length dependency management 
        function updateRelatedRangeLimits(changedId, newValue) { 
            const minControlDef = CONTROL_DEFINITIONS.find(d => d.id === 'streamMinLength');
            const maxControlDef = CONTROL_DEFINITIONS.find(d => d.id === 'streamMaxLength');
            const minInput = document.getElementById('streamMinLength');
            const maxInput = document.getElementById('streamMaxLength');
            if (!minInput || !maxInput) return; 
            
            const minValueSpan = document.getElementById('streamMinLengthValue');
            const maxValueSpan = document.getElementById('streamMaxLengthValue');

            if (changedId === 'streamMinLength') {
                const newMaxMin = Math.max(minControlDef.min, newValue);
                maxInput.min = newMaxMin;
                if (parseFloat(maxInput.value) < newMaxMin) {
                    currentSettings.streamMaxLength = newMaxMin;
                    maxInput.value = newMaxMin;
                    updateValueDisplay(maxControlDef, newMaxMin, maxInput, maxValueSpan);
                }
            } else if (changedId === 'streamMaxLength') {
                const newMinMax = Math.min(maxControlDef.max, newValue);
                minInput.max = newMinMax;
                if (parseFloat(minInput.value) > newMinMax) {
                    currentSettings.streamMinLength = newMinMax;
                    minInput.value = newMinMax;
                    updateValueDisplay(minControlDef, newMinMax, minInput, minValueSpan);
                }
            }
        }
        
        function togglePanel() {
            panel.classList.toggle('translate-x-full');
            menuButton.classList.toggle('bg-green-700/50');
            menuButton.classList.toggle('bg-gray-900/50'); 
        }

        function createControl(def) { 
            const container = document.createElement('div');
            container.className = 'flex flex-col space-y-1 mb-6'; 
            container.id = `${def.id}-container`; // Container ID for dependency toggling
            
            // Check for dependency and hide if necessary
            if (def.dependency) {
                if (!currentSettings[def.dependency]) {
                    container.style.display = 'none';
                }
            }

            // ALIGNMENT FIX: Use the dedicated CSS Grid class
            const labelContainer = document.createElement('div');
            labelContainer.className = 'control-header'; // Applies CSS Grid: 1fr | auto
            
            // 1. Create the Label (Left side)
            const label = document.createElement('label');
            label.textContent = def.label;
            label.setAttribute('for', def.id);
            if (def.description) {
                label.setAttribute('title', def.description); 
            }
            
            // 2. Create the Value Span (Right side, for range/color)
            const valueSpan = document.createElement('span');
            valueSpan.id = `${def.id}Value`; 
            valueSpan.className = 'font-bold text-green-100';

            
            let input;

            if (def.type === 'range') {
                labelContainer.appendChild(label);
                labelContainer.appendChild(valueSpan);
                container.appendChild(labelContainer);
                
                input = document.createElement('input');
                input.type = 'range';
                input.id = def.id;
                
                input.min = def.min;
                input.max = def.max;
                
                input.step = def.step;
                input.value = currentSettings[def.id];
                
                input.className = 'slider-width-fixed h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg accent-green-500';
                
                // Set initial min/max based on cross-dependencies
                if (def.id === 'streamMinLength') {
                    input.max = currentSettings.streamMaxLength;
                } else if (def.id === 'streamMaxLength') {
                    input.min = currentSettings.streamMinLength;
                }
                
                input.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    currentSettings[def.id] = val;
                    updateValueDisplay(def, val, e.target, valueSpan); 
                    
                    if (def.id === 'fontSize') {
                        syncTracerSize(val);
                    }
                    
                    if (def.id === 'streamMinLength' || def.id === 'streamMaxLength') {
                        updateRelatedRangeLimits(def.id, val);
                    }
                    
                    if (def.category !== 'Layout') {
                        applySettings(currentSettings); 
                    }
                };
                container.appendChild(input);

            } else if (def.type === 'color') {
                labelContainer.appendChild(label);
                labelContainer.appendChild(valueSpan);
                container.appendChild(labelContainer);
                
                input = document.createElement('input');
                input.type = 'color';
                input.id = def.id;
                input.value = currentSettings[def.id];
                
                input.className = 'color-picker-input slider-width-fixed'; 
                
                input.onchange = (e) => {
                    currentSettings[def.id] = e.target.value;
                    updateValueDisplay(def, currentSettings[def.id], e.target, valueSpan);
                    applySettings(currentSettings); 
                };
                container.appendChild(input);
            } else if (def.type === 'checkbox') {
                // Checkbox controls are special: they need to host the input alongside the label, and don't need the valueSpan/control-header.
                container.className = 'flex flex-col space-y-1 mb-6';
                
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'control-checkbox text-green-300';
                
                checkboxContainer.appendChild(label);
                
                input = document.createElement('input');
                input.type = 'checkbox';
                input.id = def.id;
                input.checked = currentSettings[def.id];
                input.className = 'toggle-switch-input';
                
                input.onchange = (e) => {
                    const checked = e.target.checked;
                    currentSettings[def.id] = checked;
                    applySettings(currentSettings); 
                    toggleDependencyControl(def.id, checked); // Toggle dependent controls visibility
                };
                
                checkboxContainer.appendChild(input);
                container.appendChild(checkboxContainer);
            }

            // INITIALIZATION FIX: Call updateValueDisplay using the direct reference to populate the span instantly
            if (def.type !== 'checkbox') {
                updateValueDisplay(def, currentSettings[def.id], input, valueSpan);
            }
            
            return container;
        }

        /**
         * Updates the text display and the input element's title/tooltip.
         * @param {object} def - The control definition.
         * @param {*} val - The current value.
         * @param {HTMLInputElement} inputElement - The input element (for range/color types).
         * @param {HTMLElement} valueSpanElement - The direct reference to the span element displaying the value.
         */
        function updateValueDisplay(def, val, inputElement, valueSpanElement) { 
            let displayValue = val;
            
            if (def.type === 'color') {
                displayValue = val.toUpperCase();
            } else if (def.transform) {
                displayValue = def.transform(val);
            } else {
                if (def.step >= 1 && typeof val === 'number') {
                    displayValue = Math.round(val);
                } else if (typeof val === 'number') {
                    displayValue = val;
                }
            }
            
            // This is the display value update - uses the direct reference
            if (valueSpanElement) {
                valueSpanElement.textContent = displayValue;
            }
            
            // Add native HTML tooltip for input elements
            if (inputElement) {
                inputElement.title = `${def.label}: ${displayValue}`;
            }
        }
        
        function populateControls() {
            const groupedControls = CONTROL_DEFINITIONS.reduce((acc, def) => {
                const category = def.category || 'General';
                if (!acc[category]) {
                    acc[category] = [];
                }
                acc[category].push(def);
                return acc;
            }, {});

            navTabs.innerHTML = '';
            controlsContainer.innerHTML = '';

            let firstTabId = '';

            categoryOrder.forEach((category, index) => {
                if (!groupedControls[category] || groupedControls[category].length === 0) return;

                const tabId = category.replace(/\s/g, ''); 
                if (index === 0) firstTabId = tabId;

                // 1. Create Navigation Button (Tab)
                const tabButton = document.createElement('button');
                tabButton.className = 'tab-button';
                tabButton.textContent = category;
                tabButton.dataset.target = tabId;
                tabButton.onclick = () => switchTab(tabId);
                navTabs.appendChild(tabButton);

                // 2. Create Content Section
                const contentDiv = document.createElement('div');
                contentDiv.id = tabId;
                contentDiv.className = 'tab-content space-y-6';

                const contentHeader = document.createElement('h3');
                contentHeader.className = 'text-xl font-bold text-green-300 border-b border-green-800/50 pb-1 mb-4';
                contentHeader.textContent = category;
                contentDiv.appendChild(contentHeader);


                // 3. Populate Controls in Content Section
                const controls = groupedControls[category];
                
                controls.sort((a, b) => {
                    if (a.type === 'color' && b.type !== 'color') return -1;
                    if (a.type !== 'color' && b.type === 'color') return 1;
                    return 0;
                });
                
                controls.forEach(def => {
                    contentDiv.appendChild(createControl(def));
                });
                
                // --- Add Apply Layout Button to Layout Tab ---
                if (category === 'Layout') {
                    const applyButton = document.createElement('button');
                    applyButton.className = 'apply-layout-button';
                    applyButton.textContent = 'Apply Layout Changes';
                    applyButton.onclick = reinitializeOnLayoutChange;
                    contentDiv.appendChild(applyButton);
                }

                controlsContainer.appendChild(contentDiv);
            });
            
            // Activate the first tab by default
            if (firstTabId) {
                switchTab(firstTabId);
            }
        }
        
        function switchTab(targetId) {
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            const targetButton = document.querySelector(`.tab-button[data-target="${targetId}"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }
            const targetContent = document.getElementById(targetId);
            if (targetContent) {
                 targetContent.classList.add('active');
            }
        }

        function resetSettings() {
            currentSettings = { ...DEFAULT_SETTINGS };
            applySettings(currentSettings); // Apply non-layout settings instantly
            reinitializeOnLayoutChange(); // Manually re-init for layout settings
            
            // Explicitly sync tracer size after reset to ensure the control bar is correct
            syncTracerSize(currentSettings.fontSize); 
            
            // Repopulate controls to refresh values and min/max linkages (and handle dependencies)
            populateControls(); 
            // Re-check dependencies after reset/populate
            toggleDependencyControl('variableBrightnessEnabled', currentSettings.variableBrightnessEnabled);
        }


        // --- Main Execution ---

        loadSettings(); 
        syncTracerSize(currentSettings.fontSize); 
        applySettings(currentSettings); 
        
        initializeCanvas();
        window.addEventListener('resize', initializeCanvas); 
        
        animate();
        
        populateControls();
        // Initial check for dependent controls visibility (needed for page load)
        toggleDependencyControl('variableBrightnessEnabled', currentSettings.variableBrightnessEnabled); 

        menuButton.addEventListener('click', togglePanel);
        resetButton.addEventListener('click', resetSettings);

    </script>
</body>
</html>
