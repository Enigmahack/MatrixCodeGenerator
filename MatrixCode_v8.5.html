<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain v8.5</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
:root {
    --bg-color: #000;
    --panel-bg: rgba(10, 12, 16, 0.96);
    --panel-border: rgba(34, 197, 94, 0.3);
    --text-main: #4ade80;
    --text-muted: #86efac;
    --accent: #22c55e;
    --accent-glow: rgba(34, 197, 94, 0.4);
    --danger: #ef4444;
    --info: #3b82f6; /* Preserved from existing */
    --warn: #f59e0b; /* Preserved from existing */
    --safe-top: env(safe-area-inset-top, 20px);
    --safe-right: env(safe-area-inset-right, 20px);
}
#fps-counter {
    position: fixed;
    top: 10px;
    left: 10px;
    color: var(--text-main);
    font-family: monospace;
    font-size: 14px;
    z-index: 10000; /* Ensure it is above the canvas */
    text-shadow: 0 0 5px var(--accent-glow);
    padding: 2px 5px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    user-select: none;
}
        * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        html, body {
    height: 100%;
    font-family: 'Segoe UI', 'Roboto', monospace;
    background-color: var(--bg-color);
    overscroll-behavior: none;
    overflow: hidden; /* Retained from existing style */
}
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; transform: translateZ(0); -webkit-transform: translateZ(0); }
        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }
        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }
        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }
        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }
        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        #tabTrack { display: inline-flex; width: max-content; }
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }
        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }
        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }
        .accordion-subheader {
            margin-top: 0.75rem; margin-bottom: 0.2rem;
            font-size: 0.85rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 3px;
            padding-left: 0.25rem;
        }
        .info-description {
            font-size: 1.0rem;
            color: var(--text-muted);
            padding: 0.5rem 0.25rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .faq-item {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        .faq-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .faq-question {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }
        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}
/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1.5rem;
    border-radius: 6px;
    margin-top: 1.5rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
    text-align: center;
    margin-bottom: 0.5rem;
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; margin-right: 10px; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: 25%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px; margin-right: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }
        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 10000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }
        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }
        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 48px; }
        input[type="color"] { border: none; width: 48px; height: 48px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }
        /* Color List Styling */
        .color-list-wrapper { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; width: 100%; margin-top: 8px; }
        .color-list-item { position: relative; display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; }
        .color-list-item input[type="color"] { width: 48px; height: 48px; border-width: 2px; }
        .btn-icon-remove {
            position: absolute; top: -6px; right: -6px;
            width: 20px; height: 20px; border-radius: 50%;
            background: #ef4444; color: white; border: 1px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; cursor: pointer; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            line-height: 1; padding-bottom: 2px;
        }
        .btn-icon-add {
            width: 48px; height: 48px; border-radius: 50%;
            border: 2px dashed var(--accent);
            background: rgba(34, 197, 94, 0.1);
            color: var(--accent);
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            line-height: 1; padding-bottom: 3px;
        }
        .btn-icon-add:hover { background: rgba(34, 197, 94, 0.3); transform: scale(1.05); }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }
        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }
        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }
        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        #menuToggle {
    position: fixed;
    top: max(0.75em, var(--safe-top));
    right: max(1.2em, var(--safe-right));
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--panel-border);
    background: rgba(10, 12, 16, 0.6);
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 30;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px); /* Retained from existing style */
    cursor: pointer; /* Retained from existing style */
}
#menuToggle:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 20px var(--accent);
    transform: rotate(30deg);
}
        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
/* --- MODAL UI --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 50;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
    backdrop-filter: blur(5px);
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
    background: var(--panel-bg); border: 1px solid var(--accent);
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
    width: 90%; max-width: 600px;
    border-radius: 8px;
    display: flex; flex-direction: column;
    max-height: 90vh;
}
.modal-header {
    padding: 1rem; border-bottom: 1px solid var(--panel-border);
    display: flex; justify-content: space-between; align-items: center;
    background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
}
.modal-title { font-size: 1.1rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; margin: 0; }
.modal-close { cursor: pointer; color: var(--text-muted); font-size: 1.5rem; line-height: 1; }
.modal-close:hover { color: var(--danger); }
.modal-body { padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; }
.modal-footer {
    padding: 1rem; border-top: 1px solid var(--panel-border);
    display: flex; justify-content: flex-end; gap: 1rem;
}
textarea.char-input {
    width: 100%; height: 100px; background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1); color: var(--text-main);
    padding: 0.5rem; font-family: monospace; font-size: 1rem;
    resize: vertical;
}
textarea.char-input:focus { outline: none; border-color: var(--accent); }
.modal-label { display: block; margin-bottom: 0.5rem; color: #fff; font-size: 0.9rem; font-weight: bold; }
.modal-desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; }
/* --- CHARACTER SELECTOR REFINEMENTS --- */
/* Fix label colors */
.checkbox-row span {
    color: var(--text-main);
    font-size: 0.95rem;
    font-weight: 600;
}
/* Character Grid */
.char-grid-container {
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 10px;
    max-height: 250px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 8px;
    margin-top: 10px;
}
.char-grid-item {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 20px;
    color: var(--text-muted);
    user-select: none;
    transition: all 0.2s;
}
.char-grid-item:hover {
    border-color: var(--accent);
    background: rgba(34, 197, 94, 0.2);
    color: #fff;
}
.char-grid-item.selected {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent-glow);
}
.char-grid-item.empty {
    opacity: 0.3;
    pointer-events: none;
    background: #000;
}
.char-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.scan-status {
    font-size: 0.8rem;
    color: var(--warn);
    margin-top: 5px;
    min-height: 1.2em;
}
</style>
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E">
</head>
<body>
    <div id="fps-counter" style="display: none;">FPS: 60</div>
    <!-- Primary Canvas for Matrix Animation -->
    <canvas id="matrixCanvas" aria-label="Matrix Digital Rain Animation"></canvas>
    <!-- Overlay Canvas for Vector Effects -->
    <canvas id="overlayCanvas" style="z-index: 3; pointer-events: none;"></canvas>
    <!-- Hidden Bloom Canvas for Layer Effects -->
    <canvas id="bloomCanvas" hidden aria-hidden="true"></canvas>
    <!-- Toggle Button for Opening Settings Menu -->
    <button id="menuToggle" aria-controls="settingsPanel" aria-expanded="false" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03 .66.07 .98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"></path>
        </svg>
    </button>
    <!-- Input for Importing Files -->
    <input type="file" id="importFile" accept=".json" hidden aria-label="Import JSON Configuration" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" hidden aria-label="Import Font Files" />
    <!-- Settings Panel -->
    <aside id="settingsPanel" role="dialog" aria-hidden="true">
        <header id="panelHeader" role="banner">
            <h2 class="panel-title">Settings</h2>
        </header>
        <!-- Navigation Tabs -->
        <nav id="navTabs" role="tablist" aria-label="Settings Navigation"></nav>
        <!-- Content Area -->
        <main id="contentArea">
            <!-- Dynamic content will populate through scripts -->
        </main>
        <!-- Panel Footer -->
        <footer id="panelFooter">
            <p id="globalStatus" class="status-msg"></p>
        </footer>
    </aside>
    <script>const __EMBEDDED_ASSETS__ = {"shaders": {"BASETEMPLATE.glsl": "// base_template.glsl\nprecision highp float;                    // highp for desktop; switch to mediump for mobile if needed\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;            // (width, height)\nuniform float     uTime;                  // seconds\nuniform vec2      uMouse;                 // normalized [0..1]\nuniform float     uParameter;             // UI slider [0..1]\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec4 base = texture2D(uTexture, vTexCoord);\n    gl_FragColor = base;                  // start from base; \n}\n", "crt_monitor.glsl": "// Name: CRT Monitor\n\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = lines closer together, but line thickness is proportional\nconst float LINE_THICKNESS = 0.3;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// CRT Color Shift (Chromatic Aberration) Settings\nconst float SHIFT_AMOUNT = 0.01;       // Magnitude of the color fringe (very small)\n\n// Brightness Boost (Thresholding/Glow) Settings\nconst float BRIGHTNESS_THRESHOLD = 0.3;  // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;      // How much to multiply bright colors by\n\n// --- Barrel Distortion Settings ---\nconst float BARREL_DISTORTION_AMOUNT = 1.0; // Controls the bulge magnitude (0.0 to 1.0)\n\nvoid main() {\n    \n    // --- 1. CRT Barrel Distortion (Warp) ---\n    \n    // A. Center coordinates: shifts vTexCoord from [0.0, 1.0] to [-0.5, 0.5]\n    vec2 centeredCoord = vTexCoord - 0.5;\n    \n    // B. Calculate distance squared from center\n    // The distortion effect should be stronger in the corners than in the middle.\n    // dot(v, v) is a fast way to get length squared (r*r).\n    float r2 = dot(centeredCoord, centeredCoord); \n    \n    // C. Calculate the distortion factor\n    // The factor must be > 1.0 for a convex (bulging) look. \n    // It's calculated by adding a fraction of the distance (r2) to 1.0.\n    float factor = 1.0 + r2 * (BARREL_DISTORTION_AMOUNT * uParameter * 0.25);\n\n    // D. Apply the factor and shift back to 0.0-1.0 range\n    // This coordinate will be our base for sampling the warped image.\n    vec2 warpedTexCoord = centeredCoord * factor + 0.5;\n\n    // --- Boundary Check ---\n    // If the warped coordinate is outside [0.0, 1.0], it's smeared/clipped.\n    // The 'any' function checks if any component (x or y) of the boolean vector is true.\n    if (any(lessThan(warpedTexCoord, vec2(0.0))) || any(greaterThan(warpedTexCoord, vec2(1.0)))) {\n        // If the coordinate is outside the bounds, output black (or transparent)\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return; // Exit the shader immediately to skip all further calculations\n    }\n\n    // --- 2. CRT Chromatic Shift (Red/Blue Fringing) ---\n    \n    // The centerBias calculation remains based on the original vTexCoord \n    // to keep the color shift aligned with the screen's surface.\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord);\n    \n    float centerBias = fractionalPart.x - 0.5; \n    float shiftMagnitude = sin(centerBias * 3.14159265); \n\n    // Sample the texture three times using the **warpedTexCoord** as the base\n    vec2 redCoord   = warpedTexCoord + vec2(-shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);\n    vec2 blueCoord  = warpedTexCoord + vec2( shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);\n    \n    // Use the base warped coordinate for the green channel\n    float red   = texture2D(uTexture, redCoord).r;\n    float green = texture2D(uTexture, warpedTexCoord).g; \n    float blue  = texture2D(uTexture, blueCoord).b;\n    \n    vec4 finalColor = vec4(red, green, blue, 1.0);\n\n    // --- 3. Static Grid Overlay ---\n\n    // The grid lines are calculated using the original screen coordinate (vTexCoord)\n    // which simulates the grid being painted onto the curved glass.\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n\n    // Apply the grid\n    vec3 blendedColor = mix(finalColor.rgb, GRID_COLOR, gridMask);\n    finalColor.rgb = mix(finalColor.rgb, blendedColor, GRID_OPACITY);\n\n\n    // --- 4. Brightness Boost (Thresholding/Glow Effect) ---\n\n    float brightness = dot(finalColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);\n    finalColor.rgb *= finalMultiplier;\n\n    \n    // 5. Output Final Color\n    gl_FragColor = finalColor;\n}", "dirty_LCD.glsl": "// Name: Dirty LCD Monitor\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional\nconst float LINE_THICKNESS = 0.4;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// Adding grain dirtyness to the screen\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// Random graininess\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Boosting Pixel Brightness\nconst float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by\n\n\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord);\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);\n    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY);\n\n\n    // 1. Calculate the final grid-processed color's overall brightness (Luminance).\n    float brightness = dot(color.rgb, vec3(0.1126, 0.7152, 0.0522));\n\n    // 2. Determine the boost factor\n    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.\n    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    \n    // 3. Apply the boost to the color channels.\n    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.\n    // mix(Color A, Color B, Factor)\n    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)\n    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)\n    float finalMultiplier = mix(uParameter + 1.0, BRIGHTNESS_BOOST, boostFactor * uParameter);\n    \n    color.rgb *= finalMultiplier;\n    \n    // 5. Calculate static noise    \n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 6. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * GRAIN_AMOUNT;\n    \n    // 7. Output final color\n    gl_FragColor = color;\n}", "double_vision.glsl": "// Name: Double Vision\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Configuration for the effect\nconst float BLUR_SAMPLES = 2.0; // How many times to sample the texture (higher = smoother but slower)\nconst float BLUR_AMOUNT = 0.0001; // How intense the blur is\n\nvoid main() {\n    // 1. Center the coordinates\n    // We shift vTexCoord (0.0 to 1.0) so that the center of the screen is (0.0, 0.0).\n    vec2 center = vec2(0.5, 0.5); // The blur's origin point (center of the screen)\n    vec2 direction = vTexCoord - center; // Vector pointing from center to the current pixel\n\n    // 2. Initialize the final color\n    // We start with a black color (vec4(0.0))\n    vec4 finalColor = vec4(0.0);\n\n    // 3. Loop through samples\n    for (float i = 0.0; i < BLUR_SAMPLES; i++) {\n        // Calculate the current step along the blur ray.\n        // The 'mix' function smoothly interpolates (mixes) between two values.\n        // It's used here to define a position along the ray from 0.0 (center) to 1.0 (current pixel).\n        float step = i / (BLUR_SAMPLES - 1.0);\n\n        // Calculate the new coordinate for this sample.\n        // This coordinate is closer to the center than the original vTexCoord.\n        vec2 sampleCoord = mix(vTexCoord, center, step * BLUR_AMOUNT * (uParameter * 10.0) * 100.0);\n        \n        // --- IMPORTANT LOGIC EXPLAINED BELOW ---\n        // 'mix(A, B, t)' returns A*(1-t) + B*t. \n        // We use 'step * BLUR_AMOUNT * 100.0' to control how much to mix towards the center.\n        // The factor of 100.0 turns the small BLUR_AMOUNT (e.g., 0.005) into a more usable ratio (e.g., 0.5).\n\n        // Sample the color at the new, shifted coordinate\n        vec4 sampledColor = texture2D(uTexture, sampleCoord);\n\n        // Add the sampled color to our final average\n        finalColor += sampledColor;\n    }\n\n    // 4. Calculate the average color\n    // Divide the accumulated colors by the number of samples taken.\n    gl_FragColor = finalColor / BLUR_SAMPLES;\n}", "edge_glow_sobel.glsl": "// Name: Edge Glow (Sobel)\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec2 uv = vTexCoord;\n    vec2 px = 1.0 / uResolution;          // per\u2011pixel offsets\n\n    // Luma samples\n    float tl = dot(texture2D(uTexture, uv + px*vec2(-1,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  l = dot(texture2D(uTexture, uv + px*vec2(-1,  0)).rgb, vec3(0.2126,0.7152,0.0722));\n    float bl = dot(texture2D(uTexture, uv + px*vec2(-1, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  t = dot(texture2D(uTexture, uv + px*vec2( 0,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  b = dot(texture2D(uTexture, uv + px*vec2( 0, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float tr = dot(texture2D(uTexture, uv + px*vec2( 1,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  r = dot(texture2D(uTexture, uv + px*vec2( 1,  0)).rgb, vec3(0.2126,0.7152,0.0722));\n    float br = dot(texture2D(uTexture, uv + px*vec2( 1, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n\n    float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;\n    float gy =  tl + 2.0*t + tr - bl - 2.0*b - br;\n    float edge = sqrt(gx*gx + gy*gy);\n\n    vec4 base = texture2D(uTexture, uv);\n    float glowAmt = mix(0.0, 0.6, uParameter);\n    base.rgb += edge * glowAmt;\n\n    gl_FragColor = clamp(base, 0.0, 1.0);\n}", "film_grain.glsl": "// Name: Dirty Film Grain\nprecision mediump float;\n\n// Uniforms provided by PostProcessor.js\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uTime;\nuniform float uParameter;\n\n// Use vTexCoord from Vertex Shader for correct orientation\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.1; // Intensity of the grain (0.0 to 1.0)\nconst bool ANIMATED = true;      // Whether the grain dances (true) or is static (false)\nconst float SPEED = 2.2;         // Speed of grain animation\n\n// Random function\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // Sample the original texture using standard texture coordinates\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // Calculate noise\n    // We can use gl_FragCoord or vTexCoord for noise seed\n    float t = ANIMATED ? uTime * SPEED : 0.0;\n    \n    // Generate random noise value [-1.0, 1.0]\n    float noise = (random(vTexCoord + t) - 0.5) * 2.0;\n    \n    // Apply grain\n    color.rgb += noise * ((uParameter - 0.1) + GRAIN_AMOUNT);\n    \n    // Output final color\n    gl_FragColor = color;\n}\n", "hue_shift.glsl": "// Name: Hue Shift\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c){\n    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);\n    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.x = fract(hsv.x + uTime * 0.05 * (0.2 + 0.8*uParameter));           // animate hue\n    hsv.y *= mix(1.0, 0.35, uParameter);                                    // desaturate\n    vec3 outc = hsv2rgb(hsv);\n    gl_FragColor = vec4(outc, 1.0);\n}\n", "mouse_ripple.glsl": "// Name: Mouse Lens Ripple\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec2 uv = vTexCoord;\n    vec2 center = vec2(uMouse.x, 1.0 - uMouse.y);\n    float radius = mix(0.02, 0.60, uParameter);\n    float dist = distance(uv, center);\n    float mask = smoothstep(radius, 0.0, dist);\n\n    // Dynamic ripple offset\n    float wave = sin(24.0*dist - 4.0*uTime) * 0.003 * uParameter;\n    vec2 dir = normalize(uv - center);\n    uv += dir * wave * mask;\n\n    // Mild magnification inside the lens\n    float magnify = mix(1.0, 1.15, uParameter);\n    uv = mix(uv, center + (uv - center)/magnify, mask);\n\n    gl_FragColor = texture2D(uTexture, uv);\n}\n", "pixelate.glsl": "// Name: Pixelate\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    float scale = mix(1.0, 0.15, uParameter);      // 1.0 no pixelate; 0.15 heavy\n    vec2 grid = floor(vTexCoord * uResolution * scale) / (uResolution * scale);\n    vec4 color = texture2D(uTexture, grid);\n    gl_FragColor = color;\n}\n", "screen_door.glsl": "// Name: Screen Door\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional\nconst float LINE_THICKNESS = 0.4;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// Boosting Pixel Brightness\nconst float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by\n\n\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord * uParameter);\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS * uParameter + 0.1);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS * uParameter + 0.1);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);\n    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY * uParameter);\n\n\n    // 1. Calculate the final grid-processed color's overall brightness (Luminance).\n    float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n    // 2. Determine the boost factor\n    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.\n    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    \n    // 3. Apply the boost to the color channels.\n    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.\n    // mix(Color A, Color B, Factor)\n    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)\n    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)\n    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);\n    \n    color.rgb *= finalMultiplier;\n\n    gl_FragColor = color;\n}", "smear_LCDgrid.glsl": "// Name: Vertical Smear + LED Grid\n\n// Vertical Smear (upwards only) + LED Matrix Grid (faded, brightness-aware)\n// Uniforms: uTexture, uResolution, uTime, uMouse, uParameter, vTexCoord\n// uParameter drives the smear length in pixels: 0.0 = none, 1.0 = MAX_SMEAR_PX\n\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\n// ------------------- Tunables -------------------\n\n// If the smear still goes the wrong way, flip this sign to -1.0.\n// +1.0 means \"sample from above\" when vTexCoord.y increases toward the top.\n// -1.0 means \"sample from below\".\nconst float Y_SIGN            = +1.0;\n\nconst float MAX_SMEAR_PX      = 48.0;   // max smear length (pixels) at uParameter=1\nconst float SMEAR_DECAY       = 0.30;   // exponential falloff per tap (higher = faster decay)\nconst int   SMEAR_TAPS_COUNT  = 8;      // unrolled taps count (do not change in code block)\n\n// Smear applies more strongly to bright glyphs.\n// Raise or lower the range to taste.\nconst float SMEAR_LUMA_MIN    = 0.30;   // start applying smear above this luma\nconst float SMEAR_LUMA_MAX    = 0.85;   // full smear by this luma\n\n// LED grid parameters\nconst float GRID_SPACING_PX   = 8.0;    // cell size (pixels)\nconst float GRID_THICKNESS_PX = 1.0;    // seam thickness (pixels)\nconst float GRID_FADE_MAX     = 0.15;   // max darkening on grid lines\nconst float GRID_CROSS_GLOW   = 0.02;   // tiny highlight at intersections\nconst float GRID_LUMA_POWER   = 1.2;    // tie grid visibility to luma (>=1.0 less persistent in dark)\n\n// ------------------- Helpers -------------------\n\nfloat luma(vec3 c) {\n    // Rec.709 luma\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// Sample along vertical with Y_SIGN and clamp to [0,1] range.\nvec3 sampleVertical(vec2 uv, float offsetPx, vec2 px) {\n    float y = clamp(uv.y + Y_SIGN * offsetPx * px.y, 0.0, 1.0);\n    return texture2D(uTexture, vec2(uv.x, y)).rgb;\n}\n\n// Upward-only smear via unrolled taps for WebGL1 stability.\nvec3 smearUp(vec2 uv, float smearLenPx, float brightnessFactor) {\n    // brightnessFactor scales how much we mix the smear in (from 0..1)\n    vec2  px    = 1.0 / uResolution;\n    float stepPx= smearLenPx / float(SMEAR_TAPS_COUNT);\n\n    vec3 accum  = texture2D(uTexture, uv).rgb;\n    float wsum  = 1.0;\n\n    // Unrolled 8 taps with exponential weights\n    {\n        float w1 = exp(-1.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 1.0, px) * w1;\n        wsum  += w1;\n\n        float w2 = exp(-2.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 2.0, px) * w2;\n        wsum  += w2;\n\n        float w3 = exp(-3.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 3.0, px) * w3;\n        wsum  += w3;\n\n        float w4 = exp(-4.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 4.0, px) * w4;\n        wsum  += w4;\n\n        float w5 = exp(-5.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 5.0, px) * w5;\n        wsum  += w5;\n\n        float w6 = exp(-6.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 6.0, px) * w6;\n        wsum  += w6;\n\n        float w7 = exp(-7.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 7.0, px) * w7;\n        wsum  += w7;\n\n        float w8 = exp(-8.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 8.0, px) * w8;\n        wsum  += w8;\n    }\n\n    vec3 smeared = accum / wsum;\n\n    // Mix based on glyph brightness so darker glyphs retain less shadow,\n    // matching your observation.\n    vec3 base    = texture2D(uTexture, uv).rgb;\n    float lum    = luma(base);\n    float mixAmt = brightnessFactor * smoothstep(SMEAR_LUMA_MIN, SMEAR_LUMA_MAX, lum);\n\n    return mix(base, smeared, mixAmt);\n}\n\n// LED grid mask in pixel space (gl_FragCoord).\n// Returns line intensity in 0..1.\nfloat gridMask(vec2 frag) {\n    float modX  = mod(frag.x, GRID_SPACING_PX);\n    float distX = min(modX, GRID_SPACING_PX - modX);\n\n    float modY  = mod(frag.y, GRID_SPACING_PX);\n    float distY = min(modY, GRID_SPACING_PX - modY);\n\n    float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);\n    float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);\n\n    return max(lineX, lineY);\n}\n\nvoid main() {\n    vec2 uv         = vTexCoord;\n    vec4 base4      = texture2D(uTexture, uv);\n    vec3 base       = base4.rgb;\n    vec2 frag       = gl_FragCoord.xy;\n\n    // Smear length driven by uParameter (pixels)\n    float smearLenPx = clamp(uParameter, 0.0, 1.0) * MAX_SMEAR_PX;\n\n    // Smear strength factor (independent of luma ramp)\n    float smearStrength = 1.0; // keep 1.0; you can expose a second uniform if desired\n\n    // Upward-only smear with brightness-aware mixing\n    vec3 color = smearUp(uv, smearLenPx, smearStrength);\n\n    // LED grid faded by brightness so it is less persistent in dark regions\n    float gridI   = gridMask(frag);\n    float lum     = pow(luma(color), GRID_LUMA_POWER); // make grid respond more to bright glyphs\n    float fadeAmt = GRID_FADE_MAX * lum;               // reduce grid visibility in dark areas\n\n    color *= mix(1.0, 1.0 - fadeAmt, gridI);\n\n    // Tiny intersection glow (also brightness-aware)\n    if (GRID_CROSS_GLOW > 0.0) {\n        float modX  = mod(frag.x, GRID_SPACING_PX);\n        float distX = min(modX, GRID_SPACING_PX - modX);\n        float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);\n\n        float modY  = mod(frag.y, GRID_SPACING_PX);\n        float distY = min(modY, GRID_SPACING_PX - modY);\n        float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);\n\n        color += vec3(GRID_CROSS_GLOW) * (lineX * lineY) * lum;\n    }\n\n    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}", "static_grain.glsl": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}"}, "presets": {"matrix_conf_v8.5_Presets.json": {"version": "8.5", "state": {"streamColor": "#65d778", "streamPalette": ["#0de761", "#1fd64d", "#19b81c"], "paletteBias": 0, "colorMixType": 0.45, "tracerColor": "#c2f5f5", "fontSize": 24, "streamSpeed": 16, "releaseInterval": 3, "resolution": 0.8, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": true, "debugEnabled": false, "fontFamily": "MatrixEmbedded", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 20, "overlapEnabled": false, "overlapColor": "#FFD700", "overlapDensity": 0.2, "overlapTarget": "all", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -20, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.25, "tracerGlow": 5, "clearAlpha": 0.82, "horizontalSpacingFactor": 0.7, "verticalSpacingFactor": 1, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1.1, "decayFadeDurationFrames": 24, "streamSpawnCount": 2, "eraserSpawnCount": 2, "minStreamGap": 30, "minEraserGap": 30, "minGapTypes": 29, "allowTinyStreams": true, "gradualColorStreams": false, "holeRate": 0.1, "desyncIntensity": 0, "preferClusters": true, "eraserStopChance": 1, "tracerStopChance": 1, "tracerAttackFrames": 4, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": true, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.02, "upwardTracerGlow": 8.0, "upwardTracerSpeedMult": 1.0, "upwardTracerGlimmerSpeed": 2.0, "upwardTracerGlimmerSize": 3, "upwardTracerGlimmerFill": 3, "upwardTracerGlimmerGlow": 10.0, "rotatorEnabled": true, "rotatorChance": 0.13, "rotatorSyncToTracer": true, "rotatorSyncMultiplier": 0.5, "rotatorCycleFactor": 20, "rotatorCrossfadeFrames": 5, "rotateDuringFade": false, "rotatorDesyncEnabled": false, "rotatorDesyncVariance": 0, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.39, "effectParameter": 0, "pulseEnabled": true, "pulseUseTracerGlow": false, "pulseMovieAccurate": true, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 1.1, "clearPulsePreserveSpaces": true, "clearPulseBlend": true, "clearPulseWidth": 130, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": true, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "dejaVuEnabled": true, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.07, "dejaVuBarDurationFrames": 21, "dejaVuVarianceFrames": 43, "supermanEnabled": true, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 2, "supermanBoltThickness": 5, "supermanFlickerRate": 3, "supermanWidth": 3, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerGlitter": true, "starPowerColorCycle": true, "starPowerCycleSpeed": 3, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": true, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 33, "crashSheetSpeed": 1.1, "crashSheetOpacity": 0.96, "crashStationaryChance": 17, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c", "ReverseTime": "u"}, "hideMenuIcon": true, "fontSettings": {"MatrixEmbedded": {"active": true, "useCustomChars": false, "customCharacters": ""}, "CustomFont_5e2697679380fc43": {"active": false, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 19, "crashMovieFps": true}, "savedPresets": [{"name": "Trilogy", "data": {"streamColor": "#65d778", "streamPalette": ["#0de761", "#1fd64d", "#19b81c"], "paletteBias": 0, "colorMixType": 0.45, "tracerColor": "#c2f5f5", "fontSize": 24, "streamSpeed": 16, "releaseInterval": 3, "resolution": 0.8, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": true, "debugEnabled": false, "fontFamily": "MatrixEmbedded", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 20, "overlapEnabled": false, "overlapColor": "#FFD700", "overlapDensity": 0.2, "overlapTarget": "all", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -20, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.25, "tracerGlow": 5, "clearAlpha": 0.82, "horizontalSpacingFactor": 0.7, "verticalSpacingFactor": 1, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1.1, "decayFadeDurationFrames": 24, "streamSpawnCount": 2, "eraserSpawnCount": 2, "minStreamGap": 30, "minEraserGap": 30, "minGapTypes": 29, "allowTinyStreams": true, "gradualColorStreams": false, "holeRate": 0.1, "desyncIntensity": 0, "preferClusters": true, "eraserStopChance": 1, "tracerStopChance": 1, "tracerAttackFrames": 4, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": true, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.02, "upwardTracerGlow": 8.0, "upwardTracerSpeedMult": 1.0, "upwardTracerGlimmerSpeed": 2.0, "upwardTracerGlimmerSize": 3, "upwardTracerGlimmerFill": 3, "upwardTracerGlimmerGlow": 10.0, "rotatorEnabled": true, "rotatorChance": 0.13, "rotatorSyncToTracer": true, "rotatorSyncMultiplier": 0.5, "rotatorCycleFactor": 20, "rotatorCrossfadeFrames": 5, "rotateDuringFade": false, "rotatorDesyncEnabled": false, "rotatorDesyncVariance": 0, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.39, "effectParameter": 0, "pulseEnabled": true, "pulseUseTracerGlow": false, "pulseMovieAccurate": true, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 1.1, "clearPulsePreserveSpaces": true, "clearPulseBlend": true, "clearPulseWidth": 130, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": true, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "dejaVuEnabled": true, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.07, "dejaVuBarDurationFrames": 21, "dejaVuVarianceFrames": 43, "supermanEnabled": true, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 2, "supermanBoltThickness": 5, "supermanFlickerRate": 3, "supermanWidth": 3, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerGlitter": true, "starPowerColorCycle": true, "starPowerCycleSpeed": 3, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": true, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 33, "crashSheetSpeed": 1.1, "crashSheetOpacity": 0.96, "crashStationaryChance": 17, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c", "ReverseTime": "u"}, "hideMenuIcon": true, "fontSettings": {"MatrixEmbedded": {"active": true, "useCustomChars": false, "customCharacters": ""}, "CustomFont_5e2697679380fc43": {"active": false, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 19, "crashMovieFps": true}}, {"name": "Neo Code", "data": {"streamColor": "#65d778", "streamPalette": ["#1cc427", "#20a73b", "#5ddf3a"], "paletteBias": 0, "tracerColor": "#aadaa9", "fontSize": 17, "streamSpeed": 15, "releaseInterval": 1, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": true, "debugEnabled": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": false, "brightnessVariance": 0, "overlapEnabled": false, "overlapColor": "#FFD700", "overlapDensity": 0.2, "overlapTarget": "all", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -4, "deteriorationEnabled": true, "deteriorationStrength": 2, "enableBloom": true, "bloomStrength": 3, "bloomOpacity": 0.75, "tracerGlow": 17, "clearAlpha": 0.34, "horizontalSpacingFactor": 0.85, "verticalSpacingFactor": 0.95, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 0.9, "stretchY": 0.9, "decayFadeDurationFrames": 126, "streamSpawnCount": 1, "eraserSpawnCount": 5, "minStreamGap": 6, "minEraserGap": 6, "minGapTypes": 1, "holeRate": 0, "desyncIntensity": 0.2, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 2, "tracerHoldFrames": 0, "tracerReleaseFrames": 7, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "rotatorEnabled": true, "rotatorChance": 1, "rotatorSyncToTracer": true, "rotatorSyncMultiplier": 0.1, "rotatorCycleFactor": 20, "rotatorCrossfadeFrames": 2, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 60, "shaderEnabled": false, "customShader": "// Name: CRT Monitor\n\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = lines closer together, but line thickness is proportional\nconst float LINE_THICKNESS = 0.3;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// CRT Color Shift (Chromatic Aberration) Settings\nconst float SHIFT_AMOUNT = 0.01;       // Magnitude of the color fringe (very small)\n\n// Brightness Boost (Thresholding/Glow) Settings\nconst float BRIGHTNESS_THRESHOLD = 0.3;  // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;      // How much to multiply bright colors by\n\n// --- Barrel Distortion Settings ---\nconst float BARREL_DISTORTION_AMOUNT = 1.0; // Controls the bulge magnitude (0.0 to 1.0)\n\nvoid main() {\n    \n    // --- 1. CRT Barrel Distortion (Warp) ---\n    \n    // A. Center coordinates: shifts vTexCoord from [0.0, 1.0] to [-0.5, 0.5]\n    vec2 centeredCoord = vTexCoord - 0.5;\n    \n    // B. Calculate distance squared from center\n    // The distortion effect should be stronger in the corners than in the middle.\n    // dot(v, v) is a fast way to get length squared (r*r).\n    float r2 = dot(centeredCoord, centeredCoord); \n    \n    // C. Calculate the distortion factor\n    // The factor must be > 1.0 for a convex (bulging) look. \n    // It's calculated by adding a fraction of the distance (r2) to 1.0.\n    float factor = 1.0 + r2 * (BARREL_DISTORTION_AMOUNT * uParameter * 0.25);\n\n    // D. Apply the factor and shift back to 0.0-1.0 range\n    // This coordinate will be our base for sampling the warped image.\n    vec2 warpedTexCoord = centeredCoord * factor + 0.5;\n\n    // --- Boundary Check ---\n    // If the warped coordinate is ou... [truncated]", "effectShader": null, "shaderParameter": 0.94, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanIncludeColors": true, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerGlitter": false, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c"}, "hideMenuIcon": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "dissolveMinSize": 18}}, {"name": "Trinity Code", "data": {"streamColor": "#65d778", "streamPalette": ["#3eea88", "#37e68c"], "paletteBias": 0, "tracerColor": "#aadaa9", "fontSize": 24, "streamSpeed": 16, "releaseInterval": 1, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": true, "debugEnabled": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 69, "overlapEnabled": true, "overlapColor": "#f4df57", "overlapDensity": 0.3, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -4, "deteriorationEnabled": true, "deteriorationStrength": 3, "enableBloom": true, "bloomStrength": 2, "bloomOpacity": 0.9, "tracerGlow": 10, "clearAlpha": 0.34, "horizontalSpacingFactor": 0.85, "verticalSpacingFactor": 0.95, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 0.9, "stretchY": 0.9, "decayFadeDurationFrames": 126, "streamSpawnCount": 1, "eraserSpawnCount": 4, "minStreamGap": 2, "minEraserGap": 2, "minGapTypes": 1, "holeRate": 0, "desyncIntensity": 0.15, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 2, "tracerHoldFrames": 0, "tracerReleaseFrames": 5, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "rotatorEnabled": true, "rotatorChance": 1, "rotatorSyncToTracer": true, "rotatorSyncMultiplier": 0.1, "rotatorCycleFactor": 20, "rotatorCrossfadeFrames": 2, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 60, "shaderEnabled": true, "customShader": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}", "effectShader": null, "shaderParameter": 0.16, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanIncludeColors": true, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerGlitter": false, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c"}, "hideMenuIcon": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "dissolveMinSize": 18}}]}}, "fonts": {"Matrix-Resurrected.woff2": "data:font/woff2;base64,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", "Matrix-code-bold.woff2": "data:font/woff2;base64,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", "Matrix-code-light.ttf": "data:application/octet-stream;base64,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bmkzMEFDB3VuaTMwQUQHdW5pMzBBRQd1bmkzMEFGB3VuaTMwQjMHdW5pMzBCNAd1bmkzMEI1B3VuaTMwQjYHdW5pMzBCNwd1bmkzMEI4B3VuaTMwQjkHdW5pMzBCQQd1bmkzMEJCB3VuaTMwQkMHdW5pMzBCRAd1bmkzMEJFB3VuaTMwQzMHdW5pMzBDNAd1bmkzMEM1B3VuaTMwQzYHdW5pMzBDNwd1bmkzMENBB3VuaTMwQ0IHdW5pMzBDQwd1bmkzMENEB3VuaTMwQ0YHdW5pMzBEMgd1bmkzMEQ1B3VuaTMwRDYHdW5pMzBENwd1bmkzMERCB3VuaTMwREMHdW5pMzBERAd1bmkzMERFB3VuaTMwREYHdW5pMzBFMAd1bmkzMEUxB3VuaTMwRTIHdW5pMzBFMwd1bmkzMEU0B3VuaTMwRTkHdW5pMzBFQQd1bmkzMEVCB3VuaTMwRUUHdW5pMzBFRgd1bmkzMEYyB3VuaTMwRjMHdW5pMzBGNAd1bmkzMEY1B3VuaTMwRjYHdW5pMzBGQgd1bmkzMEZDAAAAAQAB//8ADwABAAAADAAAAEwAVAACAAoABQAFAAEAEQARAAEAGQAcAAEAHgAgAAEAIgAmAAEAKwArAAEALgAuAAEAMAAwAAEAMgAyAAEAPgB7AAEABAAAAAIAAAABAAAAAQAAAAAAAQAAAADlDbeTAAAAANsFkSsAAAAA5VAOWg=="}};</script>
<script id="simulation-worker-source" type="javascript/worker">
// --- Worker Dep: Utils.js ---
const APP_VERSION = "8.5"; // Updated version
// =========================================================================
// 1. CORE UTILITIES / CONSTANTS
// =========================================================================
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a color string (Hex "#RRGGBB" or "rgb(r,g,b)") to an { r, g, b } object.
     * @param {string} input - The color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (input) => {
        if (typeof input !== "string") return { r: 0, g: 255, b: 0 };
        // Handle Hex (6 or 8 digits)
        const hexMatch = input.match(/^#?([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/);
        if (hexMatch) {
            const value = parseInt(hexMatch[1], 16);
            return {
                r: (value >> 16) & 0xFF,
                g: (value >> 8) & 0xFF,
                b: value & 0xFF
            };
        }
        // Handle RGB / RGBA
        const match = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            return {
                r: parseInt(match[1], 10),
                g: parseInt(match[2], 10),
                b: parseInt(match[3], 10)
            };
        }
        // Fallback
        return { r: 0, g: 255, b: 0 }; 
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Packs RGB components into a single 32-bit integer (0xAABBGGRR) for Little Endian (RR GG BB AA in memory).
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @param {number} a - Alpha (0-255), defaults to 255.
     * @returns {number} The packed 32-bit integer.
     */
    packAbgr: (r, g, b, a = 255) => {
        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
    },
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: '',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3,
    UPWARD_TRACER: 4
};
    // =========================================================================
    // 1.1 NOTIFICATION SYSTEM 
    // =========================================================================
// --- Worker Dep: CellGrid.js ---
// Constants for Cell State and Render Modes
const CELL_STATE = {
    INACTIVE: 0,
    ACTIVE: 1
    // OVERRIDE state is determined by the overrideActive flag
};
const RENDER_MODE = {
    STANDARD: 0, // Mix between Primary and Secondary based on 'mix'
    OVERLAP: 1,  // Visual Overlap (both visible)
    ADDITIVE: 2  // Additive blending (future proofing)
};
const OVERRIDE_MODE = {
    NONE: 0,
    CHAR: 1,
    SOLID: 2,
    FULL: 3
};
class CellGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // --- Core State ---
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.state = null; // Uint8: INACTIVE / ACTIVE
        // --- Primary Layer ---
        this.chars = null;        // Uint16
        this.colors = null;       // Uint32 (0xAABBGGRR) - Current Display Color
        this.baseColors = null;   // Uint32 (0xAABBGGRR) - Target/Stream Color
        this.alphas = null;       // Float32
        this.glows = null;        // Float32
        this.fontIndices = null;  // Uint8
        // --- Secondary Layer (Rotators / Overlaps) ---
        this.secondaryChars = null; // Uint16
        this.secondaryColors = null; // Uint32
        this.secondaryAlphas = null; // Float32
        this.secondaryGlows = null;  // Float32
        this.secondaryFontIndices = null; // Uint8
        // --- Mixing & Rendering ---
        this.mix = null;        // Float32 (0.0 = Primary, 1.0 = Secondary)
        this.renderMode = null; // Uint8 (RENDER_MODE)
        // --- Override Layer (Effects) ---
        this.overrideActive = null; // Uint8 (OVERRIDE_MODE)
        this.overrideChars = null;  // Uint16
        this.overrideColors = null; // Uint32
        this.overrideAlphas = null; // Float32
        this.overrideGlows = null;  // Float32
        this.overrideMix = null;    // Float32 (New: For FULL mode)
        this.overrideNextChars = null; // Uint16 (New: For FULL mode rotators)
        this.overrideFontIndices = null; // Uint8
        // --- Passive Layer (Effects) ---
        this.effectActive = null;   // Uint8
        this.effectChars = null;    // Uint16
        this.effectColors = null;   // Uint32
        this.effectAlphas = null;   // Float32
        this.effectGlows = null;    // Float32
        this.effectFontIndices = null; // Uint8
        // --- Simulation Logic Storage ---
        this.types = null;      // Uint8 (Tracer, Rotator, Empty)
        this.decays = null;     // Uint8
        this.ages = null;       // Int32
        this.brightness = null; // Float32
        this.rotatorOffsets = null; // Uint8 (Static noise for desync)
        // Auxiliary
        this.cellLocks = null;  // Uint8 (Prevent updates)
        // Sparse Data (Maps for memory efficiency)
        this.complexStyles = new Map(); // Dynamic styling data
        // Rotator Targets (Dense for GPU upload)
        this.nextChars = null;     // Uint16Array
        this.nextOverlapChars = null; // Uint16Array
    }
    /**
     * Resizes the grid based on new width and height.
     */
    resize(width, height, buffers = null) {
        const d = this.config.derived;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
        if (!d || !d.cellWidth || !d.cellHeight) return;
        const newCols = Math.max(1, (width / d.cellWidth) | 0);
        const newRows = Math.max(1, (height / d.cellHeight) | 0);
        if (newCols !== this.cols || newRows !== this.rows || buffers) {
            this._resizeGrid(newCols, newRows, buffers);
        }
    }
    getIndex(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return -1;
        return y * this.cols + x;
    }
    // --- Primary Layer Modifiers ---
    setPrimary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.chars[idx] = charStr.charCodeAt(0);
        this.colors[idx] = colorUint32;
        this.alphas[idx] = alpha;
        this.glows[idx] = glow;
        this.fontIndices[idx] = fontIndex;
        this.state[idx] = CELL_STATE.ACTIVE;
        this.activeIndices.add(idx);
    }
    setRotatorTarget(idx, charStr, isSecondary = false) {
        const code = charStr.charCodeAt(0);
        if (isSecondary) {
            this.nextOverlapChars[idx] = code;
        } else {
            this.nextChars[idx] = code;
        }
    }
    getRotatorTarget(idx, isSecondary = false) {
        const code = isSecondary ? this.nextOverlapChars[idx] : this.nextChars[idx];
        return (code > 0) ? String.fromCharCode(code) : null;
    }
    // --- Secondary Layer Modifiers ---
    setSecondary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.secondaryChars[idx] = charStr.charCodeAt(0);
        this.secondaryColors[idx] = colorUint32;
        this.secondaryAlphas[idx] = alpha;
        this.secondaryGlows[idx] = glow;
        this.secondaryFontIndices[idx] = fontIndex;
    }
    // --- Override Layer Modifiers ---
    // This is a 'permanent' or hard override - it directly changes state
    setOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.overrideChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideGlows[idx] = glow;
        this.overrideFontIndices[idx] = fontIndex;
        this.overrideActive[idx] = OVERRIDE_MODE.CHAR;
    }
    // This is a soft override 
    setEffectOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 1;
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Overlay Override (Mixes Effect Char on top of Primary)
    setEffectOverlay(idx, charStr, color, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 2; // 2 = Overlay Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = color;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // High Priority Override (Ignores Shadows/Masks)
    setHighPriorityEffect(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 4; // 4 = High Priority Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Shadow Overlay (Mixes Black Block on top of Primary)
    setEffectShadow(idx, alpha) {
        this.effectActive[idx] = 3; // 3 = Shadow Mode
        this.effectAlphas[idx] = alpha;
        // Chars/Colors/Fonts ignored for shadow
    }
    setSolidOverride(idx, colorUint32, alpha) {
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideActive[idx] = OVERRIDE_MODE.SOLID;
        // Chars/Glows ignored for Solid
    }
    clearOverride(idx) {
        this.overrideActive[idx] = OVERRIDE_MODE.NONE;
    }
    clearEffectOverride(idx) {
        this.effectActive[idx] = 0;
    }
    clearAllOverrides() {
        if (this.overrideActive) {
            this.overrideActive.fill(0);
        }
    }
    clearAllEffects(){
        if (this.effectActive){
            this.effectActive.fill(0);
        }
    }
    // --- General State Management ---
    clearCell(idx) {
        this.state[idx] = CELL_STATE.INACTIVE;
        this.chars[idx] = 32; // Space
        this.alphas[idx] = 0;
        this.glows[idx] = 0;
        this.mix[idx] = 0;
        this.renderMode[idx] = RENDER_MODE.STANDARD;
        // Clear simulation data
        this.types[idx] = 0;
        this.ages[idx] = 0;
        this.decays[idx] = 0;
        // Also clear secondary to be safe
        this.secondaryChars[idx] = 32;
        this.secondaryAlphas[idx] = 0;
        this.activeIndices.delete(idx);
        // Clear maps
        this.complexStyles.delete(idx);
        this.nextChars[idx] = 0;
        this.nextOverlapChars[idx] = 0;
    }
    getChar(idx) {
        // Helper for simulation reading
        return String.fromCharCode(this.chars[idx]);
    }
    getState(idx){
        // Helper for getting cell state
        return this.state[idx];
    }
    _resizeGrid(newCols, newRows, buffers = null) {
        const total = newCols * newRows;
        if (buffers) {
            // Adopt provided buffers (SharedArrayBuffer views)
            this.state = buffers.state;
            this.chars = buffers.chars;
            this.colors = buffers.colors;
            this.baseColors = buffers.baseColors;
            this.alphas = buffers.alphas;
            this.glows = buffers.glows;
            this.fontIndices = buffers.fontIndices;
            this.secondaryChars = buffers.secondaryChars;
            this.secondaryColors = buffers.secondaryColors;
            this.secondaryAlphas = buffers.secondaryAlphas;
            this.secondaryGlows = buffers.secondaryGlows;
            this.secondaryFontIndices = buffers.secondaryFontIndices;
            this.mix = buffers.mix;
            this.renderMode = buffers.renderMode;
            this.overrideActive = buffers.overrideActive;
            this.overrideChars = buffers.overrideChars;
            this.overrideColors = buffers.overrideColors;
            this.overrideAlphas = buffers.overrideAlphas;
            this.overrideGlows = buffers.overrideGlows;
            this.overrideMix = buffers.overrideMix;
            this.overrideNextChars = buffers.overrideNextChars;
            this.overrideFontIndices = buffers.overrideFontIndices;
            this.effectActive = buffers.effectActive;
            this.effectChars = buffers.effectChars;
            this.effectColors = buffers.effectColors;
            this.effectAlphas = buffers.effectAlphas;
            this.effectFontIndices = buffers.effectFontIndices;
            this.effectGlows = buffers.effectGlows;
            this.types = buffers.types;
            this.decays = buffers.decays;
            this.ages = buffers.ages;
            this.brightness = buffers.brightness;
            this.rotatorOffsets = buffers.rotatorOffsets;
            this.cellLocks = buffers.cellLocks;
            this.nextChars = buffers.nextChars;
            this.nextOverlapChars = buffers.nextOverlapChars;
            this.envGlows = buffers.envGlows;
        } else {
            // Core
            this.state = new Uint8Array(total);
            // Primary
            this.chars = new Uint16Array(total);
            this.colors = new Uint32Array(total);
            this.baseColors = new Uint32Array(total);
            this.alphas = new Float32Array(total);
            this.glows = new Float32Array(total);
            this.fontIndices = new Uint8Array(total);
            // Secondary
            this.secondaryChars = new Uint16Array(total);
            this.secondaryColors = new Uint32Array(total);
            this.secondaryAlphas = new Float32Array(total);
            this.secondaryGlows = new Float32Array(total);
            this.secondaryFontIndices = new Uint8Array(total);
            // Mix / Mode
            this.mix = new Float32Array(total);
            this.renderMode = new Uint8Array(total);
            // Override
            this.overrideActive = new Uint8Array(total);
            this.overrideChars = new Uint16Array(total);
            this.overrideColors = new Uint32Array(total);
            this.overrideAlphas = new Float32Array(total);
            this.overrideGlows = new Float32Array(total);
            this.overrideMix = new Float32Array(total);
            this.overrideNextChars = new Uint16Array(total);
            this.overrideFontIndices = new Uint8Array(total);
            // Effects
            this.effectActive = new Uint8Array(total)
            this.effectChars = new Uint16Array(total);
            this.effectColors = new Uint32Array(total);
            this.effectAlphas = new Float32Array(total);
            this.effectFontIndices = new Uint8Array(total);
            this.effectGlows = new Float32Array(total);
            // Simulation
            this.types = new Uint8Array(total);
            this.decays = new Uint8Array(total);
            this.ages = new Int32Array(total);
            this.brightness = new Float32Array(total);
            this.rotatorOffsets = new Uint8Array(total);
            this.cellLocks = new Uint8Array(total);
            // Rotators
            this.nextChars = new Uint16Array(total);
            this.nextOverlapChars = new Uint16Array(total);
            // Environmental Glows (Additive, per frame)
            this.envGlows = new Float32Array(total);
        }
        // Initialize static data (Common to both modes)
        // Note: For SAB, we might skip this if the worker handles initialization, 
        // but it's safe to re-run or let the worker overwrite it.
        // If we are the MAIN thread and just adopting SABs, we probably shouldn't random fill 
        // because the Worker might be doing it.
        // However, this random fill is for "initial static noise".
        // Let's rely on the buffer content being zeroed or initialized elsewhere if buffers are passed.
        if (!buffers) {
            const activeFonts = this.config.derived ? this.config.derived.activeFonts : null;
            const fallbackChars = "012345789Z:<=>\"*+-._!|";
            for (let i = 0; i < total; i++) {
                this.rotatorOffsets[i] = (Math.random() * 255) | 0;
                let charCode = 32; 
                if (activeFonts && activeFonts.length > 0) {
                    const f = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                    if (f.chars && f.chars.length > 0) {
                        charCode = f.chars.charCodeAt(Math.floor(Math.random() * f.chars.length));
                    }
                } else {
                    charCode = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
                }
                this.chars[i] = charCode;
            }
        }
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- Worker Dep: StreamModes.js ---
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        let hue;
        if (state.starPowerRainbowMode === 'char') {
            hue = (frame + (stream.x * 10)) % 360; // Character-based hue
        } else {
            // Full Stream Mode: Sync hue start time so they cycle together
            // If cycling is enabled, offset the base hue by the current frame * speed
            hue = stream.baseHue;
            if (state.starPowerColorCycle) {
                 hue = (hue + (frame * state.starPowerCycleSpeed)) % 360;
            }
        }
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed);
    }
    _createStyle(hue, saturation, lightness, cycle, speed) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, isEffect: true };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, isEffect: true };
    }
}
    // =========================================================================
    // 5.0 SIMULATION SYSTEM 
    // =========================================================================
// --- Worker Dep: StreamManager.js ---
class StreamManager {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.activeStreams = [];
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(grid.cols).fill(null);
        this.columnSpeeds = new Float32Array(grid.cols);
        this.streamsPerColumn = new Int16Array(grid.cols); // Track active streams count
        this.modes = this._initializeModes(config);
        this.nextSpawnFrame = 0;
        // Reusable columns pool to avoid per-spawn allocation
        this._columnsPool = new Array(this.grid.cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    resize(cols) {
        this.lastStreamInColumn = new Array(cols).fill(null);
        this.lastEraserInColumn = new Array(cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(cols).fill(null);
        this.columnSpeeds = new Float32Array(cols);
        this.streamsPerColumn = new Int16Array(cols);
        this.activeStreams = [];
        // Rebuild columns pool
        this._columnsPool = new Array(cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    update(frame, timeScale) {
        // Keep columns arrays in sync with grid size if changed (safety check)
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            this.resize(this.grid.cols);
        }
        if (timeScale > 0) {
            this._manageStreams(frame, timeScale);
        } else if (timeScale < 0) {
            this._processActiveStreams(frame, timeScale);
        }
        // If timeScale == 0, pause
    }
    _manageStreams(frame, timeScale) {
        const { state: s, derived: d } = this.config;
        // Independent Glimmer Management (Runs every frame)
        this._manageGlimmer(s);
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2;
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        this._processActiveStreams(frame, timeScale);
    }
    _manageGlimmer(s) {
        if (!s.upwardTracerEnabled || s.upwardTracerChance <= 0) return;
        // 1. Calculate Active Density per Column
        const colCounts = new Uint8Array(this.grid.cols);
        for (let i = 0; i < this.activeStreams.length; i++) {
            const stream = this.activeStreams[i];
            if (stream.isUpward && stream.active) {
                colCounts[stream.x]++;
            }
        }
        // 2. Determine Density Limit (1, 2, or 3)
        const limit = Math.ceil(s.upwardTracerChance * 3.0);
        // 3. Spawn Logic
        // Since this runs every frame, we use a low probability to fill gaps organically.
        const spawnChance = 0.05; 
        const columns = this._columnsPool;
        // Shuffle for random distribution
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (colCounts[col] < limit) {
                if (Math.random() < spawnChance) {
                    this._spawnUpwardTracerAt(col);
                    colCounts[col]++;
                }
            }
        }
    }
    _spawnStreams(s, d) {
        const columns = this._columnsPool;
        // Fisher-Yates Shuffle
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
            }
            const lastStream = this.lastStreamInColumn[col];
            // Resolve Speed for this column (Chain Consistency)
            let colSpeed = this.columnSpeeds[col];
            // Only generate a new speed if the column is completely empty of active streams
            if (this.streamsPerColumn[col] === 0) {
                // New chain, new random speed
                colSpeed = this._generateSpeed(s);
                this.columnSpeeds[col] = colSpeed;
            }
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true, colSpeed);
                eraserCount--;
                continue; 
            } 
            if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false, colSpeed);
                streamCount--;
                // Cluster Logic: 10-20% chance to spawn a neighbor
                if (s.preferClusters && streamCount > 0 && Math.random() < 0.15) {
                    // Try Right Neighbor (wrapping handled by modulo if needed, but here we just clamp)
                    const neighbor = col + 1;
                    if (neighbor < this.grid.cols) {
                        const idxN = this.grid.getIndex(neighbor, 0);
                        let blockedN = false;
                        if (idxN !== -1 && this.grid.decays[idxN] > 0) blockedN = true;
                        const lastStreamN = this.lastStreamInColumn[neighbor];
                        // Resolve Neighbor Speed
                        let neighborSpeed = this.columnSpeeds[neighbor];
                        if (!lastStreamN || !lastStreamN.active) {
                            neighborSpeed = this._generateSpeed(s);
                            this.columnSpeeds[neighbor] = neighborSpeed;
                        }
                        if (!blockedN && this._canSpawnTracer(lastStreamN, s.minStreamGap, s.minGapTypes)) {
                            this._spawnStreamAt(neighbor, false, neighborSpeed);
                            streamCount--;
                        }
                    }
                }
                continue; 
            }
        }
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        if (!lastStream || !lastStream.active) return true;
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastStream = this.lastStreamInColumn[col];
        // Prevent spawning an eraser if the column is empty or the last spawn was already an eraser.
        if (!lastStream || lastStream.isEraser) return false;
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        if (lastStream.active) {
            if (this.config.state.allowTinyStreams) {
                const s = this.config.state;
                const tinyGap = s.tracerAttackFrames + s.tracerHoldFrames + s.tracerReleaseFrames + 3;
                if (lastStream.y <= tinyGap) return false;
            } else {
                if (lastStream.y <= minGapTypes) return false;
            }
        }
        return true;
    }
    _processActiveStreams(frame, timeScale) {
        const grid = this.grid;
        const rows = grid.rows;
        const cellLocks = grid.cellLocks;
        const decays = grid.decays;
        if (Math.abs(timeScale) < 0.01) return;
        const isReverse = timeScale < 0;
        const speedMult = Math.abs(timeScale);
                for (let i = this.activeStreams.length - 1; i >= 0; i--) {
                    const stream = this.activeStreams[i];
                    if (!stream.active) {
                        if (this.streamsPerColumn[stream.x] > 0) this.streamsPerColumn[stream.x]--;
                        this.activeStreams.splice(i, 1);
                        continue;
                    }
            const headIdx = grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && cellLocks && cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.tickTimer -= speedMult;
            if (stream.tickTimer > 0) {
                continue; 
            }
            stream.tickTimer = stream.tickInterval;
            // Handle Upward Tracers (Scanners)
            if (stream.isUpward) {
                if (isReverse) {
                    stream.y++; // Move down in reverse
                    if (stream.y > rows + 5) {
                        stream.active = false;
                        continue;
                    }
                } else {
                    stream.y--; // Move up in forward
                    if (stream.y < -5) {
                        stream.active = false;
                        continue;
                    }
                }
                this._writeHead(stream, frame);
                continue; 
            }
            if (isReverse) {
                stream.y--;
                // REWIND LOGIC: Clear the "future" (the cell we just left, which was stream.y + 1)
                // This creates the effect of the stream being sucked back up.
                const oldHeadY = stream.y + 1;
                if (oldHeadY < rows) {
                    const oldIdx = grid.getIndex(stream.x, oldHeadY);
                    if (oldIdx !== -1) {
                         grid.clearCell(oldIdx);
                    }
                }
                if (stream.y < -5) {
                    stream.active = false;
                    continue;
                }
                this._writeHead(stream, frame);
            } else {
                // Drop-off logic
                if (stream.isEraser) {
                    const stopChance = this.config.state.eraserStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                } else {                    
                    const stopChance = this.config.state.tracerStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                    // In 3D mode, ignore collision with existing trails to allow high density
                    const nextY = stream.y + 1;
                    if (nextY < rows) {
                        const nextIdx = grid.getIndex(stream.x, nextY);
                        if (nextIdx !== -1 && decays[nextIdx] > 0) {
                            stream.active = false;
                            continue; 
                        }
                    }
                } 
                stream.age++;
                if (stream.age >= stream.visibleLen) {
                    this._handleStreamCompletion(stream);
                    continue;
                }
                if (stream.y < stream.len) {
                    // Debug: Clean up previous eraser position to prevent trails
                    if (stream.isEraser && this.config.state.highlightErasers) {
                        const prevIdx = grid.getIndex(stream.x, stream.y);
                        if (prevIdx !== -1) grid.clearEffectOverride(prevIdx);
                    }
                    stream.y++;
                    this._writeHead(stream, frame);
                }
            }
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        const autoErase = this.config.state.autoEraserEnabled !== false;
        // Prevent auto-eraser if an eraser is already running in this column
        const last = this.lastStreamInColumn[stream.x];
        const isBlocked = last && last !== stream && last.active && last.isEraser;
        if (!stream.isEraser && autoErase && !isBlocked) {
            this._spawnStreamAt(stream.x, true, stream.tickInterval);
        }
    }
    _spawnStreamAt(x, forceEraser, forcedSpeed) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s, forcedSpeed);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _generateSpeed(s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        if (s.desyncIntensity > 0) {
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            return Math.max(1, baseTick + offset);
        }
        return baseTick;
    }
    recalculateSpeeds() {
        const s = this.config.state;
        for (let col = 0; col < this.grid.cols; col++) {
            const newSpeed = this._generateSpeed(s);
            this.columnSpeeds[col] = newSpeed;
        }
        // Update active streams to match new column speeds immediately
        for (const stream of this.activeStreams) {
            if (stream.x >= 0 && stream.x < this.columnSpeeds.length) {
                stream.tickInterval = this.columnSpeeds[stream.x];
            }
        }
    }
    _initializeStream(x, forceEraser, s, forcedSpeed) {
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        let tickInterval = forcedSpeed;
        // Enforce Column Speed Consistency
        // If the column has an assigned speed, strictly use it to ensure Tracers and Erasers remain synchronized
        if (this.columnSpeeds[x] > 0) {
            tickInterval = this.columnSpeeds[x];
        }
        if (!tickInterval) {
            tickInterval = this._generateSpeed(s);
            // Ensure this new speed is recorded for the column
            this.columnSpeeds[x] = tickInterval;
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsUint32?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval,
            tickTimer: 0
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        stream.visibleLen = this.grid.rows + 20; 
        return stream;
    }
    _initializeTracerStream(stream, s) {
        stream.len = this.grid.rows; 
        const travelDuration = stream.len // * stream.tickInterval;
        stream.visibleLen = travelDuration + (this.grid.rows * 4);
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isUpward) {
            this._handleUpwardHead(idx, this.config.state);
            return;
        }
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        const decays = this.grid.decays;
        if (decays[idx] >= 2) return;
        if (decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            decays[idx] = 2;
        } else {
            this.grid.clearCell(idx);
        }
        if (this.config.state.highlightErasers) {
            // Debug: Show Eraser as Red 'E' using High Priority Effect layer (0xFF0000FF = Red)
            // This overlays the 'E' without destroying the underlying simulation state (decay/clear)
            this.grid.setHighPriorityEffect(idx, 'E', 0xFF0000FF, 1.0, 0, 0);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const s = this.config.state;
            const d = this.config.derived;
            const grid = this.grid;
            const cellType = s.rotatorEnabled && Math.random() < s.rotatorChance
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            grid.types[idx] = cellType;
            grid.ages[idx] = 1;
            grid.decays[idx] = 1;
            grid.mix[idx] = 0; // Reset Rotator/Mix Progress
            grid.renderMode[idx] = RENDER_MODE.STANDARD;
            grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = d.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const charStr = charSet[Math.floor(Math.random() * charSet.length)];
            // Resolve Color
            let colorUint32;
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                // Complex Style (Effect)
                grid.complexStyles.set(idx, style);
                // Convert style to color immediately
                if (style.h !== undefined) {
                    const rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    colorUint32 = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                } else {
                     // Fallback
                     colorUint32 = d.tracerColorUint32;
                }
            } else {
                grid.complexStyles.delete(idx);
                // Standard Color
                // colorMixType: 0 = Stream, 1 = Character
                const isPerChar = Math.random() < s.colorMixType;
                if (isPerChar || Math.random() < s.paletteBias) {
                    const pLen = d.paletteColorsUint32?.length || 1;
                    colorUint32 = d.paletteColorsUint32[Math.floor(Math.random() * pLen)];
                } else {
                    colorUint32 = d.paletteColorsUint32[stream.pIdx] || d.paletteColorsUint32[0];
                }
            }
            // Brightness / Alpha
            const b = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            grid.brightness[idx] = b;
            // Set Primary (Visual = Tracer Color initially)
            const tracerColor = d.tracerColorUint32;
            grid.setPrimary(idx, charStr, tracerColor, b, stream.fontIndex, s.tracerGlow);
            grid.baseColors[idx] = colorUint32; // Store Stream Color for fade target
            // Handle Overlap (Secondary)
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                const overlapChar = charSet[Math.floor(Math.random() * charSet.length)];
                // For overlaps, we usually use the same color? Or Overlap Color?
                // Previously, renderer used `overlapColor` from config for overlaps.
                // But now CellGrid stores the color.
                // We should resolve Overlap Color here.
                const ovRgb = Utils.hexToRgb(s.overlapColor);
                const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
                grid.setSecondary(idx, overlapChar, ovColor, b, stream.fontIndex, s.tracerGlow);
                grid.renderMode[idx] = RENDER_MODE.OVERLAP;
            }
        } else {
            this.grid.clearCell(idx);
        }
    }
    _spawnUpwardTracerAt(x) {
        const s = this.config.state;
        const stream = this._initializeUpwardTracerStream(x, s);
        this.activeStreams.push(stream);
        this.lastUpwardTracerInColumn[x] = stream;
    }
    _initializeUpwardTracerStream(x, s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        // Apply speed multiplier (faster scanners look better)
        const speedMult = s.upwardTracerSpeedMult || 1.5; 
        const tickInterval = Math.max(1, baseTick / speedMult);
        return {
            x,
            // Always start at the bottom to ensure upward movement only
            y: this.grid.rows, 
            active: true,
            delay: 0, // Remove delay for immediate feedback
            age: 0,
            len: 1, // Conceptually length 1 head
            isUpward: true,
            visibleLen: 1000, // Long life
            mode: 'STANDARD',
            tickInterval: tickInterval,
            tickTimer: 0
        };
    }
    addActiveStream(stream) {
        if (!stream) return;
        this.activeStreams.push(stream);
        this.streamsPerColumn[stream.x]++;
        this.lastStreamInColumn[stream.x] = stream;
        if (stream.isEraser) {
            this.lastEraserInColumn[stream.x] = stream;
        } else if (stream.isUpward) {
            this.lastUpwardTracerInColumn[stream.x] = stream;
        }
    }
    _handleUpwardHead(idx, s) {
        // Only interact if the cell is ACTIVE (has a character) AND visible
        // Prevents "resurrecting" fully faded characters which looks like spawning new ones
        if (this.grid.state[idx] === CELL_STATE.ACTIVE && this.grid.alphas[idx] > 0.1) {
            // 25% chance to leave a "blank" (gap) in the glimmer trail
            if (Math.random() < 0.25) return;
            // Mark as Glimmering immediately and store lifecycle state in complexStyles
            this.grid.mix[idx] = 30.0; 
            this.grid.complexStyles.set(idx, { type: 'glimmer', age: 1 });
        }
    }
}
// --- Worker Dep: GlowSystem.js ---
class GlowSystem {
    constructor(grid) {
        this.grid = grid;
        this.sources = [];
    }
    /**
     * Adds a transient radial glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} radius - Radius in cells.
     * @param {number} intensity - Peak intensity.
     * @param {number|null} color - Tint color (Uint32).
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential', 'none'.
     */
    add(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.addRadial(x, y, radius, intensity, color, duration, decayFn);
    }
    addRadial(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.sources.push({
            type: 'radial', x, y, radius, intensity, color, 
            duration: Math.max(1, duration), 
            maxDuration: Math.max(1, duration), 
            decayFn, 
            age: 0
        });
    }
    /**
     * Adds a transient rectangular glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} width - Full Width in cells.
     * @param {number} height - Full Height in cells.
     * @param {number} intensity - Peak intensity (inside box).
     * @param {number|null} color - Tint color.
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential'.
     * @param {number} falloff - Soft edge radius outside the box (0 = hard edge).
     */
    addRect(x, y, width, height, intensity, color = null, duration = 0, decayFn = 'linear', falloff = 2) {
        this.sources.push({
            type: 'rect', x, y, w: width, h: height, falloff, intensity, color,
            duration: Math.max(1, duration),
            maxDuration: Math.max(1, duration),
            decayFn,
            age: 0
        });
    }
    update() {
        // Lifecycle Management
        for (let i = this.sources.length - 1; i >= 0; i--) {
            const s = this.sources[i];
            s.age++;
            if (s.age >= s.duration) {
                this.sources.splice(i, 1);
            }
        }
    }
    apply() {
        if (this.sources.length === 0) return;
        const grid = this.grid;
        const cols = grid.cols;
        const rows = grid.rows;
        const gEnvGlows = grid.envGlows;
        const gColors = grid.colors;
        for (const s of this.sources) {
            // Calculate lifecycle intensity
            let currentIntensity = s.intensity;
            if (s.decayFn === 'linear') {
                currentIntensity *= 1.0 - (s.age / s.maxDuration);
            } else if (s.decayFn === 'exponential') {
                const prog = s.age / s.maxDuration;
                currentIntensity *= (1.0 - (prog * prog));
            }
            if (currentIntensity <= 0.01) continue;
            // Determine Bounds
            let minX, maxX, minY, maxY;
            if (s.type === 'rect') {
                const halfW = s.w / 2;
                const halfH = s.h / 2;
                const margin = s.falloff;
                minX = Math.floor(s.x - halfW - margin);
                maxX = Math.ceil(s.x + halfW + margin);
                minY = Math.floor(s.y - halfH - margin);
                maxY = Math.ceil(s.y + halfH + margin);
            } else {
                // Radial
                const r = s.radius;
                minX = Math.floor(s.x - r);
                maxX = Math.ceil(s.x + r);
                minY = Math.floor(s.y - r);
                maxY = Math.ceil(s.y + r);
            }
            // Clamp to grid
            minX = Math.max(0, minX); maxX = Math.min(cols - 1, maxX);
            minY = Math.max(0, minY); maxY = Math.min(rows - 1, maxY);
            for (let cy = minY; cy <= maxY; cy++) {
                for (let cx = minX; cx <= maxX; cx++) {
                    const idx = cy * cols + cx;
                    if (grid.state[idx] === 0) continue; 
                    let boost = 0;
                    if (s.type === 'rect') {
                        // Signed Distance Field logic for Box
                        // distance from center relative to half-size
                        const dx = Math.abs(cx - s.x) - (s.w / 2);
                        const dy = Math.abs(cy - s.y) - (s.h / 2);
                        // dist > 0 means outside. dist <= 0 means inside.
                        // We only care about outside distance for falloff.
                        // Inside is full intensity.
                        const outsideDist = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
                        if (outsideDist <= 0) {
                            boost = currentIntensity; // Inside box
                        } else if (outsideDist < s.falloff) {
                            // Fade out
                            boost = currentIntensity * (1.0 - (outsideDist / s.falloff));
                        }
                    } else {
                        // Radial
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < s.radius) {
                            boost = currentIntensity * (1.0 - (dist / s.radius));
                        }
                    }
                    if (boost > 0.01) {
                        gEnvGlows[idx] += boost;
                        if (s.color !== null) {
                            const blendFactor = Math.min(1.0, boost * 0.5);
                            const cur = gColors[idx];
                            const cR = cur & 0xFF;
                            const cG = (cur >> 8) & 0xFF;
                            const cB = (cur >> 16) & 0xFF;
                            const sR = s.color & 0xFF;
                            const sG = (s.color >> 8) & 0xFF;
                            const sB = (s.color >> 16) & 0xFF;
                            const nR = cR + (sR - cR) * blendFactor;
                            const nG = cG + (sG - cG) * blendFactor;
                            const nB = cB + (sB - cB) * blendFactor;
                            const nA = (cur >> 24) & 0xFF;
                            gColors[idx] = ((nA & 0xFF) << 24) | ((Math.floor(nB) & 0xFF) << 16) | ((Math.floor(nG) & 0xFF) << 8) | (Math.floor(nR) & 0xFF);
                        }
                    }
                }
            }
        }
    }
}
// --- SimulationWorker.js ---
// SimulationWorker.js
// Handles physics/simulation logic in a separate thread.
// 1. Import Dependencies (Synchronous in Workers)
// 2. Global State
let grid = null;
let streamManager = null;
let glowSystem = null;
let config = { 
    state: {}, 
    derived: {} 
}; 
// Mock ConfigurationManager interface for StreamManager
const configManagerMock = {
    get state() { return config.state; },
    get derived() { return config.derived; }
};
// 3. Simulation System (Simplified for Worker)
class WorkerSimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.streamManager = new StreamManager(grid, config);
        this.glowSystem = new GlowSystem(grid);
        this.grid.glowSystem = this.glowSystem;
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.timeScale = 1.0;
    }
    update(frame) {
        this.streamManager.update(frame, this.timeScale);
        this._manageOverlapGrid(frame);
        this._updateCells(frame, this.timeScale);
        // Glimmer Lifecycles (Refactored to method)
        this._updateGlimmerLifecycle();
        // Apply Glows
        if (this.grid.envGlows) this.grid.envGlows.fill(0);
        this.glowSystem.update();
        this.glowSystem.apply();
        if (this.grid.cellLocks) {
            this.grid.cellLocks.fill(0);
        }
    }
    _updateGlimmerLifecycle() {
        const s = this.config.state;
        const d = this.config.derived;
        // Glimmer Speed now controls the shader animation (blink/shimmer), not character rotation.
        // We iterate over a copy of keys to safely mutate the map during iteration (for movement)
        const indices = Array.from(this.grid.complexStyles.keys());
        for (const idx of indices) {
            const style = this.grid.complexStyles.get(idx);
            if (!style || style.type !== 'glimmer') continue;
            // Initialize Mobility (One-time)
            if (style.mobile === undefined) {
                // 20% chance to be a "Moving" glimmer
                if (Math.random() < 0.2) {
                    style.mobile = true;
                    // Move every 4-8 frames
                    style.moveInterval = Utils.randomInt(4, 8);
                    style.nextMove = style.age + style.moveInterval;
                    style.moveDir = -1; 
                } else {
                    style.mobile = false;
                }
            }
            const attack = s.upwardTracerAttackFrames;
            const hold = s.upwardTracerHoldFrames;
            const release = s.upwardTracerReleaseFrames;
            const totalDuration = attack + hold + release;
            style.age++;
            const activeAge = style.age - 1;
            // --- Vertical Movement Logic ---
            let currentIdx = idx;
            if (style.mobile && activeAge >= style.nextMove && activeAge < totalDuration) {
                const col = currentIdx % this.grid.cols;
                const row = Math.floor(currentIdx / this.grid.cols);
                const nextRow = row + style.moveDir;
                if (nextRow >= 0 && nextRow < this.grid.rows) {
                    const nextIdx = currentIdx + (style.moveDir * this.grid.cols);
                    if (!this.grid.complexStyles.has(nextIdx)) {
                        // Move State
                        this.grid.complexStyles.set(nextIdx, style);
                        this.grid.complexStyles.delete(currentIdx);
                        // Move Mix Value
                        this.grid.mix[nextIdx] = this.grid.mix[currentIdx];
                        this.grid.mix[currentIdx] = 0;
                        // Move Effect Char
                        this.grid.effectChars[nextIdx] = this.grid.effectChars[currentIdx];
                        this.grid.effectChars[currentIdx] = 0;
                        currentIdx = nextIdx;
                        style.nextMove = activeAge + style.moveInterval;
                    }
                }
            }
            // Ensure we use the underlying character
            this.grid.effectChars[currentIdx] = 0;
            // --- Lifecycle / Fade Logic ---
            let alpha = 0.0;
            if (activeAge <= attack) {
                alpha = (attack > 0) ? (activeAge / attack) : 1.0;
            } else if (activeAge <= attack + hold) {
                alpha = 1.0;
            } else if (activeAge <= totalDuration) {
                const releaseAge = activeAge - (attack + hold);
                alpha = (release > 0) ? (1.0 - (releaseAge / release)) : 0.0;
            }
            if (activeAge <= totalDuration) {
                this.grid.mix[currentIdx] = 30.0 + alpha;
            } else {
                this.grid.mix[currentIdx] = 0;
                this.grid.complexStyles.delete(currentIdx);
            }
        }
    }
    // Copied from SimulationSystem.js (Logic is identical)
    _manageOverlapGrid(frame) {
        const s = this.config.state;
        if (!s.overlapEnabled) {
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                if (this.grid.secondaryChars && typeof this.grid.secondaryChars.fill === 'function') {
                    this.grid.secondaryChars.fill(32); 
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = s.overlapDensity;
        const ovRgb = Utils.hexToRgb(s.overlapColor);
        const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
        const setOverlapChar = (i) => {
            let fIdx;
            if (this.grid.types[i] === CELL_TYPE.EMPTY) {
                fIdx = Math.floor(Math.random() * numFonts);
            } else {
                fIdx = this.grid.fontIndices[i];
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            let code = 32;
            if (chars && chars.length > 0) {
                const r = Math.floor(Math.random() * chars.length);
                code = chars[r].charCodeAt(0);
            }
            this.grid.secondaryChars[i] = code;
            this.grid.secondaryColors[i] = ovColor;
        };
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            const N = this.grid.secondaryChars.length;
            for (let i = 0; i < N; i++) {
                if (this.grid.overrideActive[i] !== 0) continue;
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.secondaryChars[i] = 32; 
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _updateCells(frame, timeScale = 1.0) {
        if (timeScale <= 0) return;
        if (timeScale < 1.0) {
            if (Math.random() > timeScale) return;
        }
        const s = this.config.state;
        const d = this.config.derived;
        const grid = this.grid;
        for (const idx of grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const grid = this.grid;
        if (grid.cellLocks && grid.cellLocks[idx] === 1) return;
        if (grid.overrideActive[idx] !== 0) return;
        const decay = grid.decays[idx];
        if (decay === 0) return;
        let age = grid.ages[idx];
        if (age > 0) {
            age = age + 1;
            grid.ages[idx] = age;
        }
        const isTracer = (grid.types[idx] === CELL_TYPE.TRACER || grid.types[idx] === CELL_TYPE.ROTATOR);
        const isUpward = (grid.types[idx] === CELL_TYPE.UPWARD_TRACER);
        if (decay < 2 && isTracer) {
            const attack = s.tracerAttackFrames;
            const hold = s.tracerHoldFrames;
            const release = s.tracerReleaseFrames;
            const targetGlow = s.tracerGlow;
            const tracerColor = d.tracerColorUint32;
            const baseColor = grid.baseColors[idx];
            let ratio = 0; 
            const activeAge = age - 1;
            if (s.gradualColorStreams && !isUpward) {
                const fadeStart = attack + hold;
                const fadeLen = 45.0; 
                if (activeAge > fadeStart) {
                    ratio = Math.min(1.0, (activeAge - fadeStart) / fadeLen);
                }
            } else {
                if (activeAge > attack + hold) {
                    if (release > 0) {
                        ratio = Math.min(1.0, (activeAge - (attack + hold)) / release);
                    } else {
                        ratio = 1.0;
                    }
                }
            }
            if (ratio >= 1.0) {
                grid.colors[idx] = baseColor;
                grid.glows[idx] = 0; 
                if (grid.mix[idx] >= 2.0) grid.mix[idx] = 0; 
            } else if (ratio > 0) {
                const tR = tracerColor & 0xFF;
                const tG = (tracerColor >> 8) & 0xFF;
                const tB = (tracerColor >> 16) & 0xFF;
                const bR = baseColor & 0xFF;
                const bG = (baseColor >> 8) & 0xFF;
                const bB = (baseColor >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * ratio);
                const mG = Math.floor(tG + (bG - tG) * ratio);
                const mB = Math.floor(tB + (bB - tB) * ratio);
                grid.colors[idx] = Utils.packAbgr(mR, mG, mB);
                grid.glows[idx] = targetGlow * (1.0 - ratio);
            } else {
                grid.colors[idx] = tracerColor;
                grid.glows[idx] = targetGlow;
            }
        }
        if ((s.rotatorEnabled || grid.mix[idx] > 0) && grid.types[idx] === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        if (grid.complexStyles.has(idx)) {
            const style = grid.complexStyles.get(idx);
            if (style.cycle) {
                const newHue = (style.h + style.speed) % 360;
                style.h = newHue; 
                const rgb = Utils.hslToRgb(newHue, style.s, style.l);
                grid.colors[idx] = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
            }
        }
        if (decay >= 2) {
            let useBase = true;
            if (grid.complexStyles.has(idx)) {
                const style = grid.complexStyles.get(idx);
                if (style.cycle) useBase = false;
            }
            if (useBase) {
                 grid.colors[idx] = grid.baseColors[idx];
                 grid.glows[idx] = 0;
            } else {
                grid.glows[idx] = 0;
            }
            grid.decays[idx]++;
            const newDecay = grid.decays[idx];
            if (newDecay > s.decayFadeDurationFrames + 2) {
                grid.clearCell(idx);
                return;
            }
            grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, s.decayFadeDurationFrames);
        } else {
            grid.alphas[idx] = this._calculateAlpha(idx, age, decay, s.decayFadeDurationFrames);
        }
        // Run Glimmer Lifecycle (Rotation/Fade)
        this._updateGlimmerLifecycle();
    }
    _handleRotator(idx, frame, s, d) {
        const grid = this.grid;
        const mix = grid.mix[idx]; 
        const decay = grid.decays[idx];
        if (mix > 0) {
            const step = 1.0 / Math.max(1, s.rotatorCrossfadeFrames);
            const newMix = mix + step;
            if (newMix >= 1.0) {
                const target = grid.getRotatorTarget(idx, false); 
                if (target) {
                    grid.chars[idx] = target.charCodeAt(0);
                    if (s.overlapEnabled) {
                        const ovTarget = grid.getRotatorTarget(idx, true);
                        if (ovTarget) grid.secondaryChars[idx] = ovTarget.charCodeAt(0);
                    }
                }
                grid.mix[idx] = 0;
                grid.nextChars[idx] = 0;
                grid.nextOverlapChars[idx] = 0;
            } else {
                grid.mix[idx] = newMix;
            }
        } else if (s.rotatorEnabled && (decay === 1 || (s.rotateDuringFade && decay > 1))) {
            let effectiveCycle = d.rotatorCycleFrames;
            if (s.rotatorDesyncEnabled) {
                const variancePercent = s.rotatorDesyncVariance / 100;
                const maxVariance = d.rotatorCycleFrames * variancePercent;
                const offsetNorm = (grid.rotatorOffsets[idx] / 127.5) - 1.0;
                effectiveCycle = Math.max(1, Math.round(d.rotatorCycleFrames + (offsetNorm * maxVariance)));
            }
            if (frame % effectiveCycle === 0) {
                const fontIdx = grid.fontIndices[idx];
                const activeFonts = this.config.derived.activeFonts;
                const fontData = activeFonts[fontIdx] || activeFonts[0];
                const charSet = fontData.chars;
                const nextChar = Utils.getUniqueChar(grid.getChar(idx), charSet); // Use Utils directly
                // Note: Utils.getUniqueChar takes (exclude, charSet) but Utils signature is (exclude) because Utils.CHARS is default.
                let nextCode = 32;
                if (nextChar) nextCode = nextChar.charCodeAt(0);
                else {
                    // Fallback
                     const r = Math.floor(Math.random() * charSet.length);
                     nextCode = charSet[r].charCodeAt(0);
                }
                let nextOvCode = 0;
                if (s.overlapEnabled) {
                    const r2 = Math.floor(Math.random() * charSet.length);
                    nextOvCode = charSet[r2].charCodeAt(0);
                }
                if (s.rotatorCrossfadeFrames <= 1) {
                    grid.chars[idx] = nextCode;
                    if (nextOvCode) grid.secondaryChars[idx] = nextOvCode;
                } else {
                    grid.mix[idx] = 0.01; 
                    grid.setRotatorTarget(idx, String.fromCharCode(nextCode), false);
                    if (nextOvCode) {
                        grid.setRotatorTarget(idx, String.fromCharCode(nextOvCode), true);
                    }
                }
            }
        }
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        const s = this.config.state;
        const b = this.grid.brightness[idx];
        if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            const fade = Math.pow(Math.max(0, 1.0 - ratio), 2.0);
            return 0.95 * fade * b;
        }
        let attack = s.tracerAttackFrames;
        if (this.grid.types[idx] === CELL_TYPE.UPWARD_TRACER) {
            attack = s.upwardTracerAttackFrames;
        }
        if (age <= attack && attack > 0) {
            return 0.95 * (age / attack) * b;
        }
        return 0.95 * b;
    }
}
let simSystem = null;
// 4. Message Handler
self.onmessage = function(e) {
    const msg = e.data;
    switch(msg.type) {
        case 'init':
            // 1. Setup Config
            config.state = msg.config.state;
            config.derived = msg.config.derived;
            // 2. Setup Grid with Shared Buffers
            grid = new CellGrid(configManagerMock);
            // Reconstruct Views
            grid.resize(msg.width, msg.height, msg.buffers);
            // 3. Setup Simulation
            simSystem = new WorkerSimulationSystem(grid, configManagerMock);
            // console.log("[SimulationWorker] Initialized");
            break;
        case 'config':
            config.state = msg.config.state;
            config.derived = msg.config.derived;
            // Handle resizes if necessary?
            // Usually init handles resize via buffer swap, but dynamic resize sends 'init' again?
            // If just config tweak, we update state.
            break;
        case 'resize':
             // Re-bind buffers if they changed
             if (grid) {
                 config.state = msg.config.state; // Ensure latest state for resize calc
                 config.derived = msg.config.derived;
                 grid.resize(msg.width, msg.height, msg.buffers);
                 if (simSystem) simSystem.streamManager.resize(grid.cols);
             }
             break;
        case 'replace_state':
            console.log("[SimulationWorker] Received replace_state request");
            if (simSystem && msg.state) {
                const sm = simSystem.streamManager;
                const s = msg.state;
                // Rehydrate Active Streams (Array -> Set for holes)
                // Note: The objects in s.activeStreams are clones created by postMessage.
                // We modify them in place to restore functionality.
                const rehydratedStreams = (s.activeStreams || []).map(st => {
                     if (Array.isArray(st.holes)) {
                         st.holes = new Set(st.holes);
                     }
                     return st;
                });
                sm.activeStreams = rehydratedStreams;
                sm.nextSpawnFrame = s.nextSpawnFrame || 0;
                // Typed Arrays need explicit copy if not shared (passed as ArrayBuffer usually)
                if (s.columnSpeeds) sm.columnSpeeds = new Float32Array(s.columnSpeeds);
                // Reconstruct Column References
                // Because QuantizedPulseEffect pre-mapped these arrays to the serialized objects in activeStreams,
                // and postMessage preserves the object identity graph (topology),
                // s.lastStreamInColumn[i] ALREADY points to the correct object inside s.activeStreams.
                // We don't need to manually re-link them.
                if (s.lastStreamInColumn) sm.lastStreamInColumn = s.lastStreamInColumn;
                if (s.lastEraserInColumn) sm.lastEraserInColumn = s.lastEraserInColumn;
                if (s.lastUpwardTracerInColumn) sm.lastUpwardTracerInColumn = s.lastUpwardTracerInColumn;
                // Sync Overlap State
                if (s.overlapInitialized !== undefined) simSystem.overlapInitialized = s.overlapInitialized;
                if (s._lastOverlapDensity !== undefined) simSystem._lastOverlapDensity = s._lastOverlapDensity;
                // Sync Complex Styles (Glimmer/Upward Tracers)
                if (s.complexStyles && Array.isArray(s.complexStyles)) {
                    simSystem.grid.complexStyles.clear();
                    for (const [key, value] of s.complexStyles) {
                        simSystem.grid.complexStyles.set(key, value);
                    }
                }
                // CRITICAL: Rebuild Active Indices
                // We prefer the explicit list sent from main thread to avoid SAB race conditions.
                if (grid && grid.state) {
                    grid.activeIndices.clear();
                    if (s.activeIndices && Array.isArray(s.activeIndices)) {
                        for (const idx of s.activeIndices) {
                            grid.activeIndices.add(idx);
                        }
                        console.log(`[SimulationWorker] Replaced activeIndices with ${s.activeIndices.length} entries.`);
                    } else {
                        // Fallback: Scan SAB (May be risky if not propagated)
                        console.warn("[SimulationWorker] activeIndices missing in replace_state! Scanning SAB...");
                        const total = grid.cols * grid.rows;
                        for(let i=0; i<total; i++) {
                            if (grid.state[i] === 1) { // CELL_STATE.ACTIVE
                                grid.activeIndices.add(i);
                            }
                        }
                        console.log(`[SimulationWorker] Scanned ${grid.activeIndices.size} active cells.`);
                    }
                }
                console.log("[SimulationWorker] State Swap Complete.");
            }
            break;
        case 'update':
            if (simSystem) {
                simSystem.update(msg.frame);
                // No need to post back data, it's in SharedArrayBuffer
                // We can post a 'tick' for sync if needed, but not strictly required for purely visual detached sim.
            }
            break;
    }
};
</script>
<script>
// --- Utils.js ---
const APP_VERSION = "8.5"; // Updated version
// =========================================================================
// 1. CORE UTILITIES / CONSTANTS
// =========================================================================
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a color string (Hex "#RRGGBB" or "rgb(r,g,b)") to an { r, g, b } object.
     * @param {string} input - The color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (input) => {
        if (typeof input !== "string") return { r: 0, g: 255, b: 0 };
        // Handle Hex (6 or 8 digits)
        const hexMatch = input.match(/^#?([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/);
        if (hexMatch) {
            const value = parseInt(hexMatch[1], 16);
            return {
                r: (value >> 16) & 0xFF,
                g: (value >> 8) & 0xFF,
                b: value & 0xFF
            };
        }
        // Handle RGB / RGBA
        const match = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            return {
                r: parseInt(match[1], 10),
                g: parseInt(match[2], 10),
                b: parseInt(match[3], 10)
            };
        }
        // Fallback
        return { r: 0, g: 255, b: 0 }; 
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Packs RGB components into a single 32-bit integer (0xAABBGGRR) for Little Endian (RR GG BB AA in memory).
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @param {number} a - Alpha (0-255), defaults to 255.
     * @returns {number} The packed 32-bit integer.
     */
    packAbgr: (r, g, b, a = 255) => {
        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
    },
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: '',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3,
    UPWARD_TRACER: 4
};
    // =========================================================================
    // 1.1 NOTIFICATION SYSTEM 
    // =========================================================================
// --- ConfigurationManager.js ---
class ConfigurationManager {
    constructor() {
        this.storageKey = 'matrix_config_v8.5';
        this.slotsKey = 'matrix_slots_v8.5';
        this.defaults = this._initializeDefaults();
        this.state = { ...this.defaults };
        this.derived = {};
        this.slots = this._loadSlots();
        this.subscribers = [];
        this._previousSmoothingEnabled = undefined;
        this._previousSmoothingAmount = undefined;
        // Define keys that are shared across all profiles (Global Settings)
        this.SHARED_KEYS = new Set([
            'showFpsCounter',
            'debugEnabled',
            'highlightErasers',
            'logErrors',
            'keyBindings',
            'hideMenuIcon',
            'suppressToasts',
            'renderingEngine',
            // 'savedPresets' is handled by this.slots
        ]);
        // Keys that affect derived values (safe superset to ensure correctness)
        this._derivedKeys = new Set([
            'streamSpeed',
            'horizontalSpacingFactor',
            'verticalSpacingFactor',
            'rotatorSyncToTracer',
            'rotatorSyncMultiplier',
            'rotatorCycleFactor',
            'tracerAttackFrames',
            'tracerReleaseFrames',
            'tracerHoldFrames',
            'fontSize',
            'brightnessVariance',
            'backgroundColor',
            'streamColor',
            'tracerColor',
            'streamPalette',
            'fontFamily',
            'fontWeight',
            'italicEnabled',
            'fontSettings'
        ]);
        this._loadState();
        this.updateDerivedValues();
    }
    // ====================
    // Initialization Helpers
    // ====================
    /**
     * Initializes the default configuration settings.
     * @private
     * @returns {Object} An object containing all default configuration properties.
     */
    _initializeDefaults() {
        return {
            "streamColor": "#65d778",
            "backgroundColor": "#000000",
            "streamPalette": [
              "#0de761",
              "#1fd64d",
              "#19b81c"
            ],
            "paletteBias": 0,
            "colorMixType": 0.45,
            "tracerColor": "#c2f5f5",
            "fontSize": 24,
            "streamSpeed": 16,
            "releaseInterval": 3,
            "resolution": 0.8,
            "enableGlyphAtlas": true,
            "smoothingEnabled": false,
            "smoothingAmount": 0.1,
            "showFpsCounter": true,
            "debugEnabled": false,
            "highlightErasers": false,
            "logErrors": true,
            "fontFamily": "MatrixEmbedded",
            "fontWeight": "normal",
            "italicEnabled": false,
            "mirrorEnabled": false,
            "variableBrightnessEnabled": true,
            "brightnessVariance": 20,
            "overlapEnabled": false,
            "overlapColor": "#FFD700",
            "overlapDensity": 0.2,
            "overlapTarget": "all",
            "overlapShimmer": false,
            "dissolveEnabled": true,
            "dissolveScalePercent": -20,
            "deteriorationEnabled": true,
            "deteriorationStrength": 4,
            "enableBloom": true,
            "bloomStrength": 1,
            "bloomOpacity": 0.25,
            "tracerGlow": 5,
            "clearAlpha": 0.82,
            "horizontalSpacingFactor": 0.7,
            "verticalSpacingFactor": 1,
            "fontOffsetX": 0,
            "fontOffsetY": 0,
            "stretchX": 1,
            "stretchY": 1.1,
            "decayFadeDurationFrames": 24,
            "streamSpawnCount": 2,
            "eraserSpawnCount": 2,
            "minStreamGap": 30,
            "minEraserGap": 30,
            "minGapTypes": 29,
            "allowTinyStreams": true,
            "gradualColorStreams": false,
            "holeRate": 0.1,
            "desyncIntensity": 0,
            "preferClusters": true,
            "eraserStopChance": 1,
            "tracerStopChance": 1,
            "tracerAttackFrames": 4,
            "tracerHoldFrames": 0,
            "tracerReleaseFrames": 4,
            "invertedTracerEnabled": true,
            "invertedTracerChance": 0.1,
            "upwardTracerEnabled": false,
            "upwardTracerChance": 0.02,
            "upwardTracerAttackFrames": 2,
            "upwardTracerHoldFrames": 30,
            "upwardTracerReleaseFrames": 30,
            "upwardTracerGlow": 8.0,
            "upwardTracerSpeedMult": 1.0,
            "upwardTracerGlimmerSpeed": 2.0,            
            "upwardTracerGlimmerSize": 3, // Grid Size (2x2 to 6x6)
            "upwardTracerGlimmerFill": 3, // Number of blocks to light up
            "upwardTracerGlimmerGlow": 10.0,
            "upwardTracerGlimmerFlicker": 0.5,
            "rotatorEnabled": true,
            "rotatorChance": 0.13,
            "rotatorSyncToTracer": true,
            "rotatorSyncMultiplier": 0.5,
            "rotatorCycleFactor": 20,
            "rotatorCrossfadeFrames": 5,
            "rotateDuringFade": false,
            "rotatorDesyncEnabled": false,
            "rotatorDesyncVariance": 0,
            "shaderEnabled": false,
            "customShader": null,
            "effectShader": null,
            "shaderParameter": 0.39,
            "effectParameter": 0,
            "pulseEnabled": true,
            "pulseUseTracerGlow": false,
            "pulseMovieAccurate": true,
            "pulseFrequencySeconds": 300,
            "pulseDelaySeconds": 0.7,
            "pulseDurationSeconds": 1.2,
            "pulsePreserveSpaces": true,
            "pulseIgnoreTracers": true,
            "pulseDimming": 0.2,
            "pulseBlend": false,
            "pulseWidth": 130,
            "pulseRandomPosition": true,
            "pulseInstantStart": false,
            "pulseCircular": false,
            "clearPulseEnabled": true,
            "clearPulseMovieAccurate": true,
            "clearPulseUseTracerGlow": true,
            "clearPulseFrequencySeconds": 235,
            "clearPulseDurationSeconds": 1.1,
            "clearPulsePreserveSpaces": true,
            "clearPulseBlend": true,
            "clearPulseWidth": 130,
            "clearPulseRandomPosition": true,
            "clearPulseInstantStart": false,
            "clearPulseCircular": false,
            "miniPulseEnabled": true,
            "miniPulseUseTracerGlow": true,
            "miniPulseFrequencySeconds": 450,
            "miniPulseDurationSeconds": 5,
            "miniPulsePreserveSpaces": true,
            "miniPulseThickness": 100,
            "miniPulseSpawnChance": 0.06,
            "miniPulseSpeed": 16,
            "miniPulseSize": 360,
            "quantizedPulseEnabled": true,
            "quantizedPulseFrequencySeconds": 40,
            "quantizedPulseDurationSeconds": 2.0,
            "quantizedPulseGreenFadeSeconds": 0.5,
            "quantizedPulseBorderIllumination": 4.0,
            "quantizedPulseFadeInFrames": 0,
            "quantizedPulseFadeFrames": 0,
            "quantizedRetractEnabled": false,
            "quantizedRetractFrequencySeconds": 60,
            "dejaVuEnabled": true,
            "dejaVuFrequencySeconds": 350,
            "dejaVuDurationSeconds": 5,
            "dejaVuMinRectHeight": 1,
            "dejaVuMaxRectHeight": 10,
            "dejaVuHoleBrightness": 0.02,
            "dejaVuRandomizeColors": false,
            "dejaVuIntensity": 0.07,
            "dejaVuBarDurationFrames": 21,
            "dejaVuVarianceFrames": 43,
            "supermanEnabled": true,
            "supermanFrequencySeconds": 290,
            "supermanDurationSeconds": 6,
            "supermanFadeSpeed": 6,
            "supermanGlow": 2,
            "supermanBoltThickness": 5,
            "supermanFlickerRate": 3,
            "supermanWidth": 3,
            "supermanSpawnSpeed": 69,
            "starPowerEnabled": false,
            "starPowerFreq": 100,
            "starPowerRainbowMode": "char",
            "starPowerSaturation": 100,
            "starPowerIntensity": 51,
            "starPowerColorCycle": true,
            "starPowerCycleSpeed": 3,
            "rainbowStreamEnabled": false,
            "rainbowStreamChance": 0.5,
            "rainbowStreamIntensity": 50,
            "bootSequenceEnabled": false,
            "crashEnabled": true,
            "crashFrequencySeconds": 600,
            "crashDurationSeconds": 30,
            "crashSheetCount": 33,
            "crashSheetSpeed": 1.1,
            "crashSheetOpacity": 0.96,
            "crashStationaryChance": 17,
            "crashFlashDelayMin": 3,
            "crashFlashDelayMax": 6,
            "crashEnableSmith": true,
            "crashEnableSuperman": true,
            "crashEnableFlash": true,
            "runBothInOrder": true,
            "keyBindings": {
              "Pulse": "p",
              "ClearPulse": "w",
              "MiniPulse": "e",
              "QuantizedPulse": "q",
              "QuantizedRetract": "Q",
              "DejaVu": "r",
              "Superman": "t",
              "ToggleUI": " ",
              "BootSequence": "b",
              "CrashSequence": "x",
              "BootCrashSequence": "c",
              "ReverseTime": "u"
            },
            "hideMenuIcon": true,
            "fontSettings": {
              "MatrixEmbedded": {
                "active": true,
                "useCustomChars": false,
                "customCharacters": ""
              }
            },
            "deteriorationType": "ghost",
            "tracerSizeIncrease": 1,
            "supermanProb": 4,
            "dejaVuAutoMode": true,
            "clearPulseIgnoreTracers": true,
            "dejaVuPerformanceMode": false,
            "pulseDelayFrames": 60,
            "suppressToasts": false,
            "supermanIncludeColors": true,
            "renderingEngine": "canvas",
            "dissolveMinSize": 19,
            "crashMovieFps": true
        };
    }
    /**
     * Deep clone utility to minimize allocations and handle future structuredClone availability.
     * @private
     */
    _deepClone(obj) {
        if (typeof structuredClone === 'function') {
            return structuredClone(obj);
        }
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * Loads configuration slots from local storage.
     * @private
     * @returns {Array<Object>} An array of slot data.
     */
    _loadSlots() {
        try {
            const storedSlots = localStorage.getItem(this.slotsKey);
            if (storedSlots) {
                return JSON.parse(storedSlots);
            }
        } catch (e) {
            console.warn('Failed to load slots:', e);
        }
        // Default slots if not found or error occurs
        return [
            { name: "Trilogy", data: this._deepClone(this.defaults) },
            {
                name: "Neo Code",
                data: {
                    "streamColor": "#65d778",
                    "streamPalette": ["#1cc427", "#20a73b", "#5ddf3a"],
                    "tracerColor": "#aadaa9",
                    "fontSize": 17,
                    "streamSpeed": 15,
                    "releaseInterval": 1,
                    "resolution": 1,
                    "fontFamily": "CustomFont_5e2697679380fc43",
                    "variableBrightnessEnabled": false,
                    "brightnessVariance": 0,
                    "overlapEnabled": false,
                    "dissolveScalePercent": -4,
                    "deteriorationStrength": 2,
                    "bloomStrength": 3,
                    "bloomOpacity": 0.75,
                    "tracerGlow": 17,
                    "clearAlpha": 0.34,
                    "horizontalSpacingFactor": 0.85,
                    "verticalSpacingFactor": 0.95,
                    "stretchX": 0.9,
                    "stretchY": 0.9,
                    "decayFadeDurationFrames": 126,
                    "streamSpawnCount": 1,
                    "eraserSpawnCount": 5,
                    "minStreamGap": 6,
                    "minEraserGap": 6,
                    "minGapTypes": 1,
                    "holeRate": 0,
                    "desyncIntensity": 0.2,
                    "eraserStopChance": 0,
                    "tracerStopChance": 0,
                    "tracerAttackFrames": 2,
                    "tracerHoldFrames": 0,
                    "tracerReleaseFrames": 7,
                    "invertedTracerEnabled": false,
                    "rotatorEnabled": true,
                    "rotatorChance": 1,
                    "rotatorSyncToTracer": true,
                    "rotatorSyncMultiplier": 0.1,
                    "rotatorCycleFactor": 20,
                    "rotatorCrossfadeFrames": 2,
                    "rotateDuringFade": true,
                    "rotatorDesyncEnabled": true,
                    "rotatorDesyncVariance": 60,
                    "shaderEnabled": false,
                    "shaderParameter": 0.94,
                    "fontSettings": {
                        "MatrixEmbedded": { "active": false },
                        "CustomFont_5e2697679380fc43": {
                            "active": true,
                            "useCustomChars": true,
                            "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy",
                            "useAllChars": false
                        }
                    }
                }
            },
            {
                name: "Trinity Code",
                data: {
                    "streamColor": "#65d778",
                    "streamPalette": ["#3eea88", "#37e68c"],
                    "tracerColor": "#aadaa9",
                    "fontSize": 24,
                    "streamSpeed": 16,
                    "releaseInterval": 1,
                    "resolution": 1,
                    "fontFamily": "CustomFont_5e2697679380fc43",
                    "variableBrightnessEnabled": true,
                    "brightnessVariance": 69,
                    "overlapEnabled": true,
                    "overlapColor": "#f4df57",
                    "overlapDensity": 0.3,
                    "overlapTarget": "stream",
                    "dissolveScalePercent": -4,
                    "deteriorationStrength": 3,
                    "bloomStrength": 2,
                    "bloomOpacity": 0.9,
                    "tracerGlow": 10,
                    "clearAlpha": 0.34,
                    "horizontalSpacingFactor": 0.85,
                    "verticalSpacingFactor": 0.95,
                    "stretchX": 0.9,
                    "stretchY": 0.9,
                    "decayFadeDurationFrames": 126,
                    "streamSpawnCount": 1,
                    "eraserSpawnCount": 4,
                    "minStreamGap": 2,
                    "minEraserGap": 2,
                    "minGapTypes": 1,
                    "holeRate": 0,
                    "desyncIntensity": 0.15,
                    "eraserStopChance": 0,
                    "tracerStopChance": 0,
                    "tracerAttackFrames": 2,
                    "tracerHoldFrames": 0,
                    "tracerReleaseFrames": 5,
                    "invertedTracerEnabled": false,
                    "rotatorEnabled": true,
                    "rotatorChance": 1,
                    "rotatorSyncToTracer": true,
                    "rotatorSyncMultiplier": 0.1,
                    "rotatorCycleFactor": 20,
                    "rotatorCrossfadeFrames": 2,
                    "rotateDuringFade": true,
                    "rotatorDesyncEnabled": true,
                    "rotatorDesyncVariance": 60,
                    "shaderEnabled": true,
                    "customShader": "// Name: Static Grain\nprecision mediump float;\nuniform sampler2D uTexture;\nuniform float uParameter;\nvarying vec2 vTexCoord;\nconst float GRAIN_AMOUNT = 0.05;\nfloat random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float noiseValue = random(vTexCoord);\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n    color.rgb += finalNoise * (uParameter * 0.5);\n    gl_FragColor = color;\n}",
                    "shaderParameter": 0.16,
                    "fontSettings": {
                        "MatrixEmbedded": { "active": false },
                        "CustomFont_5e2697679380fc43": {
                            "active": true,
                            "useCustomChars": true,
                            "customCharacters": "'()*+-./0123456789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`cfgnt!\"#$%&,;?@[]abmxlkjihedopqrsuvw~}{zy",
                            "useAllChars": false
                        }
                    }
                }
            }
        ];
    }
    /**
     * Saves configuration slots to local storage.
     */
    saveSlots() {
        try {
            localStorage.setItem(this.slotsKey, JSON.stringify(this.slots));
        } catch (e) {
            console.warn('Failed to save slots:', e);
        }
    }
    /**
     * Loads the application state from local storage.
     * @private
     */
    _loadState() {
        try {
            let storedState = localStorage.getItem(this.storageKey);
            // Fallback to previous version if current version not found
            if (!storedState) {
                const legacyKey = 'matrix_config_v7.5';
                storedState = localStorage.getItem(legacyKey);
            }
            if (storedState) {
                const parsed = JSON.parse(storedState);
                delete parsed.customFonts; // Remove unsupported keys if present
                // Handle new profile structure vs legacy flat structure
                if (parsed.profiles) {
                    // Flatten profiles - prioritize 2D if exists, otherwise take state
                    const p2d = parsed.profiles['2D'] || {};
                    this.state = { ...this.defaults, ...parsed.state, ...p2d };
                } else if (parsed.state) {
                    // Correctly unwrap 'state' property from saved JSON
                    this.state = { ...this.defaults, ...parsed.state };
                } else {
                    // Legacy flat structure
                    this.state = { ...this.defaults, ...parsed };
                }
                // Migration: Ensure streamPalette exists
                if (!this.state.streamPalette) {
                    this.state.streamPalette = [this.state.streamColor];
                }
                // Migration: Convert eraserStopChance from float to integer if needed
                if (this.state.eraserStopChance > 0 && this.state.eraserStopChance < 1) {
                    this.state.eraserStopChance = Math.round(this.state.eraserStopChance * 100);
                }
                // Clamp to max 25
                if (this.state.eraserStopChance > 25) {
                    this.state.eraserStopChance = 25;
                }
            } else {
                // First run: Clone defaults
                this.state = this._deepClone(this.defaults);
            }
        } catch (e) {
            console.warn('Failed to load configuration:', e);
        }
    }
    /**
     * Saves the current application state to local storage.
     */
    save() {
        try {
            // Save state
            const data = {
                state: this.state
            };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (e) {
            console.warn('Failed to save configuration:', e);
        }
    }
    /**
     * Retrieves the value of a specific configuration key.
     * @param {string} key - The key of the configuration setting.
     * @returns {*} The value of the configuration setting.
     */
    get(key) {
        return this.state[key];
    }
    /**
     * Sets the value of a configuration key and triggers updates.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The new value for the setting.
     */
    set(key, value) {
        if (this.state[key] === value) return; // Skip if no change in value
        // Special handling for shaderEnabled
        if (key === 'shaderEnabled') {
            if (value === true) { // Shader is being enabled
                // Store current smoothing values only if they are not already forced
                if (this.state.smoothingEnabled !== false) {
                    this._previousSmoothingEnabled = this.state.smoothingEnabled;
                } else {
                    this._previousSmoothingEnabled = undefined; // No previous value to restore
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this._previousSmoothingAmount = this.state.smoothingAmount;
                } else {
                    this._previousSmoothingAmount = undefined; // No previous value to restore
                }
                // Force smoothing off
                if (this.state.smoothingEnabled !== false) {
                    this.state.smoothingEnabled = false;
                    this.notify('smoothingEnabled');
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this.state.smoothingAmount = 0.1; // Minimum value as per UI definition
                    this.notify('smoothingAmount');
                }
            } else { // Shader is being disabled
                // Restore previous smoothing values if they were stored
                if (this._previousSmoothingEnabled !== undefined && this.state.smoothingEnabled !== this._previousSmoothingEnabled) {
                    this.state.smoothingEnabled = this._previousSmoothingEnabled;
                    this.notify('smoothingEnabled');
                }
                if (this._previousSmoothingAmount !== undefined && this.state.smoothingAmount !== this._previousSmoothingAmount) {
                    this.state.smoothingAmount = this._previousSmoothingAmount;
                    this.notify('smoothingAmount');
                }
                // Clear stored previous values
                this._previousSmoothingEnabled = undefined;
                this._previousSmoothingAmount = undefined;
            }
        }
        // Special handling for fontFamily: Enforce single active font in settings
        if (key === 'fontFamily') {
            const settings = this.state.fontSettings; // Reference current settings
            if (settings && settings[value]) {
                let changed = false;
                // Create a new settings object to trigger reactivity if needed, or mutate copy
                // We'll mutate deeper objects but clone the top level to be safe/clean
                const newSettings = { ...settings };
                for (const fName in newSettings) {
                    if (Object.prototype.hasOwnProperty.call(newSettings, fName)) {
                        const isActive = (fName === value);
                        if (newSettings[fName].active !== isActive) {
                            // Clone the specific font config to avoid mutation side-effects
                            newSettings[fName] = { ...newSettings[fName], active: isActive };
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    this.state.fontSettings = newSettings;
                    this.notify('fontSettings');
                }
            }
        }
        this.state[key] = value; // Update the actual key's value
        // Only recompute derived values when relevant keys change (preserves behavior, improves perf)
        if (this._derivedKeys.has(key) || key === 'ALL') {
            this.updateDerivedValues();
        }
        this.save();
        this.notify(key);
    }
    /**
     * Resets the application state to its default values.
     */
    reset() {
        // Load the "Trilogy" preset (slot 0) after a factory reset
        // This ensures the desired default configuration is applied consistently.
        this.loadFromSlot(0);
        // The loadFromSlot method already calls updateDerivedValues(), save(), and notify('ALL')
        this._showToast("Configuration Reset", "info");
    }
    /**
     * Saves the current application state to a specific slot.
     * @param {number} index - The index of the slot (0-2).
     */
    saveToSlot(index) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index] = {
                name: this.slots[index].name,
                data: this._deepClone(this.state) // Deep clone state
            };
            this.saveSlots();
            this._showToast(`Saved to Slot ${index + 1}: ${this.slots[index].name}`, "success");
        } else {
            console.warn(`Attempted to save to non-existent slot index: ${index}`);
            this._showToast(`Failed to save slot ${index + 1}`, "error");
        }
    }
    /**
     * Loads the application state from a specific slot.
     * @param {number} index - The index of the slot (0-2).
     * @returns {boolean} True if the state was loaded successfully, false otherwise.
     */
    loadFromSlot(index) {
        if (!this.slots[index]?.data) return false; // Use optional chaining for safety
        this.state = { ...this.defaults, ...this.slots[index].data };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
        this._showToast(`Loaded Preset: ${this.slots[index].name}`, "success");
        return true;
    }
    /**
     * Renames a specific configuration slot.
     * @param {number} index - The index of the slot (0-2).
     * @param {string} name - The new name for the slot.
     */
    renameSlot(index, name) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index].name = name;
            this.saveSlots();
            this._showToast(`Renamed Slot ${index + 1} to "${name}"`, "success");
        } else {
            console.warn(`Attempted to rename non-existent slot index: ${index}`);
            this._showToast(`Failed to rename slot ${index + 1}`, "error");
        }
    }
    /**
     * Subscribes a callback function to configuration changes.
     * @param {Function} callback - The function to call when configuration changes.
     */
    subscribe(callback) {
        if (typeof callback === "function") {
            this.subscribers.push(callback);
        }
    }
    /**
     * Notifies all subscribed listeners about a configuration change.
     * @param {string} key - The key of the changed configuration setting.
     */
    notify(key) {
        // Guard each subscriber to prevent one failing listener from breaking the chain
        for (let i = 0; i < this.subscribers.length; i++) {
            const callback = this.subscribers[i];
            try {
                callback(key, this.state);
            } catch (e) {
                console.warn('Subscriber callback failed:', e);
            }
        }
    }
    /**
     * Updates all derived configuration values based on the current state.
     * These are values calculated from base settings for performance or convenience.
     */
    updateDerivedValues() {
        const s = this.state;
        const cycleDuration = 21 - s.streamSpeed;
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const rotatorCycleFrames = s.rotatorSyncToTracer
            ? Math.max(1, Math.floor(cycleDuration / s.rotatorSyncMultiplier))
            : Math.max(10, Math.round(60 - s.rotatorCycleFactor * 2.5));
        // Precompute common color conversions only once
        const streamRgb = Utils.hexToRgb(s.streamColor);
        const bgRgb = Utils.hexToRgb(s.backgroundColor);
        const tracerRgb = Utils.hexToRgb(s.tracerColor);
        // Palette conversions done once and reused
        const paletteHexes = (s.streamPalette && s.streamPalette.length > 0)
            ? s.streamPalette
            : [s.streamColor];
        const paletteRgbs = new Array(paletteHexes.length);
        for (let i = 0; i < paletteHexes.length; i++) {
            paletteRgbs[i] = Utils.hexToRgb(paletteHexes[i]);
        }
        const paletteColorsStr = paletteRgbs.map(Utils.createRGBString);
        const paletteColorsUint32 = paletteRgbs.map(c => Utils.packAbgr(c.r, c.g, c.b));
        this.derived = {
            cycleDuration,
            safeAttack: Math.min(Math.max(1, s.tracerAttackFrames), cycleDuration),
            safeRelease: Math.min(s.tracerReleaseFrames, cycleDuration),
            holdFrames: Math.max(0, s.tracerHoldFrames),
            maxState: cycleDuration + Math.max(0, s.tracerHoldFrames) + cycleDuration,
            rotatorCycleFrames,
            cellWidth: s.fontSize * hFactor,
            cellHeight: s.fontSize * vFactor,
            varianceMin: 1.0 - s.brightnessVariance / 100,
            streamRgb,
            bgRgb,
            tracerRgb,
            streamColorStr: Utils.createRGBString(streamRgb),
            paletteRgbs,
            paletteColorsStr,
            paletteColorsUint32,
            streamColorUint32: Utils.packAbgr(streamRgb.r, streamRgb.g, streamRgb.b),
            tracerColorUint32: Utils.packAbgr(tracerRgb.r, tracerRgb.g, tracerRgb.b),
            tracerColorStr: Utils.createRGBString(tracerRgb),
            fontBaseStr: `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
        };
        // Active Fonts Logic
        const fontSettings = s.fontSettings || {};
        const activeFonts = [];
        for (const name in fontSettings) {
            if (!Object.prototype.hasOwnProperty.call(fontSettings, name)) continue;
            const conf = fontSettings[name];
            if (conf && conf.active) {
                let chars;
                if (conf.useCustomChars) {
                    // Respect user's setting, even if empty (clean slate).
                    // Fallback to " " (space) if effectively empty to prevent simulation errors.
                    const clean = (conf.customCharacters || "").replace(/\s+/g, '');
                    chars = clean.length > 0 ? clean : " ";
                } else {
                    // Use Default
                    chars = Utils.CHARS;
                }
                activeFonts.push({ name, chars });
            }
        }
        // Fallback if no fonts are active
        if (activeFonts.length === 0) activeFonts.push({ name: 'MatrixEmbedded', chars: Utils.CHARS });
        this.derived.activeFonts = activeFonts;
    }
    /**
     * Sets the NotificationManager instance for toast messages.
     * @param {NotificationManager} notifications 
     */
    setNotificationManager(notifications) {
        this.notifications = notifications;
    }
    /**
     * Helper to show toast messages if NotificationManager is available.
     * @param {string} message 
     * @param {string} type 
     */
    _showToast(message, type = 'info') {
        if (this.notifications) {
            this.notifications.show(message, type);
        }
    }
}
// =========================================================================
// 3.0 MATRIX GRID
// =========================================================================
// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=";
    // =========================================================================
    // 4.0 STREAM MODE
    // =========================================================================
// --- CellGrid.js ---
// Constants for Cell State and Render Modes
const CELL_STATE = {
    INACTIVE: 0,
    ACTIVE: 1
    // OVERRIDE state is determined by the overrideActive flag
};
const RENDER_MODE = {
    STANDARD: 0, // Mix between Primary and Secondary based on 'mix'
    OVERLAP: 1,  // Visual Overlap (both visible)
    ADDITIVE: 2  // Additive blending (future proofing)
};
const OVERRIDE_MODE = {
    NONE: 0,
    CHAR: 1,
    SOLID: 2,
    FULL: 3
};
class CellGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // --- Core State ---
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.state = null; // Uint8: INACTIVE / ACTIVE
        // --- Primary Layer ---
        this.chars = null;        // Uint16
        this.colors = null;       // Uint32 (0xAABBGGRR) - Current Display Color
        this.baseColors = null;   // Uint32 (0xAABBGGRR) - Target/Stream Color
        this.alphas = null;       // Float32
        this.glows = null;        // Float32
        this.fontIndices = null;  // Uint8
        // --- Secondary Layer (Rotators / Overlaps) ---
        this.secondaryChars = null; // Uint16
        this.secondaryColors = null; // Uint32
        this.secondaryAlphas = null; // Float32
        this.secondaryGlows = null;  // Float32
        this.secondaryFontIndices = null; // Uint8
        // --- Mixing & Rendering ---
        this.mix = null;        // Float32 (0.0 = Primary, 1.0 = Secondary)
        this.renderMode = null; // Uint8 (RENDER_MODE)
        // --- Override Layer (Effects) ---
        this.overrideActive = null; // Uint8 (OVERRIDE_MODE)
        this.overrideChars = null;  // Uint16
        this.overrideColors = null; // Uint32
        this.overrideAlphas = null; // Float32
        this.overrideGlows = null;  // Float32
        this.overrideMix = null;    // Float32 (New: For FULL mode)
        this.overrideNextChars = null; // Uint16 (New: For FULL mode rotators)
        this.overrideFontIndices = null; // Uint8
        // --- Passive Layer (Effects) ---
        this.effectActive = null;   // Uint8
        this.effectChars = null;    // Uint16
        this.effectColors = null;   // Uint32
        this.effectAlphas = null;   // Float32
        this.effectGlows = null;    // Float32
        this.effectFontIndices = null; // Uint8
        // --- Simulation Logic Storage ---
        this.types = null;      // Uint8 (Tracer, Rotator, Empty)
        this.decays = null;     // Uint8
        this.ages = null;       // Int32
        this.brightness = null; // Float32
        this.rotatorOffsets = null; // Uint8 (Static noise for desync)
        // Auxiliary
        this.cellLocks = null;  // Uint8 (Prevent updates)
        // Sparse Data (Maps for memory efficiency)
        this.complexStyles = new Map(); // Dynamic styling data
        // Rotator Targets (Dense for GPU upload)
        this.nextChars = null;     // Uint16Array
        this.nextOverlapChars = null; // Uint16Array
    }
    /**
     * Resizes the grid based on new width and height.
     */
    resize(width, height, buffers = null) {
        const d = this.config.derived;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
        if (!d || !d.cellWidth || !d.cellHeight) return;
        const newCols = Math.max(1, (width / d.cellWidth) | 0);
        const newRows = Math.max(1, (height / d.cellHeight) | 0);
        if (newCols !== this.cols || newRows !== this.rows || buffers) {
            this._resizeGrid(newCols, newRows, buffers);
        }
    }
    getIndex(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return -1;
        return y * this.cols + x;
    }
    // --- Primary Layer Modifiers ---
    setPrimary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.chars[idx] = charStr.charCodeAt(0);
        this.colors[idx] = colorUint32;
        this.alphas[idx] = alpha;
        this.glows[idx] = glow;
        this.fontIndices[idx] = fontIndex;
        this.state[idx] = CELL_STATE.ACTIVE;
        this.activeIndices.add(idx);
    }
    setRotatorTarget(idx, charStr, isSecondary = false) {
        const code = charStr.charCodeAt(0);
        if (isSecondary) {
            this.nextOverlapChars[idx] = code;
        } else {
            this.nextChars[idx] = code;
        }
    }
    getRotatorTarget(idx, isSecondary = false) {
        const code = isSecondary ? this.nextOverlapChars[idx] : this.nextChars[idx];
        return (code > 0) ? String.fromCharCode(code) : null;
    }
    // --- Secondary Layer Modifiers ---
    setSecondary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.secondaryChars[idx] = charStr.charCodeAt(0);
        this.secondaryColors[idx] = colorUint32;
        this.secondaryAlphas[idx] = alpha;
        this.secondaryGlows[idx] = glow;
        this.secondaryFontIndices[idx] = fontIndex;
    }
    // --- Override Layer Modifiers ---
    // This is a 'permanent' or hard override - it directly changes state
    setOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.overrideChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideGlows[idx] = glow;
        this.overrideFontIndices[idx] = fontIndex;
        this.overrideActive[idx] = OVERRIDE_MODE.CHAR;
    }
    // This is a soft override 
    setEffectOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 1;
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Overlay Override (Mixes Effect Char on top of Primary)
    setEffectOverlay(idx, charStr, color, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 2; // 2 = Overlay Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = color;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // High Priority Override (Ignores Shadows/Masks)
    setHighPriorityEffect(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 4; // 4 = High Priority Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Shadow Overlay (Mixes Black Block on top of Primary)
    setEffectShadow(idx, alpha) {
        this.effectActive[idx] = 3; // 3 = Shadow Mode
        this.effectAlphas[idx] = alpha;
        // Chars/Colors/Fonts ignored for shadow
    }
    setSolidOverride(idx, colorUint32, alpha) {
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideActive[idx] = OVERRIDE_MODE.SOLID;
        // Chars/Glows ignored for Solid
    }
    clearOverride(idx) {
        this.overrideActive[idx] = OVERRIDE_MODE.NONE;
    }
    clearEffectOverride(idx) {
        this.effectActive[idx] = 0;
    }
    clearAllOverrides() {
        if (this.overrideActive) {
            this.overrideActive.fill(0);
        }
    }
    clearAllEffects(){
        if (this.effectActive){
            this.effectActive.fill(0);
        }
    }
    // --- General State Management ---
    clearCell(idx) {
        this.state[idx] = CELL_STATE.INACTIVE;
        this.chars[idx] = 32; // Space
        this.alphas[idx] = 0;
        this.glows[idx] = 0;
        this.mix[idx] = 0;
        this.renderMode[idx] = RENDER_MODE.STANDARD;
        // Clear simulation data
        this.types[idx] = 0;
        this.ages[idx] = 0;
        this.decays[idx] = 0;
        // Also clear secondary to be safe
        this.secondaryChars[idx] = 32;
        this.secondaryAlphas[idx] = 0;
        this.activeIndices.delete(idx);
        // Clear maps
        this.complexStyles.delete(idx);
        this.nextChars[idx] = 0;
        this.nextOverlapChars[idx] = 0;
    }
    getChar(idx) {
        // Helper for simulation reading
        return String.fromCharCode(this.chars[idx]);
    }
    getState(idx){
        // Helper for getting cell state
        return this.state[idx];
    }
    _resizeGrid(newCols, newRows, buffers = null) {
        const total = newCols * newRows;
        if (buffers) {
            // Adopt provided buffers (SharedArrayBuffer views)
            this.state = buffers.state;
            this.chars = buffers.chars;
            this.colors = buffers.colors;
            this.baseColors = buffers.baseColors;
            this.alphas = buffers.alphas;
            this.glows = buffers.glows;
            this.fontIndices = buffers.fontIndices;
            this.secondaryChars = buffers.secondaryChars;
            this.secondaryColors = buffers.secondaryColors;
            this.secondaryAlphas = buffers.secondaryAlphas;
            this.secondaryGlows = buffers.secondaryGlows;
            this.secondaryFontIndices = buffers.secondaryFontIndices;
            this.mix = buffers.mix;
            this.renderMode = buffers.renderMode;
            this.overrideActive = buffers.overrideActive;
            this.overrideChars = buffers.overrideChars;
            this.overrideColors = buffers.overrideColors;
            this.overrideAlphas = buffers.overrideAlphas;
            this.overrideGlows = buffers.overrideGlows;
            this.overrideMix = buffers.overrideMix;
            this.overrideNextChars = buffers.overrideNextChars;
            this.overrideFontIndices = buffers.overrideFontIndices;
            this.effectActive = buffers.effectActive;
            this.effectChars = buffers.effectChars;
            this.effectColors = buffers.effectColors;
            this.effectAlphas = buffers.effectAlphas;
            this.effectFontIndices = buffers.effectFontIndices;
            this.effectGlows = buffers.effectGlows;
            this.types = buffers.types;
            this.decays = buffers.decays;
            this.ages = buffers.ages;
            this.brightness = buffers.brightness;
            this.rotatorOffsets = buffers.rotatorOffsets;
            this.cellLocks = buffers.cellLocks;
            this.nextChars = buffers.nextChars;
            this.nextOverlapChars = buffers.nextOverlapChars;
            this.envGlows = buffers.envGlows;
        } else {
            // Core
            this.state = new Uint8Array(total);
            // Primary
            this.chars = new Uint16Array(total);
            this.colors = new Uint32Array(total);
            this.baseColors = new Uint32Array(total);
            this.alphas = new Float32Array(total);
            this.glows = new Float32Array(total);
            this.fontIndices = new Uint8Array(total);
            // Secondary
            this.secondaryChars = new Uint16Array(total);
            this.secondaryColors = new Uint32Array(total);
            this.secondaryAlphas = new Float32Array(total);
            this.secondaryGlows = new Float32Array(total);
            this.secondaryFontIndices = new Uint8Array(total);
            // Mix / Mode
            this.mix = new Float32Array(total);
            this.renderMode = new Uint8Array(total);
            // Override
            this.overrideActive = new Uint8Array(total);
            this.overrideChars = new Uint16Array(total);
            this.overrideColors = new Uint32Array(total);
            this.overrideAlphas = new Float32Array(total);
            this.overrideGlows = new Float32Array(total);
            this.overrideMix = new Float32Array(total);
            this.overrideNextChars = new Uint16Array(total);
            this.overrideFontIndices = new Uint8Array(total);
            // Effects
            this.effectActive = new Uint8Array(total)
            this.effectChars = new Uint16Array(total);
            this.effectColors = new Uint32Array(total);
            this.effectAlphas = new Float32Array(total);
            this.effectFontIndices = new Uint8Array(total);
            this.effectGlows = new Float32Array(total);
            // Simulation
            this.types = new Uint8Array(total);
            this.decays = new Uint8Array(total);
            this.ages = new Int32Array(total);
            this.brightness = new Float32Array(total);
            this.rotatorOffsets = new Uint8Array(total);
            this.cellLocks = new Uint8Array(total);
            // Rotators
            this.nextChars = new Uint16Array(total);
            this.nextOverlapChars = new Uint16Array(total);
            // Environmental Glows (Additive, per frame)
            this.envGlows = new Float32Array(total);
        }
        // Initialize static data (Common to both modes)
        // Note: For SAB, we might skip this if the worker handles initialization, 
        // but it's safe to re-run or let the worker overwrite it.
        // If we are the MAIN thread and just adopting SABs, we probably shouldn't random fill 
        // because the Worker might be doing it.
        // However, this random fill is for "initial static noise".
        // Let's rely on the buffer content being zeroed or initialized elsewhere if buffers are passed.
        if (!buffers) {
            const activeFonts = this.config.derived ? this.config.derived.activeFonts : null;
            const fallbackChars = "012345789Z:<=>\"*+-._!|";
            for (let i = 0; i < total; i++) {
                this.rotatorOffsets[i] = (Math.random() * 255) | 0;
                let charCode = 32; 
                if (activeFonts && activeFonts.length > 0) {
                    const f = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                    if (f.chars && f.chars.length > 0) {
                        charCode = f.chars.charCodeAt(Math.floor(Math.random() * f.chars.length));
                    }
                } else {
                    charCode = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
                }
                this.chars[i] = charCode;
            }
        }
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- EffectRegistry.js ---
class EffectRegistry {
            constructor(grid, config) { 
                this.grid = grid; 
                this.config = config; 
                this.effects = []; 
            }
            register(effect) { this.effects.push(effect); }
            registerDefaults() {
                // ... (Load dynamically or manually)
            }
            trigger(name, ...args) { const fx = this.effects.find(e => e.name === name); if(fx) return fx.trigger(...args); return false; }
            update() { 
                this.grid.clearAllOverrides();
                this.grid.clearAllEffects();
                this.effects.forEach(e => {
                    e.update(); 
                    if (!e.active) return;
                    if (typeof e.applyToGrid === 'function') {
                        e.applyToGrid(this.grid);
                    } else if (typeof e.getOverride === 'function') {
                        this._applyLegacyOverride(e);
                    }
                }); 
            }
            _applyLegacyOverride(e) {
                const indices = e.getActiveIndices();
                const apply = (i) => {
                    const over = e.getOverride(i);
                    if (over) {
                        if (over.solid) {
                            // Parse Color & Alpha
                            let r=0, g=0, b=0, a=255;
                            if (over.bgColor) {
                                // Try Hex first (Utils handles it)
                                if (over.bgColor.startsWith('#')) {
                                    const rgb = Utils.hexToRgb(over.bgColor);
                                    r=rgb.r; g=rgb.g; b=rgb.b;
                                    // Hex alpha not supported by Utils.hexToRgb currently
                                } else {
                                    // Parse rgba()
                                    const match = over.bgColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                                    if (match) {
                                        r = parseInt(match[1]);
                                        g = parseInt(match[2]);
                                        b = parseInt(match[3]);
                                        if (match[4]) a = Math.floor(parseFloat(match[4]) * 255);
                                    }
                                }
                            }
                            // If explicit alpha property exists, use it?
                            // Legacy used bgColor string for solid color.
                            // But over.alpha property might exist too?
                            // Usually solid overrides use bgColor fully.
                            const color = Utils.packAbgr(r, g, b, a);
                            // Store alpha as Float (0..1) for renderer?
                            // CellGrid stores alpha as Float32.
                            // But packAbgr puts alpha in Uint32.
                            // Renderer uses Float32 alpha array.
                            // So we need to set grid.overrideAlphas[i] = a / 255.
                            this.grid.setSolidOverride(i, color, a / 255.0);
                        } else {
                            // Char Override
                            let color = 0xFFFFFFFF; 
                            if (over.color) {
                                 const rgb = Utils.hexToRgb(over.color);
                                 // Alpha from property
                                 const a = over.alpha !== undefined ? over.alpha * 255 : 255;
                                 color = Utils.packAbgr(rgb.r, rgb.g, rgb.b, a);
                            }
                            let fontIdx = 0;
                            if (over.font) {
                                 const activeFonts = this.config.derived.activeFonts;
                                 const idx = activeFonts.findIndex(f => f.name === over.font);
                                 if (idx !== -1) fontIdx = idx;
                            }
                            this.grid.setOverride(i, over.char, color, over.alpha || 1.0, fontIdx, over.glow || 0);
                        }
                    }
                };
                if (indices) {
                    for (const idx of indices) apply(idx);
                } else {
                    const total = this.grid.cols * this.grid.rows;
                    for (let i = 0; i < total; i++) apply(i);
                }
            }
            render(ctx, derived) {
                this.effects.forEach(e => {
                    if (e.active && typeof e.render === 'function') {
                        e.render(ctx, derived);
                    }
                });
            }
        }
        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; this.active = false; }
            trigger() { return false; }
            update() {}
            getActiveIndices() { return new Set(); }
        }
// --- BootEffect.js ---
class BootEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry;
        this.name = "BootSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = 3.5; 
        this.originalShader = null; 
        this.originalShaderEnabled = false; 
        this.originalShaderParameter = 0.5; 
    }
    trigger() {
        if (this.active) return false;
        // Set Effect Shader (Pass 1)
        this.c.set('effectShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; // 0.0 to 1.0 over 3.5s
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) {
    return fract(sin(n * 12.9898) * 43758.5453123);
}
float noise(float p) {
    float i = floor(p);
    float f = fract(p);
    return mix(random(i), random(i + 1.0), f * f * (3.0 - 2.0 * f));
}
float sdRoundedBox(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
float vignetteRect(vec2 uv, float margin) {
    vec2 v = smoothstep(0.0, margin, uv) * smoothstep(1.0, 1.0 - margin, uv);
    return v.x * v.y;
}
float smoothstep_custom(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * (3.0 - 2.0 * x);
}
// "Scanner Sheet" with subtle torn edges
// axis: 0 = none, 1 = jagged horizontal edges, 2 = jagged vertical edges
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    // Torn edge effect
    float jagged = 0.0;
    if (axis == 1) {
        jagged = (noise(uv.x * 50.0) - 0.5) * 0.005; 
        pos.y += jagged;
    } else if (axis == 2) {
        jagged = (noise(uv.y * 50.0) - 0.5) * 0.005;
        pos.x += jagged;
    }
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
// Asymmetrical Scanner Scenes (Full Span + Torn Edges)
vec3 getScannerScene(int pattern, vec2 uv) {
    vec3 col = vec3(1.0); 
    // Pattern 0: Split Scan (Full Width)
    if (pattern == 0) {
        float top = scannerSheet(uv, vec2(0.5, 0.75), vec2(1.0, 0.25), 0.02, 1);
        float bot = scannerSheet(uv, vec2(0.5, 0.25), vec2(1.0, 0.25), 0.02, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.6), vec2(1.0, 0.05), 0.01, 1); 
        vec3 cTop = vec3(0.85, 0.9, 0.95);
        vec3 cBot = vec3(1.0);
        col = mix(vec3(0.9), cBot, bot);
        col = mix(col, cTop, top);
        col = mix(col, vec3(0.7), art);
    }
    // Pattern 1: Faded Gradient + Full Height Side Bar
    if (pattern == 1) {
        float grad = smoothstep(0.0, 1.0, uv.y);
        col = vec3(mix(0.6, 1.0, grad));
        float bar = scannerSheet(uv, vec2(0.15, 0.5), vec2(0.08, 1.0), 0.05, 2); 
        col = mix(col, vec3(0.95), bar);
    }
    // Pattern 2: Bottom Bar (Full Width)
    if (pattern == 2) {
        col = vec3(0.85);
        float bar = scannerSheet(uv, vec2(0.5, 0.15), vec2(1.0, 0.15), 0.03, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.85), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), bar);
        col = mix(col, vec3(0.9), art);
    }
    // Pattern 3: Thick Vertical Block (Full Height)
    if (pattern == 3) {
        col = vec3(1.0);
        float side = scannerSheet(uv, vec2(0.9, 0.5), vec2(0.15, 1.0), 0.08, 2);
        float block = scannerSheet(uv, vec2(0.3, 0.5), vec2(0.15, 1.0), 0.01, 2); 
        vec3 blueLeak = vec3(0.7, 0.85, 1.0);
        col = mix(col, blueLeak, side);
        col = mix(col, vec3(0.8), block);
    }
    // Pattern 4: Top Header (Full Width)
    if (pattern == 4) {
        col = vec3(0.95);
        float head = scannerSheet(uv, vec2(0.5, 0.9), vec2(1.0, 0.1), 0.02, 1);
        float bar = scannerSheet(uv, vec2(0.5, 0.1), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), head);
        col = mix(col, vec3(0.85), bar);
    }
    // Pattern 5: Corner Heavy (Full Span components)
    if (pattern == 5) {
        col = vec3(0.9);
        float vStrip = scannerSheet(uv, vec2(0.1, 0.5), vec2(0.15, 1.0), 0.1, 2);
        float hStrip = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.08), 0.02, 1);
        col = mix(col, vec3(1.0), vStrip);
        col = mix(col, vec3(0.8), hStrip);
    }
    // Pattern 6: Wide Horizontal Split (Full Width)
    if (pattern == 6) {
        col = vec3(1.0);
        float mid = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.15), 0.05, 1);
        col = mix(vec3(0.85), vec3(1.0), mid);
    }
    return col;
}
void main() {
    vec4 origColor = texture2D(uTexture, vTexCoord);
    vec2 uv = vTexCoord;
    vec2 p = uv * 2.0 - 1.0;
    float aspect = uResolution.x / uResolution.y;
    p.x *= aspect;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0); 
    // --- TIMING ---
    float t_dot = smoothstep_custom(0.15, 0.25, uParameter);
    float t_v_stretch = smoothstep_custom(0.25, 0.35, uParameter);
    float t_h_stretch = smoothstep_custom(0.35, 0.45, uParameter);
    vec3 whiteLayer = vec3(0.0);
    float whiteAlpha = 0.0;
    if (uParameter < 0.45) {
        if (uParameter > 0.15) {
            float line_thickness = 0.008; 
            float max_height = 2.0; 
            float max_width = 2.0 * aspect;
            float current_radius = line_thickness * t_dot;
            float added_height = mix(0.0, max_height, t_v_stretch * t_v_stretch);
            float added_width = mix(0.0, max_width, t_h_stretch * t_h_stretch);
            float active_radius = mix(current_radius, 0.0, t_h_stretch);
            float d = sdRoundedBox(p, vec2(added_width, added_height), active_radius);
            float glow = 1.0 - smoothstep(0.0, 0.015, d);
            float core = 1.0 - smoothstep(0.0, 0.0005, d);
            whiteAlpha = max(glow, core);
            if (t_h_stretch < 0.1) {
                 float total_h = added_height + active_radius;
                 float v_fade = smoothstep(total_h, total_h * 0.5, abs(p.y));
                 whiteAlpha *= v_fade;
            } else {
                 whiteAlpha = mix(whiteAlpha, 1.0, t_h_stretch);
            }
            whiteLayer = vec3(1.0);
        }
    } else {
        // --- FLASHES ---
        float t_flash_phase = (uParameter - 0.45) / 0.55; 
        float cycle_count = 22.0; 
        float raw_cycle = t_flash_phase * cycle_count;
        float cycle_index = floor(raw_cycle);
        float rnd = random(cycle_index + 123.45); 
        int pattern = int(rnd * 7.0); 
        whiteLayer = getScannerScene(pattern, uv);
        whiteAlpha = 1.0; 
        float fade_out = smoothstep_custom(0.90, 1.0, uParameter);
        whiteAlpha *= (1.0 - fade_out);
    }
    // --- COMPOSITE ---
    // Tighter, less intense vignette
    float border = vignetteRect(uv, 0.01); // 1% margin
    whiteAlpha *= border;
    vec3 background = vec3(0.0);
    if (uParameter > 0.90) {
         background = origColor.rgb;
    }
    finalColor.rgb = mix(background, whiteLayer, whiteAlpha);
    gl_FragColor = finalColor;
}
`); 
        this.c.set('effectParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        // console.log("BootEffect Triggered");
        return true;
    }
    update() {
        if (!this.active) return;
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        let progress = elapsedTime / this.durationSeconds;
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('effectShader', null);
            this.c.set('effectParameter', 0.0);
            // console.log("BootEffect Finished");
            if (this.c.get('runBothInOrder') && this.registry) {
                this.registry.trigger('CrashSequence');
            }
            return;
        }
        this.c.set('effectParameter', progress);
    }
    getOverride(i) {
        return null;
    }
}
// --- ClearPulseEffect.js ---
class ClearPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "ClearPulse";
        this.active = false;
        this.origin = { x: 0, y: 0 };
        this.radius = 0;
        this.snap = null;
        const s = this._getEffectiveState();
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        this.autoTimer = s.clearPulseFrequencySeconds * fps;
        this.renderData = null;
        this.chunks = []; // For Movie Accurate Lag
        this.frameAccumulator = 0;
    }
    _getEffectiveState() {
        const s = this.c.state;
        if (!s.clearPulseMovieAccurate) return s;
        // Movie Accurate Overrides
        return {
            ...s,
            clearPulseFrequencySeconds: 235, 
            clearPulseDurationSeconds: 1.4,
            clearPulseWidth: 80, // Approx 7 chars width (depending on font size)
            clearPulseRandomPosition: false,
            clearPulseInstantStart: false,
            clearPulseCircular: false,
            clearPulsePreserveSpaces: false,
            clearPulseUseTracerGlow: false, 
            clearPulseBlend: true
        };
    }
    trigger() {
        if (this.active) return false;
        const total = this.g.cols * this.g.rows;
        const d = this.c.derived;
        const s = this._getEffectiveState();
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = "MATRIX";
        // Snapshot colors and fill chars
        this.snap = { 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total),
            colors: new Uint32Array(this.g.colors),
            tracers: new Uint8Array(total) // Track tracers for center finding
        };
        const holdEnd = d.cycleDuration + d.holdFrames;
        for (let i = 0; i < total; i++) {
            // Identify Tracer State (for center finding)
            const type = this.g.types[i]; 
            const age = this.g.ages[i];
            let isTracer = false;
            if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                const at = age - 1; 
                if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                    isTracer = true;
                } 
            }
            this.snap.tracers[i] = isTracer ? 1 : 0;
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                 this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                 this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.clearPulseMovieAccurate) {
             // Find Tracer closest to center
             const cx = Math.floor(this.g.cols / 2);
             const cy = Math.floor(this.g.rows / 2);
             let minDist = 99999999;
             let bestX = cx; 
             let bestY = cy;
             for(let i=0; i<total; i++) {
                 if (this.snap.tracers[i] === 1) {
                     const x = i % this.g.cols;
                     const y = Math.floor(i / this.g.cols);
                     const dx = (x - cx);
                     const dy = (y - cy);
                     const dist = dx*dx + dy*dy;
                     if (dist < minDist) {
                         minDist = dist;
                         bestX = x;
                         bestY = y;
                     }
                 }
             }
             ox = bestX;
             oy = bestY;
        } else if (s.clearPulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols * 0.2, this.g.cols * 0.8);
            oy = Utils.randomInt(this.g.rows * 0.2, this.g.rows * 0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.clearPulseWidth && pxDistY < s.clearPulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols / 2);
            oy = Math.floor(this.g.rows / 2);
        }
        this.origin = { x: ox, y: oy };
        this.active = true;
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        // Radius Init
        if (s.clearPulseMovieAccurate) {
            this.radius = 2 * d.cellWidth * s.stretchX; 
        } else {
            this.radius = s.clearPulseInstantStart ? s.clearPulseWidth * 2 : 0;
        }
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * fps);
        // Reset Chunks
        this.chunks = [];
        this.spawnedCount = 0;
        this.spawnCooldown = 0;
        return true;
    }
    update() {
        const s = this._getEffectiveState();
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        if (s.clearPulseMovieAccurate) {
             this.frameAccumulator++;
             if (this.frameAccumulator < 2) return;
             this.frameAccumulator = 0;
        } else {
             this.frameAccumulator = 0;
        }
        if (!this.active && s.clearPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.clearPulseFrequencySeconds * fps;
        }
        if (!this.active) { this.renderData = null; return; }
        const d = this.c.derived;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * fps);
        this.radius += this.speed;
        if (this.radius > maxDim + 400) { 
            this.active = false; 
            this.snap = null; 
            this.renderData = null; 
            return; 
        }
        // --- Chunk Lifecycle & Spawning (Movie Accurate) ---
        if (s.clearPulseMovieAccurate) {
            // 1. Update existing chunks
            for (let i = this.chunks.length - 1; i >= 0; i--) {
                this.chunks[i].life--;
                if (this.chunks[i].life <= 0) {
                    this.chunks.splice(i, 1);
                }
            }
            // 2. Cooldown
            if (this.spawnCooldown > 0) this.spawnCooldown--;
            // 3. Spawn Logic
            const progress = this.radius / maxDim;
            if (progress > 0.15 && this.spawnedCount < 4 && this.spawnCooldown <= 0) {
                const w = Utils.randomInt(Math.floor(this.g.cols * 0.5), this.g.cols);
                let h = Utils.randomInt(6, 13);
                let y = Utils.randomInt(Math.floor(this.g.rows * 0.2), Math.floor(this.g.rows * 0.8));
                const x = Utils.randomInt(0, this.g.cols - w);
                y = Math.max(0, Math.min(this.g.rows - h, y));
                const delayPixels = 4 * d.cellWidth * s.stretchX; 
                const oneCharTime = (d.cellWidth * s.stretchX) / this.speed;
                const duration = Math.ceil(delayPixels / this.speed) + Math.ceil(oneCharTime) + 2;
                this.chunks.push({
                    x, y, w, h,
                    lag: delayPixels,
                    life: duration
                });
                this.spawnedCount++;
                this.spawnCooldown = duration + 5; 
            }
        }
        // --- Optimization Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX);
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        const width = s.clearPulseWidth * 2;
        const innerEdge = this.radius - width;
        let ratio = 1;
        if (s.clearPulseMovieAccurate) {
             ratio = 1.0; // Locked 1:1 for Movie Accurate
        } else if (!s.clearPulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        let minX, maxX, minY, maxY;
        if (s.clearPulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, radiusSq: this.radius*this.radius, innerEdge, innerEdgeSq: innerEdge*innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this._getEffectiveState();
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        const aspect = 1.0; 
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: AABB Check (Skip if definitely outside)
            const x = i % grid.cols; 
            const y = Math.floor(i / grid.cols);
            const cx = Math.floor(x * d.cellWidth * s.stretchX);
            const cy = Math.floor(y * d.cellHeight * s.stretchY);
            if (cx < rd.minX || cx > rd.maxX || cy < rd.minY || cy > rd.maxY) continue;
            // Apply Catching Lag (Movie Accurate)
            let curLag = 0;
            if (s.clearPulseMovieAccurate && this.chunks) {
                for (const chunk of this.chunks) {
                    if (x >= chunk.x && x < chunk.x + chunk.w &&
                        y >= chunk.y && y < chunk.y + chunk.h) {
                        curLag = chunk.lag;
                        break;
                    }
                }
            }
            // Effective Radius for this cell
            const localRadius = Math.max(0, rd.radius - curLag);
            const localInnerEdge = Math.max(0, rd.innerEdge - curLag);
            // Distance Calc
            let dist;
            if (s.clearPulseCircular) {
                const dx = cx - rd.ox; const dy = cy - rd.oy;
                dist = Math.sqrt(dx * dx + dy * dy);
            } else {
                const dx = Math.abs(cx - rd.ox);
                const dy = Math.abs(cy - rd.oy);
                dist = Math.max(dx, dy * rd.ratio);
            }
            if (dist < localInnerEdge || dist > localRadius) continue;
            // --- Apply Override ---
            const alpha = grid.alphas[i];
            const isGap = (alpha <= 0.01);
            if (s.clearPulsePreserveSpaces && isGap) continue;
            let charCode, fontIdx, color;
            // Use LIVE grid data to prevent freezing
            if (isGap) {
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
                color = d.streamColorUint32;
            } else {
                charCode = grid.chars[i];
                fontIdx = grid.fontIndices[i];
                color = grid.colors[i];
            }
            const rel = Math.max(0, Math.min(1, (localRadius - dist) / rd.width));
            // Apply Glow Toggle
            const baseGlow = Math.max(s.tracerGlow, 30 * (1.0 - rel));
            const actualGlow = (s.clearPulseUseTracerGlow) ? baseGlow : 0;
            let finalColor;
            if (!s.clearPulseBlend) {
                // Blend OFF: Solid Tracer Color & Glow
                finalColor = tColorInt;
            } else {
                // Blend ON: Linear fade across the entire wave
                const bR = color & 0xFF;
                const bG = (color >> 8) & 0xFF;
                const bB = (color >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * rel);
                const mG = Math.floor(tG + (bG - tG) * rel);
                const mB = Math.floor(tB + (bB - tB) * rel);
                finalColor = Utils.packAbgr(mR, mG, mB);
            }
            // For lagged chunks in Movie Accurate mode, dim the wave slightly
            let finalAlpha = 1.0;
            if (s.clearPulseMovieAccurate) {
                // Movie Accurate Edge Fading, Variance & Holes
                // 1. Holes (10% chance to skip rendering the wave for this cell)
                const holeHash = Math.abs((Math.sin(i * 13.1234) * 43758.5453) % 1);
                if (holeHash < 0.1) {
                    grid.clearEffectOverride(i);
                    continue;
                }
                // 2. Brightness Variance (80% full, 20% vary)
                const varHash = Math.abs((Math.sin(i * 12.9898) * 43758.5453) % 1);
                if (varHash < 0.8) {
                    finalAlpha = 1.0;
                } else {
                    // Vary between 0.4 and 0.8
                    finalAlpha = 0.4 + ((varHash - 0.8) / 0.2) * 0.4;
                }
                // 3. Edge Fading (Outer 20% and Inner 20%)
                if (rel < 0.2) {
                    // Outer Edge
                    finalAlpha *= (rel / 0.2);
                } else if (rel > 0.8) {
                    // Inner Edge
                    finalAlpha *= ((1.0 - rel) / 0.2);
                }
                if (curLag > 0) {
                    finalAlpha *= 0.6; // Additional dimming for lag
                }
            } else {
                // Standard mode solid alpha
                finalAlpha = 1.0;
            }
            // Use Overlay Mode to preserve background simulation movement
            grid.setEffectOverlay(i, String.fromCharCode(charCode), finalColor, finalAlpha, fontIdx, actualGlow);
        }
    }
}
// --- CrashEffect.js ---
class CrashEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry; 
        this.name = "CrashSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30; 
        this.originalShader = null;
        this.originalShaderEnabled = false;
        this.originalShaderParameter = 0.5;
        this.originalFade = 0; // To store/restore fade speed
        this.frame = 0;
        this.snapshotOverlay = new Map(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.shadowMap = null;
        this.supermanState = {
            active: false,
            type: 0, 
            cells: new Set(), 
            fadingReveals: [], // Store active reveal zones
            flickerTimer: 0,
            globalTimer: 0,
            boltId: 0
        };
        this.shaderState = {
            activeId: 0, 
            timer: 0,
            duration: 0
        };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.flashState = {
            active: false,
            timer: 0,
            duration: 40, 
            nextFlash: 60, 
            cycleDuration: 240
        };
        this.MAX_BLACK_LEVEL = 0.5; 
        this.baseBlackLevel = this.MAX_BLACK_LEVEL; 
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
    }
    trigger() {
        if (this.active) return false;
        // Snapshot for Deja Vu bars to respect spaces
        this.snap = {
            alphas: new Float32Array(this.g.alphas),
            chars: new Uint16Array(this.g.chars)
        };
        // Get Stream Color for the Splash
        const colorStr = this.c.derived.streamColorStr || this.c.defaults.streamColor;
        const rgb = Utils.hexToRgb(colorStr);
        const vec3Color = `vec3(${rgb.r/255.0}, ${rgb.g/255.0}, ${rgb.b/255.0})`;
        // Set Effect Shader (Pass 1) - Leaves Custom Shader (Pass 2) intact
        this.c.set('effectShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; 
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) { return fract(sin(n) * 43758.5453123); }
float rect(vec2 uv, vec2 pos, vec2 size) {
    vec2 d = abs(uv - pos) - size;
    return 1.0 - step(0.0, max(d.x, d.y));
}
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
void main() {
    vec2 uv = vTexCoord;
    float phase_idx = floor(uParameter + 0.001);
    float progress = fract(uParameter); 
    vec4 finalColor = texture2D(uTexture, uv);
    vec3 splashColor = ${vec3Color};
    // --- PHASE 10: SPLASH EFFECT ---
    if (phase_idx == 10.0) {
         float t = progress; 
         float bar = scannerSheet(uv, vec2(0.5, 0.5), vec2(1.0, 0.2), 0.3, 1);
         float flashAlpha = bar * (1.0 - smoothstep(0.0, 0.6, t));
         if (flashAlpha > 0.0) {
            finalColor.rgb += splashColor * flashAlpha * 3.0; 
         }
    }
    // --- PHASE 2: DISTORTION ---
    if (phase_idx == 2.0) {
        vec2 center = vec2(0.5, 0.5);
        vec2 dist = uv - center;
        dist.y *= 0.02; 
        vec4 distColor = texture2D(uTexture, center + dist);
        distColor.rgb *= 1.5;
        float active = 1.0 - ((progress - 0.66) / 0.34);
        if (active > 0.0) finalColor = mix(finalColor, distColor, 0.5 * active);
    }
    // --- PHASE 9: STRETCH ---
    if (phase_idx == 9.0) {
        float sampleX = 0.3;
        vec4 stretchColor = texture2D(uTexture, vec2(sampleX, uv.y));
        float flicker = 0.5 + 0.5 * sin(progress * 30.0); 
        if (abs(uv.x - 0.33) < 0.05) { stretchColor.rgb *= 0.3; }
        stretchColor.rgb *= (1.0 + flicker);
        float alpha = (0.5 + 0.5 * flicker) * (1.0 - progress); 
        finalColor = mix(finalColor, stretchColor, alpha);
    }
    gl_FragColor = finalColor;
}
`);
        this.c.set('effectParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        this.frame = 0;
        this.snapshotOverlay.clear(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.supermanState = { 
            active: false, 
            type: 0, 
            cells: new Set(), 
            illuminatedCells: new Set(), 
            fadingReveals: [], // Ensure this is initialized!
            flickerTimer: 0, 
            globalTimer: 0, 
            boltId: 0 
        };
        this.shaderState = { activeId: 0, timer: 0, duration: 0 };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
        this.flashState.active = false;
        this.flashState.nextFlash = 30; 
        this.MAX_BLACK_LEVEL = 0.5;
        this.baseBlackLevel = this.c.get('crashEnableFlash') ? this.MAX_BLACK_LEVEL : 0.0; 
        // Immediate Spawn of all sheets
        const maxSheets = this.c.get('crashSheetCount');
        this.blackSheets = [];
        this._updateBlackSheets(maxSheets); // Force fill
        return true;
    }
    update() {
        if (!this.active) return;
        this.frame++;
        let step = 1;
        if (this.c.get('crashMovieFps')) {
             if (this.frame % 2 !== 0) return; // Skip update on odd frames to simulate 30fps visual hold
             step = 2; // Advance state by 2x to maintain duration
        }
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30;
        const progress = elapsedTime / this.durationSeconds;
        this.sheetFadeVal = Math.min(1.0, this.sheetFadeVal + (step / 45.0));
        const sheetOpacity = this.c.get('crashSheetOpacity');
        this.MAX_BLACK_LEVEL = sheetOpacity; 
        // Trigger End Effect (Deja Vu)
        if (progress > 0.92 && !this.endFlashTriggered) {
            this.endFlashTriggered = true;
            if (this.registry) {
                const remainingSeconds = (1.0 - progress) * this.durationSeconds;
                // Add small buffer to ensure overlap/fade out completes smoothly
                this.registry.trigger('DejaVu', remainingSeconds + 1.0);
            }
        }
        // --- END ---
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('effectShader', null); // Clear Effect Shader
            this.snapshotOverlay.clear();
            this.blackSheets = [];
            this.crashBars = [];
            this.supermanState.cells.clear();
            this.supermanState.illuminatedCells.clear();
            this.supermanState.geometry = null;
            return;
        }
        // --- FLASH & FADE LOGIC ---
        const enableFlash = this.c.get('crashEnableFlash');
        if (enableFlash) {
            this.baseBlackLevel = this.MAX_BLACK_LEVEL * this.sheetFadeVal;
            if (this.flashState.active) {
                this.flashState.timer += step;
                const p = Math.min(1.0, this.flashState.timer / this.flashState.duration);
                this.c.set('effectParameter', 10.0 + p);
                if (this.flashState.timer >= 1 && this.flashState.timer < 1 + step) this.sheetFadeVal = 0.0; // Trigger once
                if (this.flashState.timer >= this.flashState.duration) {
                    this.flashState.active = false;
                    this.c.set('effectParameter', 0.0);
                }
            } else {
                this.flashState.nextFlash -= step;
                if (this.flashState.nextFlash <= 0) this._triggerFlash();
            }
        } else {
            this.baseBlackLevel = 0.0;
            this.c.set('effectParameter', 0.0);
        }
        // --- SHADERS ---
        if (!this.flashState.active) {
            if (this.shaderState.activeId === 0) {
                 if (Math.random() < 0.01 * step) { // Adjust probability for step
                    const r = Math.random();
                    let id = 0; let dur = 0;
                    if (r < 0.3) { id = 3; dur = 20; } // These IDs need to match shader code or be unused
                    else if (r < 0.6) { id = 9; dur = 30; } // Phase 9 is implemented
                    else { id = 2; dur = 40; } // Phase 2 is implemented
                    if (id === 2 || id === 9) {
                        this.shaderState.activeId = id;
                        this.shaderState.duration = dur;
                        this.shaderState.timer = 0;
                    }
                 }
            } else {
                this.shaderState.timer += step;
                if (this.shaderState.timer >= this.shaderState.duration) {
                    this.shaderState.activeId = 0;
                    this.c.set('effectParameter', 0.0);
                } else {
                    const p = this.shaderState.timer / this.shaderState.duration;
                    this.c.set('effectParameter', this.shaderState.activeId + p);
                }
            }
        }
        // --- BLACK SHEETS ---
        const maxSheets = this.c.get('crashSheetCount');
        this.sheetState.timer -= step;
        if (this.sheetState.timer <= 0) {
            this.sheetState.spawning = !this.sheetState.spawning;
            this.sheetState.timer = this.sheetState.spawning ? 400 : 200; 
        }
        // Always call _updateBlackSheets to handle movement/wrapping, even if not spawning
        this._updateBlackSheets(this.sheetState.spawning ? maxSheets : 0, step);
        if (this.blackSheets.length > maxSheets) this.blackSheets.splice(maxSheets);
        // --- SUPERMAN (Lightning) ---
        if (this.c.get('crashEnableSuperman')) {
            if (this.supermanState.active) {
                this.supermanState.globalTimer -= step;
                // Update at 30fps logic matches our update frequency now
                this._generateSupermanBolt();
                if (this.supermanState.globalTimer <= 0) {
                    // Transition Active Reveal to Fading
                    if (this.supermanState.activeReveal) {
                        this.supermanState.fadingReveals.push(this.supermanState.activeReveal);
                        this.supermanState.activeReveal = null;
                    }
                    this.supermanState.active = false;
                    this.supermanState.cells.clear();
                    this.supermanState.geometry = null;
                }
            } else {
                // Random trigger
                if (Math.random() < 0.02 * step) { // Adjust prob
                    const type = Math.random() < 0.5 ? 0 : 1; 
                    this._triggerSuperman(type);
                }
            }
        } else {
            this.supermanState.active = false;
        }
        // Update Fading Triangles (Reveals)
        for (let i = this.supermanState.fadingReveals.length - 1; i >= 0; i--) {
            const t = this.supermanState.fadingReveals[i];
            t.alpha -= 0.01 * step; // Fade out speed adjusted
            if (t.alpha <= 0) {
                this.supermanState.fadingReveals.splice(i, 1);
            }
        }
        // --- OTHER ELEMENTS ---
        this._updateSnapshots();
        // Update Crash Bars
        for (let i = this.crashBars.length - 1; i >= 0; i--) {
            const b = this.crashBars[i];
            b.age += step;
            if (b.age > b.maxAge) {
                this.crashBars.splice(i, 1);
            }
        }
        if (Math.random() < 0.02 * step) this._triggerWhiteBlock(); 
        if (Math.random() < 0.02 * step) this._triggerColumnBurst(); 
        if (this.c.get('crashEnableSmith')) {
            if (!this.smithState.triggered && Math.random() < 0.001 * step) { 
                this._triggerSmith();
            }
            if (this.smithState.active) {
                this.smithState.timer -= step;
                if (this.smithState.timer <= 0) this.smithState.active = false;
            }
        }
        if (this.registry) {
            if (Math.random() < 0.001 * step) this.registry.trigger('ClearPulse');
        }
    }
    applyToGrid(grid) {
        if (!this.active) return;
        const cols = grid.cols;
        const rows = grid.rows;
        // 1. Black Sheets - GPU HANDLED (Mask Texture)
        // 2. Superman Lightning (Updated)
        if (this.supermanState.active) {
            const tracerColor = this.c.derived.tracerColorUint32;
            // Triangle Reveals are now GPU HANDLED via getReveals() / Shadow Mask Punch-out
            // Render Main Bolt (Foreground)
            if (this.supermanState.cells.size > 0) {
                for (const idx of this.supermanState.cells) {
                    const char = grid.getChar(idx);
                    if (char !== ' ') {
                        // Bolt: Tracer Color, High Glow
                        grid.setHighPriorityEffect(idx, char, tracerColor, 1.0, grid.fontIndices[idx], 1.0);
                    }
                }
            }
        }
        // 3. Crash Bars (Deja Vu Bars) - Updated Logic
        if (this.crashBars.length > 0) {
            // Requirement: "White again" -> Pure White Target
            const tR = 255; 
            const tG = 255; 
            const tB = 255;
            for (const bar of this.crashBars) {
                // Render Blocks function
                const renderBlock = (y, h, currentAge, isTopBlock) => {
                    if (currentAge < 0) return;
                    const glitchDuration = 9; 
                    const flashDuration = 4;
                    const fadeStart = glitchDuration + flashDuration;
                    let blockAlpha = 0;
                    let isGlitching = false;
                    let isFlashing = false;
                    // Phase Logic
                    if (currentAge < glitchDuration) {
                        // Phase 1: Glitch In
                        isGlitching = bar.shouldGlitch;
                        blockAlpha = 1.0;
                    } else if (currentAge < fadeStart) {
                        // Phase 2: Flash / Distortion
                        isFlashing = true;
                        blockAlpha = 1.0;
                    } else {
                        // Phase 3: Fade Out
                        // Fixed fade duration to ensure consistency regardless of offsets
                        const fadeLen = 15; 
                        blockAlpha = 1.0 - ((currentAge - fadeStart) / fadeLen);
                    }
                    if (blockAlpha <= 0) return;
                    const limitY = Math.min(rows, y + h);
                    const limitX = Math.min(cols, bar.x + bar.w);
                    for (let r = y; r < limitY; r++) {
                        // GLITCH GEOMETRY LOGIC
                        if (isGlitching) {
                            // 1. A/B Toggle for Split blocks (Type 1)
                            if (bar.type === 1) {
                                const phase = Math.floor(currentAge / 3) % 2; 
                                if (isTopBlock && phase === 1) continue;
                                if (!isTopBlock && phase === 0) continue;
                            }
                            // 2. Partial Row Rendering (Scanline/Noise) - REMOVED per user request
                            // if ((r + currentAge) % 3 !== 0) continue; 
                        }
                        const rowOffset = r * cols;
                        for (let x = bar.x; x < limitX; x++) {
                            // DISTORTION LOGIC (Flash Phase)
                            let targetX = x;
                            if (isFlashing) {
                                // Horizontal Shredding
                                if (Math.random() < 0.3) {
                                    targetX = x + (Math.random() < 0.5 ? -1 : 1) * Utils.randomInt(1, 3);
                                }
                                // Vertical Jitter (Row shift)
                                if (Math.random() < 0.1) {
                                    // Visual effect only, doesn't change `idx` calc below unless we refactor
                                    // For now, let's stick to X distortion to avoid bounds checking hell
                                }
                            }
                            if (targetX < 0 || targetX >= cols) continue;
                            const idx = rowOffset + targetX;
                            // 1. Alpha Variance
                            const hash = Math.sin(idx * 12.9898 + bar.id) * 43758.5453;
                            const rnd = hash - Math.floor(hash);
                            let finalAlpha = blockAlpha; 
                            // Add slight noise to edges
                            if (!isFlashing && rnd > 0.9) finalAlpha *= 0.8;
                            if (finalAlpha <= 0.01) continue;
                            // 2. Flash in together
                            const liveAlpha = grid.alphas[idx];
                            const liveChar = grid.chars[idx];
                            const liveColor = grid.colors[idx];
                            const fontIdx = grid.fontIndices[idx];
                            let charStr, displayFont;
                            if (liveAlpha > 0.01) {
                                charStr = String.fromCharCode(liveChar);
                                displayFont = fontIdx;
                            } else if (this.snap && this.snap.alphas[idx] > 0.01) {
                                const charSeed = (idx ^ Math.floor(bar.id)) * 7.123;
                                const charCode = Utils.CHARS.charCodeAt(Math.floor((charSeed - Math.floor(charSeed)) * Utils.CHARS.length));
                                charStr = String.fromCharCode(charCode);
                                displayFont = 0;
                            } else {
                                continue; 
                            }
                            // 3. Bright White Blending
                            let mR, mG, mB;
                            if (isFlashing) {
                                // Pure White during flash
                                mR = 255; mG = 255; mB = 255;
                            } else {
                                const lR = liveColor & 0xFF; 
                                const lG = (liveColor >> 8) & 0xFF; 
                                const lB = (liveColor >> 16) & 0xFF;
                                const blendWeight = 0.9; // Mostly Target (White)
                                mR = Math.floor(lR + (tR - lR) * blendWeight);
                                mG = Math.floor(lG + (tG - lG) * blendWeight);
                                mB = Math.floor(lB + (tB - lB) * blendWeight);
                            }
                            const finalColor = Utils.packAbgr(mR, mG, mB);
                            // Force High Alpha for "White" look
                            grid.setHighPriorityEffect(idx, charStr, finalColor, 1.0, displayFont, 1.0 * finalAlpha); 
                        }
                    }
                };
                // Render based on Type
                if (bar.type === 1) {
                    renderBlock(bar.y, bar.subH, bar.age, true); // Top (Normal time)
                    renderBlock(bar.y + bar.subH + 17, bar.subH, bar.age - 6, false); // Bottom (Offset by 6 frames)
                } else if (bar.type === 2) {
                    let renderY = bar.y;
                    if (bar.age > 8) renderY = bar.y + 6;
                    renderBlock(renderY, bar.subH, bar.age, true);
                } else {
                    renderBlock(bar.y, bar.subH, bar.age, true);
                }
            }
        }
        // 4. Snapshots (Smith)
        for (const [idx, snap] of this.snapshotOverlay) {
             if (snap.alpha <= 0.01) continue;
             // Smith is now handled as a Shadow Mask, do not render as override
             if (snap.isSmith) continue; 
             const char = snap.char;
             // Snap color is stored as hex string
             const color = Utils.hexToRgb(snap.color);
             const packedColor = Utils.packAbgr(color.r, color.g, color.b);
             grid.setOverride(idx, char, packedColor, snap.alpha, grid.fontIndices[idx], snap.isSmith ? 0 : 8.0);
        }
    }
    _triggerFlash() {
        this.flashState.active = true;
        this.flashState.timer = 0;
        this.flashState.duration = 40; 
        const minS = this.c.get('crashFlashDelayMin');
        const maxS = this.c.get('crashFlashDelayMax');
        this.flashState.nextFlash = (minS + Math.random() * (maxS - minS)) * 60; 
    }
    _updateBlackSheets(maxSheets, step = 1) {
        // Fill up to maxSheets immediately
        while (this.blackSheets.length < maxSheets) { 
            const grid = this.g;
            // Generate dimensions (4 to 16)
            const w = Utils.randomInt(4, 16);
            const h = Utils.randomInt(4, 16);
            let c = Math.floor(Math.random() * (grid.cols - w));
            let row = Math.floor(Math.random() * (grid.rows - h));
            // Orthogonal Movement Logic
            const speedScale = (Math.random() * 1.5 + 0.5); 
            let dx = 0;
            let dy = 0;
            // Configurable Chance to be stationary
            const stationaryChance = this.c.get('crashStationaryChance') / 100.0;
            if (Math.random() > stationaryChance) {
                const axis = Math.random() < 0.5 ? 'x' : 'y';
                const dir = Math.random() < 0.5 ? 1 : -1;
                dx = axis === 'x' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
                dy = axis === 'y' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
            }
            const maxAlpha = this.c.get('crashSheetOpacity');
            this.blackSheets.push({ 
                c, r: row, w, h,
                posX: c, posY: row, 
                baseDx: dx, 
                baseDy: dy, 
                targetW: w, targetH: h, 
                // Requirement 1: Immediate Spawn (No Fade In)
                currentAlpha: maxAlpha, 
                targetAlpha: maxAlpha, 
                maxAlpha: maxAlpha,
                blur: 0.0
            });
        }
        // Update Position & Wrapping
        for (const s of this.blackSheets) {
            // Update Alpha (Fade Out logic handled by sheetFadeVal globally, but per-sheet fade-in removed)
            s.maxAlpha = this.c.get('crashSheetOpacity') * this.sheetFadeVal;
            s.currentAlpha = s.maxAlpha; 
            // Move
            s.posX += s.baseDx * this.c.get('crashSheetSpeed') * step;
            s.posY += s.baseDy * this.c.get('crashSheetSpeed') * step;
            // Wrapping Logic (Requirement 2)
            if (s.posX > this.g.cols) s.posX -= this.g.cols;
            if (s.posX + s.w < 0) s.posX += this.g.cols;
            if (s.posY > this.g.rows) s.posY -= this.g.rows;
            if (s.posY + s.h < 0) s.posY += this.g.rows;
        }
    }
    // New Generic Interface for Renderer (Requirement 4: Layering/Wrapping Visuals)
    getMasks() {
        if (!this.active) return [];
        const masks = [];
        const cols = this.g.cols;
        const rows = this.g.rows;
        // 1. Black Sheets
        for (const s of this.blackSheets) {
            // Main Body
            masks.push({
                x: s.posX, y: s.posY, w: s.w, h: s.h,
                alpha: s.currentAlpha, blur: s.blur
            });
            // Horizontal Wrapping Ghost
            if (s.posX + s.w > cols) {
                masks.push({
                    x: s.posX - cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posX < 0) {
                 masks.push({
                    x: s.posX + cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
            // Vertical Wrapping Ghost
            if (s.posY + s.h > rows) {
                masks.push({
                    x: s.posX, y: s.posY - rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posY < 0) {
                masks.push({
                    x: s.posX, y: s.posY + rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
        }
        // 2. Smith Shadow Masks
        for (const [idx, snap] of this.snapshotOverlay) {
            if (snap.isSmith && snap.alpha > 0.01) {
                const x = idx % cols;
                const y = Math.floor(idx / cols);
                // Combine fade alpha (snap.alpha) with density alpha (snap.densityAlpha)
                const combinedAlpha = snap.alpha * (snap.densityAlpha || 0.5);
                masks.push({
                    x: x, y: y, w: 1, h: 1,
                    alpha: combinedAlpha, 
                    blur: 0.1 // Crisp blocks for pixelated look
                });
            }
        }
        return masks;
    }
    _getFontName(i) {
        const fontIdx = this.g.fontIndices[i];
        const fonts = this.c.derived.activeFonts;
        return (fonts && fonts[fontIdx]) ? fonts[fontIdx].name : this.c.state.fontFamily;
    }
    _triggerSmith() {
        this.smithState.triggered = true;
        this.smithState.active = true;
        this.smithState.timer = 30; // Halved
        this._triggerFlash();
        // Mapping ASCII density to Shadow Mask Alpha
        // @ (100) -> 1.0 (Darkest/Solid)
        // . (5)   -> 0.1 (Lightest)
        const densityAlphaMap = {
            '@': 1.0, '%': 0.9, '#': 0.8,
            '*': 0.6, '+': 0.5, '=': 0.4,
            ':': 0.3, '-': 0.2, '.': 0.1
        };
        const asciiArt = [
            "                                      *##*#*####+                                        ",
            "                                   # @@@%%#%%%%%##*-                                      ",
            "                                  % @%%#*+**+=::=*+-=:                                    ",
            "                                 % @#+                -#                                  ",
            "                                = @#=                  .%                                 ",
            "                                @@#-                   +=                                ",
            "                               = @@%*-:                 + @                                ",
            "                               * @@@#=:.               .+ @                                ",
            "                               * @@@*-                  = @                                ",
            "                               : @@@+-=#@@@@@@@*-+%@@@@@%=                                ",
            "                               -+%%+-*% @@@@@@@.  % @@@%%%%                                ",
            "                              :***%+-:-% @@@@%=   .#%%#*#=                                ",
            "                               :-:*+-:..-++-=     ===-:+:                                ",
            "                                --*#+++=-...-+%###:-===+                                 ",
            "                                 :=**++=--.  :*#*.   :+                                  ",
            "                                   =*+++=-    -===.  .-                                  ",
            "                                   *##**+-+**+.     :-                                   ",
            "                                   **#####**########*                                    ",
            "                                   +*######*+=--.  -*                                    ",
            "                                   +*+*#####********+                                    ",
            "                                   # -++########*#*++ .                                  ",
            "                                 .%*    =*#######*+-  ++                                 ",
            "                              .*#%%#-      =####**    ++=-=.                             ",
            "                         :=+***##%%##        .***     +++=--===--:                       ",
            "                  +++++++++*+*########       :###%    ++++==-+======--                   ",
            "               +***++++++++++****####**      #%**#+    *+++***+====+++++==               ",
            "            =*+*+++++++++++++*%%#*##***+      #**      =++++*++==+********+              ",
            "            %#*++++*++++**+++++*#*#****+      ++*       +++++++++******####*             ",
            "            ###*+++**+++***+++*+++******+     ++*#      -=+++++++*****#%%%##:            ",
            "            ####**+***+++***++#*+++*****+:    =+*##     .=++++==+*****#%%%#%%            ",
            "           -#####******+++****+*++++*****+    =+*##*     =+++===+*#**##%%%#%%-           ",
            "           *%#######***+++*****+*+++++****+   -***#**    =+++===+*#**##%%%% @%%           ",
            "           #%#*###*##***+++*****+#+++++****=  :*#####=   -=++===**#*##%%%%%%%%           ",
            "           #%#*##%##%#**++++****++#+++++***+   =++++++    =++===*#####%%%% @@%%           "
        ];
        const grid = this.g;
        const artHeight = asciiArt.length;
        const artWidth = asciiArt[0].length; 
        const startR = Math.floor((grid.rows - artHeight) / 2);
        const startC = Math.floor((grid.cols - artWidth) / 2);
        const endFrame = this.frame + 90;
        const borderMap = new Map(); // Store border indices to avoid duplicates
        for (let r = 0; r < artHeight; r++) {
            const line = asciiArt[r];
            const rowIdx = startR + r;
            if (rowIdx < 0 || rowIdx >= grid.rows) continue;
            for (let c = 0; c < line.length; c++) {
                const char = line[c];
                const colIdx = startC + c;
                if (colIdx < 0 || colIdx >= grid.cols) continue;
                const i = rowIdx * grid.cols + colIdx;
                if (char === ' ') {
                    // Check if this empty space is a border (has a non-empty neighbor)
                    // We check purely based on the source ASCII art for shape consistency
                    let isBorder = false;
                    const neighbors = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];
                    for (const [dr, dc] of neighbors) {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < artHeight && nc >= 0 && nc < artWidth) {
                            if (asciiArt[nr][nc] !== ' ') {
                                isBorder = true;
                                break;
                            }
                        }
                    }
                    if (isBorder) {
                         borderMap.set(i, {
                            densityAlpha: 0.15, // Subtle outline
                            alpha: 1.0, 
                            endFrame: endFrame, 
                            isSmith: true
                        });
                    }
                    continue; 
                }
                // Get Density Alpha
                const density = densityAlphaMap[char] || 0.2;
                this.snapshotOverlay.set(i, {
                    densityAlpha: density,
                    alpha: 1.0, // Fade Alpha
                    endFrame: endFrame, 
                    isSmith: true
                });
            }
        }
        // Apply borders
        for (const [key, val] of borderMap) {
            if (!this.snapshotOverlay.has(key)) {
                this.snapshotOverlay.set(key, val);
            }
        }
    }
    _getStaticChar(idx) {
        // Deterministic pseudo-random character based on index and current bolt
        // Simple hash: (idx * magic1 + boltId * magic2) % len
        const seed = Math.floor(idx * 137 + this.supermanState.boltId * 997);
        const charSet = Utils.CHARS;
        return charSet[seed % charSet.length];
    }
    _triggerSuperman(type) {
        this.supermanState.active = true;
        this.supermanState.type = type; 
        this.supermanState.globalTimer = 30; // Halved
        this.supermanState.flickerTimer = 0;
        this.supermanState.boltId = Math.random() * 1000; // Unique ID for this bolt instance
        this._generateSupermanBolt();
    }
    _generateSupermanBolt() {
        const s = this.supermanState;
        s.cells.clear();
        if (!s.geometry) {
            this._initSupermanGeometry();
            // Initialize active reveal for this new bolt
            s.activeReveal = { 
                type: 'rects', 
                rects: [], 
                alpha: 1.0 
            };
        }
        const g = s.geometry;
        // Draw Main Path (Populates s.cells)
        this._drawJaggedLine(g.start.x, g.start.y, g.end.x, g.end.y, s.cells, 2);
        // Draw Branches (Populates s.cells)
        if (g.branches) {
            for (const b of g.branches) {
                this._drawJaggedLine(g.split.x, g.split.y, b.x, b.y, s.cells, 1);
            }
        }
        // Calculate Border Cells (1 char away)
        if (s.activeReveal) {
            const cols = this.g.cols;
            const rows = this.g.rows;
            const borderSet = new Set();
            const borderRects = [];
            for (const idx of s.cells) {
                const cx = idx % cols;
                const cy = Math.floor(idx / cols);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            const nIdx = ny * cols + nx;
                            if (!s.cells.has(nIdx) && !borderSet.has(nIdx)) {
                                borderSet.add(nIdx);
                                borderRects.push({ x: nx, y: ny, w: 1, h: 1 });
                            }
                        }
                    }
                }
            }
            s.activeReveal.rects = borderRects;
        }
    }
    _initSupermanGeometry() {
        const grid = this.g;
        const s = this.supermanState;
        // 1. Pick Start/End Corners
        const corners = [
            { x: 0, y: 0 }, // TL
            { x: grid.cols - 1, y: 0 }, // TR
            { x: grid.cols - 1, y: grid.rows - 1 }, // BR
            { x: 0, y: grid.rows - 1 } // BL
        ];
        const startIdx = Utils.randomInt(0, 3);
        const endIdx = (startIdx + 2) % 4; // Opposite corner
        const start = corners[startIdx];
        const end = corners[endIdx];
        s.geometry = { start, end };
        // Type 1: Branching
        if (s.type === 1) {
            // Split Point (35-40%)
            const splitT = 0.35 + (Math.random() * 0.05);
            const splitX = Math.floor(start.x + (end.x - start.x) * splitT);
            const splitY = Math.floor(start.y + (end.y - start.y) * splitT);
            s.geometry.split = { x: splitX, y: splitY };
            // Calculate Main Bolt Angle
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const mainAngle = Math.atan2(dy, dx);
            const branches = [];
            const numBranches = Utils.randomInt(1, 3);
            let furthestBranch = null;
            let maxDist = -1;
            // Define adjacent edges for the END corner
            for (let i = 0; i < numBranches; i++) {
                let tx, ty;
                let attempts = 0;
                let valid = false;
                while (!valid && attempts < 10) {
                    attempts++;
                    const useHorizontal = Math.random() < 0.5;
                    if (useHorizontal) {
                        ty = end.y;
                        tx = Utils.randomInt(0, grid.cols - 1);
                    } else {
                        tx = end.x;
                        ty = Utils.randomInt(0, grid.rows - 1);
                    }
                    // Check Angle Constraint (< 50 deg)
                    const bDx = tx - splitX;
                    const bDy = ty - splitY;
                    const branchAngle = Math.atan2(bDy, bDx);
                    let diff = Math.abs(branchAngle - mainAngle);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff; // Normalize to 0..PI
                    const deg = diff * (180 / Math.PI);
                    if (deg < 50) {
                        valid = true;
                    }
                }
                if (valid) {
                    const bPoint = { x: tx, y: ty };
                    branches.push(bPoint);
                    const d = Math.hypot(tx - splitX, ty - splitY);
                    if (d > maxDist) {
                        maxDist = d;
                        furthestBranch = bPoint;
                    }
                }
            }
            s.geometry.branches = branches;
        }
    }
    getReveals() {
        const reveals = [...this.supermanState.fadingReveals];
        if (this.supermanState.activeReveal) {
            reveals.push(this.supermanState.activeReveal);
        }
        return reveals;
    }
    _drawJaggedLine(x0, y0, x1, y1, set, baseThickness = 1) {
        const points = [];
        // Elastic / Arcing Lightning with Time-Based Animation
        const dist = Math.hypot(x1 - x0, y1 - y0);
        const steps = Math.ceil(dist * 0.8); // High resolution for smooth arcs
        // Perpendicular Vector for displacement
        const dx = x1 - x0;
        const dy = y1 - y0;
        const nx = -dy / dist; // Normalized Perpendicular X
        const ny = dx / dist;  // Normalized Perpendicular Y
        let px = x0;
        let py = y0;
        const time = this.frame * 0.3; 
        const seed = this.supermanState.boltId; 
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            let tx = x0 + dx * t;
            let ty = y0 + dy * t;
            const thickness = baseThickness;
            // Chaotic Displacement
            const arc1 = Math.sin(t * Math.PI + seed + time * 0.5) * 4.0;
            const arc2 = Math.sin(t * Math.PI * 4.0 + seed * 2.0 - time * 1.5) * 2.0;
            const jitter = Math.sin(t * Math.PI * 25.0 + time * 8.0) * 0.8;
            const noise = (Math.random() - 0.5) * 1.2;
            const envelope = Math.sin(t * Math.PI); 
            const displacement = (arc1 + arc2 + jitter + noise) * envelope * 2.0;
            tx += nx * displacement;
            ty += ny * displacement;
            points.push({x: tx, y: ty}); // Capture point
            if (i > 0) {
                this._drawLine(px, py, tx, ty, set, thickness);
            }
            px = tx;
            py = ty;
        }
        return points;
    }
    _drawLine(x0, y0, x1, y1, set, thickness = 1) {
        // Bresenham-like algorithm for connected line
        let x = Math.floor(x0);
        let y = Math.floor(y0);
        const endX = Math.floor(x1);
        const endY = Math.floor(y1);
        const dx = Math.abs(endX - x);
        const dy = Math.abs(endY - y);
        const sx = (x < endX) ? 1 : -1;
        const sy = (y < endY) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            // Apply thickness by adding neighbors
            for (let ox = 0; ox < thickness; ox++) {
                for (let oy = 0; oy < thickness; oy++) {
                    const cx = x + ox;
                    const cy = y + oy;
                    if (cx >= 0 && cx < this.g.cols && cy >= 0 && cy < this.g.rows) {
                        set.add(cy * this.g.cols + cx);
                    }
                }
            }
            if (x === endX && y === endY) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                y += sy;
            }
        }
    }
    _triggerWhiteBlock() {
        if (this.crashBars.length > 0) return;
        const grid = this.g;
        // Random Type: 0, 1, 2
        const type = Math.floor(Math.random() * 3);
        // Requirement: Blocks strictly 10-12 chars high
        const subH = Utils.randomInt(10, 12);
        let h = subH;
        if (type === 1) h = subH * 2 + 17; // Two blocks + gap
        const r = Math.floor(Math.random() * (grid.rows - h));
        // Requirement: Always span the full width, random height only
        const w = grid.cols;
        const x = 0;
        let duration = 15; // Shorter duration for standard blocks
        if (type === 1) duration = 40; // Longer duration for split blocks to accommodate offset & flash phases
        this.crashBars.push({
            x: x, 
            y: r,
            w: w, 
            h: h,
            subH: subH, // Store the actual block height
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000,
            type: type,
            // User Request: Flickering happens only occasionally
            shouldGlitch: Math.random() < 0.3
        });
    }
    _triggerColumnBurst() {
        const grid = this.g;
        const col = Math.floor(Math.random() * grid.cols);
        let startRow = Math.floor(Math.random() * (grid.rows / 2)); 
        let height = Math.floor(Math.random() * (grid.rows / 2)) + (grid.rows / 4);
        if (Math.random() < 0.3) { startRow = 0; height = grid.rows; }
        const duration = 4; // Halved
        this.crashBars.push({
            x: col, 
            y: startRow,
            w: 1, 
            h: height,
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000 
        });
    }
    _updateSnapshots() {
        const currentFrame = this.frame; 
        for (const [index, snapshot] of this.snapshotOverlay.entries()) {
            if (currentFrame > snapshot.endFrame) this.snapshotOverlay.delete(index);
            else {
                const rem = snapshot.endFrame - currentFrame;
                if (snapshot.isSmith) { 
                    // Slower fade for Smith to stand out in the dark (40 frame fade)
                    if (rem < 40) snapshot.alpha = rem / 40.0; 
                } 
                else { if (rem < 10) snapshot.alpha = rem / 10.0; }
            }
        }
    }
}
// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); 
        this.name = "DejaVu"; 
        this.active = false; 
        this.autoTimer = c.state.dejaVuFrequencySeconds * 60; 
        this.map = null;
        this.bars = [];
        // Sub-effect states
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Shader State
        this.shaderActive = false;
        this.originalFade = 0;
    }
    trigger(durationSeconds = null) { 
        if(this.active) return false; 
        this.active = true; 
        const seconds = durationSeconds || this.c.state.dejaVuDurationSeconds;
        this.timer = seconds * 60; 
        this.bars = []; 
        this.map = new Uint8Array(this.g.rows); 
        // Reset sub-effects
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Override Stream Fade
        this.originalFade = this.c.get('decayFadeDurationFrames');
        this.c.set('decayFadeDurationFrames', 0);
        // Enable Glitch Shader
        this._enableShader();
        return true; 
    }
    _enableShader() {
        if (this.shaderActive) return;
        const glitchShader = `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
varying vec2 vTexCoord;
float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
void main() {
    vec2 uv = vTexCoord;
    vec4 color = texture2D(uTexture, uv);
    float t = floor(uTime * 15.0);
    if (rand(vec2(t, 1.0)) > 0.95) {
        float ry = rand(vec2(t, 2.0));
        float rh = rand(vec2(t, 3.0)) * 0.15; 
        if (uv.y > ry && uv.y < ry + rh) {
             float shift = (rand(vec2(t, 4.0)) - 0.5) * 0.02;
             float r = texture2D(uTexture, vec2(uv.x + shift + 0.003, uv.y)).r;
             float g = texture2D(uTexture, vec2(uv.x + shift, uv.y)).g;
             float b = texture2D(uTexture, vec2(uv.x + shift - 0.003, uv.y)).b;
             float a = texture2D(uTexture, vec2(uv.x + shift, uv.y)).a;
             color = vec4(r, g, b, a);
             if (rand(vec2(t, 5.0)) > 0.8) {
                float dir = (rand(vec2(t, 6.0)) > 0.5) ? 1.0 : -1.0;
                float jump = dir * (0.03 + rand(vec2(t, 7.0)) * 0.04);
                color = texture2D(uTexture, vec2(uv.x + jump, uv.y));
             }
        }
    }
    gl_FragColor = color;
}
`;
        this.c.set('effectShader', glitchShader);
        this.shaderActive = true;
    }
    _disableShader() {
        if (!this.shaderActive) return;
        this.c.set('effectShader', null);
        this.shaderActive = false;
    }
    update() {
        const s = this.c.state;
        if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
        if(!this.active) return;
        if(this.timer-- <= 0) { 
            this.active = false; 
            this.bars = []; 
            this.map = null; 
            this._disableShader();
            // Restore Fade
            this.c.set('decayFadeDurationFrames', this.originalFade);
            return; 
        }
        this.map.fill(0);
        if(Math.random() < s.dejaVuIntensity) {
            const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); 
            const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
            const duration = s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10);
            this.bars.push({ y, h, age: 0, maxAge: duration });
            if (this.g.glowSystem) {
                this.g.glowSystem.addRect(
                    this.g.cols / 2, y + (h / 2), this.g.cols, h, 2.0, this.c.derived.streamColorUint32, duration, 'linear', 4
                );
            }
        }
        const activeFonts = this.c.derived.activeFonts;
        const glitchCount = Math.max(1, Math.floor(this.g.cols * 0.05));
        const cols = this.g.cols;
        const rows = this.g.rows;
        const randomizeColors = s.dejaVuRandomizeColors;
        for(let i=this.bars.length-1; i>=0; i--) {
            const b = this.bars[i]; 
            b.age++;
            if(b.age > b.maxAge) { this.bars.splice(i, 1); continue; } 
            const limit = Math.min(rows, b.y + b.h);
            for(let r=b.y; r < limit; r++) {
                this.map[r] = 1; 
                for(let k=0; k<glitchCount; k++) {
                    const x = (Math.random() * cols) | 0;
                    const idx = r * cols + x;
                    this.g.mix[idx] = 0; 
                    const fontIdx = (Math.random() * activeFonts.length) | 0;
                    const fontData = activeFonts[fontIdx];
                    if (fontData.chars.length > 0) {
                        const char = fontData.chars[(Math.random() * fontData.chars.length) | 0];
                        let color = this.g.colors[idx];
                        const alpha = this.g.alphas[idx];
                        const glow = this.g.glows[idx];
                        if(randomizeColors) {
                            const h = (Math.random() * 360) | 0;
                            const rgb = Utils.hslToRgb(h, 90, 70);
                            color = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                            this.g.complexStyles.set(idx, { h, s: 90, l: 70, glitched: true });
                            this.g.baseColors[idx] = color;
                        }
                        this.g.setPrimary(idx, char, color, alpha, fontIdx, glow);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            this.vertGlitch.timer--;
            if (this.vertGlitch.timer <= 0) this.vertGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.vertGlitch.active = true;
                this.vertGlitch.timer = 15; 
                this.vertGlitch.width = Utils.randomInt(4, 7);
                this.vertGlitch.srcX = Utils.randomInt(0, this.g.cols - this.vertGlitch.width);
            }
        }
        if (this.doubleGlitch.active) {
            this.doubleGlitch.timer--;
            if (this.doubleGlitch.timer <= 0) this.doubleGlitch.active = false;
        } else {
            if (Math.random() < 0.015) {
                this.doubleGlitch.active = true;
                this.doubleGlitch.timer = Utils.randomInt(5, 15);
                this.doubleGlitch.h = Math.floor(this.g.rows / 3);
                this.doubleGlitch.startY = Utils.randomInt(0, this.g.rows - this.doubleGlitch.h);
                this.doubleGlitch.shiftX = Utils.randomInt(5, 20) * (Math.random() < 0.5 ? 1 : -1);
            }
        }
        if (this.horizGlitch.active) {
            this.horizGlitch.timer--;
            if (this.horizGlitch.timer <= 0) this.horizGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.horizGlitch.active = true;
                this.horizGlitch.timer = Utils.randomInt(5, 10);
                this.horizGlitch.shift = Utils.randomInt(3, 10) * (Math.random() < 0.5 ? 1 : -1);
                this.horizGlitch.flash = Math.random() < 0.5;
                this.horizGlitch.rows = [];
                const count = Utils.randomInt(5, 20);
                for(let i=0; i<count; i++) {
                    this.horizGlitch.rows.push(Utils.randomInt(0, this.g.rows-1));
                }
            }
        }
    }
    applyToGrid(grid) {
        if(!this.active) return;
        if (!this.map) return;
        const s = this.c.state; 
        const d = this.c.derived;
        const cols = grid.cols;
        const tracerColor = d.tracerColorUint32;
        const holeBrightness = s.dejaVuHoleBrightness;
        const activeFonts = d.activeFonts;
        const fallbackFontIdx = 0;
        const fallbackChars = activeFonts[0].chars;
        const timeSeed = Math.floor(Date.now() / 150);
        for (let y = 0; y < grid.rows; y++) {
            if (this.map[y] === 1) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const baseAlpha = grid.alphas[i];
                    const char = grid.getChar(i);
                    const fontIdx = grid.fontIndices[i];
                    if (baseAlpha < 0.01) {
                        if (holeBrightness > 0.01) {
                            if (fallbackChars && fallbackChars.length > 0) {
                                const hash = (i ^ timeSeed) * 2654435761;
                                const rndIdx = (hash & 0x7FFFFFFF) % fallbackChars.length;
                                grid.setOverride(i, fallbackChars[rndIdx], tracerColor, holeBrightness, fallbackFontIdx, 0);
                            } else {
                                grid.setOverride(i, char, tracerColor, holeBrightness, fallbackFontIdx, 0);
                            }
                        }
                    } else {
                        grid.setOverride(i, char, tracerColor, baseAlpha, fontIdx, 0);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            const { srcX, width } = this.vertGlitch;
            for (let y = 0; y < grid.rows; y++) {
                if (this.map[y] !== 1) continue;
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const readX = srcX + (x % width);
                    if (readX >= cols) continue;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor; 
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.doubleGlitch.active) {
            const { startY, h, shiftX } = this.doubleGlitch;
            const endY = Math.min(grid.rows, startY + h);
            for (let y = startY; y < endY; y++) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shiftX;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor;
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.horizGlitch.active) {
            const { rows, shift, flash } = this.horizGlitch;
            for (const r of rows) {
                if (r >= grid.rows) continue;
                const rowOffset = r * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shift;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    let char = grid.getChar(readIdx);
                    let alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    let color = grid.colors[readIdx];
                    let glow = grid.glows[readIdx];
                    const needsRandom = flash || (alpha < 0.1);
                    if (needsRandom && fallbackChars && fallbackChars.length > 0) {
                         const rndIdx = (Math.random() * fallbackChars.length) | 0;
                         char = fallbackChars[rndIdx];
                    }
                    if (flash) {
                        color = 0xFFFFFFFF; 
                        alpha = 1.0;
                        glow = 5.0; 
                    } else {
                         color = tracerColor;
                    }
                    grid.setOverride(i, char, color, alpha, fontIdx, glow);
                }
            }
        }
    }
}
// --- GlowSystem.js ---
class GlowSystem {
    constructor(grid) {
        this.grid = grid;
        this.sources = [];
    }
    /**
     * Adds a transient radial glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} radius - Radius in cells.
     * @param {number} intensity - Peak intensity.
     * @param {number|null} color - Tint color (Uint32).
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential', 'none'.
     */
    add(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.addRadial(x, y, radius, intensity, color, duration, decayFn);
    }
    addRadial(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.sources.push({
            type: 'radial', x, y, radius, intensity, color, 
            duration: Math.max(1, duration), 
            maxDuration: Math.max(1, duration), 
            decayFn, 
            age: 0
        });
    }
    /**
     * Adds a transient rectangular glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} width - Full Width in cells.
     * @param {number} height - Full Height in cells.
     * @param {number} intensity - Peak intensity (inside box).
     * @param {number|null} color - Tint color.
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential'.
     * @param {number} falloff - Soft edge radius outside the box (0 = hard edge).
     */
    addRect(x, y, width, height, intensity, color = null, duration = 0, decayFn = 'linear', falloff = 2) {
        this.sources.push({
            type: 'rect', x, y, w: width, h: height, falloff, intensity, color,
            duration: Math.max(1, duration),
            maxDuration: Math.max(1, duration),
            decayFn,
            age: 0
        });
    }
    update() {
        // Lifecycle Management
        for (let i = this.sources.length - 1; i >= 0; i--) {
            const s = this.sources[i];
            s.age++;
            if (s.age >= s.duration) {
                this.sources.splice(i, 1);
            }
        }
    }
    apply() {
        if (this.sources.length === 0) return;
        const grid = this.grid;
        const cols = grid.cols;
        const rows = grid.rows;
        const gEnvGlows = grid.envGlows;
        const gColors = grid.colors;
        for (const s of this.sources) {
            // Calculate lifecycle intensity
            let currentIntensity = s.intensity;
            if (s.decayFn === 'linear') {
                currentIntensity *= 1.0 - (s.age / s.maxDuration);
            } else if (s.decayFn === 'exponential') {
                const prog = s.age / s.maxDuration;
                currentIntensity *= (1.0 - (prog * prog));
            }
            if (currentIntensity <= 0.01) continue;
            // Determine Bounds
            let minX, maxX, minY, maxY;
            if (s.type === 'rect') {
                const halfW = s.w / 2;
                const halfH = s.h / 2;
                const margin = s.falloff;
                minX = Math.floor(s.x - halfW - margin);
                maxX = Math.ceil(s.x + halfW + margin);
                minY = Math.floor(s.y - halfH - margin);
                maxY = Math.ceil(s.y + halfH + margin);
            } else {
                // Radial
                const r = s.radius;
                minX = Math.floor(s.x - r);
                maxX = Math.ceil(s.x + r);
                minY = Math.floor(s.y - r);
                maxY = Math.ceil(s.y + r);
            }
            // Clamp to grid
            minX = Math.max(0, minX); maxX = Math.min(cols - 1, maxX);
            minY = Math.max(0, minY); maxY = Math.min(rows - 1, maxY);
            for (let cy = minY; cy <= maxY; cy++) {
                for (let cx = minX; cx <= maxX; cx++) {
                    const idx = cy * cols + cx;
                    if (grid.state[idx] === 0) continue; 
                    let boost = 0;
                    if (s.type === 'rect') {
                        // Signed Distance Field logic for Box
                        // distance from center relative to half-size
                        const dx = Math.abs(cx - s.x) - (s.w / 2);
                        const dy = Math.abs(cy - s.y) - (s.h / 2);
                        // dist > 0 means outside. dist <= 0 means inside.
                        // We only care about outside distance for falloff.
                        // Inside is full intensity.
                        const outsideDist = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
                        if (outsideDist <= 0) {
                            boost = currentIntensity; // Inside box
                        } else if (outsideDist < s.falloff) {
                            // Fade out
                            boost = currentIntensity * (1.0 - (outsideDist / s.falloff));
                        }
                    } else {
                        // Radial
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < s.radius) {
                            boost = currentIntensity * (1.0 - (dist / s.radius));
                        }
                    }
                    if (boost > 0.01) {
                        gEnvGlows[idx] += boost;
                        if (s.color !== null) {
                            const blendFactor = Math.min(1.0, boost * 0.5);
                            const cur = gColors[idx];
                            const cR = cur & 0xFF;
                            const cG = (cur >> 8) & 0xFF;
                            const cB = (cur >> 16) & 0xFF;
                            const sR = s.color & 0xFF;
                            const sG = (s.color >> 8) & 0xFF;
                            const sB = (s.color >> 16) & 0xFF;
                            const nR = cR + (sR - cR) * blendFactor;
                            const nG = cG + (sG - cG) * blendFactor;
                            const nB = cB + (sB - cB) * blendFactor;
                            const nA = (cur >> 24) & 0xFF;
                            gColors[idx] = ((nA & 0xFF) << 24) | ((Math.floor(nB) & 0xFF) << 16) | ((Math.floor(nG) & 0xFF) << 8) | (Math.floor(nR) & 0xFF);
                        }
                    }
                }
            }
        }
    }
}
// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "MiniPulse";
        this.active = false;
        this.sessionTimer = 0;
        this.autoTimer = c.state.miniPulseFrequencySeconds * 60;
        this.pulses = [];
        this.renderPulses = [];
    }
    trigger() {
        if (this.active) return false;
        this.active = true;
        this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60;
        this.pulses = [];
        return true;
    }
    update() {
        const s = this.c.state;
        const d = this.c.derived;
        if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.miniPulseFrequencySeconds * 60;
        }
        if (this.active) {
            this.sessionTimer--;
            if (Math.random() < s.miniPulseSpawnChance) {
                this.pulses.push({
                    x: Utils.randomInt(0, this.g.cols),
                    y: Utils.randomInt(0, this.g.rows),
                    r: 0,
                    maxR: s.miniPulseSize,
                    speed: s.miniPulseSpeed
                });
            }
            if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
        }
        this.renderPulses = [];
        for (let i = this.pulses.length - 1; i >= 0; i--) {
            const p = this.pulses[i];
            p.r += p.speed;
            if (p.r > p.maxR + 100) {
                this.pulses.splice(i, 1);
                continue;
            }
            const ox = (p.x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5);
            const oy = (p.y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
            const minX = ox - p.r;
            const maxX = ox + p.r;
            const minY = oy - p.r;
            const maxY = oy + p.r;
            const rSq = p.r * p.r;
            const innerEdge = Math.max(0, p.r - s.miniPulseThickness);
            const innerEdgeSq = innerEdge * innerEdge;
            this.renderPulses.push({
                ox, oy,
                minX, maxX, minY, maxY,
                r: p.r,
                rSq,
                innerEdge,
                innerEdgeSq,
                maxR: p.maxR
            });
        }
    }
    applyToGrid(grid) {
        if (!this.active || this.renderPulses.length === 0) return;
        const s = this.c.state;
        const d = this.c.derived;
        const cW = d.cellWidth * s.stretchX;
        const cH = d.cellHeight * s.stretchY;
        const tracerColor = d.tracerColorUint32;
        // Unpack Tracer Color for blending
        const tR = tracerColor & 0xFF;
        const tG = (tracerColor >> 8) & 0xFF;
        const tB = (tracerColor >> 16) & 0xFF;
        for (const p of this.renderPulses) {
            const startCol = Math.max(0, Math.floor(p.minX / cW));
            const endCol = Math.min(grid.cols, Math.ceil(p.maxX / cW));
            const startRow = Math.max(0, Math.floor(p.minY / cH));
            const endRow = Math.min(grid.rows, Math.ceil(p.maxY / cH));
            for (let y = startRow; y < endRow; y++) {
                const rowOffset = y * grid.cols;
                for (let x = startCol; x < endCol; x++) {
                    const i = rowOffset + x;
                    // Skip empty cells (No scrambling)
                    const baseAlpha = grid.alphas[i];
                    if (baseAlpha <= 0.01) continue;
                    const cx = (x * cW) + (cW * 0.5);
                    const cy = (y * cH) + (cH * 0.5);
                    if (s.pulseCircular !== false) {
                        const dx = cx - p.ox;
                        const dy = cy - p.oy;
                        const distSq = (dx * dx) + (dy * dy);
                        if (distSq > p.rSq || distSq < p.innerEdgeSq) continue;
                    } else {
                        const dist = Math.max(Math.abs(cx - p.ox), Math.abs(cy - p.oy));
                        if (dist > p.r || dist < p.innerEdge) continue;
                    }
                    // Hit!
                    let lifeFade = 1.0;
                    if (p.r > p.maxR) lifeFade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                    if (lifeFade <= 0.01) continue;
                    // Blend Tracer Color -> Stream Color
                    // Ratio: lifeFade. 1.0 = Tracer. 0.0 = Stream.
                    const streamColor = grid.colors[i];
                    const sR = streamColor & 0xFF;
                    const sG = (streamColor >> 8) & 0xFF;
                    const sB = (streamColor >> 16) & 0xFF;
                    const mR = Math.floor(sR + (tR - sR) * lifeFade);
                    const mG = Math.floor(sG + (tG - sG) * lifeFade);
                    const mB = Math.floor(sB + (tB - sB) * lifeFade);
                    const finalColor = Utils.packAbgr(mR, mG, mB);
                    const baseGlow = s.tracerGlow * lifeFade;
                    const glow = (s.miniPulseUseTracerGlow) ? baseGlow : 0;
                    // Override acts as a "Lighting" layer here.
                    // We use existing char and font.
                    // We use existing alpha to preserve fade state.
                    grid.setOverride(i, grid.getChar(i), finalColor, baseAlpha, grid.fontIndices[i], glow);
                }
            }
        }
    }
}
// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); this.name = "Pulse"; 
        this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
        this.snap = null; 
        const s = this._getEffectiveState();
        const fps = s.pulseMovieAccurate ? 30 : 60;
        this.autoTimer = s.pulseFrequencySeconds * fps;
        this.renderData = null; 
        this.frameAccumulator = 0;
    }
    _getEffectiveState() {
        const s = this.c.state;
        if (!s.pulseMovieAccurate) return s;
        // Movie Accurate Overrides
        return {
            ...s,
            pulseFrequencySeconds: 300, 
            pulseDelaySeconds: 1.0,      // Dark delay of 1 second
            pulseDurationSeconds: 1.4,   // Wave expands for 1.4 seconds
            pulseWidth: 150,             // Ignored in MA custom logic but kept for safety
            pulseRandomPosition: false,  // We calculate specific start
            pulseInstantStart: false,
            pulseCircular: false,        // Rectangular
            pulseAspectRatio: 1.6,       // 16:10 Aspect Ratio (Width / Height)
            pulsePreserveSpaces: true,
            pulseIgnoreTracers: true,
            pulseUseTracerGlow: true,    // Always use glow in movie accurate mode
            pulseDimming: 0.2,
            pulseBlend: false
        };
    }
    trigger() {
        if(this.active) return false;
        const total = this.g.cols * this.g.rows;
        // Snapshot the current grid state
        this.snap = { 
            chars: new Uint16Array(this.g.chars), 
            fontIndices: new Uint8Array(this.g.fontIndices),
            alphas: new Float32Array(this.g.alphas), 
            colors: new Uint32Array(this.g.colors), 
            tracers: new Uint8Array(total), 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total)
        };
        const d = this.c.derived; const s = this._getEffectiveState(); const holdEnd = d.cycleDuration + d.holdFrames;
        const fps = s.pulseMovieAccurate ? 30 : 60;
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = Utils.CHARS;
        for(let i=0; i<total; i++) {
            // Identify Tracer State
            const type = this.g.types[i]; 
            const age = this.g.ages[i];
            let isTracer = false;
            if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                const at = age - 1; 
                if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                    isTracer = true;
                } 
            }
            this.snap.tracers[i] = isTracer ? 1 : 0; 
            // Generate Fill Char/Font for gaps
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.pulseMovieAccurate) {
             // Find Tracer closest to center
             const cx = Math.floor(this.g.cols / 2);
             const cy = Math.floor(this.g.rows / 2);
             let minDist = 99999999;
             let bestX = cx; 
             let bestY = cy;
             for(let i=0; i<total; i++) {
                 if (this.snap.tracers[i] === 1) {
                     const x = i % this.g.cols;
                     const y = Math.floor(i / this.g.cols);
                     const dx = (x - cx);
                     const dy = (y - cy);
                     const dist = dx*dx + dy*dy;
                     if (dist < minDist) {
                         minDist = dist;
                         bestX = x;
                         bestY = y;
                     }
                 }
             }
             ox = bestX;
             oy = bestY;
        } else if (s.pulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8);
            oy = Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.pulseWidth && pxDistY < s.pulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols/2);
            oy = Math.floor(this.g.rows/2);
        }
        this.origin = {x: ox, y: oy};
        this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelaySeconds * fps; 
        // Radius Init
        if (s.pulseMovieAccurate) {
            this.radius = 2 * d.cellWidth * s.stretchX; 
        } else {
            this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; 
        }
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * fps);
        // --- Dynamic Delay Chunks ---
        this.chunks = [];
        this.spawnedCount = 0;
        this.spawnCooldown = 0;
        return true; 
    }
    update() {
        const s = this._getEffectiveState();
        const fps = s.pulseMovieAccurate ? 30 : 60;
        if (s.pulseMovieAccurate) {
             this.frameAccumulator++;
             if (this.frameAccumulator < 2) return;
             this.frameAccumulator = 0;
        } else {
             this.frameAccumulator = 0;
        }
        if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * fps; }
        if(!this.active) { this.renderData = null; return; }
        const d = this.c.derived;
        if(this.state === 'WAITING') { 
            if(--this.timer <= 0) { this.state = 'EXPANDING'; }
        } else {
            const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
            this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * fps);
            this.radius += this.speed; 
            if(this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
            // --- Chunk Lifecycle & Spawning ---
            if (s.pulseMovieAccurate) {
                // 1. Update existing chunks
                for (let i = this.chunks.length - 1; i >= 0; i--) {
                    this.chunks[i].life--;
                    if (this.chunks[i].life <= 0) {
                        this.chunks.splice(i, 1);
                    }
                }
                // 2. Cooldown
                if (this.spawnCooldown > 0) this.spawnCooldown--;
                // 3. Spawn Logic
                const progress = this.radius / maxDim;
                if (progress > 0.15 && this.spawnedCount < 4 && this.spawnCooldown <= 0) {
                    // Spawn new chunk - Select Type
                    const type = Math.floor(Math.random() * 3);
                    const w = Utils.randomInt(Math.floor(this.g.cols * 0.5), this.g.cols);
                    let h, y;
                    if (type === 0) {
                        // Type A: Bottom Half
                        h = Math.floor(this.g.rows / 2);
                        y = Math.floor(this.g.rows / 2);
                    } else if (type === 1) {
                        // Type B: Mid Section (9-10 tall)
                        h = Utils.randomInt(9, 10);
                        // Center near wave edge, but favor middle
                        const rY = this.radius / 1.6;
                        const topEdgeY = (this.origin.y * d.cellHeight * s.stretchY - rY) / (d.cellHeight * s.stretchY);
                        const botEdgeY = (this.origin.y * d.cellHeight * s.stretchY + rY) / (d.cellHeight * s.stretchY);
                        let targetY = (Math.random() < 0.5) ? topEdgeY : botEdgeY;
                        y = Math.floor(targetY - h / 2);
                        // Constrain to "Middle-ish" (20% to 80%)
                        y = Math.max(Math.floor(this.g.rows * 0.2), Math.min(Math.floor(this.g.rows * 0.8) - h, y));
                    } else {
                        // Type C: Thin Strip (4 tall) near bottom
                        h = 4;
                        y = Utils.randomInt(this.g.rows - 15, this.g.rows - 5);
                    }
                    const x = Utils.randomInt(0, this.g.cols - w);
                    // Final Clamp
                    y = Math.max(0, Math.min(this.g.rows - h, y));
                    const delayPixels = 4 * d.cellWidth * s.stretchX; 
                    // Duration: Time to traverse delay + Time to traverse 1 extra char + buffer
                    const oneCharTime = (d.cellWidth * s.stretchX) / this.speed;
                    const duration = Math.ceil(delayPixels / this.speed) + Math.ceil(oneCharTime) + 2;
                    this.chunks.push({
                        x, y, w, h,
                        lag: delayPixels,
                        life: duration
                    });
                    this.spawnedCount++;
                    this.spawnCooldown = duration + 5; // Wait at least 5 frames after despawn
                }
            }
        }
        // --- Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); 
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        // Effective ratio for calculation
        let ratio = 1;
        if (s.pulseMovieAccurate) {
             ratio = 1.6; // Locked 16:10
        } else if (!s.pulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        const width = s.pulseWidth * 2; 
        const innerEdge = this.radius - width;
        let minX, maxX, minY, maxY;
        if (s.pulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this._getEffectiveState(); 
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        // ===========================================
        // MOVIE ACCURATE RENDER PATH
        // ===========================================
        if (s.pulseMovieAccurate) {
             const aspect = 1.0; 
             const sideWidth = 7 * d.cellWidth * s.stretchX; 
             const vertWidth = 5 * d.cellHeight * s.stretchY; 
             const fadeSizeSide = 0.5 * d.cellWidth * s.stretchX;
             const fadeSizeVert = 0.5 * d.cellHeight * s.stretchY;
             const initHoleRad = 2 * d.cellWidth * s.stretchX; 
             const maxWaveWidth = sideWidth; 
             let innerB = Math.max(initHoleRad, this.radius - maxWaveWidth);
             let outerB = this.radius;
             const revealFadeLenSide = 2 * d.cellWidth * s.stretchX;
             const revealFadeLenVert = 2 * d.cellHeight * s.stretchY;
             const maxRad = Math.max(grid.cols * d.cellWidth * s.stretchX, grid.rows * d.cellHeight * s.stretchY);
             const delayDist = 4 * d.cellWidth * s.stretchX;
             const r30 = maxRad * 0.30;
             const r40 = maxRad * 0.40; 
             const rHalfRow = Math.floor(grid.rows / 2);
             const progress = this.radius / maxRad;
             // FADE TO DARK LOGIC
             // Timer counts DOWN. We want to fade OUT in the first 10 frames of the wait.
             // Max timer = s.pulseDelaySeconds * 60
             const maxTimer = s.pulseDelaySeconds * 60;
             const timeElapsed = maxTimer - this.timer;
             const fadeDur = 10; // Frames
             let fadeMult = s.pulseDimming;
             if (timeElapsed < fadeDur) {
                 const t = timeElapsed / fadeDur; 
                 // Lerp from 1.0 to s.pulseDimming
                 fadeMult = 1.0 + (s.pulseDimming - 1.0) * t;
             }
             for (let i = 0; i < total; i++) {
                 // Common Data Fetch
                 const snAlpha = this.snap.alphas[i];
                 let charCode = this.snap.chars[i];
                 let color = this.snap.colors[i];
                 let fontIdx = this.snap.fontIndices[i];
                 const isTracer = (this.snap.tracers[i] === 1);
                 // Fill gaps from snapshot
                 const isGap = (snAlpha <= 0.01);
                 if (isGap) {
                     charCode = this.snap.fillChars[i];
                     color = d.streamColorUint32;
                     fontIdx = this.snap.fillFonts[i];
                 }
                 if (this.state === 'WAITING') {
                     // 1. Darken Everything with Fade
                     if (isTracer) {
                         const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                         // Tracers REMAIN BRIGHT (Ignore fadeMult)
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                     } else {
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * fadeMult, fontIdx, 0);
                     }
                     continue;
                 }
                 // EXPANDING
                 const x = i % grid.cols; 
                 const y = Math.floor(i / grid.cols);
                 const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                 const cy = Math.floor(y * d.cellHeight * s.stretchY);
                 // --- Apply Catching Lag ---
                 let curLag = 0;
                 // Check active chunks
                 if (this.chunks) {
                     const col = x; 
                     const row = y;
                     for (const chunk of this.chunks) {
                         if (col >= chunk.x && col < chunk.x + chunk.w &&
                             row >= chunk.y && row < chunk.y + chunk.h) {
                             curLag = chunk.lag;
                             break; // Apply first found (or max if we wanted overlap)
                         }
                     }
                 }
                 const localOuter = Math.max(0, outerB - curLag);
                 const localInner = Math.max(0, innerB - curLag);
                 const dx = Math.abs(cx - rd.ox);
                 const dy = Math.abs(cy - rd.oy);
                 const dyScaled = dy * aspect;
                 const dist = Math.max(dx, dyScaled);
                 const isSide = (dx > dyScaled);
                 const fadeSize = isSide ? fadeSizeSide : fadeSizeVert;
                 if (dist > localOuter) {
                     // --- OUTSIDE ---
                     // Check if this block is "Lagging" (Delayed Chunk)
                     if (curLag > 0 && dist < outerB) {
                         // LAGGED CHUNK: Faded Pulse Character on Dimmed Background
                         // User Req: "characters... empty due to delay be faded characters the color of the pulse wave"
                         // User Req: "green code... should be dark like the background"
                         const displayChar = String.fromCharCode(this.snap.fillChars[i]);
                         const displayFont = this.snap.fillFonts[i];
                         // Dim the underlying green code
                         let baseColor = grid.colors[i];
                         const r = baseColor & 0xFF;
                         const g = (baseColor >> 8) & 0xFF;
                         const b = (baseColor >> 16) & 0xFF;
                         baseColor = Utils.packAbgr(Math.floor(r * s.pulseDimming), Math.floor(g * s.pulseDimming), Math.floor(b * s.pulseDimming));
                         // Faded Pulse Overlay (Alpha 0.4 - Visible but Dim)
                         grid.setEffectOverlay(i, displayChar, baseColor, 0.4, displayFont, 0); // No glow for faded part
                     } else {
                         // NORMAL BACKGROUND
                         if (isTracer) {
                             // Tracers remain bright outside
                             const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                         } else {
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                         }
                     }
                 } 
                 else {
                     // --- INSIDE WAVE FRONT (Revealing Simulation) ---
                     if (dist > localInner) {
                         // --- WAVE BAND OVERLAY ---
                         // 0. Random Glitch "Dead" Characters (2% chance - sparse)
                         if ((i * 13) % 100 < 2) {
                             grid.clearEffectOverride(i); // Show simulation (with its gaps)
                         } else {
                             // Use random char and font
                             const displayChar = String.fromCharCode(this.snap.fillChars[i]);
                             const displayFont = this.snap.fillFonts[i];
                             // 1. Alpha Variance (15% chance to be 20% darker)
                             // Base: 1.0 (Full Bright)
                             // Variance: 0.8 (20% darker)
                             let alpha = 1.0;
                             if ((i * 37) % 100 < 15) {
                                 alpha = 0.8; 
                             }
                             // 2. Delay Dimming
                             // If this part of the wave is delayed (lagged), dim it.
                             if (curLag > 0) {
                                 alpha *= 0.6;
                             }
                             // Slight Glow -> Bold/Thicker (1.5)
                             const waveGlow = 1.5;
                             // Dimming Logic for Leading Edge (First 5 chars)
                             let baseColor = grid.colors[i];
                             // Check distance from leading edge
                             const edgeDist = localOuter - dist;
                             const threshold = 5 * d.cellWidth * s.stretchX;
                             if (edgeDist < threshold) {
                                 const r = baseColor & 0xFF;
                                 const g = (baseColor >> 8) & 0xFF;
                                 const b = (baseColor >> 16) & 0xFF;
                                 // Dim by 50%
                                 baseColor = Utils.packAbgr(Math.floor(r * 0.5), Math.floor(g * 0.5), Math.floor(b * 0.5));
                             }
                             // Use Overlay Mode (2) to see simulation underneath
                             grid.setEffectOverlay(i, displayChar, baseColor, alpha, displayFont, waveGlow);
                         }
                     } else {
                         // --- HOLE (Full Reveal) ---
                         grid.clearEffectOverride(i);
                     }
                 }
             }
             return; // End MA path
        }
        // ===========================================
        // STANDARD PATH (Original Logic)
        // ===========================================
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: Skip if we are waiting (Override whole screen efficiently)
            let dist = 0;
            if (this.state === 'EXPANDING') {
                const x = i % grid.cols; 
                const y = Math.floor(i / grid.cols);
                const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                const cy = Math.floor(y * d.cellHeight * s.stretchY);
                if (s.pulseCircular) {
                    const dx = cx - rd.ox; const dy = cy - rd.oy;
                    dist = Math.sqrt(dx*dx + dy*dy);
                } else {
                    const dx = Math.abs(cx - rd.ox);
                    const dy = Math.abs(cy - rd.oy);
                    dist = Math.max(dx, dy * rd.ratio);
                }
                // 1. HOLE (Inner Edge): Instant Reveal
                if (dist < rd.innerEdge) {
                    grid.clearEffectOverride(i); 
                    continue;
                }
            } else {
                dist = 999999; // Waiting state: effectively infinite distance
            }
            // --- Common Data Fetch ---
            const snAlpha = this.snap.alphas[i];
            let charCode = this.snap.chars[i];
            let fontIdx = this.snap.fontIndices[i];
            let color = this.snap.colors[i];
            const isTracer = (this.snap.tracers[i] === 1);
            const isGap = (snAlpha <= 0.01);
            // Apply Gap Filling (Global)
            if (isGap && !s.pulsePreserveSpaces) {
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
            }
            // 2. BACKGROUND (Dimmed)
            // Condition: Waiting OR Outside Radius
            if (this.state === 'WAITING' || dist > rd.radius) {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else if (isTracer && s.pulseIgnoreTracers) {
                    // Keep original tracer
                    const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                } else {
                    // Dimmed Snapshot
                    if (snAlpha > 0.01 || !s.pulsePreserveSpaces) {
                        grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                    } else {
                        grid.clearEffectOverride(i);
                    }
                }
            } 
            // 3. WAVE BAND (Bright)
            // Condition: We are here because dist >= innerEdge AND dist <= radius
            else {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else {
                    // Calculate relative position (0.0 at outer edge, 1.0 at inner edge)
                    // (radius - dist) is small at edge, large at inner
                    const rel = Math.max(0, Math.min(1, (rd.radius - dist) / (s.pulseWidth * 1.25)));
                    let finalColor = tColorInt;
                    if (s.pulseBlend) {
                        const bR = color & 0xFF;
                        const bG = (color >> 8) & 0xFF;
                        const bB = (color >> 16) & 0xFF;
                        const mR = Math.floor(tR + (bR - tR) * rel);
                        const mG = Math.floor(tG + (bG - tG) * rel);
                        const mB = Math.floor(tB + (bB - tB) * rel);
                        finalColor = Utils.packAbgr(mR, mG, mB);
                    }
                    const glowAmount = (s.pulseUseTracerGlow) ? Math.max(s.tracerGlow, 30 * (1.0 - rel)) : 0;
                    // Force alpha 1.0 for the wave
                    grid.setEffectOverride(i, String.fromCharCode(charCode), finalColor, 1.0 , fontIdx, glowAmount);
                }
            }
        }
    }
}
// --- QuantizedPulseEffect.js ---
class QuantizedPulseEffect extends AbstractEffect {
    constructor(grid, config) {
        super(grid, config);
        this.name = "QuantizedPulse";
        this.active = false;
        // Simulation State
        this.blocks = [];      // {x, y}
        this.lines = [];       // {x, y, w, h, alpha, persistence}
        this.frontier = [];    // {x, y}
        // Bitmask Map: Bit 0 = Occupied, Bit 1 = Frontier, Bits 2-15 = BurstID
        this.map = null;       // Uint16Array
        this.mapCols = 0;
        this.burstCounter = 0;
        this.origin = null;    // {x, y} center of plus
        this.blocksAdded = 0;
        this.tendrils = [];    // [{x,y}, {x,y}...]
        // Catch/Stall State
        this.catchTimer = 0;   
        // Timing
        this.nextExpandTime = 0;
        this.currentDelay = 0;
        this.blockSize = 4;
        this.timeoutId = null;
        // Fade State
        this.isFading = false;
        this.fadeAlpha = 1.0;
        this.fadeInAlpha = 0.0;
        this.isExpanding = false; // Tracks if the pulse is actively growing
        this.isFinishing = false; // Legacy flag, replaced by isExpanding logic
        // Flash State
        this.flashIntensity = null; 
        this.activeFlashes = new Set();
    }
    _getEffectiveState() {
        const s = this.c.state;
        const fadeFrames = s.quantizedPulseFadeFrames !== undefined ? s.quantizedPulseFadeFrames : 15;
        const fadeInFrames = s.quantizedPulseFadeInFrames !== undefined ? s.quantizedPulseFadeInFrames : 5;
        // If fadeFrames is 0 (Off), fade is instant (speed 1.0)
        const lineSpeed = fadeFrames > 0 ? (1.0 / fadeFrames) : 1.0;
        return {
            enabled: s.quantizedPulseEnabled,
            freq: s.quantizedPulseFrequencySeconds,
            duration: s.quantizedPulseDurationSeconds || 2.0,
            initialSpeed: 10,   // Hard-coded as requested (was s.quantizedPulseSpeed || 10)
            fadeFrames: fadeFrames,
            fadeInFrames: fadeInFrames,
            baseDelay: 1.0,     // Much faster start (was 8)
            acceleration: 1, // Very subtle acceleration (was 0.94)
            minDelay: 0.5,      // Keep top speed cap same
            blockSize: 4,
            lineFadeSpeed: lineSpeed 
        };
    }
    stop() {
        this.active = false;
        this.isFading = false;
        this.isFinishing = false;
        this.fadeAlpha = 1.0;
        this.swapped = false;
        this.swapTimer = 0;
        this.growthPhase = 0;
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        // Immediate cleanup
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        if (this.map) this.map.fill(0);
        this.activeFlashes.clear();
        if (this.flashIntensity) this.flashIntensity.fill(0);
        this.g.clearAllOverrides();
    }
    beginFade() {
        const s = this._getEffectiveState();
        if (s.fadeFrames > 0) {
            this.isFading = true;
            this.fadeAlpha = 1.0;
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
                this.timeoutId = null;
            }
        } else {
            this.stop();
        }
    }
    resetExpansion() {
        this.isExpanding = false;
        this.swapped = false;
        this.swapTimer = 0;
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        // Clear Expansion State ONLY
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        if (this.map) this.map.fill(0);
        // Do NOT clear flashes or overrides here
    }
    trigger() {
        // If already expanding, reset the expansion part but keep flashes
        if (this.isExpanding) this.resetExpansion();
        this.active = true;
        this.isExpanding = true;
        this.isFading = false;
        this.isFinishing = false;
        this.fadeAlpha = 1.0;
        this.startTime = Date.now();
        this.growthPhase = 0; // 0: Start, 1: NSEW, 2: NS, 3: Full
        const s = this._getEffectiveState();
        this.fadeInAlpha = (s.fadeInFrames > 0) ? 0.0 : 1.0;
        // INIT SHADOW WORLD (Full Simulation)
        this._initShadowWorld();
        this.timeoutId = setTimeout(() => {
            this._finishExpansion(); // Force finish
        }, 60000); 
        // Resize map
        this.mapPad = 60; 
        this.mapCols = this.g.cols + this.mapPad * 2;
        this.mapRows = this.g.rows + this.mapPad * 2;
        const total = this.mapCols * this.mapRows;
        if (!this.map || this.map.length !== total) {
            this.map = new Uint16Array(total);
        } else {
            this.map.fill(0);
        }
        // Resize Flash Intensity (Preserve existing if size matches)
        const totalGrid = this.g.cols * this.g.rows;
        if (!this.flashIntensity || this.flashIntensity.length !== totalGrid) {
            this.flashIntensity = new Float32Array(totalGrid);
            this.activeFlashes.clear();
        }
        // Do NOT clear activeFlashes or flashIntensity here to allow persistence
        this.burstCounter = 0;
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        this.catchTimer = 0;
        this.localFrame = 0;
        this.swapTimer = 0;
        this.swapped = false;
        const cx = Math.floor((this.g.cols / 2) / 4) * 4;
        const cy = Math.floor((this.g.rows / 2) / 4) * 4;
        this._addBlock(cx, cy);
        this.origin = {x: cx, y: cy};
        this.blocksAdded = 1; 
        this.currentDelay = s.baseDelay;
        this.nextExpandTime = this.currentDelay;
        return true;
    }
    // ... (unchanged methods: _initShadowWorld, _updateShadowWorld, _finishExpansion, _addBlock, _isOccupied, _applyMask) ...
    _initShadowWorld() {
        // Create a Shadow Grid and Simulation to run the "New World"
        // This ensures settings match exactly and allows for a state swap later.
        // 1. Setup Shadow Grid
        this.shadowGrid = new CellGrid(this.c);
        const d = this.c.derived;
        // Resize to match main grid dimensions
        const w = this.g.cols * d.cellWidth;
        const h = this.g.rows * d.cellHeight;
        this.shadowGrid.resize(w, h);
                // 2. Setup Shadow Simulation
                // We force main thread execution for simplicity of buffer access
                this.shadowSim = new SimulationSystem(this.shadowGrid, this.c);
                this.shadowSim.useWorker = false;
                if (this.shadowSim.worker) {
                    this.shadowSim.worker.terminate();
                    this.shadowSim.worker = null;
                }
                // 2b. PRE-WARMUP INJECTION (Immediate Population)
                // This guarantees density and eliminates the need for long warmup delays.
                const sm = this.shadowSim.streamManager;
                const s = this.c.state;
                // Ensure StreamManager has correct dimensions
                sm.resize(this.shadowGrid.cols);
                // Shuffled columns to guarantee distribution
                const columns = Array.from({length: this.shadowGrid.cols}, (_, i) => i);
                for (let i = columns.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [columns[i], columns[j]] = [columns[j], columns[i]];
                }
                // Target 75% of columns to be populated initially
                const injectionCount = Math.floor(this.shadowGrid.cols * 0.75);
                for (let k = 0; k < injectionCount; k++) {
                    const col = columns[k];
                    // Random Start Y (Full Height Distribution)
                    const startY = Math.floor(Math.random() * this.shadowGrid.rows);
                    // 20% chance for Eraser, 80% for Tracer
                    const isEraser = Math.random() < 0.2;
                    const stream = sm._initializeStream(col, isEraser, s);
                    stream.y = startY;
                    stream.age = startY; // Match age to position
                    sm.addActiveStream(stream);
                }
                // 3. Warm Up (Faster)
                // 400 frames is enough to generate trails for injected streams
                this.shadowSim.timeScale = 1.0;
                const warmupFrames = 400;
                for (let i = 0; i < warmupFrames; i++) {
                    this.shadowSim.update(i);
                }
                // 4. Quick Density Check (Safety Only)
                let extraFrames = 0;
                const maxExtra = 200; 
                const totalCells = this.shadowGrid.cols * this.shadowGrid.rows;
                const targetActive = Math.floor(totalCells * 0.015);
                while (extraFrames < maxExtra) {
                     let activeCount = 0;
                     for(let k=0; k<totalCells; k+=10) {
                         if (this.shadowGrid.state[k] === 1) activeCount++;
                     }
                     if ((activeCount * 10) > targetActive) break;
                     this.shadowSim.update(warmupFrames + extraFrames);
                     extraFrames++;
                }
                        this.localFrame = warmupFrames + extraFrames;
                    }
                    _updateShadowWorld() {
        if (!this.shadowSim || !this.shadowGrid) return;
        // 1. Advance Shadow Simulation
        this.shadowSim.update(this.localFrame);
        // 2. Copy Shadow State to Main Grid's OVERRIDE Layer
        // This effectively projects the "New World" onto the "Old World"
        // where overrideActive is set (inside the pulse).
        const g = this.g;
        const sg = this.shadowGrid;
        g.overrideChars.set(sg.chars);
        g.overrideColors.set(sg.colors);
        g.overrideAlphas.set(sg.alphas);
        g.overrideGlows.set(sg.glows);
        g.overrideNextChars.set(sg.nextChars);
        // Note: We do NOT copy 'types', 'decays' etc to Override, 
        // because Override is purely visual. Logic state stays in shadowSim.
    }
    _finishExpansion() {
        // console.log("[QuantizedPulse] Finishing Expansion...");
        try {
            const g = this.g;
            const sg = this.shadowGrid;
            if (sg) {
                // ... (Buffer Commit logic same as before, simplified for brevity in thought, but full copy in code)
                // 1. Commit Buffer State
                g.state.set(sg.state); 
                g.chars.set(sg.chars);
                g.colors.set(sg.colors);
                g.baseColors.set(sg.baseColors); 
                g.alphas.set(sg.alphas);
                g.glows.set(sg.glows);
                g.fontIndices.set(sg.fontIndices);
                g.renderMode.set(sg.renderMode); 
                g.types.set(sg.types);
                g.decays.set(sg.decays);
                g.ages.set(sg.ages);
                g.brightness.set(sg.brightness);
                g.rotatorOffsets.set(sg.rotatorOffsets);
                g.cellLocks.set(sg.cellLocks);
                g.nextChars.set(sg.nextChars);
                g.nextOverlapChars.set(sg.nextOverlapChars);
                // Copy Secondary Layer
                g.secondaryChars.set(sg.secondaryChars);
                g.secondaryColors.set(sg.secondaryColors);
                g.secondaryAlphas.set(sg.secondaryAlphas);
                g.secondaryGlows.set(sg.secondaryGlows);
                g.secondaryFontIndices.set(sg.secondaryFontIndices);
                // Copy Mix State
                g.mix.set(sg.mix);
                // 2. Commit Active Indices
                if (sg.activeIndices.size > 0) {
                    g.activeIndices.clear();
                    for (const idx of sg.activeIndices) {
                        g.activeIndices.add(idx);
                    }
                }
                // 3. Commit Complex Objects
                g.complexStyles.clear();
                for (const [key, value] of sg.complexStyles) {
                    g.complexStyles.set(key, {...value});
                }
                // 4. SWAP STREAM MANAGER STATE
                if (window.matrix && window.matrix.simulation) {
                    const mainSim = window.matrix.simulation;
                    const shadowMgr = this.shadowSim.streamManager;
                    const streamMap = new Map();
                    const serializedStreams = shadowMgr.activeStreams.map(s => {
                        const copy = {...s};
                        if (copy.holes instanceof Set) copy.holes = Array.from(copy.holes);
                        streamMap.set(s, copy);
                        return copy;
                    });
                    const serializeRefArray = (arr) => arr.map(s => (s && streamMap.has(s)) ? streamMap.get(s) : null);
                    const state = {
                        activeStreams: serializedStreams, 
                        columnSpeeds: shadowMgr.columnSpeeds,
                        streamsPerColumn: shadowMgr.streamsPerColumn,   
                        lastStreamInColumn: serializeRefArray(shadowMgr.lastStreamInColumn),
                        lastEraserInColumn: serializeRefArray(shadowMgr.lastEraserInColumn),
                        lastUpwardTracerInColumn: serializeRefArray(shadowMgr.lastUpwardTracerInColumn),
                        nextSpawnFrame: shadowMgr.nextSpawnFrame,
                        overlapInitialized: this.shadowSim.overlapInitialized,
                        _lastOverlapDensity: this.shadowSim._lastOverlapDensity,
                        activeIndices: Array.from(sg.activeIndices)
                    };
                    const frameOffset = mainSim.frame || 0; 
                    state.nextSpawnFrame = frameOffset + (state.nextSpawnFrame - this.localFrame);
                    if (mainSim.useWorker && mainSim.worker) {
                        mainSim.worker.postMessage({ type: 'replace_state', state: state });
                        mainSim.worker.postMessage({ type: 'config', config: { state: JSON.parse(JSON.stringify(this.c.state)), derived: this.c.derived } });
                    } else {
                        state.activeStreams.forEach(s => { if (Array.isArray(s.holes)) s.holes = new Set(s.holes); });
                        const mainMgr = mainSim.streamManager;
                        mainMgr.activeStreams = state.activeStreams;
                        mainMgr.columnSpeeds.set(state.columnSpeeds);
                        mainMgr.streamsPerColumn.set(state.streamsPerColumn);
                        mainMgr.lastStreamInColumn = state.lastStreamInColumn;
                        mainMgr.lastEraserInColumn = state.lastEraserInColumn;
                        mainMgr.lastUpwardTracerInColumn = state.lastUpwardTracerInColumn;
                        mainMgr.nextSpawnFrame = state.nextSpawnFrame;
                        mainSim.overlapInitialized = state.overlapInitialized;
                        mainSim._lastOverlapDensity = state._lastOverlapDensity;
                        if (state.activeIndices) {
                            mainSim.grid.activeIndices.clear();
                            state.activeIndices.forEach(idx => mainSim.grid.activeIndices.add(idx));
                        }
                    }
                }
            }
            // 5. End Expansion Phase
            this.resetExpansion(); // Stops expanding, keeps active for flashes
            this.g.clearAllOverrides(); // Clear overrides (except what updateFlashes restores)
            this._updateFlashes(); // Re-apply flashes on the NEW grid state to prevent 1-frame snap
            this.shadowGrid = null;
            this.shadowSim = null;
        } catch (e) {
            console.error("[QuantizedPulse] Swap failed:", e);
            this.g.clearAllOverrides();
            this.stop();
        }
    }
    _addBlock(x, y, burstId = 0) {
        // Prevent duplicate adds
        if (this._isOccupied(x, y)) return;
        this.blocks.push({x, y});
        // Update Map: Set Occupied (Bit 0) and BurstID (Bits 2-15)
        const mx = x + this.mapPad;
        const my = y + this.mapPad;
        if (mx >= 0 && my >= 0 && mx < this.mapCols && my < this.mapRows) {
            const idx = my * this.mapCols + mx;
            this.map[idx] = (this.map[idx] & ~2) | 1 | (burstId << 2);
            // REVEAL: Set Override Active (Show New World) - On-screen only
            if (x >= -4 && y >= -4 && x < this.g.cols && y < this.g.rows) {
                const centerX = this.g.cols / 2;
                const centerY = this.g.rows / 2;
                const maxDist = Math.sqrt(centerX*centerX + centerY*centerY);
                // Calculate Scale for this block (center of 4x4)
                const bx = x + 2;
                const by = y + 2;
                const dx = bx - centerX;
                const dy = by - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                let scale = Math.max(0, 1.0 - (dist / maxDist));
                scale = Math.pow(scale, 1.5);
                const bs = 4;
                for(let by=0; by<bs; by++) {
                    for(let bx=0; bx<bs; bx++) {
                         const gx = x + bx;
                         const gy = y + by;
                         if (gx >= 0 && gy >= 0 && gx < this.g.cols && gy < this.g.rows) {
                             const cellIdx = gy * this.g.cols + gx;
                             // Enable CHAR override (Mode 3 = FULL, allows overrideMix)
                             this.g.overrideActive[cellIdx] = 3; 
                             // Sync Mix State (Glimmer/Rotator) for the Reveal
                             if (this.shadowGrid) {
                                 this.g.overrideMix[cellIdx] = this.shadowGrid.mix[cellIdx];
                             }
                             // Initial Flash
                             this.flashIntensity[cellIdx] = 1.0 * scale;
                             this.activeFlashes.add(cellIdx);
                         }
                    }
                }
            }
        }
        // --- NEW: Active Spawn Logic ---
        // As the pulse expands, randomly spawn tracers in the revealed area.
        // This ensures the effect doesn't just reveal empty space.
        if (this.shadowSim && this.shadowSim.streamManager) {
            const sm = this.shadowSim.streamManager;
            // 30% chance to spawn a tracer in this new block
            if (Math.random() < 0.3) {
                // Pick random position within the 4x4 block
                const spawnX = x + Math.floor(Math.random() * 4);
                const spawnY = y + Math.floor(Math.random() * 4);
                if (spawnX >= 0 && spawnX < this.shadowGrid.cols && 
                    spawnY >= 0 && spawnY < this.shadowGrid.rows) {
                    // Only spawn if column isn't already too busy at this height?
                    // Actually, force spawn is what we want to ensure visibility.
                    const stream = sm._initializeStream(spawnX, false, this.c.state);
                    stream.y = spawnY;
                    stream.age = spawnY; // Match age to position
                    sm.addActiveStream(stream);
                }
            }
        }
        const bs = 4;
        const neighbors = [
            {x: x, y: y - bs, side: 0}, // Top
            {x: x + bs, y: y, side: 1}, // Right
            {x: x, y: y + bs, side: 2}, // Bottom
            {x: x - bs, y: y, side: 3}  // Left
        ];
        for (const pn of neighbors) {
            // Check if neighbor exists and is occupied
            if (this._isOccupied(pn.x, pn.y)) {
                // Determine if this is a "merged" neighbor (same burst) or "boundary" neighbor (old burst)
                let isSameBurst = false;
                const nmx = pn.x + this.mapPad;
                const nmy = pn.y + this.mapPad;
                if (nmx >= 0 && nmy >= 0 && nmx < this.mapCols && nmy < this.mapRows) {
                     const nbVal = this.map[nmy * this.mapCols + nmx];
                     const nbBurst = nbVal >> 2;
                     if (burstId > 0 && nbBurst === burstId) isSameBurst = true;
                }
                // If different bursts (or one is start/old), draw a boundary line
                if (!isSameBurst) {
                    let lx, ly, lw, lh;
                    if (pn.side === 0) { lx = x; ly = y; lw = bs; lh = 0; }      // Top Edge
                    else if (pn.side === 1) { lx = x + bs; ly = y; lw = 0; lh = bs; } // Right Edge
                    else if (pn.side === 2) { lx = x; ly = y + bs; lw = bs; lh = 0; } // Bottom Edge
                    else if (pn.side === 3) { lx = x; ly = y; lw = 0; lh = bs; }      // Left Edge
                    const s = this._getEffectiveState();
                    const persistence = s.fadeFrames > 0 ? (10 + Math.random() * 10) : 10;
                    this.lines.push({
                        x: lx, y: ly, w: lw, h: lh, 
                        alpha: 1.0, 
                        persistence: persistence, 
                        isNew: true 
                    });
                }
            } else {
                // Neighbor is empty -> Add to frontier
                const nmx = pn.x + this.mapPad;
                const nmy = pn.y + this.mapPad;
                if (nmx >= 0 && nmy >= 0 && nmx < this.mapCols && nmy < this.mapRows) {
                    const pIdx = nmy * this.mapCols + nmx;
                    // If not occupied (Bit 0) and not already frontier (Bit 1)
                    if ((this.map[pIdx] & 3) === 0) {
                        this.frontier.push({x: pn.x, y: pn.y});
                        this.map[pIdx] |= 2; // Set Frontier Bit
                    }
                }
            }
        }
    }
    _isOccupied(x, y) {
        const mx = x + this.mapPad;
        const my = y + this.mapPad;
        if (mx < 0 || my < 0 || mx >= this.mapCols || my >= this.mapRows) return false;
        return (this.map[my * this.mapCols + mx] & 1) !== 0;
    }
    _applyMask() {
        // Re-apply override flags for ALL active blocks
        // This is necessary because EffectRegistry clears overrides every frame.
        const bs = 4;
        const g = this.g;
        const sg = this.shadowGrid;
        for (const b of this.blocks) {
            for(let by=0; by<bs; by++) {
                const gy = b.y + by;
                if (gy >= this.g.rows) continue;
                const rowOffset = gy * this.g.cols;
                for(let bx=0; bx<bs; bx++) {
                     const gx = b.x + bx;
                     if (gx < this.g.cols) {
                         const idx = rowOffset + gx;
                         g.overrideActive[idx] = 3; 
                         // Sync Mix State (Glimmer/Rotator) for the Reveal
                         // This allows the New World to show advanced visual states
                         if (sg) {
                             g.overrideMix[idx] = sg.mix[idx];
                         }
                     }
                }
            }
        }
    }
    update() {
        if (!this.active) return;
        // 1. Expansion Logic (If active)
        if (this.isExpanding) {
            this.localFrame++;
            const s = this._getEffectiveState();
            // Run Shadow Sim & Update Overrides
            this._updateShadowWorld();
            this._applyMask();
            this._updateBorderIllumination(); // CONTINUOUS BORDER ILLUMINATION
            // Handle Fade In
            if (this.fadeInAlpha < 1.0) {
                this.fadeInAlpha += 1.0 / Math.max(1, s.fadeInFrames);
                if (this.fadeInAlpha > 1.0) this.fadeInAlpha = 1.0;
            }
            // Time-Based Expansion Control
            const elapsed = Date.now() - this.startTime;
            const durationMs = s.duration * 1000; 
            // 1. Hard Time Limit (Duration + 1s buffer)
            if (elapsed > durationMs + 1000) {
                this._finishExpansion();
                // Continue to update flashes even after finish
            }
            // 2. Off-Screen Check (Optimization)
            else if (this.localFrame % 10 === 0 && this.frontier.length > 0) {
                let allOffScreen = true;
                const b = 4;
                const minX = -b, maxX = this.g.cols + b;
                const minY = -b, maxY = this.g.rows + b;
                for (const f of this.frontier) {
                    if (f.x >= minX && f.x < maxX && f.y >= minY && f.y < maxY) {
                        allOffScreen = false;
                        break;
                    }
                }
                if (allOffScreen) {
                    this._finishExpansion();
                    // Continue to update flashes
                }
            }
            if (this.isExpanding) {
                // --- SEQUENCED GROWTH LOGIC ---
                if (this.growthPhase === 0) {
                    // Initial Center Quad (Done in trigger)
                    this.growthPhase = 1;
                    this.nextExpandTime = this.localFrame + 10;
                }
                else if (this.growthPhase === 1) {
                    // Phase 1: N, S, E, W
                    if (this.localFrame >= this.nextExpandTime) {
                        const offsets = [{x:0, y:-4}, {x:0, y:4}, {x:-4, y:0}, {x:4, y:0}];
                        for (const o of offsets) {
                            this._addBlock(this.origin.x + o.x, this.origin.y + o.y, this.burstCounter);
                        }
                        this.growthPhase = 2;
                        this.nextExpandTime = this.localFrame + 10;
                    }
                }
                else if (this.growthPhase === 2) {
                    // Phase 2: N, S (Extended)
                    if (this.localFrame >= this.nextExpandTime) {
                        const offsets = [{x:0, y:-8}, {x:0, y:8}];
                        for (const o of offsets) {
                            this._addBlock(this.origin.x + o.x, this.origin.y + o.y, this.burstCounter);
                        }
                        this.growthPhase = 3;
                    }
                }
                else {
                    // Phase 3: Standard Expansion
                    const progress = Math.min(1.0, elapsed / durationMs);
                    const totalVisibleBlocks = (this.g.cols * this.g.rows) / 16; 
                    const exponent = Math.max(1.0, 3.0 - (10 / 10)); 
                    const targetBlocks = Math.floor((totalVisibleBlocks * 1.5) * Math.pow(progress, exponent));
                    let needed = targetBlocks - this.blocksAdded;
                    // Dynamic Tendril Frequency: Slower duration = Slower tendrils
                    // Example: 2s -> every 4 frames. 10s -> every 20 frames.
                    const tendrilFreq = Math.max(2, Math.floor(s.duration * 2));
                    if (needed > 0 && this.localFrame % tendrilFreq === 0) {
                        this._updateTendrils(s);
                    }
                    if (this.localFrame % 3 === 0) {
                        if (needed > 0 || (this.blocksAdded < 10 && this.frontier.length > 0)) {
                             const burstCap = 600;
                             let burst = Math.min(needed, burstCap);
                             if (burst < 1) burst = 1;
                             this._updateExpansionBurst(burst);
                        }
                    }
                }
                this._updateLines(s);
            }
        }
        // 2. Process Flashes (ALWAYS run this, regardless of expansion state)
        // This ensures flashes decay properly after the swap/finish
        this._updateFlashes();
        // 3. Check for Full Completion
        // Stop ONLY if not expanding AND no active flashes
        if (!this.isExpanding && this.activeFlashes.size === 0) {
            this.stop(); 
        }
    }
    _updateBorderIllumination() {
        const bs = 4;
        const centerX = this.g.cols / 2;
        const centerY = this.g.rows / 2;
        // Max distance is corner to center
        const maxDist = Math.sqrt(centerX*centerX + centerY*centerY);
        // Iterate only over lines (The visual border)
        for (const l of this.lines) {
            if (!l.isNew) continue; // Skip old/green lines
            // Calculate scale based on distance from center
            // 1.0 at center, 0.0 at edge
            const dx = (l.x + (l.w > 0 ? l.w/2 : 0)) - centerX;
            const dy = (l.y + (l.h > 0 ? l.h/2 : 0)) - centerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            // Smooth falloff: (1 - dist/max)^1.5
            let scale = Math.max(0, 1.0 - (dist / maxDist));
            scale = Math.pow(scale, 1.5); // Quadratic-ish falloff
            let isHorizontal = (l.w > 0);
            if (isHorizontal) {
                const isTopOccupied = this._isOccupied(l.x, l.y - 4);
                const isBottomOccupied = this._isOccupied(l.x, l.y);
                if (isTopOccupied && !isBottomOccupied) {
                    this._illuminateSpan(l.x, l.y - 1, 4, 1, scale);
                }
                else if (isBottomOccupied && !isTopOccupied) {
                    this._illuminateSpan(l.x, l.y, 4, 1, scale);
                }
            } else {
                const isLeftOccupied = this._isOccupied(l.x - 4, l.y);
                const isRightOccupied = this._isOccupied(l.x, l.y);
                if (isLeftOccupied && !isRightOccupied) {
                    this._illuminateSpan(l.x - 1, l.y, 1, 4, scale);
                }
                else if (isRightOccupied && !isLeftOccupied) {
                    this._illuminateSpan(l.x, l.y, 1, 4, scale);
                }
            }
        }
    }
    _illuminateSpan(x, y, w, h, scale = 1.0) {
        // Illuminate a strip of pixels (w x h)
        // Check if they are valid AND contain a character in the New World (ShadowGrid)
        // If so, boost flash.
        if (!this.shadowGrid) return;
        for(let py = y; py < y + h; py++) {
            if (py < 0 || py >= this.g.rows) continue;
            for(let px = x; px < x + w; px++) {
                if (px < 0 || px >= this.g.cols) continue;
                const idx = py * this.g.cols + px;
                // Check if Shadow Grid has a character here (New World Stream)
                if (this.shadowGrid.chars[idx] !== 0) {
                     // Found a stream char!
                     // Sustain the flash
                     this.flashIntensity[idx] = 1.0 * scale; 
                     this.activeFlashes.add(idx);
                }
            }
        }
    }
    _updateTendrils(s) {
        // Limit attempts per frame
        const attempts = 6; 
        const maxSearch = 3; // Search up to 4 spots
        const maxBlind = 3;  
        for (let i = 0; i < attempts; i++) {
            if (this.frontier.length === 0) break;
            // Pick random frontier block
            const idx = Math.floor(Math.random() * this.frontier.length);
            const f = this.frontier[idx];
            // Pick ONE random direction to extend (Orthogonal/Edge only)
            const dirs = [{x:0, y:-4}, {x:4, y:0}, {x:0, y:4}, {x:-4, y:0}];
            const d = dirs[Math.floor(Math.random() * dirs.length)];
            // 1. Scan Phase (Look Ahead)
            let limit = 0;
            let foundTarget = false;
            for (let k = 0; k < maxSearch; k++) {
                const tx = f.x + (d.x * k);
                const ty = f.y + (d.y * k);
                // If blocked by existing pulse block, stop scanning
                if (this._isOccupied(tx, ty)) break;
                limit++;
                // Check for Code (Target)
                if (this._hasCode(tx, ty)) {
                    foundTarget = true;
                    break; // Lock on!
                }
            }
            // 2. Constraint Phase
            // If we didn't lock onto code, constrain the extension
            if (!foundTarget) {
                limit = Math.min(limit, maxBlind);
            }
            // 3. Build Phase
            // If limit > 0, we can extend
            if (limit > 0) {
                for (let k = 0; k < limit; k++) {
                    const tx = f.x + (d.x * k);
                    const ty = f.y + (d.y * k);
                    this._addBlock(tx, ty, this.burstCounter);
                }
            }
        }
    }
    _hasCode(x, y) {
        // Check center of the 4x4 block
        const gx = x + 2;
        const gy = y + 2;
        if (gx < 0 || gy < 0 || gx >= this.g.cols || gy >= this.g.rows) return false;
        const idx = this.g.getIndex(gx, gy);
        return (this.g.state && this.g.state[idx] === 1);
    }
    // _hardenTendril removed
    _updateLines(s) {
        for (let i = this.lines.length - 1; i >= 0; i--) {
            if (this.lines[i].persistence > 0) {
                this.lines[i].persistence--;
            } else {
                let speed;
                if (this.lines[i].isNew) {
                    speed = s.lineFadeSpeed; // Use standard fade for yellow lines
                } else {
                    // Use configurable fade for Green lines
                    // If setting is 0, fade is instant (speed = 1.0)
                    const duration = this.c.state.quantizedPulseGreenFadeSeconds !== undefined ? this.c.state.quantizedPulseGreenFadeSeconds : 0.5;
                    speed = (duration <= 0.01) ? 1.0 : (1.0 / (duration * 60));
                }
                this.lines[i].alpha -= speed;
                if (this.lines[i].alpha <= 0) this.lines.splice(i, 1);
            }
        }
    }
    _updateStart(s) {
        const neighbors = [
            {x: this.origin.x, y: this.origin.y - 4},
            {x: this.origin.x + 4, y: this.origin.y},
            {x: this.origin.x, y: this.origin.y + 4},
            {x: this.origin.x - 4, y: this.origin.y}
        ];
        const next = neighbors.find(n => !this._isOccupied(n.x, n.y));
        if (next) {
            this._addBlock(next.x, next.y);
            this.blocksAdded++;
            const fIdx = this.frontier.findIndex(f => f.x === next.x && f.y === next.y);
            if (fIdx !== -1) {
                const f = this.frontier[fIdx];
                const mx = f.x + this.mapPad;
                const my = f.y + this.mapPad;
                if (mx >= 0 && my >= 0 && mx < this.mapCols && my < this.mapRows) {
                    this.map[my * this.mapCols + mx] &= ~2;
                }
                const l = this.frontier.pop();
                if (fIdx < this.frontier.length) {
                    this.frontier[fIdx] = l;
                }
            }
        }
    }
    _updateExpansionBurst(count) {
        // CYCLE START: Merge previous new lines (turn them green)
        const greenDuration = this.c.state.quantizedPulseGreenFadeSeconds !== undefined ? this.c.state.quantizedPulseGreenFadeSeconds : 0.5;
        // Use a loop that allows removal (iterate backwards or filter)
        for (let i = this.lines.length - 1; i >= 0; i--) {
            const l = this.lines[i];
            if (l.isNew) {
                if (greenDuration <= 0.01) {
                    // Immediate removal if fade is 0
                    this.lines.splice(i, 1);
                } else {
                    l.isNew = false;
                    // Start fading immediately (persistence = 0)
                    // The duration is controlled solely by the alpha decay rate
                    l.persistence = 0; 
                    l.alpha = 1.0;
                }
            }
        }
        let burstCount = count;
        // Increment Burst Counter (1..16383)
        this.burstCounter = (this.burstCounter + 1) & 0x3FFF; 
        if (this.burstCounter === 0) this.burstCounter = 1;
        let processed = 0;
        // --- PHASE 1: PRIORITY FILL (Holes / 1x1 Quads) ---
        // Scan frontier for any nodes with >= 3 neighbors. Fill them immediately.
        for (let i = this.frontier.length - 1; i >= 0; i--) {
            if (processed >= burstCount) break;
            const f = this.frontier[i];
            // Validation
            const mx = f.x + this.mapPad;
            const my = f.y + this.mapPad;
            if (mx < 0 || my < 0 || mx >= this.mapCols || my >= this.mapRows) {
                const last = this.frontier.pop();
                if (i < this.frontier.length) this.frontier[i] = last;
                continue;
            }
            const val = this.map[my * this.mapCols + mx];
            if ((val & 1) !== 0 || (val & 2) === 0) {
                 const last = this.frontier.pop();
                 if (i < this.frontier.length) this.frontier[i] = last;
                 continue;
            }
            // Check Neighbors
            let neighbors = 0;
            if (this._isOccupied(f.x, f.y - 4)) neighbors++;
            if (this._isOccupied(f.x + 4, f.y)) neighbors++;
            if (this._isOccupied(f.x, f.y + 4)) neighbors++;
            if (this._isOccupied(f.x - 4, f.y)) neighbors++;
            // If it's a hole (>=3 neighbors), fill it!
            if (neighbors >= 3) {
                const wmx = f.x + this.mapPad;
                const wmy = f.y + this.mapPad;
                this.map[wmy * this.mapCols + wmx] &= ~2; 
                const last = this.frontier.pop();
                if (i < this.frontier.length) this.frontier[i] = last;
                if (!this._isOccupied(f.x, f.y)) {
                    this._addBlock(f.x, f.y, this.burstCounter);
                    processed++;
                }
            }
        }
        // --- PHASE 2: WEIGHTED EXPANSION ---
        let attempts = 0;
        const maxAttempts = burstCount * 8 + 50; 
        while (processed < burstCount && this.frontier.length > 0 && attempts < maxAttempts) {
            attempts++;
            // Standard expansion (K=10 is sufficient as holes are handled)
            const K = 10; 
            let bestIdx = -1;
            let bestWeight = -1;
            for (let k = 0; k < K; k++) {
                const idx = Math.floor(Math.random() * this.frontier.length);
                const f = this.frontier[idx];
                // Validation
                const mx = f.x + this.mapPad;
                const my = f.y + this.mapPad;
                if (mx >= 0 && my >= 0 && mx < this.mapCols && my < this.mapRows) {
                     const val = this.map[my * this.mapCols + mx];
                     if ((val & 1) !== 0 || (val & 2) === 0) {
                         const last = this.frontier.pop();
                         if (idx < this.frontier.length) {
                             this.frontier[idx] = last;
                             if (bestIdx === this.frontier.length) bestIdx = idx;
                         }
                         k--; 
                         if (this.frontier.length === 0) break;
                         continue;
                     }
                } else {
                    const last = this.frontier.pop();
                     if (idx < this.frontier.length) {
                         this.frontier[idx] = last;
                         if (bestIdx === this.frontier.length) bestIdx = idx;
                     }
                    k--;
                    if (this.frontier.length === 0) break;
                    continue;
                }
                // Calculate Weight (Distance based + Axis Bias)
                // Normalize to Aspect Ratio so we reach edges roughly same time
                const ratio = this.g.cols / Math.max(1, this.g.rows);
                const dx = Math.abs(f.x - this.origin.x);
                const dy = Math.abs(f.y - this.origin.y);
                const scaledDy = dy * ratio;
                // Elliptical Distance
                const dist = Math.sqrt(dx*dx + scaledDy*scaledDy);
                let w = 1.0; 
                w += Math.max(0, 100 - dist);
                // Axis Bias: Normalized (0..1) so it doesn't grow with distance
                // Prevents "runaway" edges where being far out makes you MORE attractive.
                // Multiplier 15.0 gives a constant preference for axes vs diagonal.
                const axisBias = Math.abs(dx - scaledDy) / (dist + 1.0);
                w += axisBias * 15.0; 
                w += Math.random() * 5.0; 
                if (w > bestWeight) {
                    bestWeight = w;
                    bestIdx = idx;
                }
            }
            if (this.frontier.length === 0) break;
            if (bestIdx === -1) continue; 
            const winner = this.frontier[bestIdx];
            // Remove winner from frontier (Bit 1 clear + array removal)
            const wmx = winner.x + this.mapPad;
            const wmy = winner.y + this.mapPad;
            if (wmx >= 0 && wmy >= 0 && wmx < this.mapCols && wmy < this.mapRows) {
                this.map[wmy * this.mapCols + wmx] &= ~2; // Clear Frontier Bit
            }
            const last = this.frontier.pop();
            if (bestIdx < this.frontier.length) {
                this.frontier[bestIdx] = last;
            }
            if (!this._isOccupied(winner.x, winner.y)) {
                this._addBlock(winner.x, winner.y, this.burstCounter);
                processed++;
                // Only do Group Additions if we aren't filling a hole
                // If neighbors >= 3, we likely just plugged a gap, so stop.
                let winnerNeighbors = 0;
                if (this._isOccupied(winner.x, winner.y - 4)) winnerNeighbors++;
                if (this._isOccupied(winner.x + 4, winner.y)) winnerNeighbors++;
                if (this._isOccupied(winner.x, winner.y + 4)) winnerNeighbors++;
                if (this._isOccupied(winner.x - 4, winner.y)) winnerNeighbors++;
                if (winnerNeighbors < 3) {
                    // GROUP ADDITION LOGIC (Weighted for ~66% Groups, ~33% Singles)
                const rand = Math.random();
                // 15% chance for 2x3 or 3x2 (Large Rectangles)
                if (rand < 0.15) {
                     const candidates = [
                        // 2x3 (Vertical)
                        [{x:4,y:0}, {x:0,y:4}, {x:4,y:4}, {x:0,y:8}, {x:4,y:8}],
                        [{x:-4,y:0}, {x:0,y:4}, {x:-4,y:4}, {x:0,y:8}, {x:-4,y:8}],
                        // 3x2 (Horizontal)
                        [{x:4,y:0}, {x:8,y:0}, {x:0,y:4}, {x:4,y:4}, {x:8,y:4}],
                        [{x:4,y:0}, {x:8,y:0}, {x:0,y:-4}, {x:4,y:-4}, {x:8,y:-4}]
                     ];
                     const cluster = candidates[Math.floor(Math.random() * candidates.length)];
                     cluster.forEach(offset => {
                        const tx = winner.x + offset.x;
                        const ty = winner.y + offset.y;
                        if (!this._isOccupied(tx, ty)) {
                            this._addBlock(tx, ty, this.burstCounter);
                            const tmx = tx + this.mapPad;
                            const tmy = ty + this.mapPad;
                            if (tmx >= 0 && tmy >= 0 && tmx < this.mapCols && tmy < this.mapRows) this.map[tmy * this.mapCols + tmx] &= ~2;
                        }
                     });
                }
                // 15% chance for 2x2 (Square)
                else if (rand < 0.30) {
                    const candidates = [
                        [{x:4,y:0}, {x:0,y:4}, {x:4,y:4}],    
                        [{x:-4,y:0}, {x:0,y:4}, {x:-4,y:4}],  
                        [{x:4,y:0}, {x:0,y:-4}, {x:4,y:-4}],  
                        [{x:-4,y:0}, {x:0,y:-4}, {x:-4,y:-4}] 
                    ];
                    const cluster = candidates[Math.floor(Math.random() * candidates.length)];
                    cluster.forEach(offset => {
                        const tx = winner.x + offset.x;
                        const ty = winner.y + offset.y;
                        if (!this._isOccupied(tx, ty)) {
                            this._addBlock(tx, ty, this.burstCounter);
                            const tmx = tx + this.mapPad;
                            const tmy = ty + this.mapPad;
                            if (tmx >= 0 && tmy >= 0 && tmx < this.mapCols && tmy < this.mapRows) this.map[tmy * this.mapCols + tmx] &= ~2;
                        }
                    });
                }
                // 15% chance for 1x3 or 3x1 (Long Strips)
                else if (rand < 0.45) {
                    const candidates = [
                        // 3x1 (Horizontal)
                        [{x:4,y:0}, {x:8,y:0}],      // Right
                        [{x:-4,y:0}, {x:-8,y:0}],    // Left
                        [{x:-4,y:0}, {x:4,y:0}],     // Center
                        // 1x3 (Vertical)
                        [{x:0,y:4}, {x:0,y:8}],      // Down
                        [{x:0,y:-4}, {x:0,y:-8}],    // Up
                        [{x:0,y:-4}, {x:0,y:4}]      // Center
                    ];
                    const cluster = candidates[Math.floor(Math.random() * candidates.length)];
                    cluster.forEach(offset => {
                        const tx = winner.x + offset.x;
                        const ty = winner.y + offset.y;
                        if (!this._isOccupied(tx, ty)) {
                            this._addBlock(tx, ty, this.burstCounter);
                            const tmx = tx + this.mapPad;
                            const tmy = ty + this.mapPad;
                            if (tmx >= 0 && tmy >= 0 && tmx < this.mapCols && tmy < this.mapRows) this.map[tmy * this.mapCols + tmx] &= ~2;
                        }
                    });
                }
                // 35% chance for 1x2 or 2x1 (Small Rects)
                else if (rand < 0.90) {
                    const type = Math.random() < 0.5 ? 'h' : 'v';
                    let extra = null;
                    if (type === 'h') {
                        if (!this._isOccupied(winner.x + 4, winner.y)) extra = {x: winner.x + 4, y: winner.y};
                        else if (!this._isOccupied(winner.x - 4, winner.y)) extra = {x: winner.x - 4, y: winner.y};
                    } 
                    if (!extra) { 
                        if (!this._isOccupied(winner.x, winner.y + 4)) extra = {x: winner.x, y: winner.y + 4};
                        else if (!this._isOccupied(winner.x, winner.y - 4)) extra = {x: winner.x, y: winner.y - 4};
                    }
                    if (extra) {
                        this._addBlock(extra.x, extra.y, this.burstCounter);
                        const emx = extra.x + this.mapPad;
                        const emy = extra.y + this.mapPad;
                        if (emx >= 0 && emy >= 0 && emx < this.mapCols && emy < this.mapRows) this.map[emy * this.mapCols + emx] &= ~2;
                    }
                }
                // Remaining 10%: Single (winner only) - Do nothing extra
            }
        }
    }
    }
    applyToGrid(grid) {
        // No grid overrides
    }
    _updateFlashes() {
        if (this.activeFlashes.size === 0) return;
        const g = this.g;
        const decay = 1.0 / 30.0; // Fade over ~0.5 seconds (double speed)
        const toRemove = [];
        for (const idx of this.activeFlashes) {
            let intensity = this.flashIntensity[idx];
            if (intensity <= 0) {
                toRemove.push(idx);
                continue;
            }
            // Decrease Intensity
            intensity -= decay;
            this.flashIntensity[idx] = intensity;
            if (intensity > 0) {
                // Enable Override for this cell (CHAR mode)
                // This allows the Main Sim's 'mix' (Glimmer/Rotator) to show through 
                // while we override the Color/Glow for the flash.
                // NOTE: If it's already Mode 3 (Pulse Reveal), we KEEP it Mode 3.
                // Mode 3 supports overrides just like Mode 1, but includes mix states.
                if (g.overrideActive[idx] !== 3) {
                     g.overrideActive[idx] = 1; 
                }
                // Apply Flash to Glow (Visual Brightness)
                // This adds brightness in the character's OWN color in the shader
                // Use configurable Border Illumination setting
                const illumination = this.c.state.quantizedPulseBorderIllumination !== undefined ? this.c.state.quantizedPulseBorderIllumination : 4.0;
                g.overrideGlows[idx] += illumination * intensity;
                // Also boost the base color saturation towards its max intensity
                const col = g.overrideColors[idx];
                const r = col & 0xFF;
                const gVal = (col >> 8) & 0xFF;
                const b = (col >> 16) & 0xFF;
                const a = (col >> 24) & 0xFF;
                // Scale up towards 255 without shifting hue to white
                const maxVal = Math.max(r, gVal, b, 1);
                const targetScale = 255 / maxVal;
                const scale = 1.0 + (targetScale - 1.0) * intensity;
                const rNew = Math.min(255, Math.floor(r * scale));
                const gNew = Math.min(255, Math.floor(gVal * scale));
                const bNew = Math.min(255, Math.floor(b * scale));
                g.overrideColors[idx] = (a << 24) | (bNew << 16) | (gNew << 8) | rNew;
            } else {
                toRemove.push(idx);
            }
        }
        for (const idx of toRemove) {
            this.activeFlashes.delete(idx);
            this.flashIntensity[idx] = 0;
        }
    }
    render(ctx, derived) {
        if (!this.active || !this.isExpanding) return;
        const s = this.c.state;
        const cw = derived.cellWidth * s.stretchX;
        const ch = derived.cellHeight * s.stretchY;
        const colorStr = '#FFFF6E';
        const masterAlpha = this.fadeAlpha * this.fadeInAlpha;
        ctx.lineCap = 'butt';
        ctx.lineWidth = Math.max(1, cw * 0.15); 
        ctx.strokeStyle = colorStr;
        ctx.shadowBlur = 25; // Increased illumination
        ctx.shadowColor = colorStr;
        ctx.globalAlpha = masterAlpha;
        // Split paths for different dash patterns
        const hPath = new Path2D();
        const vPath = new Path2D();
        for (const b of this.blocks) {
            const nTop = this._isOccupied(b.x, b.y - 4);
            const nRight = this._isOccupied(b.x + 4, b.y);
            const nBottom = this._isOccupied(b.x, b.y + 4);
            const nLeft = this._isOccupied(b.x - 4, b.y);
            const bx = b.x * cw;
            const by = b.y * ch;
            const bw = 4 * cw;
            const bh = 4 * ch;
            if (!nTop) { hPath.moveTo(bx, by); hPath.lineTo(bx + bw, by); }
            if (!nRight) { vPath.moveTo(bx + bw, by); vPath.lineTo(bx + bw, by + bh); }
            if (!nBottom) { hPath.moveTo(bx, by + bh); hPath.lineTo(bx + bw, by + bh); }
            if (!nLeft) { vPath.moveTo(bx, by); vPath.lineTo(bx, by + bh); }
        }
        // 1. Draw Horizontal (Standard Pattern)
        // [0.5, 0.5, 1.5, 0.5]
        ctx.setLineDash([cw * 0.5, cw * 0.5, cw * 1.5, cw * 0.5]);
        ctx.stroke(hPath);
        // 2. Draw Vertical (Randomized/Small Pattern)
        // [0.2, 0.3, 0.5, 0.3, 1.2, 0.5] - Includes smaller 0.2 bits
        ctx.setLineDash([cw * 0.2, cw * 0.3, cw * 0.5, cw * 0.3, cw * 1.2, cw * 0.5]);
        ctx.stroke(vPath);
        // Render Tendrils
        if (this.tendrils.length > 0) {
            ctx.globalAlpha = 0.5 * masterAlpha;
            ctx.setLineDash([cw * 0.2, cw * 0.2]); 
            ctx.beginPath();
            for (const t of this.tendrils) {
                for (const b of t.path) {
                    const bx = b.x * cw;
                    const by = b.y * ch;
                    const bw = 4 * cw;
                    const bh = 4 * ch;
                    ctx.rect(bx, by, bw, bh);
                }
            }
            ctx.stroke();
            ctx.globalAlpha = masterAlpha;
        }
        ctx.shadowBlur = 0; 
        // Internal Lines (Merge Lines) - Use Code Color (Green)
        ctx.strokeStyle = derived.streamColorStr; // Matrix Green for internal structure
        ctx.setLineDash([cw * 0.25, cw * 0.25, cw * 0.5, cw * 0.25]);
        for (const l of this.lines) {
            let lineAlpha = l.alpha * masterAlpha;
                        // Two-Cycle Logic: New lines are Yellow (Perimeter), Old are Green (Code)
                        if (l.isNew) {
                            ctx.strokeStyle = colorStr; 
                            ctx.shadowBlur = 25;
                            ctx.shadowColor = colorStr; // Match Shadow to Gold
                            // Flicker Logic: 40% chance to dim (More frequent)                // Range: 0.1 to 0.6 (More noticeable dimming)
                if (Math.random() < 0.4) {
                    lineAlpha *= (0.1 + Math.random() * 0.5);
                }
            } else {
                // Use Primary Stream Color for solidified lines
                const col = derived.streamColorStr;
                ctx.strokeStyle = col; 
                ctx.shadowColor = col; 
            }
            ctx.globalAlpha = lineAlpha;
            ctx.beginPath();
            const lx = l.x * cw;
            const ly = l.y * ch;
            const lPxW = l.w * cw;
            const lPxH = l.h * ch;
            ctx.moveTo(lx, ly);
            ctx.lineTo(lx + lPxW, ly + lPxH);
            ctx.stroke();
        }
        ctx.setLineDash([]); 
        ctx.globalAlpha = 1.0; 
        ctx.shadowBlur = 0;
    }
}
// --- QuantizedRetractEffect.js ---
class QuantizedRetractEffect extends AbstractEffect {
    constructor(grid, config) {
        super(grid, config);
        this.name = "QuantizedRetract";
        this.active = false;
        // Simulation State
        this.blocks = [];      // {x, y}
        this.lines = [];       // {x, y, w, h, alpha, persistence}
        this.frontier = [];    // {x, y}
        // Bitmask Map: Bit 0 = Occupied, Bit 1 = Frontier, Bits 2-15 = BurstID
        this.map = null;       // Uint16Array
        this.mapCols = 0;
        this.burstCounter = 0;
        this.blocksAdded = 0;
        this.tendrils = [];    // [{x,y}, {x,y}...]
        // Timing
        this.nextExpandTime = 0;
        this.currentDelay = 0;
        this.blockSize = 4;
        this.timeoutId = null;
        // Fade State
        this.isFading = false;
        this.fadeAlpha = 1.0;
        this.fadeInAlpha = 0.0;
        this.isExpanding = false; 
        // Flash State
        this.flashIntensity = null; 
        this.activeFlashes = new Set();
    }
    _getEffectiveState() {
        const s = this.c.state;
        const fadeFrames = s.quantizedPulseFadeFrames !== undefined ? s.quantizedPulseFadeFrames : 15;
        const fadeInFrames = s.quantizedPulseFadeInFrames !== undefined ? s.quantizedPulseFadeInFrames : 5;
        // If fadeFrames is 0 (Off), fade is instant (speed 1.0)
        const lineSpeed = fadeFrames > 0 ? (1.0 / fadeFrames) : 1.0;
        // Reuse Pulse Settings where appropriate, but maybe add specific overrides later
        return {
            enabled: s.quantizedPulseEnabled, // Reuse toggle for now
            freq: s.quantizedPulseFrequencySeconds,
            duration: s.quantizedPulseDurationSeconds || 2.0,
            fadeFrames: fadeFrames,
            fadeInFrames: fadeInFrames,
            baseDelay: 1.0,     
            minDelay: 0.5,      
            blockSize: 4,
            lineFadeSpeed: lineSpeed 
        };
    }
    stop() {
        this.active = false;
        this.isFading = false;
        this.fadeAlpha = 1.0;
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        if (this.map) this.map.fill(0);
        this.activeFlashes.clear();
        if (this.flashIntensity) this.flashIntensity.fill(0);
        this.g.clearAllOverrides();
    }
    resetExpansion() {
        this.isExpanding = false;
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        if (this.map) this.map.fill(0);
    }
    trigger() {
        if (this.isExpanding) this.resetExpansion();
        this.active = true;
        this.isExpanding = true;
        this.isFading = false;
        this.fadeAlpha = 1.0;
        this.startTime = Date.now();
        const s = this._getEffectiveState();
        this.fadeInAlpha = (s.fadeInFrames > 0) ? 0.0 : 1.0;
        // INIT SHADOW WORLD
        this._initShadowWorld();
        this.timeoutId = setTimeout(() => {
            this._finishExpansion(); // Force finish
        }, 60000); 
        // Resize map
        this.mapPad = 60; 
        this.mapCols = this.g.cols + this.mapPad * 2;
        this.mapRows = this.g.rows + this.mapPad * 2;
        const total = this.mapCols * this.mapRows;
        if (!this.map || this.map.length !== total) {
            this.map = new Uint16Array(total);
        } else {
            this.map.fill(0);
        }
        const totalGrid = this.g.cols * this.g.rows;
        if (!this.flashIntensity || this.flashIntensity.length !== totalGrid) {
            this.flashIntensity = new Float32Array(totalGrid);
            this.activeFlashes.clear();
        }
        this.burstCounter = 0;
        this.blocks = [];
        this.lines = [];
        this.frontier = [];
        this.tendrils = [];
        this.blocksAdded = 0;
        this.localFrame = 0;
        // INITIALIZATION: Start from Edges
        this._initEdges();
        this.currentDelay = s.baseDelay;
        this.nextExpandTime = this.currentDelay;
        return true;
    }
    _initEdges() {
        const bs = 4;
        const cols = this.g.cols;
        const rows = this.g.rows;
        // Add blocks along the perimeter, aligned to 4x4 grid
        const startX = Math.floor((cols / 2) / 4) * 4;
        const startY = Math.floor((rows / 2) / 4) * 4;
        // Not center, but edges. We align to 4x4 relative to 0,0 usually.
        // Top & Bottom
        for (let x = -4; x < cols + 4; x += 4) {
            this._addBlock(x, -4); // Just off-screen top
            this._addBlock(x, rows); // Just off-screen bottom
        }
        // Left & Right (exclude corners already added)
        for (let y = 0; y < rows; y += 4) {
            this._addBlock(-4, y); // Left
            this._addBlock(cols, y); // Right
        }
        this.blocksAdded = this.blocks.length;
    }
    _initShadowWorld() {
        // Reuse same logic as Pulse
        this.shadowGrid = new CellGrid(this.c);
        const d = this.c.derived;
        const w = this.g.cols * d.cellWidth;
        const h = this.g.rows * d.cellHeight;
        this.shadowGrid.resize(w, h);
        this.shadowSim = new SimulationSystem(this.shadowGrid, this.c);
        this.shadowSim.useWorker = false;
        if (this.shadowSim.worker) {
            this.shadowSim.worker.terminate();
            this.shadowSim.worker = null;
        }
        this.shadowSim.timeScale = 1.0;
        const s = this.c.state;
        const avgSpeed = Math.max(1, 21 - (s.streamSpeed || 10)); 
        const framesNeeded = Math.ceil(this.g.rows * avgSpeed * 1.5);
        const warmupFrames = Math.max(400, Math.min(3000, framesNeeded));
        for (let i = 0; i < warmupFrames; i++) {
            this.shadowSim.update(i);
        }
        this.localFrame = warmupFrames;
    }
    _updateShadowWorld() {
        if (!this.shadowSim || !this.shadowGrid) return;
        this.localFrame++;
        this.shadowSim.update(this.localFrame);
        // Copy Overrides (Same as Pulse)
        const g = this.g;
        const sg = this.shadowGrid;
        g.overrideChars.set(sg.chars);
        g.overrideColors.set(sg.colors);
        g.overrideAlphas.set(sg.alphas);
        g.overrideGlows.set(sg.glows);
        g.overrideNextChars.set(sg.nextChars);
    }
    _finishExpansion() {
        try {
            const g = this.g;
            const sg = this.shadowGrid;
            if (sg) {
                // Commit Buffer State (Same as Pulse)
                g.state.set(sg.state); 
                g.chars.set(sg.chars);
                g.colors.set(sg.colors);
                g.baseColors.set(sg.baseColors); 
                g.alphas.set(sg.alphas);
                g.glows.set(sg.glows);
                g.fontIndices.set(sg.fontIndices);
                g.renderMode.set(sg.renderMode); 
                g.types.set(sg.types);
                g.decays.set(sg.decays);
                g.ages.set(sg.ages);
                g.brightness.set(sg.brightness);
                g.rotatorOffsets.set(sg.rotatorOffsets);
                g.cellLocks.set(sg.cellLocks);
                g.nextChars.set(sg.nextChars);
                g.nextOverlapChars.set(sg.nextOverlapChars);
                g.secondaryChars.set(sg.secondaryChars);
                g.secondaryColors.set(sg.secondaryColors);
                g.secondaryAlphas.set(sg.secondaryAlphas);
                g.secondaryGlows.set(sg.secondaryGlows);
                g.secondaryFontIndices.set(sg.secondaryFontIndices);
                g.mix.set(sg.mix);
                if (sg.activeIndices.size > 0) {
                    g.activeIndices.clear();
                    for (const idx of sg.activeIndices) {
                        g.activeIndices.add(idx);
                    }
                }
                g.complexStyles.clear();
                for (const [key, value] of sg.complexStyles) {
                    g.complexStyles.set(key, {...value});
                }
                // Swap Stream Manager
                if (window.matrix && window.matrix.simulation) {
                    const mainSim = window.matrix.simulation;
                    const shadowMgr = this.shadowSim.streamManager;
                    const streamMap = new Map();
                    const serializedStreams = shadowMgr.activeStreams.map(s => {
                        const copy = {...s};
                        if (copy.holes instanceof Set) copy.holes = Array.from(copy.holes);
                        streamMap.set(s, copy);
                        return copy;
                    });
                    const serializeRefArray = (arr) => arr.map(s => (s && streamMap.has(s)) ? streamMap.get(s) : null);
                    const state = {
                        activeStreams: serializedStreams, 
                        columnSpeeds: shadowMgr.columnSpeeds,   
                        lastStreamInColumn: serializeRefArray(shadowMgr.lastStreamInColumn),
                        lastEraserInColumn: serializeRefArray(shadowMgr.lastEraserInColumn),
                        lastUpwardTracerInColumn: serializeRefArray(shadowMgr.lastUpwardTracerInColumn),
                        nextSpawnFrame: shadowMgr.nextSpawnFrame,
                        overlapInitialized: this.shadowSim.overlapInitialized,
                        _lastOverlapDensity: this.shadowSim._lastOverlapDensity,
                        activeIndices: Array.from(sg.activeIndices)
                    };
                    const frameOffset = mainSim.frame || 0; 
                    state.nextSpawnFrame = frameOffset + (state.nextSpawnFrame - this.localFrame);
                    if (mainSim.useWorker && mainSim.worker) {
                        mainSim.worker.postMessage({ type: 'replace_state', state: state });
                        mainSim.worker.postMessage({ type: 'config', config: { state: JSON.parse(JSON.stringify(this.c.state)), derived: this.c.derived } });
                    } else {
                        state.activeStreams.forEach(s => { if (Array.isArray(s.holes)) s.holes = new Set(s.holes); });
                        const mainMgr = mainSim.streamManager;
                        mainMgr.activeStreams = state.activeStreams;
                        mainMgr.columnSpeeds.set(state.columnSpeeds);
                        mainMgr.lastStreamInColumn = state.lastStreamInColumn;
                        mainMgr.lastEraserInColumn = state.lastEraserInColumn;
                        mainMgr.lastUpwardTracerInColumn = state.lastUpwardTracerInColumn;
                        mainMgr.nextSpawnFrame = state.nextSpawnFrame;
                        mainSim.overlapInitialized = state.overlapInitialized;
                        mainSim._lastOverlapDensity = state._lastOverlapDensity;
                        if (state.activeIndices) {
                            mainSim.grid.activeIndices.clear();
                            state.activeIndices.forEach(idx => mainSim.grid.activeIndices.add(idx));
                        }
                    }
                }
            }
            this.resetExpansion(); 
            this.g.clearAllOverrides(); 
            this._updateFlashes(); 
            this.shadowGrid = null;
            this.shadowSim = null;
        } catch (e) {
            console.error("[QuantizedRetract] Swap failed:", e);
            this.g.clearAllOverrides();
            this.stop();
        }
    }
    _addBlock(x, y, burstId = 0) {
        if (this._isOccupied(x, y)) return;
        this.blocks.push({x, y});
        const mx = x + this.mapPad;
        const my = y + this.mapPad;
        if (mx >= 0 && my >= 0 && mx < this.mapCols && my < this.mapRows) {
            const idx = my * this.mapCols + mx;
            this.map[idx] = (this.map[idx] & ~2) | 1 | (burstId << 2);
            // Retract Reveal Scale:
            // 1.0 at Edge, 0.0 at Center? 
            // Pulse was 1.0 at center, 0.0 at edge.
            // For Retract, we want intensity highest at the leading edge (inner edge).
            // But visually, maintaining standard intensity is fine.
            // On-Screen Check
            if (x >= -4 && y >= -4 && x < this.g.cols && y < this.g.rows) {
                // Calculate distance from center
                const centerX = this.g.cols / 2;
                const centerY = this.g.rows / 2;
                const maxDist = Math.sqrt(centerX*centerX + centerY*centerY);
                const bx = x + 2;
                const by = y + 2;
                const dx = bx - centerX;
                const dy = by - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                // Scale increases as we get closer to center? Or stays high?
                // Let's keep it similar to Pulse: Brighter near origin?
                // Origin here is "Everywhere outside".
                // Let's just use dist/maxDist (1.0 at edge, 0.0 at center)
                let scale = (dist / maxDist);
                scale = Math.pow(scale, 0.5); // Bias towards 1.0
                const bs = 4;
                for(let by=0; by<bs; by++) {
                    for(let bx=0; bx<bs; bx++) {
                         const gx = x + bx;
                         const gy = y + by;
                         if (gx >= 0 && gy >= 0 && gx < this.g.cols && gy < this.g.rows) {
                             const cellIdx = gy * this.g.cols + gx;
                             this.g.overrideActive[cellIdx] = 3; 
                             if (this.shadowGrid) {
                                 this.g.overrideMix[cellIdx] = this.shadowGrid.mix[cellIdx];
                             }
                             this.flashIntensity[cellIdx] = 1.0 * scale;
                             this.activeFlashes.add(cellIdx);
                         }
                    }
                }
            }
        }
        const bs = 4;
        const neighbors = [
            {x: x, y: y - bs, side: 0}, 
            {x: x + bs, y: y, side: 1}, 
            {x: x, y: y + bs, side: 2}, 
            {x: x - bs, y: y, side: 3}  
        ];
        for (const pn of neighbors) {
            if (this._isOccupied(pn.x, pn.y)) {
                let isSameBurst = false;
                const nmx = pn.x + this.mapPad;
                const nmy = pn.y + this.mapPad;
                if (nmx >= 0 && nmy >= 0 && nmx < this.mapCols && nmy < this.mapRows) {
                     const nbVal = this.map[nmy * this.mapCols + nmx];
                     const nbBurst = nbVal >> 2;
                     if (burstId > 0 && nbBurst === burstId) isSameBurst = true;
                }
                if (!isSameBurst) {
                    let lx, ly, lw, lh;
                    if (pn.side === 0) { lx = x; ly = y; lw = bs; lh = 0; }     
                    else if (pn.side === 1) { lx = x + bs; ly = y; lw = 0; lh = bs; } 
                    else if (pn.side === 2) { lx = x; ly = y + bs; lw = bs; lh = 0; } 
                    else if (pn.side === 3) { lx = x; ly = y; lw = 0; lh = bs; }      
                    const s = this._getEffectiveState();
                    const persistence = s.fadeFrames > 0 ? (10 + Math.random() * 10) : 10;
                    this.lines.push({
                        x: lx, y: ly, w: lw, h: lh, 
                        alpha: 1.0, 
                        persistence: persistence, 
                        isNew: true 
                    });
                }
            } else {
                const nmx = pn.x + this.mapPad;
                const nmy = pn.y + this.mapPad;
                if (nmx >= 0 && nmy >= 0 && nmx < this.mapCols && nmy < this.mapRows) {
                    const pIdx = nmy * this.mapCols + nmx;
                    if ((this.map[pIdx] & 3) === 0) {
                        this.frontier.push({x: pn.x, y: pn.y});
                        this.map[pIdx] |= 2; 
                    }
                }
            }
        }
    }
    _isOccupied(x, y) {
        const mx = x + this.mapPad;
        const my = y + this.mapPad;
        if (mx < 0 || my < 0 || mx >= this.mapCols || my >= this.mapRows) return false;
        return (this.map[my * this.mapCols + mx] & 1) !== 0;
    }
    _applyMask() {
        const bs = 4;
        const g = this.g;
        const sg = this.shadowGrid;
        for (const b of this.blocks) {
            for(let by=0; by<bs; by++) {
                const gy = b.y + by;
                if (gy >= this.g.rows) continue;
                const rowOffset = gy * this.g.cols;
                for(let bx=0; bx<bs; bx++) {
                     const gx = b.x + bx;
                     if (gx < this.g.cols) {
                         const idx = rowOffset + gx;
                         g.overrideActive[idx] = 3; 
                         if (sg) {
                             g.overrideMix[idx] = sg.mix[idx];
                         }
                     }
                }
            }
        }
    }
    update() {
        if (!this.active) return;
        if (this.isExpanding) {
            this.localFrame++;
            const s = this._getEffectiveState();
            this._updateShadowWorld();
            this._applyMask();
            this._updateBorderIllumination(); 
            if (this.fadeInAlpha < 1.0) {
                this.fadeInAlpha += 1.0 / Math.max(1, s.fadeInFrames);
                if (this.fadeInAlpha > 1.0) this.fadeInAlpha = 1.0;
            }
            const elapsed = Date.now() - this.startTime;
            const durationMs = s.duration * 1000; 
            if (elapsed > durationMs + 2000) {
                this._finishExpansion();
            }
            // Check if full (Frontier Empty AND Center Covered)
            // Or just check frame count?
            // Heuristic: If frontier is empty, we are done (screen filled)
            else if (this.localFrame % 10 === 0 && this.frontier.length === 0 && this.blocksAdded > 100) {
                this._finishExpansion();
            }
            if (this.isExpanding) {
                // Growth Logic - Inwards
                const progress = Math.min(1.0, elapsed / durationMs);
                // Target Blocks matches Pulse logic, but applied to filling the screen
                const totalBlocks = (this.g.cols * this.g.rows) / 16; 
                // We want to reach roughly totalBlocks by end of duration
                const targetBlocks = Math.floor(totalBlocks * Math.pow(progress, 1.5)); // Slower start, fast finish? 
                // Retract starts fast (large perimeter) and slows down (small center)?
                // Actually perimeter is large, so we add many blocks per burst.
                // Let's target a linear fill rate relative to area
                let needed = targetBlocks - this.blocksAdded;
                // Since we start with perimeter, blocksAdded is already non-zero.
                if (needed > 0 || this.localFrame < 10) { // Always force start
                     const burstCap = 800; // Higher cap for large perimeter
                     let burst = Math.min(needed, burstCap);
                     if (burst < 5) burst = 5; 
                     this._updateExpansionBurst(burst);
                }
                this._updateLines(s);
            }
        }
        this._updateFlashes();
        if (!this.isExpanding && this.activeFlashes.size === 0) {
            this.stop(); 
        }
    }
    _updateBorderIllumination() {
        const centerX = this.g.cols / 2;
        const centerY = this.g.rows / 2;
        const maxDist = Math.sqrt(centerX*centerX + centerY*centerY);
        for (const l of this.lines) {
            if (!l.isNew) continue; 
            const dx = (l.x + (l.w > 0 ? l.w/2 : 0)) - centerX;
            const dy = (l.y + (l.h > 0 ? l.h/2 : 0)) - centerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            // Retract: Brightest near center (End of effect)? 
            // Or Brightest at edge (Start of effect)?
            // Visual preference: Leading edge should be bright.
            // As it moves inwards, distance decreases.
            // So we want scale to be high regardless?
            // Let's use 1.0 constant for now, maybe pulsate?
            let scale = 1.0;
            let isHorizontal = (l.w > 0);
            if (isHorizontal) {
                const isTopOccupied = this._isOccupied(l.x, l.y - 4);
                const isBottomOccupied = this._isOccupied(l.x, l.y);
                if (isTopOccupied && !isBottomOccupied) this._illuminateSpan(l.x, l.y - 1, 4, 1, scale);
                else if (isBottomOccupied && !isTopOccupied) this._illuminateSpan(l.x, l.y, 4, 1, scale);
            } else {
                const isLeftOccupied = this._isOccupied(l.x - 4, l.y);
                const isRightOccupied = this._isOccupied(l.x, l.y);
                if (isLeftOccupied && !isRightOccupied) this._illuminateSpan(l.x - 1, l.y, 1, 4, scale);
                else if (isRightOccupied && !isLeftOccupied) this._illuminateSpan(l.x, l.y, 1, 4, scale);
            }
        }
    }
    _illuminateSpan(x, y, w, h, scale = 1.0) {
        if (!this.shadowGrid) return;
        for(let py = y; py < y + h; py++) {
            if (py < 0 || py >= this.g.rows) continue;
            for(let px = x; px < x + w; px++) {
                if (px < 0 || px >= this.g.cols) continue;
                const idx = py * this.g.cols + px;
                if (this.shadowGrid.chars[idx] !== 0) {
                     this.flashIntensity[idx] = 1.0 * scale; 
                     this.activeFlashes.add(idx);
                }
            }
        }
    }
    _updateExpansionBurst(count) {
        // Merge Lines
        const greenDuration = this.c.state.quantizedPulseGreenFadeSeconds !== undefined ? this.c.state.quantizedPulseGreenFadeSeconds : 0.5;
        for (let i = this.lines.length - 1; i >= 0; i--) {
            const l = this.lines[i];
            if (l.isNew) {
                if (greenDuration <= 0.01) {
                    this.lines.splice(i, 1);
                } else {
                    l.isNew = false;
                    l.persistence = 0; 
                    l.alpha = 1.0;
                }
            }
        }
        let burstCount = count;
        this.burstCounter = (this.burstCounter + 1) & 0x3FFF; 
        if (this.burstCounter === 0) this.burstCounter = 1;
        let processed = 0;
        let attempts = 0;
        const maxAttempts = burstCount * 8 + 50; 
        // Retract Logic: Grow Inwards from Frontier
        // The frontier is the inner edge of the ring.
        // We want to pick blocks that move CLOSER to center.
        const cx = this.g.cols / 2;
        const cy = this.g.rows / 2;
        while (processed < burstCount && this.frontier.length > 0 && attempts < maxAttempts) {
            attempts++;
            const K = 5; 
            let bestIdx = -1;
            let bestDist = 999999; 
            // Scan K random frontier points, pick one closest to center
            // (Since we want to fill INWARDS)
            for (let k = 0; k < K; k++) {
                const idx = Math.floor(Math.random() * this.frontier.length);
                const f = this.frontier[idx];
                const mx = f.x + this.mapPad;
                const my = f.y + this.mapPad;
                // Validate
                if (mx < 0 || my < 0 || mx >= this.mapCols || my >= this.mapRows ||
                    (this.map[my * this.mapCols + mx] & 1) !== 0) { // Occupied
                     // Cleanup invalid
                     const last = this.frontier.pop();
                     if (idx < this.frontier.length) this.frontier[idx] = last;
                     k--; 
                     if (this.frontier.length === 0) break;
                     continue;
                }
                const dx = f.x - cx;
                const dy = f.y - cy;
                const dist = dx*dx + dy*dy;
                // We want smallest distance (closest to center)
                // Add noise to prevent perfect circle
                const score = dist + (Math.random() * 500);
                if (score < bestDist) {
                    bestDist = score;
                    bestIdx = idx;
                }
            }
            if (bestIdx === -1) continue;
            const winner = this.frontier[bestIdx];
            // Mark non-frontier
            const wmx = winner.x + this.mapPad;
            const wmy = winner.y + this.mapPad;
            this.map[wmy * this.mapCols + wmx] &= ~2; 
            const last = this.frontier.pop();
            if (bestIdx < this.frontier.length) this.frontier[bestIdx] = last;
            if (!this._isOccupied(winner.x, winner.y)) {
                this._addBlock(winner.x, winner.y, this.burstCounter);
                processed++;
                // Optional: Cluster fills (2x2, etc) to make it blocky
                // Copy-paste cluster logic from Pulse but keep it simple for now
                if (Math.random() < 0.5) {
                    // Try to add a neighbor closer to center
                    const dx = winner.x - cx;
                    const dy = winner.y - cy;
                    let tx = winner.x, ty = winner.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        tx += (dx > 0 ? -4 : 4); // Move towards X center
                    } else {
                        ty += (dy > 0 ? -4 : 4); // Move towards Y center
                    }
                    if (!this._isOccupied(tx, ty)) {
                        this._addBlock(tx, ty, this.burstCounter);
                        processed++;
                    }
                }
            }
        }
    }
    _updateFlashes() {
        if (this.activeFlashes.size === 0) return;
        const g = this.g;
        const decay = 1.0 / 30.0; 
        const toRemove = [];
        for (const idx of this.activeFlashes) {
            let intensity = this.flashIntensity[idx];
            if (intensity <= 0) {
                toRemove.push(idx);
                continue;
            }
            intensity -= decay;
            this.flashIntensity[idx] = intensity;
            if (intensity > 0) {
                if (g.overrideActive[idx] !== 3) {
                     g.overrideActive[idx] = 1; 
                }
                const illumination = this.c.state.quantizedPulseBorderIllumination !== undefined ? this.c.state.quantizedPulseBorderIllumination : 4.0;
                g.overrideGlows[idx] += illumination * intensity;
                const col = g.overrideColors[idx];
                const r = col & 0xFF;
                const gVal = (col >> 8) & 0xFF;
                const b = (col >> 16) & 0xFF;
                const a = (col >> 24) & 0xFF;
                const maxVal = Math.max(r, gVal, b, 1);
                const targetScale = 255 / maxVal;
                const scale = 1.0 + (targetScale - 1.0) * intensity;
                const rNew = Math.min(255, Math.floor(r * scale));
                const gNew = Math.min(255, Math.floor(gVal * scale));
                const bNew = Math.min(255, Math.floor(b * scale));
                g.overrideColors[idx] = (a << 24) | (bNew << 16) | (gNew << 8) | rNew;
            } else {
                toRemove.push(idx);
            }
        }
        for (const idx of toRemove) {
            this.activeFlashes.delete(idx);
            this.flashIntensity[idx] = 0;
        }
    }
    render(ctx, derived) {
        if (!this.active || !this.isExpanding) return;
        const s = this.c.state;
        const cw = derived.cellWidth * s.stretchX;
        const ch = derived.cellHeight * s.stretchY;
        const colorStr = '#FFFF6E'; // Gold
        const masterAlpha = this.fadeAlpha * this.fadeInAlpha;
        ctx.lineCap = 'butt';
        ctx.lineWidth = Math.max(1, cw * 0.15); 
        ctx.strokeStyle = colorStr;
        ctx.shadowBlur = 25; 
        ctx.shadowColor = colorStr;
        ctx.globalAlpha = masterAlpha;
        const hPath = new Path2D();
        const vPath = new Path2D();
        for (const b of this.blocks) {
            const nTop = this._isOccupied(b.x, b.y - 4);
            const nRight = this._isOccupied(b.x + 4, b.y);
            const nBottom = this._isOccupied(b.x, b.y + 4);
            const nLeft = this._isOccupied(b.x - 4, b.y);
            const bx = b.x * cw;
            const by = b.y * ch;
            const bw = 4 * cw;
            const bh = 4 * ch;
            if (!nTop) { hPath.moveTo(bx, by); hPath.lineTo(bx + bw, by); }
            if (!nRight) { vPath.moveTo(bx + bw, by); vPath.lineTo(bx + bw, by + bh); }
            if (!nBottom) { hPath.moveTo(bx, by + bh); hPath.lineTo(bx + bw, by + bh); }
            if (!nLeft) { vPath.moveTo(bx, by); vPath.lineTo(bx, by + bh); }
        }
        ctx.setLineDash([cw * 0.5, cw * 0.5, cw * 1.5, cw * 0.5]);
        ctx.stroke(hPath);
        ctx.setLineDash([cw * 0.2, cw * 0.3, cw * 0.5, cw * 0.3, cw * 1.2, cw * 0.5]);
        ctx.stroke(vPath);
        ctx.shadowBlur = 0; 
        ctx.strokeStyle = derived.streamColorStr; 
        ctx.setLineDash([cw * 0.25, cw * 0.25, cw * 0.5, cw * 0.25]);
        for (const l of this.lines) {
            let lineAlpha = l.alpha * masterAlpha;
            if (l.isNew) {
                ctx.strokeStyle = colorStr; 
                ctx.shadowBlur = 25;
                ctx.shadowColor = colorStr; 
                if (Math.random() < 0.4) {
                    lineAlpha *= (0.1 + Math.random() * 0.5);
                }
            } else {
                const col = derived.streamColorStr;
                ctx.strokeStyle = col; 
                ctx.shadowColor = col; 
            }
            ctx.globalAlpha = lineAlpha;
            ctx.beginPath();
            const lx = l.x * cw;
            const ly = l.y * ch;
            const lPxW = l.w * cw;
            const lPxH = l.h * ch;
            ctx.moveTo(lx, ly);
            ctx.lineTo(lx + lPxW, ly + lPxH);
            ctx.stroke();
        }
        ctx.setLineDash([]); 
        ctx.globalAlpha = 1.0; 
        ctx.shadowBlur = 0;
    }
}
// --- ReverseEffect.js ---
class ReverseEffect extends AbstractEffect {
    constructor(grid, config, effectRegistry) {
        super(grid, config);
        this.name = "ReverseTime";
        this.effectRegistry = effectRegistry;
        this.active = false;
        // Sequence phases
        // 0: Idle
        // 1: Slow Down
        // 2: Stop
        // 3: Reverse (Rewind)
        // 4: Reset (Pulse Handoff)
        this.phase = 0;
        this.timer = 0;
        // Configuration
        this.durationSlow = 60;  // Frames to slow down (1s)
        this.durationStop = 20;   // Frames to hold stop (~0.3s)
        this.durationRewind = 100; // Frames to rewind (~1.6s)
        this.rewindSpeed = -3.0;   // Rewind speed multiplier
    }
    trigger() {
        return this.start();
    }
    getOverride(i) {
        return null;
    }
    getActiveIndices() {
        return null;
    }
    start() {
        if (this.active) return false;
        this.active = true;
        this.phase = 1;
        this.timer = 0;
        this.sim = window.matrix ? window.matrix.simulation : null;
        if (!this.sim) {
            console.error("ReverseEffect: SimulationSystem not found.");
            this.active = false;
            return false;
        }
        return true;
    }
    update() {
        if (!this.active || !this.sim) return;
        this.timer++;
        switch (this.phase) {
            case 1: // SLOW DOWN
                {
                    const progress = this.timer / this.durationSlow;
                    const t = 1.0 - Math.pow(1 - progress, 3); 
                    this.sim.timeScale = 1.0 - t;
                    if (this.timer >= this.durationSlow) {
                        this.sim.timeScale = 0;
                        this.phase = 2;
                        this.timer = 0;
                    }
                }
                break;
            case 2: // STOP (HOLD)
                {
                    this.sim.timeScale = 0;
                    if (this.timer >= this.durationStop) {
                        this.phase = 3;
                        this.timer = 0;
                    }
                }
                break;
            case 3: // REWIND
                {
                    if (this.timer < 60) {
                        const t = this.timer / 60;
                        this.sim.timeScale = -t * Math.abs(this.rewindSpeed);
                    } else {
                        this.sim.timeScale = this.rewindSpeed;
                    }
                    if (this.timer >= this.durationRewind) {
                        this.phase = 4;
                        this.timer = 0;
                    }
                }
                break;
            case 4: // PULSE HANDOFF
                {
                    // Resume Normal Simulation
                    this.sim.timeScale = 1.0;
                    // Trigger Standard Pulse Effect (runs correctly with its own freeze/dim)
                    // We assume the user has configured the Pulse effect as desired (e.g. Movie Accurate)
                    this.effectRegistry.trigger('Pulse');
                    // Deactivate Time Control
                    this.active = false;
                    this.phase = 0;
                }
                break;
        }
    }
}
// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.afterimages = new Map(); 
                this.timer = 0;
                this.spawnX = 0;
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this.spawnX = 0;
                this.afterimages.clear();
                this._generateBolt();
                return true; 
            }
            update() {
                const s = this.c.state;
                // Update afterimages (fade out)
                if (this.afterimages.size > 0) {
                    // Fade speed: higher = slower. Default ~20.
                    // 20 -> 0.05 decay. 
                    const decay = 1.0 / Math.max(1, s.supermanFadeSpeed || 20); 
                    for (const [index, alpha] of this.afterimages) {
                        const newAlpha = alpha - decay;
                        if (newAlpha <= 0.01) {
                            this.afterimages.delete(index);
                        } else {
                            this.afterimages.set(index, newAlpha);
                        }
                    }
                }
                if(!this.active && this.afterimages.size === 0) {
                     return;
                }
                if (this.active) {
                    this.timer--;
                    // Spawning logic
                    // Speed 40 ~ crosses screen in roughly 0.5-1s depending on refresh rate.
                    // Factor: Speed 40 -> 0.04 * cols per frame. 
                    // If cols=100, 4 cells/frame. 25 frames total.
                    const speedVal = s.supermanSpawnSpeed || 40;
                    const speedFactor = Math.max(1, speedVal) / 1000; 
                    this.spawnX += (this.g.cols * speedFactor);
                    if (this.spawnX > this.g.cols) this.spawnX = this.g.cols;
                    if (this.timer <= 0) {
                        this.active = false;
                        this.lightningPath.clear();
                        return;
                    }
                    this.flickerTimer++;
                    if (this.flickerTimer >= s.supermanFlickerRate) {
                        this._generateBolt();
                        this.flickerTimer = 0;
                    } else {
                        this._refreshAfterimages();
                    }
                }
            }
            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                let cy = startY;
                const limitX = Math.floor(this.spawnX);
                for (let x = 0; x < this.g.cols; x++) {
                    if (x > limitX) break;
                    // Jitter / Width logic
                    const variance = Math.max(1, s.supermanWidth); 
                    const noise = Utils.randomInt(-variance, variance);
                    // Gentle center pull to keep it on screen but allow jitter
                    const distFromCenter = (this.g.rows / 2) - cy;
                    cy += noise + (distFromCenter * 0.05); 
                    if (cy < 0) cy = 0;
                    if (cy >= this.g.rows) cy = this.g.rows - 1;
                    const thickness = s.supermanBoltThickness; 
                    const halfThick = Math.floor(thickness / 2);
                    for (let dy = -halfThick; dy <= halfThick; dy++) {
                        const thickY = Math.round(cy) + dy;
                        if (thickY >= 0 && thickY < this.g.rows) {
                            const idx = this.g.getIndex(x, thickY);
                            if (idx !== -1) {
                                this.lightningPath.add(idx);
                            }
                        }
                    }
                }
                this._refreshAfterimages();
            }
            _refreshAfterimages() {
                for (const idx of this.lightningPath) {
                    this.afterimages.set(idx, 1.0);
                }
            }
            getOverride(i) {
                if (this.afterimages.has(i)) {
                    const alphaChar = this.g.alphas[i];
                    if (alphaChar <= 0.05) return null;
                    const effectAlpha = this.afterimages.get(i);
                    const s = this.c.state;
                    const fontIdx = this.g.fontIndices[i];
                    const fontName = this.c.derived.activeFonts[fontIdx]?.name || s.fontFamily;
                    return {
                        char: this.g.getChar(i),
                        font: fontName,
                        color: this.c.derived.streamColorStr, 
                        alpha: effectAlpha, 
                        glow: s.supermanGlow, 
                        size: 1,
                        solid: false, 
                        blend: true 
                    };
                }
                return null;
            }
            getActiveIndices() {
                if ((!this.active && this.afterimages.size === 0)) return new Set();
                return this.afterimages.keys();
            }
        }
    // =========================================================================
    // 7.0 CANVAS RENDERER
    // =========================================================================
// --- GlyphAtlas.js ---
class GlyphAtlas {
    constructor(config, fontName = null, customChars = null) {
        this.config = config;
        this.fontName = fontName;
        this.customChars = customChars;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true, willReadFrequently: true });
        // Map character strings to their rect in the atlas
        this.charMap = new Map();
        // Atlas dimensions and cell size
        this.cellSize = 0;
        this.atlasWidth = 0;
        this.atlasHeight = 0;
        // State tracking for updates
        this.currentFont = '';
        this.currentPalette = '';
        this.needsUpdate = true;
        // Pre-calculated half sizes for centering
        this.halfCell = 0;
        // Internal caches for differential updates
        this.fixedCols = 16; // Strategy 4: Default safety
        this._lastCols = 0;
        this._lastRows = 0;
        this._lastCharListKey = '';
        // Safety flags
        this.valid = true;
        this.MAX_HEIGHT = 8192; // Common safe limit for mobile/desktop
        // Fast Lookup for Renderer (CharCode -> AtlasID)
        this.codeToId = new Int16Array(65536).fill(-1);
        // Glyph Cache Optimization: Filter unsupported characters
        this.testCanvas = document.createElement('canvas');
        this.testCanvas.width = 20;
        this.testCanvas.height = 20;
        this.testCtx = this.testCanvas.getContext('2d', { willReadFrequently: true });
        this._cachedFilteredChars = null;
        this._cachedFilterKey = '';
        // Lazy Loading State
        this.usedChars = []; // List of characters currently in atlas
        this.capacity = 0;   // Current max characters
        this.minCapacity = 256; // Starting capacity
        this.hasChanges = false;
        this.fontReady = false;
    }
    /**
     * Initializes or updates the atlas configuration.
     * Clears the atlas and resets state to allow lazy loading.
     */
    update() {
        const s = this.config.state;
        const d = this.config.derived;
        // Determine font info (but NOT the full char list anymore for pre-fill)
        const fontFamily = this.fontName || s.fontFamily;
        // Check sizing dependencies
        const maxSize = s.fontSize + s.tracerSizeIncrease;
        const style = s.italicEnabled ? 'italic ' : '';
        const fontBase = `${style}${s.fontWeight} ${maxSize}px ${fontFamily}`;
        const padding = 10 * 2; // Fixed padding, decoupled from tracerGlow
        const paletteStr = d.paletteColorsStr.join(',');
        const fullConfigStr = paletteStr + '|' + s.overlapColor + '|' + fontBase + '|' + padding;
        const isFontReady = document.fonts.check(fontBase);
        if (this.currentFont === fontBase && 
            this.currentPalette === fullConfigStr && 
            this.fontReady === isFontReady && 
            !this.needsUpdate) {
            return;
        }
        // Configuration changed: Reset everything
        this.currentFont = fontBase;
        this.currentPalette = fullConfigStr;
        this.fontReady = isFontReady;
        // If font isn't ready, we force a retry next frame, but we TRY to render anyway (Canvas fallback)
        if (!isFontReady) {
            this.needsUpdate = true;
            // console.warn(`[GlyphAtlas] Font ${fontBase} not ready. Rendering with fallback.`);
        } else {
            this.needsUpdate = false;
        }
        // Reset dynamic state
        // Use a representative string with high/low chars
        this.ctx.font = fontBase;
        const metrics = this.ctx.measureText("Mjg|[]{}()"); 
        // fallback if metrics not supported
        let actualHeight = maxSize;
        if (metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent) {
            actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        } else {
            actualHeight = maxSize * 1.2; // generous fallback
        }
        this.cellSize = Math.ceil(Math.max(maxSize, actualHeight) + padding);
        this.halfCell = this.cellSize / 2;
        // Strategy 4: Fixed Width, Vertical Expansion
        // Fix columns based on a reasonable texture width (e.g., 2048)
        const TARGET_WIDTH = 2048;
        this.fixedCols = Math.max(1, Math.floor(TARGET_WIDTH / this.cellSize));
        // Reset dynamic state
        this.usedChars = [];
        this.charMap.clear();
        this.capacity = this.minCapacity;
        // Initial sizing (reset = true)
        this._resizeAtlas(d, true);
    }
    _resizeAtlas(d, reset = false) {
        // Use fixed columns
        const cols = this.fixedCols;
        const rows = Math.ceil(this.capacity / cols);
        this._lastCols = cols;
        this._lastRows = rows;
        const newAtlasWidth = cols * this.cellSize;
        const newAtlasHeight = rows * this.cellSize;
        if (newAtlasHeight > this.MAX_HEIGHT) {
             console.error(`[GlyphAtlas] Texture Limit Exceeded: Height ${newAtlasHeight} > ${this.MAX_HEIGHT}`);
             console.error(`Details: Capacity=${this.capacity}, Cols=${cols}, Rows=${rows}, CellSize=${this.cellSize}`);
             this.valid = false;
             return;
        }
        this.valid = true;
        this.atlasWidth = newAtlasWidth;
        this.atlasHeight = newAtlasHeight;
        // Preserve existing content if not resetting
        let savedContent = null;
        if (!reset && this.canvas.width > 0 && this.canvas.height > 0) {
             savedContent = document.createElement('canvas');
             savedContent.width = this.canvas.width;
             savedContent.height = this.canvas.height;
             savedContent.getContext('2d').drawImage(this.canvas, 0, 0);
        }
        // Resize Canvas (clears content)
        if (this.canvas.width !== this.atlasWidth || this.canvas.height !== this.atlasHeight) {
            this.canvas.width = this.atlasWidth;
            this.canvas.height = this.atlasHeight;
        } else {
            this.ctx.clearRect(0, 0, this.atlasWidth, this.atlasHeight);
        }
        // Restore content
        if (savedContent) {
            this.ctx.drawImage(savedContent, 0, 0);
        }
        // Full update required on resize/clear (GPU texture must be resized)
        this.needsFullUpdate = true;
        this.dirtyRects = []; // Clear partial updates as we are doing full
        // Setup Context (State is lost on resize)
        this.ctx.font = this.currentFont;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.ctx.fillStyle = '#FFFFFF';
        if (reset) {
            this.codeToId.fill(-1);
        }
    }
    /**
     * Adds a character to the atlas if space permits, expanding if necessary.
     */
    addChar(char) {
        if (!this.valid) return null;
        // Safety: Check if already exists to prevent duplicates
        if (this.charMap.has(char)) {
            const rect = this.charMap.get(char);
            const code = char.charCodeAt(0);
            if (code < 65536) this.codeToId[code] = rect.id;
            return rect;
        }
        // Check if supported first
        const checkFont = this.currentFont.replace(/\d+px/, '16px'); 
        const sig = this._getCharSignature(checkFont, char);
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        if (!sig || sig === emptySig) {
            // Unsupported, do not add
            return null;
        }
        this.usedChars.push(char);
        if (this.usedChars.length > this.capacity) {
            this._expandAtlas();
        }
        // Always draw the new char (even after expansion)
        if (this.valid) {
            const index = this.usedChars.length - 1;
            this._drawSingleChar(char, index);
        }
        // Return the new mapping
        return this.charMap.get(char);
    }
    _expandAtlas() {
        // Double capacity
        this.capacity *= 2;
        // Re-calculate dimensions and resize canvas (preserving content)
        const d = this.config.derived; 
        this._resizeAtlas(d, false);
        // No need to redraw old characters! 
        // Fixed columns ensure indices match locations.
    }
    _drawSingleChar(char, index) {
        const col = index % this._lastCols;
        const row = (index / this._lastCols) | 0;
        const x = col * this.cellSize + this.halfCell;
        const y = row * this.cellSize + this.halfCell;
        const rect = {
            x: col * this.cellSize,
            y: row * this.cellSize,
            w: this.cellSize,
            h: this.cellSize,
            id: index // Store index for shader lookup
        };
        this.charMap.set(char, rect);
        this.ctx.fillText(char, x, y);
        // Strategy 2: Incremental Updates - Capture pixel data
        const imageData = this.ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
        this.dirtyRects.push({
            x: rect.x,
            y: rect.y,
            w: rect.w,
            h: rect.h,
            data: imageData
        });
        // Update fast lookup
        const code = char.charCodeAt(0);
    }
    resetChanges() {
        this.hasChanges = false; // Keep for compatibility if used elsewhere
        this.dirtyRects = [];
        this.needsFullUpdate = false;
    }
    /**
     * Returns the source coordinates for a character.
     * Lazily adds the character if not present.
     * @param {string} char 
         * @returns {Object|null} Source rect {x,y,w,h} or null
     */
    get(char) {
        const rect = this.charMap.get(char);
        if (rect) return rect;
        // Lazy Load
        return this.addChar(char);
    }
    /**
     * Filters the character list to only include those supported by the font.
     * Caches the result to avoid expensive re-scans.
     */
    _getFilteredChars(rawList, font) {
        // Use a key that includes the font (with size replaced by standard) and the raw list
        // Note: We use the full fontBase as key because if size changes significantly, 
        // we might want to re-check (though unlikely to change support).
        const key = font + '::' + rawList.length + ':' + rawList;
        if (this._cachedFilteredChars !== null && this._cachedFilterKey === key) {
            return this._cachedFilteredChars;
        }
        const filtered = [];
        // Pre-calculate empty signature (tofu)
        // We use a fixed size for checking to avoid large canvas requirements
        const checkFont = font.replace(/\d+px/, '16px'); 
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        for (let i = 0; i < rawList.length; i++) {
            const char = rawList[i];
            const sig = this._getCharSignature(checkFont, char);
            // If signature exists and is different from tofu, it's supported.
            // (We assume space ' ' is either not in list or handled by renderer if empty)
            if (sig && sig !== emptySig) {
                filtered.push(char);
            }
        }
        // If we filtered out everything (e.g. font not loaded yet), 
        // fall back to raw list to avoid complete invisibility, 
        // or return empty string? 
        // Returning empty string means nothing draws.
        // Returning raw list means we might draw boxes.
        // Let's return filtered. If font loads later, update() should be triggered by something?
        // Actually, GlyphAtlas doesn't auto-update on font load unless triggered externally.
        // But usually FontManager triggers a re-render/update.
        this._cachedFilteredChars = (typeof rawList === 'string') ? filtered.join('') : filtered;
        this._cachedFilterKey = key;
        // console.log(`[GlyphAtlas] Filtered chars: ${rawList.length} -> ${filtered.length}`);
        return this._cachedFilteredChars;
    }
    /**
     * Computes a simple pixel sum signature for a character to detect 'tofu'.
     */
    _getCharSignature(font, char) {
        this.testCtx.clearRect(0, 0, 20, 20);
        this.testCtx.font = font;
        this.testCtx.textBaseline = 'middle';
        this.testCtx.textAlign = 'center';
        this.testCtx.fillStyle = '#fff';
        this.testCtx.fillText(char, 10, 10);
        const data = this.testCtx.getImageData(5, 5, 10, 10).data;
        let sum = 0;
        // Check alpha channel
        for(let i = 3; i < data.length; i += 4) {
            sum += data[i];
        }
        return sum;
    }
}
// --- PostProcessor.js ---
class PostProcessor {
    constructor(config) {
        this.config = config;
        this.gl = null;
        this.program = null; // Custom User Shader
        this.effectProgram = null; // System Effect Shader (e.g. Deja Vu)
        this.canvas = document.createElement('canvas'); // Offscreen WebGL canvas
        // Textures
        this.texture = null; // Source Input
        this.intermediateTexture = null; // Output of Pass 1
        // Buffers
        this.positionBuffer = null;
        this.framebuffer = null; // For Pass 1
        this.defaultFragmentShader = `
            precision mediump float;
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uParameter;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = texture2D(uTexture, vTexCoord);
            }
        `;
        this.vertexShaderSource = `
            attribute vec2 aPosition;
            varying vec2 vTexCoord;
            uniform float uFlipY;
            void main() {
                // Map -1..1 to 0..1 for tex coords
                vTexCoord = (aPosition + 1.0) * 0.5;
                if (uFlipY > 0.5) {
                    vTexCoord.y = 1.0 - vTexCoord.y; 
                }
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        this._initWebGL();
    }
    _initWebGL() {
        this.gl = this.canvas.getContext('webgl', { 
            alpha: true, 
            preserveDrawingBuffer: true 
        });
        if (!this.gl) {
            console.warn("WebGL not supported for Post Processing");
            return;
        }
        // Full screen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1
        ]);
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        // Input Texture
        this.texture = this._createTexture();
        // Intermediate Texture (for Pass 1 output)
        this.intermediateTexture = this._createTexture();
        // Framebuffer for Pass 1
        this.framebuffer = this.gl.createFramebuffer();
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.intermediateTexture, 0);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.compileShader(this.config.get('customShader') || this.defaultFragmentShader);
        this.compileEffectShader(this.config.get('effectShader'));
    }
    _createTexture() {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        return tex;
    }
    compileShader(fragSource) {
        this.program = this._compileProgram(fragSource);
    }
    compileEffectShader(fragSource) {
        if (!fragSource) {
            this.effectProgram = null;
            return;
        }
        this.effectProgram = this._compileProgram(fragSource);
    }
    _compileProgram(fragSource) {
        if (!this.gl) return null;
        if (!fragSource) fragSource = this.defaultFragmentShader;
        const createShader = (type, source) => {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                console.warn(type === this.gl.VERTEX_SHADER ? 'Vertex Shader Error' : 'Fragment Shader Error', this.gl.getShaderInfoLog(shader));
                this.gl.deleteShader(shader);
                return null;
            }
            return shader;
        };
        const vs = createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        const fs = createShader(this.gl.FRAGMENT_SHADER, fragSource);
        if (!vs || !fs) return null;
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.warn("Program Link Error", this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    resize(width, height) {
        if (!this.gl) return;
        this.canvas.width = width;
        this.canvas.height = height;
        // Resize textures
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.intermediateTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
    }
    render(sourceCanvas, time, mouseX = 0, mouseY = 0, param = 0.5, effectParam = 0.0) {
        if (!this.gl) return;
        // Ensure state is clean before we start
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        // Upload Source to Input Texture
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceCanvas);
        let inputTex = this.texture;
        let flipY = 1.0; // Default: Flip Y for Canvas source
        // PASS 1: Effect Shader (e.g. Deja Vu)
        if (this.effectProgram) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT); // Clear intermediate FBO
            this._drawPass(this.effectProgram, inputTex, time, mouseX, mouseY, effectParam, flipY);
            // Output of Pass 1 becomes Input of Pass 2
            inputTex = this.intermediateTexture;
            flipY = 0.0; // Next pass uses FBO source, no flip needed
        }
        // PASS 2: Custom Shader (Final Post-Process)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null); // Draw to screen (canvas)
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        const prog = this.program || this._compileProgram(this.defaultFragmentShader);
        this._drawPass(prog, inputTex, time, mouseX, mouseY, param, flipY);
    }
    _drawPass(prog, texture, time, mouseX, mouseY, param, flipY) {
        this.gl.useProgram(prog);
        const posLoc = this.gl.getAttribLocation(prog, 'aPosition');
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(posLoc);
        this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        const uTex = this.gl.getUniformLocation(prog, 'uTexture');
        this.gl.uniform1i(uTex, 0);
        const uRes = this.gl.getUniformLocation(prog, 'uResolution');
        this.gl.uniform2f(uRes, this.canvas.width, this.canvas.height);
        const uTime = this.gl.getUniformLocation(prog, 'uTime');
        this.gl.uniform1f(uTime, time);
        const uMouse = this.gl.getUniformLocation(prog, 'uMouse');
        if (uMouse) this.gl.uniform2f(uMouse, mouseX, mouseY);
        const uParam = this.gl.getUniformLocation(prog, 'uParameter');
        if (uParam) this.gl.uniform1f(uParam, param);
        const uFlip = this.gl.getUniformLocation(prog, 'uFlipY');
        if (uFlip) this.gl.uniform1f(uFlip, flipY);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
}
// --- WebGLRenderer.js ---
class WebGLRenderer {
    constructor(canvasId, grid, config, effects) {
        this.cvs = document.getElementById(canvasId);
        // Enforce WebGL2
        this.gl = this.cvs.getContext('webgl2', { alpha: false, preserveDrawingBuffer: false });
        if (!this.gl) {
            console.error("WebGLRenderer: WebGL 2 hardware acceleration not supported.");
            throw new Error("WebGL 2 not supported");
        }
        // Check for Float Texture Support (for HDR Bloom)
        this.canUseFloat = false;
        const ext = this.gl.getExtension('EXT_color_buffer_float');
        if (ext) this.canUseFloat = true;
        this.grid = grid;
        this.config = config;
        this.effects = effects;
        this.glyphAtlases = new Map();
        // --- Core WebGL State ---
        this.program = null;       
        this.bloomProgram = null;  
        this.colorProgram = null;  
        this.atlasTexture = null;  
        this.vao = null;           
        // --- Buffers ---
        this.instanceCapacity = 0; 
        this.instanceData = null; 
        this.instanceBuffer = null;
        this.depthBuffer = null; // New Depth Buffer
        // --- Framebuffers for Bloom ---
        this.fboA = null; 
        this.fboB = null; 
        this.fboC = null; // New Scratch FBO
        this.texA = null; 
        this.texB = null; 
        this.texC = null; // New Scratch Texture
        this.bloomWidth = 0;
        this.bloomHeight = 0;
        // --- State Tracking ---
        this.w = 0;
        this.h = 0;
        this.needsAtlasUpdate = true;
        this.mouseX = 0.5;
        this.mouseY = 0.5;
        this._setupMouseTracking();
        this._initGlimmerTexture(); // Generate Optimization Texture
        this._initShaders();
        this._initBuffers();
        this._initBloomBuffers();
        console.log("Rendering Engine: WebGL 2 (v8 CellGrid Optimized Fixed)");
        if (typeof PostProcessor !== 'undefined') {
            this.postProcessor = new PostProcessor(config);
            this.postProcessor.canvas.id = 'shaderCanvas';
            this.postProcessor.canvas.style.position = 'absolute';
            this.postProcessor.canvas.style.top = '0';
            this.postProcessor.canvas.style.left = '0';
            this.postProcessor.canvas.style.zIndex = '2'; 
            this.postProcessor.canvas.style.display = 'none'; 
            if (this.cvs.parentNode) {
                this.cvs.parentNode.insertBefore(this.postProcessor.canvas, this.cvs.nextSibling);
            }
            this.lastShaderSource = null;
            this.lastEffectSource = null;
        }
    }
    dispose() {
        if (this._mouseMoveHandler) window.removeEventListener('mousemove', this._mouseMoveHandler);
        if (this._touchMoveHandler) window.removeEventListener('touchmove', this._touchMoveHandler);
        if (this.postProcessor && this.postProcessor.canvas && this.postProcessor.canvas.parentNode) {
            this.postProcessor.canvas.parentNode.removeChild(this.postProcessor.canvas);
        }
        if (this.gl) {
            if (this.program2D) this.gl.deleteProgram(this.program2D);
            if (this.program && this.program !== this.program2D) this.gl.deleteProgram(this.program);
            if (this.bloomProgram) this.gl.deleteProgram(this.bloomProgram);
            if (this.colorProgram) this.gl.deleteProgram(this.colorProgram);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        }
    }
    _isMenuOpen() {
        const panel = document.getElementById('settingsPanel');
        return panel && panel.classList.contains('open');
    }
    _setupMouseTracking() {
        this._mouseMoveHandler = (e) => {
            if (this._isMenuOpen()) return;
            // Fallback for 2D or unlocked 3D (standard cursor tracking)
            const rect = this.cvs.getBoundingClientRect();
            this.mouseX = (e.clientX - rect.left) / rect.width;
            this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height);
        };
        this._touchMoveHandler = (e) => {
            if (this._isMenuOpen()) return;
            if (e.touches.length > 0) {
                const rect = this.cvs.getBoundingClientRect();
                this.mouseX = (e.clientX - rect.left) / rect.width;
                this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height);
            }
        };
        window.addEventListener('mousemove', this._mouseMoveHandler);
        window.addEventListener('touchmove', this._touchMoveHandler, { passive: true });
    }
    _initGlimmerTexture() {
        // Generate a 64x256 Noise Texture for Glimmer Optimization
        // Uses Strict Orthogonal "Manhattan" Walkers for Tetris-like connectivity
        const w = 64;
        const h = 256;
        const data = new Uint8Array(w * h);
        data.fill(0);
        // More walkers, but much sparser trail (fragmented)
        const numWalkers = 40;
        for (let n = 0; n < numWalkers; n++) {
            let x = Math.floor(Math.random() * w);
            let y = 0;
            let steps = 0;
            const maxSteps = h * 4; 
            while (y < h && steps < maxSteps) {
                // Fragmented: Only 40% chance to draw a block at current step
                // This creates "broken" connections and inconsistency
                if (Math.random() < 0.4) {
                    data[y * w + x] = 255;
                }
                const r = Math.random();
                if (r < 0.65) {
                    // Move UP (65% chance)
                    y++;
                } else if (r < 0.825) {
                    // Move LEFT
                    x = (x - 1 + w) % w;
                } else {
                    // Move RIGHT
                    x = (x + 1) % w;
                }
                steps++;
            }
        }
        this.glimmerTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.glimmerTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, w, h, 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, data);
        // Use NEAREST to preserve "Blocky/Digital" look
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    }
    _createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    _createProgram(vsSource, fsSource) {
        const vs = this._createShader(this.gl.VERTEX_SHADER, vsSource);
        const fs = this._createShader(this.gl.FRAGMENT_SHADER, fsSource);
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
        _initShaders() {
            // --- SHADOW MASK SHADER ---
            const shadowVS = `#version 300 es
                layout(location=0) in vec2 a_quad;
                layout(location=1) in vec4 a_rect;
                layout(location=2) in float a_alpha;
                layout(location=3) in float a_blur;
                uniform vec2 u_gridSize;
                out vec2 v_uv;
                out float v_alpha;
                out float v_blur;
                void main() {
                    vec2 size = a_rect.zw;
                    vec2 pos = a_rect.xy;
                    vec2 worldPos = pos + (a_quad * size);
                    vec2 uv = worldPos / u_gridSize;
                    gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
                    v_uv = a_quad;
                    v_alpha = a_alpha;
                    v_blur = a_blur;
                }
            `;
            const shadowFS = `#version 300 es
                precision mediump float;
                in vec2 v_uv;
                in float v_alpha;
                in float v_blur;
                out vec4 fragColor;
                void main() {
                    vec2 d = abs(v_uv - 0.5) * 2.0;
                    float dist = max(d.x, d.y);
                    float edge = 1.0 - smoothstep(1.0 - max(0.001, v_blur), 1.0, dist);
                    fragColor = vec4(0.0, 0.0, 0.0, v_alpha * edge);
                }
            `;
            this.shadowProgram = this._createProgram(shadowVS, shadowFS);
            // --- MATRIX SHADERS (SPLIT 2D/3D) ---
            const matrixVS_Common = `#version 300 es
                precision mediump float;
                layout(location=0) in vec2 a_quad;
                layout(location=1) in vec2 a_pos;
                layout(location=2) in float a_charIdx;
                layout(location=3) in vec4 a_color;
                layout(location=4) in float a_alpha;
                layout(location=5) in float a_decay;
                layout(location=6) in float a_glow;
                layout(location=7) in float a_mix;
                layout(location=8) in float a_nextChar;
                layout(location=9) in vec3 a_depth;
                out vec2 v_uv;
                out vec2 v_uv2;
                out vec4 v_color;
                out float v_mix;
                out float v_glow;
                out float v_prog;
                out vec2 v_screenUV;
                out vec2 v_shadowUV;
                out vec2 v_cellUV;
            `;
            // 2D Vertex Shader
            const matrixVS2D = matrixVS_Common + `
                uniform vec2 u_resolution;
                uniform vec2 u_atlasSize;
                uniform vec2 u_gridSize;
                uniform float u_cellSize;
                uniform float u_cols;
                uniform float u_decayDur;
                uniform vec2 u_stretch;
                uniform float u_mirror;
                uniform float u_dissolveEnabled;
                uniform float u_dissolveScale;
                void main() {
                    // Decay Scale Logic
                    float scale = 1.0;
                    v_prog = 0.0;
                    v_cellUV = a_quad;
                    if (a_decay >= 2.0) {
                        v_prog = (a_decay - 2.0) / u_decayDur;
                        if (u_dissolveEnabled > 0.5) {
                            scale = mix(1.0, u_dissolveScale, v_prog);
                        } else {
                            scale = 1.0;
                        }
                    }
                    // Position Calculation (2D)
                    vec2 centerPos2D = (a_quad - 0.5) * u_cellSize * scale;
                    vec2 worldPos = a_pos + centerPos2D;
                    v_shadowUV = worldPos / u_gridSize;
                    // Mirror/Stretch
                    vec2 gridCenter = u_gridSize * 0.5;
                    worldPos.x = (worldPos.x - gridCenter.x) * u_stretch.x + (u_resolution.x * 0.5);
                    worldPos.y = (worldPos.y - gridCenter.y) * u_stretch.y + (u_resolution.y * 0.5);
                    if (u_mirror < 0.0) worldPos.x = u_resolution.x - worldPos.x;
                    // 2D Mode (Legacy Clip Space)
                    vec2 clip = (worldPos / u_resolution) * 2.0 - 1.0;
                    clip.y = -clip.y;
                    gl_Position = vec4(clip, 0.0, 1.0);
                    // Pass Attributes
                    vec3 ndc = gl_Position.xyz / gl_Position.w;
                    v_screenUV = ndc.xy * 0.5 + 0.5;
                    v_color = a_color;
                    v_color.a *= a_alpha;
                    v_mix = a_mix;
                    v_glow = a_glow;
                    // UV 1
                    float cIdx = a_charIdx;
                    float row = floor(cIdx / u_cols);
                    float col = mod(cIdx, u_cols);
                    vec2 uvBase = vec2(col, row) * u_cellSize;
                    v_uv = (uvBase + (a_quad * u_cellSize)) / u_atlasSize;
                    // UV 2
                    if (a_mix > 0.0) {
                        float cIdx2 = a_nextChar;
                        float row2 = floor(cIdx2 / u_cols);
                        float col2 = mod(cIdx2, u_cols);
                        vec2 uvBase2 = vec2(col2, row2) * u_cellSize;
                        v_uv2 = (uvBase2 + (a_quad * u_cellSize)) / u_atlasSize;
                    } else {
                        v_uv2 = v_uv;
                    }
                }
            `;
            // Optimized Fragment Shader (Shared)
            const matrixFS = `#version 300 es
                precision mediump float;
                in vec2 v_uv;
                in vec2 v_uv2;
                in vec4 v_color;
                in float v_mix;
                in float v_glow;
                in float v_prog;
                in vec2 v_screenUV;
                in vec2 v_shadowUV;
                in vec2 v_cellUV;
                uniform sampler2D u_texture;
                uniform sampler2D u_shadowMask; 
                uniform sampler2D u_glimmerNoise; // <-- Optimization Texture
                uniform float u_time;
                uniform float u_dissolveEnabled; 
                uniform float u_dissolveScale;
                uniform float u_dissolveSize;
                uniform float u_deteriorationEnabled;
                uniform float u_deteriorationStrength;
                uniform vec2 u_atlasSize;
                uniform vec2 u_gridSize; 
                uniform float u_cellSize; 
                uniform vec2 u_cellScale; 
                uniform vec4 u_overlapColor;
                uniform float u_glimmerSpeed;
                uniform float u_glimmerSize;
                uniform float u_glimmerFill; // Unused in optimized version (baked into texture density)
                uniform float u_glimmerIntensity;
                uniform float u_glimmerFlicker; // Controls spread of flicker
                // 0 = Base (Glyphs/Glow), 1 = Shadow
                uniform int u_passType;
                out vec4 fragColor;
                // Pseudo-random function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                vec2 random2(vec2 st) {
                    st = vec2( dot(st,vec2(127.1,311.7)),
                               dot(st,vec2(269.5,183.3)) );
                    return -1.0 + 2.0*fract(sin(st)*43758.5453123);
                }
                // Helper to apply all visual degradations (Dissolve + Ghosting) identically
                float getProcessedAlpha(vec2 uv) {
                    float a = texture(u_texture, uv).a;
                    float ghost1 = 0.0;
                    float ghost2 = 0.0;
                    // Trail Ghosting (Vertical Blur) - Sample first
                    if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                        float blurDist = (u_deteriorationStrength * v_prog) / u_atlasSize.y;
                        ghost1 = texture(u_texture, uv + vec2(0.0, blurDist)).a;
                        ghost2 = texture(u_texture, uv - vec2(0.0, blurDist)).a;
                    }
                    // Alpha Erosion Dissolve (Burn away from edges)
                    // Apply to MAIN char AND GHOSTS
                    if (u_dissolveEnabled > 0.5 && v_prog > 0.0) {
                        float erosion = v_prog * 1.2; 
                        a = min(a, smoothstep(erosion, erosion + 0.1, a));
                        if (ghost1 > 0.0) ghost1 = min(ghost1, smoothstep(erosion, erosion + 0.1, ghost1));
                        if (ghost2 > 0.0) ghost2 = min(ghost2, smoothstep(erosion, erosion + 0.1, ghost2));
                    }
                    // Combine
                    if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                        a = max(a, max(ghost1, ghost2) * 0.5);
                    }
                    return a;
                }
                void main() {
                    // Decode High Priority Signal
                    bool isHighPriority = (v_mix >= 9.5);
                    float useMix = isHighPriority ? v_mix - 10.0 : v_mix;
                    // Sample Shadow Mask
                    float shadow = texture(u_shadowMask, v_shadowUV).a;
                    // Sample Texture with Effects
                    float tex1 = getProcessedAlpha(v_uv);
                    vec4 baseColor = v_color;
                    // Default Standard Mode
                    float finalAlpha = tex1;
                    // GLIMMER LOGIC (State 30.0 -> useMix 20.0)
                    float glimmer = 0.0;
                    if (useMix >= 19.5) {
                        float gOpacity = clamp(useMix - 20.0, 0.0, 1.0);
                        useMix = 0.0; // Reset
                        float rawTex = texture(u_texture, v_uv).a;
                        if (rawTex > 0.3) {
                            // 1. Calculate Seed with Time Step (Pattern Switching)
                            // u_glimmerSpeed controls the frequency of pattern changes (Hz)
                            float switchFreq = max(0.01, u_glimmerSpeed);
                            float timeStep = floor(u_time * switchFreq);
                            vec2 renderSize = u_cellSize * u_cellScale; 
                            vec2 cellGridPos = floor((v_shadowUV * u_gridSize) / renderSize);
                            // Perturb seed with timeStep to switch patterns
                            vec2 seed = cellGridPos + vec2(timeStep * 37.0, timeStep * 11.0);
                            float cellRand = random(seed);
                            // 2. Determine Shape/Position
                            // "Lamp illuminating pattern from behind" - Shapes are geometric/tech
                            vec2 center = vec2(0.5);
                            vec2 sizeBounds = vec2(0.1, 0.1); // Default
                            float rotation = 0.0;
                            // Probability Distribution:
                            // 0.00 - 0.30: Vertical Bars (30%)
                            // 0.30 - 0.60: Horizontal Bars (30%)
                            // 0.60 - 0.80: Small Rects/Blocks (20%)
                            // 0.80 - 1.00: Diagonals (20%)
                            if (cellRand < 0.15) {
                                // Vertical Left
                                center = vec2(0.2, 0.5);
                                sizeBounds = vec2(0.08, 0.45);
                            } else if (cellRand < 0.30) {
                                // Vertical Right
                                center = vec2(0.8, 0.5);
                                sizeBounds = vec2(0.08, 0.45);
                            } else if (cellRand < 0.40) {
                                // Horizontal Top
                                center = vec2(0.5, 0.8);
                                sizeBounds = vec2(0.45, 0.08);
                            } else if (cellRand < 0.50) {
                                // Horizontal Bottom
                                center = vec2(0.5, 0.2);
                                sizeBounds = vec2(0.45, 0.08);
                            } else if (cellRand < 0.60) {
                                // Horizontal Middle
                                center = vec2(0.5, 0.5);
                                sizeBounds = vec2(0.45, 0.06);
                            } else if (cellRand < 0.70) {
                                // Small Rect Center
                                center = vec2(0.5, 0.5);
                                sizeBounds = vec2(0.15, 0.15);
                            } else if (cellRand < 0.80) {
                                // Small Rect Random Offset (based on fractional part of seed)
                                float offX = fract(cellRand * 10.0) * 0.6 - 0.3; // -0.3 to 0.3
                                float offY = fract(cellRand * 20.0) * 0.6 - 0.3;
                                center = vec2(0.5 + offX, 0.5 + offY);
                                sizeBounds = vec2(0.12, 0.12);
                            } else if (cellRand < 0.90) {
                                // Diagonal 1 (TL to BR)
                                rotation = 0.785398; // +45 deg
                                sizeBounds = vec2(0.05, 0.55); 
                            } else {
                                // Diagonal 2 (BL to TR)
                                rotation = -0.785398; // -45 deg
                                sizeBounds = vec2(0.05, 0.55);
                            }
                            // 3. Sample Noise Texture (Luminosity Modulator)
                            // Remove continuous scrolling. Pattern is static per timeStep.
                            // Map Cell Position to Texture Space
                            vec2 noiseUV = vec2(cellGridPos.x / 64.0, cellGridPos.y / 64.0);
                            // Apply random offset based on seed
                            noiseUV += vec2(cellRand * 123.0, cellRand * 456.0);
                            float activeVal = texture(u_glimmerNoise, noiseUV).r;
                            // 4. Draw Shape (Geometry is Constant per Cell)
                            vec2 p = v_cellUV - center;
                            // Apply Rotation if needed
                            if (rotation != 0.0) {
                                float s = sin(rotation);
                                float c = cos(rotation);
                                p = vec2(p.x * c - p.y * s, p.x * s + p.y * c);
                            }
                            p = abs(p);
                            float r = 0.01; // Sharp corners
                            float d = length(max(p - sizeBounds, 0.0)) + min(max(p.x - sizeBounds.x, p.y - sizeBounds.y), 0.0) - r;
                            float core = 1.0 - smoothstep(-0.01, 0.01, d);
                            float halo = 1.0 - smoothstep(0.0, 0.15, d);
                            float shape = core + (halo * 0.4);
                            // 5. Apply Luminosity & Flicker
                            // "Bad Connection / Fluorescent" Flicker
                            float flicker = 1.0;
                            // Flicker Spread Control:
                            // u_glimmerFlicker determines probability of a cell being "faulty"
                            if (cellRand < u_glimmerFlicker) {
                                // 1. Primary Flicker Cycle (Variable speed per cell)
                                float cycleSpeed = 10.0 + (cellRand * 20.0);
                                float flickerBase = sin(u_time * cycleSpeed + (cellRand * 100.0));
                                // 2. Hard Cutout (Thresholding)
                                // Occasional complete dropouts. If base wave is low, light cuts out.
                                float cutout = smoothstep(-0.4, -0.2, flickerBase);
                                // 3. High Frequency Jitter (When ON)
                                // Simulates the electrical noise
                                float jitter = 0.7 + 0.6 * fract(sin(dot(vec2(u_time, cellRand), vec2(12.9898,78.233))) * 43758.5453);
                                flicker = cutout * jitter;
                                // 4. Long Random Dropouts (The "Dead Cell" Effect)
                                // Sample noise at a very slow speed
                                vec2 dropoutUV = vec2(cellGridPos.x / 13.0, (u_time * 0.5) + cellRand * 50.0);
                                float dropoutVal = texture(u_glimmerNoise, dropoutUV).r;
                                // 20% chance to be completely dead at any moment for flickering cells
                                if (dropoutVal < 0.2) {
                                    flicker = 0.0;
                                }
                            }
                            // Combine: Shape * NoiseModulation * Flicker * Opacity
                            glimmer = shape * (0.4 + (0.6 * activeVal)) * flicker;
                            glimmer *= gOpacity;
                        }
                    }
                    if (useMix >= 4.0) {
                        // Overlay Mode (Tracers/Effects)
                        // Use baseColor so tracers follow Stream Color.
                        float originalBaseAlpha = baseColor.a;
                        float ovAlpha = useMix - 4.0;
                        float tex2 = getProcessedAlpha(v_uv2);
                        float effA = tex2 * ovAlpha;
                        float simA = tex1 * originalBaseAlpha;
                        // Mix towards White (Tracer-like) instead of just boosting brightness
                        vec3 targetColor = vec3(0.95, 0.95, 0.95); 
                        baseColor.rgb = mix(baseColor.rgb, targetColor, effA);
                        finalAlpha = max(simA, effA);
                        baseColor.a = 1.0; // Prevent base instance alpha (0 for empty) from killing the overlay
                    } else if (useMix >= 3.0) {
                        // Solid Mode
                        finalAlpha = 1.0;
                    } else if (useMix >= 2.0) {
                        // Overlap Mode
                        // Apply same effects to secondary character
                        float tex2 = getProcessedAlpha(v_uv2);
                        float intersection = tex1 * tex2;
                        // Primary visible, secondary invisible except intersection
                        finalAlpha = tex1; 
                        // If intersecting, use overlap color
                        if (intersection > 0.1) {
                                baseColor.rgb = u_overlapColor.rgb;
                        }
                    } else if (useMix > 0.0) {
                        // Rotator Mix
                        // For rotator, we might NOT want dissolve/ghosting on the incoming char yet?
                        // Usually rotator happens on active cells (decay=0).
                        // If decay=0, getProcessedAlpha just returns raw alpha. So it's safe.
                        float tex2 = getProcessedAlpha(v_uv2);
                        finalAlpha = mix(tex1, tex2, useMix);
                    }
                    if (finalAlpha < 0.01) discard;
                    // Apply Shadow Darkening
                    // shadow = 0..1 (0=No Shadow, 1=Black)
                    // LAYER PRECEDENCE:
                    // 1. Background Code & Tracers -> Affect by Shadow
                    // 2. High Priority Effects (Lightning) -> Ignore Shadow (v_mix >= 10.0)
                    if (!isHighPriority) {
                        baseColor.rgb *= (1.0 - shadow);
                    }
                    vec4 col = baseColor;
                    // Boost brightness for glow (Bloom trigger)
                    // Multiply by alpha to ensure it fades out with the character
                    if (v_glow > 0.0) {
                        // GLOW logic must also respect shadow for non-high-priority effects!
                        // If shadow is active, the baseColor is darkened.
                        // The GLOW should also be darkened/suppressed.
                        // Otherwise a black char will still emit light.
                        float glowFactor = v_glow;
                        if (!isHighPriority) {
                            glowFactor *= (1.0 - shadow);
                        }
                        col.rgb += (glowFactor * 0.3 * col.a);
                    }
                    // Base Alpha (Stream Fade)
                    float streamAlpha = col.a * finalAlpha;
                    if (glimmer > 0.0) {
                        // 1. Turn the block White (mix base color to white)
                        // Clamp mixing factor to 1.0 to stay within white range
                        col.rgb = mix(col.rgb, vec3(1.0), min(1.0, glimmer));
                        // 2. Add Bright Glow (Additively)
                        // Use u_glimmerIntensity (from slider) to boost brightness significantly
                        // We do NOT multiply by shadow here, allowing glimmer to pierce darkness
                        // Scale by 0.3 to match standard glow intensity curve
                        vec3 glowBoost = vec3(u_glimmerIntensity * 0.3) * glimmer;
                        col.rgb += glowBoost;
                        // Force alpha to be at least the glimmer opacity
                        streamAlpha = max(streamAlpha, glimmer);
                    }
                    fragColor = vec4(col.rgb, streamAlpha);
                }
            `;
            this.program2D = this._createProgram(matrixVS2D, matrixFS);
            this.program = this.program2D; // Default fallback
            // Keep existing Bloom/Color programs
            const bloomVS = `#version 300 es\nlayout(location=0) in vec2 a_position; out vec2 v_uv; void main(){ v_uv=a_position*0.5+0.5; gl_Position=vec4(a_position, 0.0, 1.0); }`;
            const bloomFS = `#version 300 es\nprecision mediump float; in vec2 v_uv; uniform sampler2D u_image; uniform bool u_horizontal; uniform float u_weight[5]; uniform float u_spread; uniform float u_opacity; out vec4 fragColor; void main(){ vec2 tex_offset=(1.0/vec2(textureSize(u_image, 0)))*u_spread; vec3 result=texture(u_image, v_uv).rgb*u_weight[0]; if(u_horizontal){ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; } }else{ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; } } fragColor=vec4(result*u_opacity, 1.0); }`;
            this.bloomProgram = this._createProgram(bloomVS, bloomFS);
            const colorVS = `#version 300 es\nlayout(location=0) in vec2 a_position; void main(){ gl_Position=vec4(a_position, 0.0, 1.0); }`;
            const colorFS = `#version 300 es\nprecision mediump float; uniform vec4 u_color; out vec4 fragColor; void main(){ fragColor=u_color; }`;
            this.colorProgram = this._createProgram(colorVS, colorFS);
        }
    _initBuffers() {
        const quadVerts = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);
        const screenQuadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
        this.quadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, quadVerts, this.gl.STATIC_DRAW);
        this.screenQuadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, screenQuadVerts, this.gl.STATIC_DRAW);
        // Shadow Instance Buffer (Dynamic)
        this.shadowInstanceBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
        this.shadowInstanceCapacity = 1000;
        // Initial capacity: 1000 sheets * 20 bytes (x,y,w,h,a)
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * 20, this.gl.DYNAMIC_DRAW);
        // Instance buffers will be created in resize()
        this.posBuffer = null;
        this.charBuffer = null;
        this.colorBuffer = null;
        this.alphaBuffer = null;
        this.decayBuffer = null;
        this.glowBuffer = null;
        this.mixBuffer = null;
        this.nextCharBuffer = null;
        // Mapped Arrays (CPU side)
        this.mappedChars = null;
        this.mappedNextChars = null;
    }
    _initBloomBuffers() {
        this.fboA = this.gl.createFramebuffer(); this.texA = this.gl.createTexture();
        this.fboB = this.gl.createFramebuffer(); this.texB = this.gl.createTexture();
        this.fboC = this.gl.createFramebuffer(); this.texC = this.gl.createTexture();
        // Shadow Mask FBO
        this.shadowMaskFbo = this.gl.createFramebuffer(); 
        this.shadowMaskTex = this.gl.createTexture();
    }
    _configureFramebuffer(fbo, tex, width, height) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fbo);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        let internalFormat = this.gl.RGBA;
        let type = this.gl.UNSIGNED_BYTE;
        if (this.canUseFloat) {
            internalFormat = this.gl.RGBA16F;
            type = this.gl.HALF_FLOAT;
        }
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, internalFormat, width, height, 0, this.gl.RGBA, type, null);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, tex, 0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
    handleFontChange() { this.glyphAtlases.clear(); this.needsAtlasUpdate = true; }
    handleAppearanceChange() { this.needsAtlasUpdate = true; }
    updateSmoothing() { 
        const s = this.config.state.smoothingEnabled ? this.config.state.smoothingAmount : 0; 
        this.cvs.style.filter = `blur(${s}px)`; 
    }
    resize() {
        const s = this.config.state;
        const d = this.config.derived;
        const scale = s.resolution;
        this.handleAppearanceChange();
        this.w = window.innerWidth;
        this.h = window.innerHeight;
        // Fix: Explicitly set CSS size to match window, independent of buffer resolution
        this.cvs.style.width = `${this.w}px`;
        this.cvs.style.height = `${this.h}px`;
        const pw = Math.floor(this.w * scale);
        const ph = Math.floor(this.h * scale);
        if (this.cvs.width !== pw || this.cvs.height !== ph) {
            this.cvs.width = pw; this.cvs.height = ph; this.gl.viewport(0, 0, pw, ph);
        }
        if (this.fboWidth !== pw || this.fboHeight !== ph) {
            this.fboWidth = pw; this.fboHeight = ph;
            this.bloomWidth = Math.floor(pw * 0.5); this.bloomHeight = Math.floor(ph * 0.5);
            if (pw > 0 && ph > 0) {
                this._configureFramebuffer(this.fboA, this.texA, this.fboWidth, this.fboHeight);
                this._configureFramebuffer(this.fboB, this.texB, this.bloomWidth, this.bloomHeight);
                this._configureFramebuffer(this.fboC, this.texC, this.bloomWidth, this.bloomHeight);
                // Shadow Mask (Matches Render Resolution)
                this._configureFramebuffer(this.shadowMaskFbo, this.shadowMaskTex, this.fboWidth, this.fboHeight);
            }
        }
        if (this.postProcessor) { this.postProcessor.resize(pw, ph); this.postProcessor.canvas.style.width = `${this.w}px`; this.postProcessor.canvas.style.height = `${this.h}px`; }
        // --- Resize Buffers ---
        const totalCells = this.grid.cols * this.grid.rows;
        // Helper to recreate buffer
        const ensureBuf = (buf, size, drawType = this.gl.DYNAMIC_DRAW) => {
             if (buf) this.gl.deleteBuffer(buf);
             const newBuf = this.gl.createBuffer();
             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, newBuf);
             this.gl.bufferData(this.gl.ARRAY_BUFFER, size, drawType);
             return newBuf;
        };
        // Static Position Buffer
        this.posBuffer = ensureBuf(this.posBuffer, totalCells * 8, this.gl.STATIC_DRAW); // 2 floats * 4 bytes
        const posData = new Float32Array(totalCells * 2);
        const cw = d.cellWidth; const ch = d.cellHeight;
        const xOff = s.fontOffsetX; const yOff = s.fontOffsetY;
        for (let i = 0; i < totalCells; i++) {
             const col = i % this.grid.cols;
             const row = Math.floor(i / this.grid.cols);
             posData[i*2] = col * cw + cw * 0.5 + xOff;
             posData[i*2+1] = row * ch + ch * 0.5 + yOff;
        }
        // Fix: Explicitly bind posBuffer before uploading posData
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, posData);
        // Dynamic Buffers
        this.charBuffer = ensureBuf(this.charBuffer, totalCells * 2); // Uint16
        this.colorBuffer = ensureBuf(this.colorBuffer, totalCells * 4); // Uint32 (RGBA)
        this.alphaBuffer = ensureBuf(this.alphaBuffer, totalCells * 4); // Float32
        this.decayBuffer = ensureBuf(this.decayBuffer, totalCells); // Uint8
        this.glowBuffer = ensureBuf(this.glowBuffer, totalCells * 4); // Float32
        this.mixBuffer = ensureBuf(this.mixBuffer, totalCells * 4); // Float32
        this.nextCharBuffer = ensureBuf(this.nextCharBuffer, totalCells * 2); // Uint16
        // Mapped Arrays
        this.mappedChars = new Uint16Array(totalCells);
        this.mappedNextChars = new Uint16Array(totalCells);
        // Upload Buffers (CPU merging for overrides/effects)
        this.uploadColors = new Uint32Array(totalCells);
        this.uploadAlphas = new Float32Array(totalCells);
        this.uploadDecays = new Uint8Array(totalCells); // Decays usually don't have overrides but safe to copy
        this.uploadGlows = new Float32Array(totalCells);
        this.uploadMix = new Float32Array(totalCells);
        this._setupVAO();
    }
    _setupVAO() {
        if (this.vao) this.gl.deleteVertexArray(this.vao);
        this.vao = this.gl.createVertexArray();
        this.gl.bindVertexArray(this.vao);
        // 0: Quad (Vertex)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        // 1: Pos (Static Instance)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.enableVertexAttribArray(1);
        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(1, 1);
        // 2: CharIdx (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.enableVertexAttribArray(2);
        this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(2, 1);
        // 3: Color (Dynamic Instance, Uint32 -> Vec4 Normalized)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.enableVertexAttribArray(3);
        this.gl.vertexAttribPointer(3, 4, this.gl.UNSIGNED_BYTE, true, 0, 0);
        this.gl.vertexAttribDivisor(3, 1);
        // 4: Alpha (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.enableVertexAttribArray(4);
        this.gl.vertexAttribPointer(4, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(4, 1);
        // 5: Decay (Dynamic Instance, Uint8 -> Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.enableVertexAttribArray(5);
        this.gl.vertexAttribPointer(5, 1, this.gl.UNSIGNED_BYTE, false, 0, 0);
        this.gl.vertexAttribDivisor(5, 1);
        // 6: Glow (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.enableVertexAttribArray(6);
        this.gl.vertexAttribPointer(6, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(6, 1);
        // 7: Mix (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.enableVertexAttribArray(7);
        this.gl.vertexAttribPointer(7, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(7, 1);
        // 8: NextChar (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.enableVertexAttribArray(8);
        this.gl.vertexAttribPointer(8, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(8, 1);
        this.gl.bindVertexArray(null);
    }
    _drawFullscreenTexture(texture, opacity, blurAmt) {
        if (!this.bloomProgram) return;
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [1.0, 0.0, 0.0, 0.0, 0.0];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), 1);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    _runBlur(sourceTex, horizontal, strength, width, height, opacity = 1.0) {
        if (!this.bloomProgram) return;
        this.gl.disable(this.gl.BLEND);
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, sourceTex);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), strength);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), horizontal ? 1 : 0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    render(frame) {
        if (!this.posBuffer || this.fboWidth === 0) return; 
        const { state: s, derived: d } = this.config;
        const grid = this.grid;
        const activeFonts = d.activeFonts;
        const gl = this.gl;
        gl.enable(gl.BLEND);
        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        // --- ATLAS UPDATE ---
        const font = activeFonts[0];
        if (!font) return;
        let atlas = this.glyphAtlases.get(font.name);
        if (!atlas) {
            atlas = new GlyphAtlas(this.config, font.name, font.chars);
            this.glyphAtlases.set(font.name, atlas);
        } else {
            atlas.fontName = font.name; 
        }
        if (this.needsAtlasUpdate || atlas.needsUpdate) atlas.update();
        if (!atlas.glTexture || atlas.needsFullUpdate) {
            // Full Upload (Initial or Resize)
            if (!atlas.glTexture) atlas.glTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            // Re-apply parameters in case it's a new texture
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
            atlas.resetChanges();
        } else if (atlas.dirtyRects.length > 0) {
            // Incremental Update
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            for (const rect of atlas.dirtyRects) {
                this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, rect.x, rect.y, this.gl.RGBA, this.gl.UNSIGNED_BYTE, rect.data);
            }
            atlas.resetChanges();
        }
        this.needsAtlasUpdate = false;
        // --- MERGE & MAP ---
        const totalCells = grid.cols * grid.rows;
        if (this.mappedChars.length !== totalCells) return;
        const gChars = grid.chars;
        const gNext = grid.nextChars;
        const gSecChars = grid.secondaryChars;
        const gColors = grid.colors;
        const gAlphas = grid.alphas;
        const gDecays = grid.decays;
        const gGlows = grid.glows;
        const gMix = grid.mix;
        const gMode = grid.renderMode;
        const gEnvGlows = grid.envGlows;
        const ovActive = grid.overrideActive;
        const ovChars = grid.overrideChars;
        const ovColors = grid.overrideColors;
        const ovAlphas = grid.overrideAlphas;
        const ovGlows = grid.overrideGlows;
        const ovNextChars = grid.overrideNextChars;
        const effActive = grid.effectActive;
        const effChars = grid.effectChars;
        const effColors = grid.effectColors;
        const effAlphas = grid.effectAlphas;
        const effGlows = grid.effectGlows;
        const lookup = atlas.codeToId;
        const mChars = this.mappedChars;
        const mNext = this.mappedNextChars;
        const uColors = this.uploadColors;
        const uAlphas = this.uploadAlphas;
        const uDecays = this.uploadDecays;
        const uGlows = this.uploadGlows;
        const uMix = this.uploadMix;
        const mapChar = (c) => {
            if (c <= 32) return 0;
            let id = lookup[c];
            if (id === -1) {
                const rect = atlas.addChar(String.fromCharCode(c));
                id = rect ? rect.id : 0;
            }
            return id;
        };
        for (let i = 0; i < totalCells; i++) {
            // PRIORITY 1: PASSIVE EFFECT (Pulse, etc.)
            if (effActive && effActive[i]) {
                if (effActive[i] === 3) {
                    // SHADOW MODE
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = gColors[i];
                    uAlphas[i] = 1.0; // Force full alpha, let ovAlpha handle opacity
                    uDecays[i] = gDecays[i];
                    uGlows[i] = 0.0; // Disable glow for shadowboxes
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 5.0 + eAlpha; 
                    mNext[i] = 0;
                    continue;
                }
                if (effActive[i] === 2) {
                    // OVERLAY MODE: Draw Sim + White Effect
                    // 1. Load Simulation
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = effColors[i]; // Use effect-provided color (allows dimming)
                    uAlphas[i] = gAlphas[i];
                    uDecays[i] = gDecays[i];
                    uGlows[i] = gGlows[i] + effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    // 2. Load Effect
                    mNext[i] = mapChar(effChars[i]);
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 4.0 + eAlpha; 
                    continue;
                }
                if (effActive[i] === 4) {
                    // HIGH PRIORITY OVERRIDE (Superman/Lightning)
                    // Behaves like Standard Override but sets Mix >= 10.0 to signal "Ignore Shadow"
                    mChars[i] = mapChar(effChars[i]);
                    uColors[i] = effColors[i];
                    uAlphas[i] = effAlphas[i];
                    uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    uDecays[i] = 0; 
                    uMix[i] = 10.0; // Signal Value
                    mNext[i] = 0;
                    continue;
                }
                // STANDARD OVERRIDE (Replace)
                mChars[i] = mapChar(effChars[i]);
                uColors[i] = effColors[i];
                uAlphas[i] = effAlphas[i];
                uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                // Force "Solid" render behavior for effects to prevent simulation fading
                uDecays[i] = 0; 
                uMix[i] = 0.0; // Treat as solid/override in shader
                mNext[i] = 0;
                continue; 
            }
            // PRIORITY 2: HARD OVERRIDE (Deja Vu, etc.)
            // These usually indicate a logic change or interruption.
            const ov = ovActive[i];
            if (ov) {
                if (ov === 2) { // SOLID
                    mChars[i] = 0;
                    mNext[i] = 0;
                    uMix[i] = 3.0; // Trigger SOLID mode in shader
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = (gEnvGlows ? gEnvGlows[i] : 0);
                } else { // CHAR (Mode 1) or FULL (Mode 3)
                    mChars[i] = mapChar(ovChars[i]);
                    const mode = gMode[i];
                    if (mode === 1) { // OVERLAP
                        mNext[i] = mapChar(gSecChars[i]);
                        uMix[i] = 2.0; 
                    } else {
                        mNext[i] = 0;
                        uMix[i] = 0;
                    }
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = ovGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    if (ov === 3) {
                         // FULL OVERRIDE: Use Override Mix (New World state)
                         const mixVal = grid.overrideMix[i];
                         uMix[i] = mixVal;
                         if (mixVal > 0) {
                             mNext[i] = mapChar(ovNextChars[i]);
                         }
                    } else {
                         // CHAR OVERRIDE: Inherit Main Mix (Old World state)
                         if (gMix[i] > 0) {
                             uMix[i] = gMix[i];
                         }
                    }
                }
                continue;
            }
            // PRIORITY 3: STANDARD SIMULATION
            // Check for Glimmer (mix >= 30.0) which uses effectChars for non-destructive cycling
            const mix = gMix[i];
            let c = gChars[i];
            if (mix >= 30.0) {
                // Use visual override from effectChars if available
                const ec = effChars[i];
                if (ec > 0) c = ec;
            }
            mChars[i] = mapChar(c);
            uColors[i] = gColors[i];
            uAlphas[i] = gAlphas[i];
            uDecays[i] = gDecays[i];
            uGlows[i] = gGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
            const mode = gMode[i];
            if (mode === 1) { // OVERLAP
                mNext[i] = mapChar(gSecChars[i]);
                uMix[i] = 2.0; 
            } else {
                uMix[i] = mix;
                if (mix > 0) {
                    mNext[i] = mapChar(gNext[i]);
                } else {
                    mNext[i] = 0;
                }
            }
        }
        if (atlas.hasChanges) {
             this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
             this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
             atlas.resetChanges();
        }
        // --- UPLOAD ---
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mChars);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uColors);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uAlphas);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uDecays);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uGlows);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uMix);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mNext);
        // --- SHADOW MASK PASS ---
        // Render Shadow Masks from Effects (Generic)
        if (this.fboWidth > 0 && this.fboHeight > 0) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.shadowMaskFbo);
            this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
            this.gl.colorMask(true, true, true, true); // Ensure writes are enabled
            this.gl.clearColor(0, 0, 0, 0); 
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            // Collect Masks from All Active Effects
            let masks = [];
            if (this.effects) {
                 // Support both Array and Map structures for EffectRegistry
                 const effectList = (Array.isArray(this.effects.effects)) 
                    ? this.effects.effects 
                    : (this.effects.effects instanceof Map) 
                        ? Array.from(this.effects.effects.values()) 
                        : (typeof this.effects.get === 'function' && typeof this.effects.getAll === 'function') // Handle registry with getters
                            ? this.effects.getAll() // Assuming a getAll exists, or fallback to iterating specific known effects if not
                            : []; 
                 // If getAll doesn't exist, we might need to rely on the Map iterator if effects.effects is private.
                 // However, let's assume standard iteration is possible.
                 // Fallback: If effects.effects is a Map, use values().
                 const iterable = (this.effects.effects instanceof Map) ? this.effects.effects.values() : effectList;
                 for (const effect of iterable) {
                     if (effect.active) {
                         // Check for CrashEffect legacy support or new Generic Interface
                         if (effect.name === 'CrashSequence' && effect.blackSheets) {
                             // Legacy/Specific Support for CrashEffect
                             for (const s of effect.blackSheets) {
                                 masks.push({
                                     x: s.posX, y: s.posY, w: s.w, h: s.h,
                                     alpha: s.currentAlpha * s.maxAlpha,
                                     blur: (s.blur !== undefined) ? s.blur : 0.0 // Default to 0 for Crash
                                 });
                             }
                         }
                         // Future Generic Interface: getMasks()
                         if (typeof effect.getMasks === 'function') {
                             const effectMasks = effect.getMasks();
                             if (Array.isArray(effectMasks)) {
                                 masks.push(...effectMasks);
                             }
                         }
                     }
                 }
            }
            if (masks.length > 0 && this.shadowInstanceBuffer) {
                this.gl.useProgram(this.shadowProgram);
                // Upload Instance Data (x, y, w, h, alpha, blur) - 6 floats
                const count = masks.length;
                if (!this.shadowData || this.shadowData.length < count * 6) {
                    this.shadowData = new Float32Array(count * 6 * 2); 
                }
                const data = this.shadowData;
                for (let i=0; i<count; i++) {
                    const m = masks[i];
                    data[i*6+0] = m.x;
                    data[i*6+1] = m.y;
                    data[i*6+2] = m.w;
                    data[i*6+3] = m.h;
                    data[i*6+4] = m.alpha;
                    data[i*6+5] = (m.blur !== undefined) ? m.blur : 0.2; // Default blur if missing
                }
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // 6 floats * 4 bytes = 24 bytes per instance
                const stride = 24;
                if (count > this.shadowInstanceCapacity) {
                     this.shadowInstanceCapacity = Math.max(count, this.shadowInstanceCapacity * 2);
                     this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * stride, this.gl.DYNAMIC_DRAW);
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                } else {
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                }
                // Setup Attributes
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // a_rect (vec4)
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, stride, 0);
                this.gl.vertexAttribDivisor(1, 1);
                // a_alpha (float)
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 1, this.gl.FLOAT, false, stride, 16);
                this.gl.vertexAttribDivisor(2, 1);
                // a_blur (float)
                this.gl.enableVertexAttribArray(3);
                this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, stride, 20);
                this.gl.vertexAttribDivisor(3, 1);
                this.gl.uniform2f(this.gl.getUniformLocation(this.shadowProgram, 'u_gridSize'), grid.cols, grid.rows);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, count);
                this.gl.vertexAttribDivisor(1, 0);
                this.gl.vertexAttribDivisor(2, 0);
                this.gl.vertexAttribDivisor(3, 0);
                this.gl.disableVertexAttribArray(1);
                this.gl.disableVertexAttribArray(2);
                this.gl.disableVertexAttribArray(3);
            }
            // --- REVEAL PUNCH-OUT PASS (Subtract Alpha) ---
            // Only necessary if we have drawn shadows
            if (typeof masks !== 'undefined' && masks && masks.length > 0 && this.effects) {
                let crash = null;
                // Locate CrashEffect
                if (Array.isArray(this.effects.effects)) {
                     crash = this.effects.effects.find(e => e.name === 'CrashSequence');
                } else if (this.effects.effects instanceof Map) {
                     crash = this.effects.effects.get('CrashSequence');
                } else if (typeof this.effects.get === 'function') {
                     crash = this.effects.get('CrashSequence');
                }
                if (crash && crash.active && typeof crash.getReveals === 'function') {
                    const reveals = crash.getReveals();
                    if (reveals.length > 0) {
                        // Use Color Program to draw fading triangles
                        this.gl.useProgram(this.colorProgram);
                        // Punch-out blend mode: DestAlpha = DestAlpha * (1 - SrcAlpha)
                        // Src = (0,0,0, RevealAlpha)
                        this.gl.blendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_ALPHA);
                        if (!this.revealBuffer) {
                            this.revealBuffer = this.gl.createBuffer();
                        }
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.revealBuffer);
                        // Enable Position Attribute (Location 0 in colorProgram)
                        this.gl.enableVertexAttribArray(0);
                        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                        const cols = grid.cols;
                        const rows = grid.rows;
                        // Buffer for batching vertices
                        // Estimate size: 50 reveals * 100 segments * 6 verts * 2 coords = ~60k floats
                        // Just allocate dynamically per frame or reuse a large buffer.
                        // For simplicity/safety in this refactor, let's process per reveal and use bufferData.
                        for (const r of reveals) {
                            const alpha = r.alpha;
                            if (alpha <= 0.01) continue;
                            this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), 0, 0, 0, alpha);
                            let vertices = null;
                            if (r.type === 'rects' && r.rects) {
                                const count = r.rects.length;
                                if (count > 0) {
                                    const data = new Float32Array(count * 6 * 2);
                                    let ptr = 0;
                                    for (const rect of r.rects) {
                                        const x1 = (rect.x / cols) * 2.0 - 1.0;
                                        const y1 = (rect.y / rows) * 2.0 - 1.0; 
                                        const x2 = ((rect.x + rect.w) / cols) * 2.0 - 1.0;
                                        const y2 = ((rect.y + rect.h) / rows) * 2.0 - 1.0;
                                        // Triangle 1
                                        data[ptr++] = x1; data[ptr++] = y1;
                                        data[ptr++] = x2; data[ptr++] = y1;
                                        data[ptr++] = x1; data[ptr++] = y2;
                                        // Triangle 2
                                        data[ptr++] = x2; data[ptr++] = y1;
                                        data[ptr++] = x2; data[ptr++] = y2;
                                        data[ptr++] = x1; data[ptr++] = y2;
                                    }
                                    vertices = data;
                                }
                            }
                            else if (r.type === 'strip' && r.trunk && r.branch) {
                                // Draw Triangle Strip between Trunk and Branch
                                const len = Math.min(r.trunk.length, r.branch.length);
                                if (len < 2) continue;
                                // 2 triangles per segment * (len-1) segments * 3 verts * 2 coords
                                const data = new Float32Array((len - 1) * 6 * 2);
                                let ptr = 0;
                                for (let i = 0; i < len - 1; i++) {
                                    // Points in Grid Space
                                    const t1 = r.trunk[i];
                                    const t2 = r.trunk[i+1];
                                    const b1 = r.branch[i];
                                    const b2 = r.branch[i+1];
                                    // Convert to Clip Space
                                    // X: 0..cols -> -1..1
                                    // Y: 0..rows -> -1..1
                                    const ax = (t1.x / cols) * 2.0 - 1.0; const ay = (t1.y / rows) * 2.0 - 1.0;
                                    const bx = (t2.x / cols) * 2.0 - 1.0; const by = (t2.y / rows) * 2.0 - 1.0;
                                    const cx = (b1.x / cols) * 2.0 - 1.0; const cy = (b1.y / rows) * 2.0 - 1.0;
                                    const dx = (b2.x / cols) * 2.0 - 1.0; const dy = (b2.y / rows) * 2.0 - 1.0;
                                    // Triangle 1: t1, t2, b1
                                    data[ptr++] = ax; data[ptr++] = ay;
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                    // Triangle 2: t2, b2, b1
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = dx; data[ptr++] = dy;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                }
                                vertices = data;
                            } 
                            // Legacy/Fallback Triangle support (if needed, though we moved to strip)
                            else if (r.p1 && r.p2 && r.p3) {
                                const x1 = (r.p1.x / cols) * 2.0 - 1.0; const ay = (r.p1.y / rows) * 2.0 - 1.0;
                                const x2 = (r.p2.x / cols) * 2.0 - 1.0; const by = (r.p2.y / rows) * 2.0 - 1.0;
                                const x3 = (r.p3.x / cols) * 2.0 - 1.0; const cy = (r.p3.y / rows) * 2.0 - 1.0;
                                vertices = new Float32Array([x1, ay, x2, by, x3, cy]);
                            }
                            if (vertices) {
                                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
                                this.gl.drawArrays(this.gl.TRIANGLES, 0, vertices.length / 2);
                            }
                        }
                    }
                }
            }
        }
        // --- DRAW ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA);
        this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
        // 1. Trail Fade (Draw Black Quad)
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        if (this.colorProgram) {
            this.gl.useProgram(this.colorProgram);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
            this.gl.enableVertexAttribArray(0); 
            this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
            // Apply Background Color for Fade
            const br = d.bgRgb ? d.bgRgb.r / 255.0 : 0.0;
            const bg = d.bgRgb ? d.bgRgb.g / 255.0 : 0.0;
            const bb = d.bgRgb ? d.bgRgb.b / 255.0 : 0.0;
            this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), br, bg, bb, s.clearAlpha);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        // 2. Draw Cells
        // Determine Program based on mode
        const activeProgram = this.program2D;
        this.gl.useProgram(activeProgram);
        // --- Shared Uniforms ---
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_resolution'), this.w, this.h);
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_atlasSize'), atlas.canvas.width, atlas.canvas.height);
        // Calculate Grid Size in Pixels for Centering
        const gridPixW = grid.cols * d.cellWidth;
        const gridPixH = grid.rows * d.cellHeight;
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_gridSize'), gridPixW, gridPixH);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_cellSize'), atlas.cellSize);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_cols'), atlas._lastCols);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_decayDur'), s.decayFadeDurationFrames);
        // Grid Layout Stretch
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_stretch'), s.stretchX, s.stretchY);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_mirror'), s.mirrorEnabled ? -1.0 : 1.0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_texture'), 0);
        // Bind Shadow Mask
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.shadowMaskTex);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_shadowMask'), 1);
        // Bind Glimmer Optimization Texture
        this.gl.activeTexture(this.gl.TEXTURE2);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.glimmerTexture);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_glimmerNoise'), 2);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_time'), performance.now() / 1000.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveEnabled'), s.dissolveEnabled ? 1.0 : 0.0);
        // Decoupled: Shader blink speed is constant, Slider controls Char Cycle speed
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerSpeed'), s.upwardTracerGlimmerSpeed || 1.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerSize'), s.upwardTracerGlimmerSize || 3.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerFill'), s.upwardTracerGlimmerFill || 3.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerIntensity'), s.upwardTracerGlimmerGlow || 10.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerFlicker'), s.upwardTracerGlimmerFlicker !== undefined ? s.upwardTracerGlimmerFlicker : 0.5);
        // Calculate Cell Scale (Aspect Ratio Correction)
        const scaleMult = 1.0;
        const cellScaleX = (d.cellWidth / atlas.cellSize) * scaleMult;
        const cellScaleY = (d.cellHeight / atlas.cellSize) * scaleMult;
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_cellScale'), cellScaleX, cellScaleY);
        // Target Scale: 1.0 + percent/100. e.g. -20% -> 0.8
        const percent = s.dissolveScalePercent !== undefined ? s.dissolveScalePercent : -20;
        const dissolveScale = s.dissolveEnabled ? (1.0 + (percent / 100.0)) : 1.0;
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveScale'), dissolveScale);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveSize'), s.dissolveMinSize || 1.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_deteriorationEnabled'), s.deteriorationEnabled ? 1.0 : 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_deteriorationStrength'), s.deteriorationStrength);
        // Pass Overlap Color
        const ovRgb = Utils.hexToRgb(s.overlapColor || "#FFD700");
        this.gl.uniform4f(this.gl.getUniformLocation(activeProgram, 'u_overlapColor'), ovRgb.r/255.0, ovRgb.g/255.0, ovRgb.b/255.0, 1.0);
        this.gl.bindVertexArray(this.vao);
        // Ensure blending is enabled for the main draw
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        // Draw Main Pass
        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, totalCells);
        this.gl.bindVertexArray(null);
        // --- POST PROCESS (Bloom) ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        const br = d.bgRgb ? d.bgRgb.r / 255.0 : 0.0;
        const bg = d.bgRgb ? d.bgRgb.g / 255.0 : 0.0;
        const bb = d.bgRgb ? d.bgRgb.b / 255.0 : 0.0;
        this.gl.clearColor(br, bg, bb, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        const blurAmt = s.smoothingEnabled ? s.smoothingAmount : 0;
        this._drawFullscreenTexture(this.texA, 1.0, blurAmt);
        if (s.enableBloom) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
            this.gl.viewport(0, 0, this.bloomWidth, this.bloomHeight);
            let spread = s.bloomStrength * 1.0; 
            this._runBlur(this.texA, true, spread, this.fboWidth, this.fboHeight); 
            const iterations = 3;
            for (let i = 0; i < iterations; i++) {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboC);
                this._runBlur(this.texB, false, spread, this.bloomWidth, this.bloomHeight);
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
                this._runBlur(this.texC, true, spread, this.bloomWidth, this.bloomHeight);
            }
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE); 
            this._drawFullscreenTexture(this.texB, s.bloomOpacity, 0);
        }
        if (this.postProcessor) {
            const customSource = s.shaderEnabled ? s.customShader : null;
            const effectSource = s.effectShader;
            // Compile Custom Shader if changed
            if (customSource !== this.lastShaderSource) {
                this.postProcessor.compileShader(customSource);
                this.lastShaderSource = customSource;
            }
            // Compile Effect Shader if changed
            if (effectSource !== this.lastEffectSource) {
                this.postProcessor.compileEffectShader(effectSource);
                this.lastEffectSource = effectSource;
            }
            const isActive = (s.shaderEnabled && customSource) || effectSource;
            if (isActive) {
                const param = s.shaderParameter !== undefined ? s.shaderParameter : 0.5;
                const effectParam = s.effectParameter !== undefined ? s.effectParameter : 0.0;
                this.postProcessor.render(this.cvs, performance.now() / 1000, this.mouseX, this.mouseY, param, effectParam);
                if (this.postProcessor.canvas.style.display === 'none') {
                    this.postProcessor.canvas.style.display = 'block';
                    this.cvs.style.opacity = '0'; 
                }
            } else {
                if (this.postProcessor.canvas.style.display !== 'none') {
                    this.postProcessor.canvas.style.display = 'none';
                    this.cvs.style.opacity = '1';
                }
            }
        }
    }
}
// --- SimulationSystem.js ---
class SimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        // --- Web Worker Support ---
        this.worker = null;
        this.useWorker = false;
        this.workerBuffers = null; // Store current SABs
        // Check for SharedArrayBuffer support
        // Note: functionality requires secure context (HTTPS/localhost) and cross-origin isolation headers.
        if (typeof SharedArrayBuffer !== 'undefined') {
            try {
                // Test creation
                new SharedArrayBuffer(10);
                this.useWorker = true;
                console.log("[SimulationSystem] SharedArrayBuffer supported. Initializing Simulation Worker.");
            } catch (e) {
                console.warn("[SimulationSystem] SharedArrayBuffer defined but creation failed. Fallback to main thread.", e);
            }
        } else {
             console.log("[SimulationSystem] SharedArrayBuffer not supported. Fallback to main thread.");
        }
        if (this.useWorker) {
            this._initWorker();
            // Intercept Grid Resize to manage Shared Memory
            // This ensures MatrixKernel calls to grid.resize() trigger our memory management
            const originalResize = this.grid.resize.bind(this.grid);
            this.grid.resize = (width, height) => {
                // 1. Calculate Dimensions (Copied logic from CellGrid to know size)
                const d = this.config.derived;
                if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
                const cols = Math.max(1, (width / d.cellWidth) | 0);
                const rows = Math.max(1, (height / d.cellHeight) | 0);
                const total = cols * rows;
                // 2. Allocate Shared Buffers
                this.workerBuffers = this._createSharedBuffers(total);
                // 3. Resize Grid using Shared Buffers
                originalResize(width, height, this.workerBuffers);
                // 4. Update Worker
                this.worker.postMessage({
                    type: 'resize',
                    width: width,
                    height: height,
                    buffers: this.workerBuffers,
                    config: {
                        state: JSON.parse(JSON.stringify(this.config.state)),
                        derived: this.config.derived // Derived often has getters, ensure it's serializable or plain object?
                        // ConfigurationManager.derived is usually a proxy or object. 
                        // We might need to extract values if it's a Proxy.
                        // Assuming standard object for now or that structuredClone handles it.
                    }
                });
            };
        }
        this.streamManager = new StreamManager(grid, config);
        this.glowSystem = new GlowSystem(grid);
        this.grid.glowSystem = this.glowSystem; 
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.timeScale = 1.0;
        // Subscribe to config changes to keep worker in sync
        if (this.useWorker) {
            this.config.subscribe((key) => {
                // Simple sync: send entire state on change. Optimized? No. Robust? Yes.
                // We avoid sending on 'resolution' changes here because 'resize' handles that.
                if (key !== 'resolution' && key !== 'stretchX' && key !== 'stretchY') {
                    this.worker.postMessage({
                        type: 'config',
                        config: {
                            state: JSON.parse(JSON.stringify(this.config.state)),
                            derived: this.config.derived
                        }
                    });
                }
            });
        }
    }
    _initWorker() {
        const embeddedWorker = document.getElementById('simulation-worker-source');
        if (embeddedWorker) {
            console.log("[SimulationSystem] Using embedded worker source.");
            const blob = new Blob([embeddedWorker.textContent], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            this.worker = new Worker(workerUrl);
        } else {
            console.log("[SimulationSystem] Using external worker file.");
            this.worker = new Worker('js/simulation/SimulationWorker.js');
        }
        this.worker.onmessage = (e) => {
            // Handle messages from worker (e.g., debug logs, sync ticks)
            if (e.data.type === 'log') console.log('[Worker]', e.data.message);
        };
        // Initial setup message will be sent by the first resize() call 
        // which happens immediately in MatrixKernel.initAsync()
    }
    _createSharedBuffers(total) {
        // Helper to create a specific typed array view on a SAB
        const createSAB = (bytes) => new SharedArrayBuffer(bytes);
        // Align to 4 bytes for safety/performance
        const uint8Size = total;
        const uint16Size = total * 2;
        const uint32Size = total * 4;
        const float32Size = total * 4;
        const int32Size = total * 4;
        const buffers = {
            state: new Uint8Array(createSAB(uint8Size)),
            chars: new Uint16Array(createSAB(uint16Size)),
            colors: new Uint32Array(createSAB(uint32Size)),
            baseColors: new Uint32Array(createSAB(uint32Size)),
            alphas: new Float32Array(createSAB(float32Size)),
            glows: new Float32Array(createSAB(float32Size)),
            fontIndices: new Uint8Array(createSAB(uint8Size)),
            secondaryChars: new Uint16Array(createSAB(uint16Size)),
            secondaryColors: new Uint32Array(createSAB(uint32Size)),
            secondaryAlphas: new Float32Array(createSAB(float32Size)),
            secondaryGlows: new Float32Array(createSAB(float32Size)),
            secondaryFontIndices: new Uint8Array(createSAB(uint8Size)),
            mix: new Float32Array(createSAB(float32Size)),
            renderMode: new Uint8Array(createSAB(uint8Size)),
            overrideActive: new Uint8Array(createSAB(uint8Size)),
            overrideChars: new Uint16Array(createSAB(uint16Size)),
            overrideColors: new Uint32Array(createSAB(uint32Size)),
            overrideAlphas: new Float32Array(createSAB(float32Size)),
            overrideGlows: new Float32Array(createSAB(float32Size)),
            overrideMix: new Float32Array(createSAB(float32Size)),
            overrideNextChars: new Uint16Array(createSAB(uint16Size)),
            overrideFontIndices: new Uint8Array(createSAB(uint8Size)),
            effectActive: new Uint8Array(createSAB(uint8Size)),
            effectChars: new Uint16Array(createSAB(uint16Size)),
            effectColors: new Uint32Array(createSAB(uint32Size)),
            effectAlphas: new Float32Array(createSAB(float32Size)),
            effectFontIndices: new Uint8Array(createSAB(uint8Size)),
            effectGlows: new Float32Array(createSAB(float32Size)),
            types: new Uint8Array(createSAB(uint8Size)),
            decays: new Uint8Array(createSAB(uint8Size)),
            ages: new Int32Array(createSAB(int32Size)),
            brightness: new Float32Array(createSAB(float32Size)),
            rotatorOffsets: new Uint8Array(createSAB(uint8Size)),
            cellLocks: new Uint8Array(createSAB(uint8Size)),
            nextChars: new Uint16Array(createSAB(uint16Size)),
            nextOverlapChars: new Uint16Array(createSAB(uint16Size)),
            envGlows: new Float32Array(createSAB(float32Size))
        };
        return buffers;
    }
    update(frame) {
        if (this.useWorker && this.worker) {
            // Offload to Worker
            this.worker.postMessage({
                type: 'update',
                frame: frame
            });
            // Main thread does NOTHING for simulation logic
            // It just renders whatever is in the SharedBuffers
        } else {
            // Fallback: Local Logic
            this.streamManager.update(frame, this.timeScale);
            this._manageOverlapGrid(frame);
            this._updateCells(frame, this.timeScale);
            // Local Glimmer Lifecycle (Copy-paste logic from Worker/Original)
            this._updateGlimmerLifecycle();
            if (this.grid.envGlows) this.grid.envGlows.fill(0);
            this.glowSystem.update();
            this.glowSystem.apply();
            if (this.grid.cellLocks) this.grid.cellLocks.fill(0);
        }
    }
    _updateGlimmerLifecycle() {
        const s = this.config.state;
        const d = this.config.derived;
        // We iterate over a copy of keys to safely mutate the map during iteration (for movement)
        const indices = Array.from(this.grid.complexStyles.keys());
        for (const idx of indices) {
            const style = this.grid.complexStyles.get(idx);
            if (!style) continue;
            // Pause Glimmer updates if cell is frozen by an effect (e.g. Pulse Pause)
            if (this.grid.effectActive[idx] !== 0 || this.grid.overrideActive[idx] !== 0) continue;
            // --- TYPE 1: STANDARD GLIMMER (Upward Tracers) ---
            if (style.type === 'glimmer') {
                // Initialize Mobility (One-time)
                if (style.mobile === undefined) {
                    // 20% chance to be a "Moving" glimmer
                    if (Math.random() < 0.2) {
                        style.mobile = true;
                        // Move every 4-8 frames
                        style.moveInterval = Utils.randomInt(4, 8);
                        style.nextMove = style.age + style.moveInterval;
                        // Direction: Strictly Up (-1)
                        style.moveDir = -1; 
                    } else {
                        style.mobile = false;
                    }
                }
                const attack = s.upwardTracerAttackFrames;
                const hold = s.upwardTracerHoldFrames;
                const release = s.upwardTracerReleaseFrames;
                const totalDuration = attack + hold + release;
                style.age++;
                const activeAge = style.age - 1;
                // --- Vertical Movement Logic ---
                let currentIdx = idx;
                if (style.mobile && activeAge >= style.nextMove && activeAge < totalDuration) {
                    const col = currentIdx % this.grid.cols;
                    const row = Math.floor(currentIdx / this.grid.cols);
                    const nextRow = row + style.moveDir;
                    if (nextRow >= 0 && nextRow < this.grid.rows) {
                        const nextIdx = currentIdx + (style.moveDir * this.grid.cols);
                        // Only move if target is not already a glimmer or locked
                        if (!this.grid.complexStyles.has(nextIdx)) {
                            // Move State
                            this.grid.complexStyles.set(nextIdx, style);
                            this.grid.complexStyles.delete(currentIdx);
                            // Move Mix Value
                            this.grid.mix[nextIdx] = this.grid.mix[currentIdx];
                            this.grid.mix[currentIdx] = 0;
                            // Move Effect Char (if any, though we forced 0 below, but good practice)
                            this.grid.effectChars[nextIdx] = this.grid.effectChars[currentIdx];
                            this.grid.effectChars[currentIdx] = 0;
                            currentIdx = nextIdx;
                            style.nextMove = activeAge + style.moveInterval;
                        }
                    }
                }
                // Ensure we use the underlying character (Visual Highlight Only)
                this.grid.effectChars[currentIdx] = 0;
                // --- Lifecycle / Fade Logic ---
                let alpha = 0.0;
                if (activeAge <= attack) {
                    alpha = (attack > 0) ? (activeAge / attack) : 1.0;
                } else if (activeAge <= attack + hold) {
                    alpha = 1.0;
                } else if (activeAge <= totalDuration) {
                    const releaseAge = activeAge - (attack + hold);
                    alpha = (release > 0) ? (1.0 - (releaseAge / release)) : 0.0;
                }
                if (activeAge <= totalDuration) {
                    // Keep alive even if alpha is 0 (start of attack)
                    this.grid.mix[currentIdx] = 30.0 + alpha;
                } else {
                    this.grid.mix[currentIdx] = 0;
                    this.grid.complexStyles.delete(currentIdx);
                }
            }
        }
    }
    _manageOverlapGrid(frame) {
        const s = this.config.state;
        if (!s.overlapEnabled) {
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                if (this.grid.secondaryChars && typeof this.grid.secondaryChars.fill === 'function') {
                    this.grid.secondaryChars.fill(32); 
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = s.overlapDensity;
        const ovRgb = Utils.hexToRgb(s.overlapColor);
        const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
        const setOverlapChar = (i) => {
            let fIdx;
            if (this.grid.types[i] === CELL_TYPE.EMPTY) {
                fIdx = Math.floor(Math.random() * numFonts);
            } else {
                fIdx = this.grid.fontIndices[i];
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            let code = 32;
            if (chars && chars.length > 0) {
                const r = Math.floor(Math.random() * chars.length);
                code = chars[r].charCodeAt(0);
            }
            this.grid.secondaryChars[i] = code;
            this.grid.secondaryColors[i] = ovColor;
        };
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            const N = this.grid.secondaryChars.length;
            for (let i = 0; i < N; i++) {
                // If cell is overridden (e.g. Pulse Freeze), do not change secondary char
                if (this.grid.overrideActive[i] !== 0) continue;
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.secondaryChars[i] = 32; 
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _updateCells(frame, timeScale = 1.0) {
        // Pause simulation updates if time is stopped or reversed
        if (timeScale <= 0) return;
        // Slow Motion: Probabilistic update for integer-based counters
        if (timeScale < 1.0) {
            if (Math.random() > timeScale) return;
        }
        const s = this.config.state;
        const d = this.config.derived;
        const grid = this.grid;
        for (const idx of grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const grid = this.grid;
        if (grid.cellLocks && grid.cellLocks[idx] === 1) return;
        // If an effect is overriding this cell, pause simulation updates (Freeze)
        if (grid.overrideActive[idx] !== 0) return;
        const decay = grid.decays[idx];
        if (decay === 0) return;
        let age = grid.ages[idx];
        if (age > 0) {
            age = this._incrementAge(age, d.maxState);
            grid.ages[idx] = age;
        }
        // --- TRACER COLOR FADE ---
        // Transitions from Tracer Color -> Stream Color based on Age
        // Only apply if NOT decaying (Erasers trigger decay)
        const isTracer = (grid.types[idx] === CELL_TYPE.TRACER || grid.types[idx] === CELL_TYPE.ROTATOR);
        const isUpward = (grid.types[idx] === CELL_TYPE.UPWARD_TRACER);
        if (decay < 2 && isTracer) {
            const attack = s.tracerAttackFrames;
            const hold = s.tracerHoldFrames;
            const release = s.tracerReleaseFrames;
            const targetGlow = s.tracerGlow;
            const tracerColor = d.tracerColorUint32;
            const baseColor = grid.baseColors[idx];
            let ratio = 0; // 0 = Tracer, 1 = Base
            // Age 1..Attack: Fade In (Alpha handles this, color stays Tracer)
            // Attack..Attack+Hold: Hold Tracer Color
            // Attack+Hold..End: Fade to Stream Color
            const activeAge = age - 1;
            if (s.gradualColorStreams && !isUpward) {
                // Gradual Fade: Linearly interpolate over a long distance (e.g. 45 chars/frames)
                // Starts fading immediately after attack+hold
                const fadeStart = attack + hold;
                const fadeLen = 45.0; 
                if (activeAge > fadeStart) {
                    ratio = Math.min(1.0, (activeAge - fadeStart) / fadeLen);
                }
            } else {
                // Standard Logic
                if (activeAge > attack + hold) {
                    if (release > 0) {
                        ratio = Math.min(1.0, (activeAge - (attack + hold)) / release);
                    } else {
                        ratio = 1.0;
                    }
                }
            }
            if (ratio >= 1.0) {
                grid.colors[idx] = baseColor;
                grid.glows[idx] = 0; // Remove glow after transition
                // Only clear Glimmer (high mix values)
                // Rotators use mix 0..1, so preserve values < 2.0
                if (grid.mix[idx] >= 2.0) grid.mix[idx] = 0; 
            } else if (ratio > 0) {
                // Blend
                const tR = tracerColor & 0xFF;
                const tG = (tracerColor >> 8) & 0xFF;
                const tB = (tracerColor >> 16) & 0xFF;
                const bR = baseColor & 0xFF;
                const bG = (baseColor >> 8) & 0xFF;
                const bB = (baseColor >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * ratio);
                const mG = Math.floor(tG + (bG - tG) * ratio);
                const mB = Math.floor(tB + (bB - tB) * ratio);
                grid.colors[idx] = Utils.packAbgr(mR, mG, mB);
                grid.glows[idx] = targetGlow * (1.0 - ratio);
            } else {
                // Hold Tracer
                grid.colors[idx] = tracerColor;
                grid.glows[idx] = targetGlow;
            }
        }
        // Handle Rotator
        // Allow rotator to finish its transition (mix > 0) even if subsequently disabled
        if ((s.rotatorEnabled || grid.mix[idx] > 0) && grid.types[idx] === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        // Handle Dynamic Colors (Effects)
        if (grid.complexStyles.has(idx)) {
            const style = grid.complexStyles.get(idx);
            if (style.cycle) {
                const newHue = (style.h + style.speed) % 360;
                style.h = newHue; 
                const rgb = Utils.hslToRgb(newHue, style.s, style.l);
                grid.colors[idx] = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
            }
        }
        // Handle Decay / Alpha
        if (decay >= 2) {
            // Ensure trails are Stream Color, not Tracer Color
            let useBase = true;
            if (grid.complexStyles.has(idx)) {
                const style = grid.complexStyles.get(idx);
                if (style.cycle) useBase = false;
            }
            if (useBase) {
                if (decay === 2) { // First frame of decay
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                } else {
                    // Also enforce it in case we missed frame 2 (unlikely but safe)
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                }
            } else {
                // For cycling effects, just kill the glow
                grid.glows[idx] = 0;
            }
            grid.decays[idx]++;
            const newDecay = grid.decays[idx];
            if (this._shouldDecay(idx, newDecay, s.decayFadeDurationFrames)) {
                grid.clearCell(idx);
                return;
            }
            grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, s.decayFadeDurationFrames);
        } else {
            grid.alphas[idx] = this._calculateAlpha(idx, age, decay, s.decayFadeDurationFrames);
        }
    }
    _incrementAge(age, maxState) {
        return age + 1;
    }
    _handleRotator(idx, frame, s, d) {
        const grid = this.grid;
        const mix = grid.mix[idx]; 
        const decay = grid.decays[idx];
        if (mix > 0) {
            this._progressRotator(idx, mix, s.rotatorCrossfadeFrames);
        } else if (s.rotatorEnabled && (decay === 1 || (s.rotateDuringFade && decay > 1))) {
            this._cycleRotator(idx, frame, s.rotatorCrossfadeFrames, d.rotatorCycleFrames, s);
        }
    }
    _progressRotator(idx, currentMix, crossfadeFrames) {
        const grid = this.grid;
        const step = 1.0 / Math.max(1, crossfadeFrames);
        const newMix = currentMix + step;
        if (newMix >= 1.0) {
            const target = grid.getRotatorTarget(idx, false); 
            if (target) {
                grid.chars[idx] = target.charCodeAt(0);
                if (this.config.state.overlapEnabled) {
                    const ovTarget = grid.getRotatorTarget(idx, true);
                    if (ovTarget) {
                        grid.secondaryChars[idx] = ovTarget.charCodeAt(0);
                    }
                }
            }
            grid.mix[idx] = 0;
            // Clear rotator targets
            grid.nextChars[idx] = 0;
            grid.nextOverlapChars[idx] = 0;
        } else {
            grid.mix[idx] = newMix;
        }
    }
    _cycleRotator(idx, frame, crossfadeFrames, cycleFrames, s) {
        const grid = this.grid;
        let effectiveCycle = cycleFrames;
        if (s.rotatorDesyncEnabled) {
            const variancePercent = s.rotatorDesyncVariance / 100;
            const maxVariance = cycleFrames * variancePercent;
            const offsetNorm = (grid.rotatorOffsets[idx] / 127.5) - 1.0;
            effectiveCycle = Math.max(1, Math.round(cycleFrames + (offsetNorm * maxVariance)));
        }
        if (frame % effectiveCycle === 0) {
            const fontIdx = grid.fontIndices[idx];
            const activeFonts = this.config.derived.activeFonts;
            const fontData = activeFonts[fontIdx] || activeFonts[0];
            const charSet = fontData.chars;
            const nextChar = this._getUniqueChar(grid.getChar(idx), charSet);
            const nextCode = nextChar.charCodeAt(0);
            let nextOvCode = 0;
            if (this.config.state.overlapEnabled) {
                const curOv = String.fromCharCode(grid.secondaryChars[idx]);
                const nextOv = this._getUniqueChar(curOv, charSet);
                nextOvCode = nextOv.charCodeAt(0);
            }
            if (crossfadeFrames <= 1) {
                grid.chars[idx] = nextCode;
                if (nextOvCode) grid.secondaryChars[idx] = nextOvCode;
            } else {
                grid.mix[idx] = 0.01; 
                grid.setRotatorTarget(idx, nextChar, false);
                if (nextOvCode) {
                    grid.setRotatorTarget(idx, String.fromCharCode(nextOvCode), true);
                }
            }
        }
    }
    _getUniqueChar(exclude, charSet) {
        if (!charSet) charSet = Utils.CHARS;
        if (charSet.length <= 1) return charSet[0];
        let char;
        let attempts = 0;
        do {
            char = charSet[Math.floor(Math.random() * charSet.length)];
            attempts++;
        } while (char === exclude && attempts < 10);
        return char;
    }
    _shouldDecay(idx, decay, fadeDurationFrames) {
        return decay > fadeDurationFrames + 2;
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        const s = this.config.state;
        const b = this.grid.brightness[idx];
        // Fading OUT
        if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            // Use power curve for smoother perceived fade (starts fading sooner)
            const fade = Math.pow(Math.max(0, 1.0 - ratio), 2.0);
            return 0.95 * fade * b;
        }
        // Fading IN
        let attack = s.tracerAttackFrames;
        if (this.grid.types[idx] === CELL_TYPE.UPWARD_TRACER) {
            attack = s.upwardTracerAttackFrames;
        }
        if (age <= attack && attack > 0) {
            return 0.95 * (age / attack) * b;
        }
        // Standard State
        return 0.95 * b;
    }
}
// --- StreamManager.js ---
class StreamManager {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.activeStreams = [];
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(grid.cols).fill(null);
        this.columnSpeeds = new Float32Array(grid.cols);
        this.streamsPerColumn = new Int16Array(grid.cols); // Track active streams count
        this.modes = this._initializeModes(config);
        this.nextSpawnFrame = 0;
        // Reusable columns pool to avoid per-spawn allocation
        this._columnsPool = new Array(this.grid.cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    resize(cols) {
        this.lastStreamInColumn = new Array(cols).fill(null);
        this.lastEraserInColumn = new Array(cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(cols).fill(null);
        this.columnSpeeds = new Float32Array(cols);
        this.streamsPerColumn = new Int16Array(cols);
        this.activeStreams = [];
        // Rebuild columns pool
        this._columnsPool = new Array(cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    update(frame, timeScale) {
        // Keep columns arrays in sync with grid size if changed (safety check)
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            this.resize(this.grid.cols);
        }
        if (timeScale > 0) {
            this._manageStreams(frame, timeScale);
        } else if (timeScale < 0) {
            this._processActiveStreams(frame, timeScale);
        }
        // If timeScale == 0, pause
    }
    _manageStreams(frame, timeScale) {
        const { state: s, derived: d } = this.config;
        // Independent Glimmer Management (Runs every frame)
        this._manageGlimmer(s);
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2;
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        this._processActiveStreams(frame, timeScale);
    }
    _manageGlimmer(s) {
        if (!s.upwardTracerEnabled || s.upwardTracerChance <= 0) return;
        // 1. Calculate Active Density per Column
        const colCounts = new Uint8Array(this.grid.cols);
        for (let i = 0; i < this.activeStreams.length; i++) {
            const stream = this.activeStreams[i];
            if (stream.isUpward && stream.active) {
                colCounts[stream.x]++;
            }
        }
        // 2. Determine Density Limit (1, 2, or 3)
        const limit = Math.ceil(s.upwardTracerChance * 3.0);
        // 3. Spawn Logic
        // Since this runs every frame, we use a low probability to fill gaps organically.
        const spawnChance = 0.05; 
        const columns = this._columnsPool;
        // Shuffle for random distribution
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (colCounts[col] < limit) {
                if (Math.random() < spawnChance) {
                    this._spawnUpwardTracerAt(col);
                    colCounts[col]++;
                }
            }
        }
    }
    _spawnStreams(s, d) {
        const columns = this._columnsPool;
        // Fisher-Yates Shuffle
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
            }
            const lastStream = this.lastStreamInColumn[col];
            // Resolve Speed for this column (Chain Consistency)
            let colSpeed = this.columnSpeeds[col];
            // Only generate a new speed if the column is completely empty of active streams
            if (this.streamsPerColumn[col] === 0) {
                // New chain, new random speed
                colSpeed = this._generateSpeed(s);
                this.columnSpeeds[col] = colSpeed;
            }
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true, colSpeed);
                eraserCount--;
                continue; 
            } 
            if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false, colSpeed);
                streamCount--;
                // Cluster Logic: 10-20% chance to spawn a neighbor
                if (s.preferClusters && streamCount > 0 && Math.random() < 0.15) {
                    // Try Right Neighbor (wrapping handled by modulo if needed, but here we just clamp)
                    const neighbor = col + 1;
                    if (neighbor < this.grid.cols) {
                        const idxN = this.grid.getIndex(neighbor, 0);
                        let blockedN = false;
                        if (idxN !== -1 && this.grid.decays[idxN] > 0) blockedN = true;
                        const lastStreamN = this.lastStreamInColumn[neighbor];
                        // Resolve Neighbor Speed
                        let neighborSpeed = this.columnSpeeds[neighbor];
                        if (!lastStreamN || !lastStreamN.active) {
                            neighborSpeed = this._generateSpeed(s);
                            this.columnSpeeds[neighbor] = neighborSpeed;
                        }
                        if (!blockedN && this._canSpawnTracer(lastStreamN, s.minStreamGap, s.minGapTypes)) {
                            this._spawnStreamAt(neighbor, false, neighborSpeed);
                            streamCount--;
                        }
                    }
                }
                continue; 
            }
        }
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        if (!lastStream || !lastStream.active) return true;
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastStream = this.lastStreamInColumn[col];
        // Prevent spawning an eraser if the column is empty or the last spawn was already an eraser.
        if (!lastStream || lastStream.isEraser) return false;
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        if (lastStream.active) {
            if (this.config.state.allowTinyStreams) {
                const s = this.config.state;
                const tinyGap = s.tracerAttackFrames + s.tracerHoldFrames + s.tracerReleaseFrames + 3;
                if (lastStream.y <= tinyGap) return false;
            } else {
                if (lastStream.y <= minGapTypes) return false;
            }
        }
        return true;
    }
    _processActiveStreams(frame, timeScale) {
        const grid = this.grid;
        const rows = grid.rows;
        const cellLocks = grid.cellLocks;
        const decays = grid.decays;
        if (Math.abs(timeScale) < 0.01) return;
        const isReverse = timeScale < 0;
        const speedMult = Math.abs(timeScale);
                for (let i = this.activeStreams.length - 1; i >= 0; i--) {
                    const stream = this.activeStreams[i];
                    if (!stream.active) {
                        if (this.streamsPerColumn[stream.x] > 0) this.streamsPerColumn[stream.x]--;
                        this.activeStreams.splice(i, 1);
                        continue;
                    }
            const headIdx = grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && cellLocks && cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.tickTimer -= speedMult;
            if (stream.tickTimer > 0) {
                continue; 
            }
            stream.tickTimer = stream.tickInterval;
            // Handle Upward Tracers (Scanners)
            if (stream.isUpward) {
                if (isReverse) {
                    stream.y++; // Move down in reverse
                    if (stream.y > rows + 5) {
                        stream.active = false;
                        continue;
                    }
                } else {
                    stream.y--; // Move up in forward
                    if (stream.y < -5) {
                        stream.active = false;
                        continue;
                    }
                }
                this._writeHead(stream, frame);
                continue; 
            }
            if (isReverse) {
                stream.y--;
                // REWIND LOGIC: Clear the "future" (the cell we just left, which was stream.y + 1)
                // This creates the effect of the stream being sucked back up.
                const oldHeadY = stream.y + 1;
                if (oldHeadY < rows) {
                    const oldIdx = grid.getIndex(stream.x, oldHeadY);
                    if (oldIdx !== -1) {
                         grid.clearCell(oldIdx);
                    }
                }
                if (stream.y < -5) {
                    stream.active = false;
                    continue;
                }
                this._writeHead(stream, frame);
            } else {
                // Drop-off logic
                if (stream.isEraser) {
                    const stopChance = this.config.state.eraserStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                } else {                    
                    const stopChance = this.config.state.tracerStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                    // In 3D mode, ignore collision with existing trails to allow high density
                    const nextY = stream.y + 1;
                    if (nextY < rows) {
                        const nextIdx = grid.getIndex(stream.x, nextY);
                        if (nextIdx !== -1 && decays[nextIdx] > 0) {
                            stream.active = false;
                            continue; 
                        }
                    }
                } 
                stream.age++;
                if (stream.age >= stream.visibleLen) {
                    this._handleStreamCompletion(stream);
                    continue;
                }
                if (stream.y < stream.len) {
                    // Debug: Clean up previous eraser position to prevent trails
                    if (stream.isEraser && this.config.state.highlightErasers) {
                        const prevIdx = grid.getIndex(stream.x, stream.y);
                        if (prevIdx !== -1) grid.clearEffectOverride(prevIdx);
                    }
                    stream.y++;
                    this._writeHead(stream, frame);
                }
            }
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        const autoErase = this.config.state.autoEraserEnabled !== false;
        // Prevent auto-eraser if an eraser is already running in this column
        const last = this.lastStreamInColumn[stream.x];
        const isBlocked = last && last !== stream && last.active && last.isEraser;
        if (!stream.isEraser && autoErase && !isBlocked) {
            this._spawnStreamAt(stream.x, true, stream.tickInterval);
        }
    }
    _spawnStreamAt(x, forceEraser, forcedSpeed) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s, forcedSpeed);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _generateSpeed(s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        if (s.desyncIntensity > 0) {
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            return Math.max(1, baseTick + offset);
        }
        return baseTick;
    }
    recalculateSpeeds() {
        const s = this.config.state;
        for (let col = 0; col < this.grid.cols; col++) {
            const newSpeed = this._generateSpeed(s);
            this.columnSpeeds[col] = newSpeed;
        }
        // Update active streams to match new column speeds immediately
        for (const stream of this.activeStreams) {
            if (stream.x >= 0 && stream.x < this.columnSpeeds.length) {
                stream.tickInterval = this.columnSpeeds[stream.x];
            }
        }
    }
    _initializeStream(x, forceEraser, s, forcedSpeed) {
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        let tickInterval = forcedSpeed;
        // Enforce Column Speed Consistency
        // If the column has an assigned speed, strictly use it to ensure Tracers and Erasers remain synchronized
        if (this.columnSpeeds[x] > 0) {
            tickInterval = this.columnSpeeds[x];
        }
        if (!tickInterval) {
            tickInterval = this._generateSpeed(s);
            // Ensure this new speed is recorded for the column
            this.columnSpeeds[x] = tickInterval;
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsUint32?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval,
            tickTimer: 0
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        stream.visibleLen = this.grid.rows + 20; 
        return stream;
    }
    _initializeTracerStream(stream, s) {
        stream.len = this.grid.rows; 
        const travelDuration = stream.len // * stream.tickInterval;
        stream.visibleLen = travelDuration + (this.grid.rows * 4);
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isUpward) {
            this._handleUpwardHead(idx, this.config.state);
            return;
        }
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        const decays = this.grid.decays;
        if (decays[idx] >= 2) return;
        if (decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            decays[idx] = 2;
        } else {
            this.grid.clearCell(idx);
        }
        if (this.config.state.highlightErasers) {
            // Debug: Show Eraser as Red 'E' using High Priority Effect layer (0xFF0000FF = Red)
            // This overlays the 'E' without destroying the underlying simulation state (decay/clear)
            this.grid.setHighPriorityEffect(idx, 'E', 0xFF0000FF, 1.0, 0, 0);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const s = this.config.state;
            const d = this.config.derived;
            const grid = this.grid;
            const cellType = s.rotatorEnabled && Math.random() < s.rotatorChance
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            grid.types[idx] = cellType;
            grid.ages[idx] = 1;
            grid.decays[idx] = 1;
            grid.mix[idx] = 0; // Reset Rotator/Mix Progress
            grid.renderMode[idx] = RENDER_MODE.STANDARD;
            grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = d.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const charStr = charSet[Math.floor(Math.random() * charSet.length)];
            // Resolve Color
            let colorUint32;
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                // Complex Style (Effect)
                grid.complexStyles.set(idx, style);
                // Convert style to color immediately
                if (style.h !== undefined) {
                    const rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    colorUint32 = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                } else {
                     // Fallback
                     colorUint32 = d.tracerColorUint32;
                }
            } else {
                grid.complexStyles.delete(idx);
                // Standard Color
                // colorMixType: 0 = Stream, 1 = Character
                const isPerChar = Math.random() < s.colorMixType;
                if (isPerChar || Math.random() < s.paletteBias) {
                    const pLen = d.paletteColorsUint32?.length || 1;
                    colorUint32 = d.paletteColorsUint32[Math.floor(Math.random() * pLen)];
                } else {
                    colorUint32 = d.paletteColorsUint32[stream.pIdx] || d.paletteColorsUint32[0];
                }
            }
            // Brightness / Alpha
            const b = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            grid.brightness[idx] = b;
            // Set Primary (Visual = Tracer Color initially)
            const tracerColor = d.tracerColorUint32;
            grid.setPrimary(idx, charStr, tracerColor, b, stream.fontIndex, s.tracerGlow);
            grid.baseColors[idx] = colorUint32; // Store Stream Color for fade target
            // Handle Overlap (Secondary)
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                const overlapChar = charSet[Math.floor(Math.random() * charSet.length)];
                // For overlaps, we usually use the same color? Or Overlap Color?
                // Previously, renderer used `overlapColor` from config for overlaps.
                // But now CellGrid stores the color.
                // We should resolve Overlap Color here.
                const ovRgb = Utils.hexToRgb(s.overlapColor);
                const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
                grid.setSecondary(idx, overlapChar, ovColor, b, stream.fontIndex, s.tracerGlow);
                grid.renderMode[idx] = RENDER_MODE.OVERLAP;
            }
        } else {
            this.grid.clearCell(idx);
        }
    }
    _spawnUpwardTracerAt(x) {
        const s = this.config.state;
        const stream = this._initializeUpwardTracerStream(x, s);
        this.activeStreams.push(stream);
        this.lastUpwardTracerInColumn[x] = stream;
    }
    _initializeUpwardTracerStream(x, s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        // Apply speed multiplier (faster scanners look better)
        const speedMult = s.upwardTracerSpeedMult || 1.5; 
        const tickInterval = Math.max(1, baseTick / speedMult);
        return {
            x,
            // Always start at the bottom to ensure upward movement only
            y: this.grid.rows, 
            active: true,
            delay: 0, // Remove delay for immediate feedback
            age: 0,
            len: 1, // Conceptually length 1 head
            isUpward: true,
            visibleLen: 1000, // Long life
            mode: 'STANDARD',
            tickInterval: tickInterval,
            tickTimer: 0
        };
    }
    addActiveStream(stream) {
        if (!stream) return;
        this.activeStreams.push(stream);
        this.streamsPerColumn[stream.x]++;
        this.lastStreamInColumn[stream.x] = stream;
        if (stream.isEraser) {
            this.lastEraserInColumn[stream.x] = stream;
        } else if (stream.isUpward) {
            this.lastUpwardTracerInColumn[stream.x] = stream;
        }
    }
    _handleUpwardHead(idx, s) {
        // Only interact if the cell is ACTIVE (has a character) AND visible
        // Prevents "resurrecting" fully faded characters which looks like spawning new ones
        if (this.grid.state[idx] === CELL_STATE.ACTIVE && this.grid.alphas[idx] > 0.1) {
            // 25% chance to leave a "blank" (gap) in the glimmer trail
            if (Math.random() < 0.25) return;
            // Mark as Glimmering immediately and store lifecycle state in complexStyles
            this.grid.mix[idx] = 30.0; 
            this.grid.complexStyles.set(idx, { type: 'glimmer', age: 1 });
        }
    }
}
// --- StreamModes.js ---
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        let hue;
        if (state.starPowerRainbowMode === 'char') {
            hue = (frame + (stream.x * 10)) % 360; // Character-based hue
        } else {
            // Full Stream Mode: Sync hue start time so they cycle together
            // If cycling is enabled, offset the base hue by the current frame * speed
            hue = stream.baseHue;
            if (state.starPowerColorCycle) {
                 hue = (hue + (frame * state.starPowerCycleSpeed)) % 360;
            }
        }
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed);
    }
    _createStyle(hue, saturation, lightness, cycle, speed) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, isEffect: true };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, isEffect: true };
    }
}
    // =========================================================================
    // 5.0 SIMULATION SYSTEM 
    // =========================================================================
// --- CharacterSelectorModal.js ---
class CharacterSelectorModal {
    constructor(config, fontManager, notificationMgr) {
        this.config = config;
        this.fonts = fontManager;
        this.notifications = notificationMgr;
        this.dom = null;
        this.currentFont = null;
        // Canvas for glyph detection
        this.scanCanvas = document.createElement('canvas');
        this.scanCanvas.width = 20;
        this.scanCanvas.height = 20;
        this.scanCtx = this.scanCanvas.getContext('2d', { willReadFrequently: true });
        // Subscribe to config changes for fontSettings
        this.config.subscribe((key) => this._handleConfigChange(key));
    }
    show() {
        if (!this.dom) {
            this._createDOM();
        }
        this._refreshFontList();
        const currentFamily = this.config.get('fontFamily');
        const isKnown = this.fonts.loadedFonts.some(f => f.name === currentFamily) || currentFamily === 'MatrixEmbedded';
        this.currentFont = isKnown ? currentFamily : 'MatrixEmbedded';
        if (this.dom.fontSelect.querySelector(`option[value="${this.currentFont}"]`)) {
            this.dom.fontSelect.value = this.currentFont;
        } else {
             this.currentFont = 'MatrixEmbedded';
             this.dom.fontSelect.value = 'MatrixEmbedded';
        }
        this._loadFontSettings(this.currentFont);
        this.dom.overlay.classList.add('visible');
    }
    hide() {
        if (this.dom) {
            this.dom.overlay.classList.remove('visible');
        }
    }
    _handleConfigChange(key) {
        if (key === 'fontSettings' && this.dom && this.dom.overlay.classList.contains('visible')) {
            // If font settings changed while modal is open, reload current font settings to refresh UI
            this._loadFontSettings(this.currentFont);
        }
    }
    _createDOM() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        const content = document.createElement('div');
        content.className = 'modal-content';
        // Header
        const header = document.createElement('div');
        header.className = 'modal-header';
        header.innerHTML = '<h3 class="modal-title">Manage Characters</h3><div class="modal-close"></div>';
        header.querySelector('.modal-close').onclick = () => this.hide();
        // Body
        const body = document.createElement('div');
        body.className = 'modal-body';
        // 1. Font Selector
        const fontRow = document.createElement('div');
        fontRow.innerHTML = '<label class="modal-label">Select Font to Edit</label>';
        this.fontSelect = document.createElement('select');
        this.fontSelect.onchange = (e) => this._loadFontSettings(e.target.value);
        fontRow.appendChild(this.fontSelect);
        body.appendChild(fontRow);
        // 2. Active Toggle
        const activeRow = document.createElement('div');
        activeRow.className = 'checkbox-row';
        activeRow.innerHTML = '<span>Include in Rain</span><input type="checkbox" id="fontActiveToggle">';
        activeRow.querySelector('input').onchange = (e) => this._updateSetting('active', e.target.checked);
        this.activeToggle = activeRow.querySelector('input');
        body.appendChild(activeRow);
        // 3. Custom Chars Toggle
        const customToggleRow = document.createElement('div');
        customToggleRow.className = 'checkbox-row';
        customToggleRow.innerHTML = '<span>Use Custom Characters</span><input type="checkbox" id="fontCustomToggle">';
        customToggleRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useCustomChars', e.target.checked);
            this._toggleInputs(e.target.checked);
        };
        this.customToggle = customToggleRow.querySelector('input');
        body.appendChild(customToggleRow);
        // 4. Use All Characters Toggle
        const useAllRow = document.createElement('div');
        useAllRow.className = 'checkbox-row';
        useAllRow.innerHTML = '<span>Auto-Detect All Characters</span><input type="checkbox" id="fontUseAllToggle">';
        useAllRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useAllChars', e.target.checked);
            this._handleUseAll(e.target.checked);
        };
        this.useAllToggle = useAllRow.querySelector('input');
        body.appendChild(useAllRow);
        this.scanStatus = document.createElement('div');
        this.scanStatus.className = 'scan-status';
        body.appendChild(this.scanStatus);
        // 5. Visual Picker
        const pickerGroup = document.createElement('div');
        pickerGroup.innerHTML = '<label class="modal-label">Visual Selector</label><div class="modal-desc">Click characters to add/remove them. Empty boxes are unsupported by this font.</div>';
        this.charGrid = document.createElement('div');
        this.charGrid.className = 'char-grid-container';
        pickerGroup.appendChild(this.charGrid);
        body.appendChild(pickerGroup);
        // 6. Manual Input (Fallback)
        const inputGroup = document.createElement('div');
        inputGroup.innerHTML = '<label class="modal-label">Manual Input</label>';
        this.charInput = document.createElement('textarea');
        this.charInput.className = 'char-input';
        this.charInput.placeholder = 'Or paste characters here...';
        this.charInput.oninput = (e) => {
            this._updateSetting('customCharacters', e.target.value);
            this._updateGridSelection();
        };
        inputGroup.appendChild(this.charInput);
        body.appendChild(inputGroup);
        // Footer
        const footer = document.createElement('div');
        footer.className = 'modal-footer';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'action-btn btn-info';
        saveBtn.textContent = 'Done';
        saveBtn.style.width = 'auto';
        saveBtn.onclick = () => this.hide();
        footer.appendChild(saveBtn);
        content.append(header, body, footer);
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        this.dom = { overlay, fontSelect: this.fontSelect };
    }
    _refreshFontList() {
        this.fontSelect.innerHTML = '';
        const fonts = [
            { name: 'MatrixEmbedded', display: 'Matrix Custom Code (Default)' },
            ...this.fonts.loadedFonts.filter(f => !f.isEmbedded)
        ];
        fonts.forEach(f => {
            const opt = document.createElement('option');
            opt.value = f.name;
            opt.textContent = f.display || f.name;
            this.fontSelect.appendChild(opt);
        });
    }
    _loadFontSettings(fontName) {
        this.currentFont = fontName;
        const allSettings = this.config.get('fontSettings') || {};
        if (!allSettings[fontName]) {
             allSettings[fontName] = { active: false, useCustomChars: false, useAllChars: false, customCharacters: "" };
        }
        const settings = allSettings[fontName];
        this.activeToggle.checked = settings.active;
        this.customToggle.checked = settings.useCustomChars;
        this.useAllToggle.checked = settings.useAllChars;
        this.charInput.value = settings.customCharacters || "";
        this._toggleInputs(settings.useCustomChars);
        // If Use All is checked, run the scan logic visually but don't overwrite if not needed
        // Ideally we only run scan if useAllChars is TRUE.
        if (settings.useCustomChars) {
            if (settings.useAllChars) {
                this._handleUseAll(true); // Will re-scan and disable inputs
            } else {
                this._renderGrid(); // Just render grid for manual selection
            }
        }
    }
    _toggleInputs(enabled) {
        const opacity = enabled ? 1 : 0.5;
        this.useAllToggle.disabled = !enabled;
        this.useAllToggle.parentElement.style.opacity = opacity;
        // If "Use All" is checked, specific inputs are disabled regardless of "Use Custom"
        const allChecked = this.useAllToggle.checked;
        const manualEnabled = enabled && !allChecked;
        this.charInput.disabled = !manualEnabled;
        this.charInput.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.pointerEvents = manualEnabled ? 'auto' : 'none';
        if (enabled && !allChecked) {
            this._renderGrid();
        }
    }
    async _handleUseAll(checked) {
        if (!checked) {
            this._toggleInputs(true); // Re-enable manual inputs
            this.scanStatus.textContent = '';
            return;
        }
        this.charInput.disabled = true;
        this.charInput.style.opacity = 0.5;
        this.charGrid.style.opacity = 0.5;
        this.charGrid.style.pointerEvents = 'none';
        this.scanStatus.textContent = 'Scanning font for all valid glyphs...';
        // Yield to UI render
        await new Promise(r => setTimeout(r, 50));
        const validChars = this._scanForChars(this.currentFont);
        this.charInput.value = validChars;
        this._updateSetting('customCharacters', validChars);
        this.scanStatus.textContent = `Scan complete. Found ${validChars.length} characters.`;
        this._renderGrid(); // Visual confirmation
    }
    _scanForChars(fontName) {
        const ranges = [
            [33, 126], // Basic Latin
            [161, 255], // Latin-1
            [1024, 1279], // Cyrillic
            [913, 969], // Greek
            [5792, 5887], // Runic
            [12353, 12447], // Hiragana
            [12448, 12543], // Katakana
            [65377, 65439] // Halfwidth Katakana
        ];
        let valid = "";
        // Get "tofu" or empty signature
        const emptySig = this._getCharSignature(fontName, '\uFFFF');
        const spaceSig = this._getCharSignature(fontName, ' ');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(fontName, char);
                // If distinct from empty/tofu, it's valid
                if (sig && sig !== emptySig && sig !== spaceSig) {
                    valid += char;
                }
            }
        }
        return valid;
    }
    _getCharSignature(fontName, char) {
        this.scanCtx.clearRect(0, 0, 20, 20);
        this.scanCtx.font = `16px "${fontName}"`;
        this.scanCtx.textBaseline = 'middle';
        this.scanCtx.textAlign = 'center';
        this.scanCtx.fillStyle = '#fff';
        this.scanCtx.fillText(char, 10, 10);
        // Get pixel data hash-ish
        const data = this.scanCtx.getImageData(5, 5, 10, 10).data; // Sample center 10x10
        let sum = 0;
        for(let i=3; i<data.length; i+=4) { // check alpha only
            sum += data[i];
        }
        return sum; // simple sum signature
    }
    _renderGrid() {
        this.charGrid.innerHTML = '';
        // Define grid ranges (subset of scan ranges for visual sanity)
        const ranges = [
            [33, 126], // ASCII
            [12448, 12543] // Katakana
        ];
        const currentSet = new Set(this.charInput.value.split(''));
        const emptySig = this._getCharSignature(this.currentFont, '\uFFFF');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(this.currentFont, char);
                // If valid glyph
                if (sig && sig !== emptySig) {
                    const el = document.createElement('div');
                    el.className = 'char-grid-item';
                    el.textContent = char;
                    el.style.fontFamily = this.currentFont;
                    if (currentSet.has(char)) el.classList.add('selected');
                    el.onclick = () => {
                        if (this.useAllToggle.checked) return; // Locked
                        this._toggleChar(char);
                        el.classList.toggle('selected');
                    };
                    this.charGrid.appendChild(el);
                }
            }
        }
    }
    _toggleChar(char) {
        let val = this.charInput.value;
        if (val.includes(char)) {
            val = val.replace(char, '');
        } else {
            val += char;
        }
        this.charInput.value = val;
        this._updateSetting('customCharacters', val);
    }
    _updateGridSelection() {
        const currentSet = new Set(this.charInput.value.split(''));
        Array.from(this.charGrid.children).forEach(el => {
            if (currentSet.has(el.textContent)) el.classList.add('selected');
            else el.classList.remove('selected');
        });
    }
    _updateSetting(key, value) {
        if (!this.currentFont) return;
        const allSettings = { ...this.config.get('fontSettings') };
        if (!allSettings[this.currentFont]) {
            allSettings[this.currentFont] = {};
        }
        allSettings[this.currentFont][key] = value;
        this.config.set('fontSettings', allSettings);
    }
}
// --- FontManager.js ---
class FontManager {
  constructor(config, notificationMgr) {
    this.config = config;
    this.notifications = notificationMgr;
    // IndexedDB
    this.dbName = 'MatrixFontDB';
    this.storeName = 'fonts';
    this.db = null;
    // Runtime font bookkeeping
    this.loadedFonts = [];     // { name, display, isEmbedded, mimeType?, data? }
    this.subscribers = [];
    this.embeddedFontName = 'MatrixEmbedded';
    // Internal: promises to prevent duplicate loads per face
    this._facePromises = new Map(); // key: fontName -> Promise<void>
    this._defaultCanvasPx = 20;     // used for document.fonts.load exact-size readiness
    this._loadTimeoutMs = 8000;     // defensive timeout for font loads
    // Listen for config resets to re-inject custom font entries
    this.config.subscribe((key) => this._onConfigChange(key));
  }
  _onConfigChange(key) {
    if (key === 'ALL' || key === 'fontSettings') {
        // Re-ensure all loaded fonts exist in the new settings
        this.loadedFonts.forEach(f => {
            this._ensureFontConfig(f.name);
        });
    }
    // Check if the current font family is actually available
    if (key === 'fontFamily' || key === 'ALL') {
        const currentFont = this.config.get('fontFamily');
        const isDefault = currentFont === 'MatrixEmbedded';
        const isLoaded = this.loadedFonts.some(f => f.name === currentFont);
        if (!isDefault && !isLoaded) {
            this.notifications.show(`Font "${currentFont}" not found. Using fallback.`, 'warning');
        }
    }
  }
  /** Initialize: inject embedded font (if present) + open DB + load stored fonts. */
  async init() {
    if (typeof DEFAULT_FONT_DATA === 'string' && DEFAULT_FONT_DATA.length > 50) {
      await this.injectEmbeddedFont();
    }
    try {
      await this._openDB();
      await this._loadFontsFromDB();
    } catch (error) {
      console.warn('Font DB Error:', error);
      this.notifications.show('Failed to initialize Font Database', 'error');
    }
  }
  /** Subscribe to changes in loadedFonts. */
  subscribe(callback) {
    this.subscribers.push(callback);
  }
  /** Notify subscribers. */
  _notify() {
    this.subscribers.forEach(cb => cb(this.loadedFonts));
  }
  /** Ensure config entry exists for a font. */
  _ensureFontConfig(fontName) {
    const settings = { ...this.config.get('fontSettings') };
    if (!settings[fontName]) {
      settings[fontName] = {
        active: false,
        useCustomChars: false,
        customCharacters: ""
      };
      this.config.set('fontSettings', settings);
    }
  }
  /**
   * Inject embedded default Matrix font (data: URI or base64) if not yet loaded.
   * Uses FontFace + document.fonts to ensure readiness.
   */
  async injectEmbeddedFont() {
    const isFontInjected = this.loadedFonts.some(f => f.name === this.embeddedFontName);
    if (isFontInjected) return;
    const ok = await this._registerFontFace({
      name: this.embeddedFontName,
      // DEFAULT_FONT_DATA is expected to be a data: URL (e.g., data:font/woff2;base64,...)
      // If it's raw base64, wrap as data:font/woff2;base64,<data>
      // Otherwise, provide a normal URL to a woff2 file.
      sourceUrl: DEFAULT_FONT_DATA,
      // Hint the format since data URLs dont carry a MIME header you can inspect easily.
      formatHint: "format('woff2')",
      canvasPx: this._defaultCanvasPx
    });
    if (ok) {
      this.loadedFonts.push({
        name: this.embeddedFontName,
        display: 'The Matrix Custom Code',
        isEmbedded: true
      });
      // Ensure default font is active/configured
      const settings = { ...this.config.get('fontSettings') };
      if (!settings[this.embeddedFontName]) {
        settings[this.embeddedFontName] = {
          active: true,
          useCustomChars: false,
          customCharacters: ""
        };
        this.config.set('fontSettings', settings);
      }
    } else {
        this.notifications.show('Failed to load embedded font', 'error');
    }
  }
  /**
   * Programmatic font registration using FontFace.
   * Replaces the old <style>@font-face</style> injection.
   *
   * @param {Object} opts
   *  - name: string (family)
   *  - sourceUrl: string (Blob URL, data: URL, or http(s) URL)
   *  - formatHint: string e.g. "format('woff2')" (optional but recommended)
   *  - weight/style/stretch/unicodeRange: CSS descriptors (optional)
   *  - canvasPx: number (exact size youll use for canvas metrics readiness)
   *  - preload: boolean (inject <link rel="preload"> if sourceUrl is http(s))
   */
  async _registerFontFace(opts) {
    const {
      name,
      sourceUrl,
      formatHint,
      weight = '400',
      style = 'normal',
      stretch = 'normal',
      unicodeRange,
      canvasPx = this._defaultCanvasPx,
      preload = false
    } = opts;
    // De-dupe: once per family
    if (this._facePromises.has(name)) {
      return this._facePromises.get(name);
    }
    const task = (async () => {
      // (Optional) preload for http(s) sources
      if (preload && /^https?:/.test(sourceUrl)) {
        this._injectPreload(sourceUrl);
      }
      // src string (programmatic FontFace supports url()+format())
      const src = formatHint ? `url("${sourceUrl}") ${formatHint}` : `url("${sourceUrl}")`;
      const descriptors = { weight, style, stretch };
      if (unicodeRange) descriptors.unicodeRange = unicodeRange;
      const face = new FontFace(name, src, descriptors);
      // Defensive timeout so we never hang the animation pipeline.
      const timeout = new Promise((_, rej) =>
        setTimeout(() => rej(new Error(`Font load timeout: ${name}`)), this._loadTimeoutMs)
      );
      // Load the font bytes & parse the face
      await Promise.race([face.load(), timeout]);
      // Register with the document
      document.fonts.add(face);
      // Ensure exact face+size is available for canvas metrics
      await document.fonts.load(`${canvasPx}px "${name}"`);
      await document.fonts.ready;
      return true;
    })().catch(err => {
      console.warn(`[FontManager] Failed to load "${name}"`, err);
      return false;
    });
    this._facePromises.set(name, task);
    return task;
  }
  /** Preload helper to avoid late discovery & double fetch. */
  _injectPreload(href) {
    const existing = document.querySelector(`link[rel="preload"][as="font"][href="${href}"]`);
    if (existing) return;
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'font';
    link.href = href;
    link.type = 'font/woff2';
    link.crossOrigin = 'anonymous'; // critical for font preloads to be reusable from cache
    document.head.appendChild(link);
  }
  /**
   * Legacy wrapper: Keep method name for compatibility.
   * Internally routes to FontFace registration.
   *
   * @param {string} name    - family name
   * @param {string} url     - Blob URL / data URL / http(s)
   * @param {string} format  - e.g., "format('woff2')"
   */
  async _injectCSS(name, url, format) {
    return this._registerFontFace({ name, sourceUrl: url, formatHint: format, canvasPx: this._defaultCanvasPx });
  }
  /** Open/create IndexedDB store. */
  async _openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onupgradeneeded = event => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'name' });
        }
      };
      request.onsuccess = event => {
        this.db = event.target.result;
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /** Load stored fonts: register faces + ensure readiness, then notify. */
  async _loadFontsFromDB() {
    return new Promise(resolve => {
      if (!this.db) return resolve();
      const txn = this.db.transaction(this.storeName, 'readonly');
      const store = txn.objectStore(this.storeName);
      store.getAll().onsuccess = async event => {
        const storedFonts = event.target.result || [];
        // Keep only embedded font in runtime list; reload DB fonts fresh
        this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
        await Promise.all(storedFonts.map(async (font) => {
          this.loadedFonts.push(font);
          this._ensureFontConfig(font.name);
          const type = font.mimeType || (font.data && font.data.type) || 'font/woff2';
          const format = this._getFormatFromType(type);
          const blobUrl = URL.createObjectURL(font.data);
          const ok = await this._registerFontFace({
            name: font.name,
            sourceUrl: blobUrl,
            formatHint: format,
            canvasPx: this._defaultCanvasPx
          });
          // Once registered and ready, we can revoke the blob URL to free memory
          // (the face is now owned by document.fonts).
          try { URL.revokeObjectURL(blobUrl); } catch (_) {}
          if (!ok) {
            console.warn(`Font "${font.name}" failed to register from DB`);
          }
        }));
        this._notify();
        resolve();
      };
    });
  }
  /** Map MIME -> format() hint for @font-face / FontFace src. */
  _getFormatFromType(mimeType = '') {
    const mt = mimeType.toLowerCase();
    if (mt.includes('woff2')) return "format('woff2')";
    if (mt.includes('woff'))  return "format('woff')";
    if (mt.includes('opentype') || mt.includes('otf')) return "format('opentype')";
    return "format('truetype')";
  }
  /**
   * Import a custom font file: hash, persist in DB, register via FontFace, notify.
   * Keeps your existing external behavior but ensures readiness & object URL cleanup.
   */
  importFont(file) {
    const reader = new FileReader();
    reader.onload = async event => {
      const arrayBuffer = event.target.result;
      const blob = new Blob([arrayBuffer], { type: file.type });
      let fontName;
      try {
        const hash = await Utils.computeSHA256(arrayBuffer);
        fontName = `CustomFont_${hash.substring(0, 16)}`;
      } catch (e) {
        console.warn("Hashing failed, falling back to timestamp", e);
        fontName = `CustomFont_${Date.now()}`;
      }
      const record = {
        name: fontName,
        display: file.name,
        data: blob,
        mimeType: file.type
      };
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.put(record).onsuccess = async () => {
        const format = this._getFormatFromType(file.type);
        // Register via FontFace & ensure ready
        const blobUrl = URL.createObjectURL(blob);
        const ok = await this._registerFontFace({
          name: fontName,
          sourceUrl: blobUrl,
          formatHint: format,
          canvasPx: this._defaultCanvasPx
        });
        try { URL.revokeObjectURL(blobUrl); } catch (_) {}
        this.loadedFonts.push(record);
        this._ensureFontConfig(fontName);
        // If desired, auto-activate imported font (kept as comment to preserve your behavior)
        const settings = { ...this.config.get('fontSettings') };
        settings[fontName].active = true;
        this.config.set('fontSettings', settings);
        if (ok) {
          this.config.set('fontFamily', fontName);
          this._notify();
          this.notifications.show(`Imported: ${file.name}`, 'success');
        } else {
          this.notifications.show(`Import failed: ${file.name}`, 'error');
        }
      };
      txn.onerror = () => {
        this.notifications.show('Database Write Failed', 'error');
      };
    };
    reader.readAsArrayBuffer(file);
  }
  /**
   * Delete by font id/name.
   * Note: FontFace entries registered in document.fonts cant be explicitly removed,
   * but removing config, style tags (legacy), and revoking Blob URLs (handled above)
   * prevents leaks and stops future use.
   */
  deleteFont(id) {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.delete(id).onsuccess = () => {
        // Remove legacy style tag (if any)
        document.getElementById(`style-${id}`)?.remove();
        const deletedFont = this.loadedFonts.find(font => font.name === id);
        this.loadedFonts = this.loadedFonts.filter(font => font.name !== id);
        // Deactivate in config to prevent rendering issues
        const settings = { ...this.config.get('fontSettings') };
        if (settings[id]) {
          settings[id].active = false;
          this.config.set('fontSettings', settings);
        }
        if (this.config.state.fontFamily === id) {
          this.config.set('fontFamily', this.config.defaults.fontFamily);
          this.notifications.show(`Deleted font was active. Reverted to default.`, 'warning');
        } else {
             this.notifications.show(`Deleted font: ${deletedFont ? deletedFont.display : id}`, 'success');
        }
        this._notify();
        resolve();
      };
      store.delete(id).onerror = () => {
          this.notifications.show('Failed to delete font', 'error');
          resolve();
      };
    });
  }
  /** Clear DB + keep only embedded runtime fonts. */
  deleteAllFonts() {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.clear().onsuccess = () => {
        // Remove any legacy <style> tags
        this.loadedFonts
          .filter(font => !font.isEmbedded)
          .forEach(font => document.getElementById(`style-${font.name}`)?.remove());
        // Keep only embedded fonts
        this.loadedFonts = this.loadedFonts.filter(font => font.isEmbedded);
        this._notify();
        this.notifications.show('All custom fonts deleted', 'success');
        resolve();
      };
      store.clear().onerror = () => {
          this.notifications.show('Failed to clear fonts', 'error');
          resolve();
      };
    });
  }
  // ---------- Canvas helpers (optional but handy) ----------
  /**
   * Build a safe canvas font shorthand string for metrics & drawing.
   * @param {string} family
   * @param {number} sizePx
   * @param {string} weight
   * @param {string} style
   * @param {string} fallbackStack
   */
  buildCanvasFont({ family, sizePx = this._defaultCanvasPx, weight = '400', style = 'normal', fallbackStack = 'monospace' } = {}) {
    // e.g. "normal 400 20px 'MatrixEmbedded', monospace"
    return `${style} ${weight} ${sizePx}px '${family}', ${fallbackStack}`;
  }
  /**
   * Ensure a specific family is ready for the given canvas size before drawing.
   * (Useful if you change sizes dynamically.)
   */
  async ensureReadyForCanvasSize(family, sizePx = this._defaultCanvasPx) {
    await document.fonts.load(`${sizePx}px "${family}"`);
       await document.fonts.ready;
  }
}
    // =========================================================================
    // 9.0 UI MANAGER
    // =========================================================================
// --- NotificationManager.js ---
class NotificationManager {
    constructor(config) {
        this.config = config;
        this.container = document.getElementById('toast-container') || this._createContainer();
    }
    /**
     * Creates and initializes the toast container if it doesn't exist.
     * @returns {HTMLElement} The toast container DOM element.
     */
    _createContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.setAttribute('aria-live', 'polite'); // Accessibility: Announce updates to screen readers.
        container.setAttribute('role', 'status'); // Accessibility: Define the type of content the container holds.
        document.body.appendChild(container);
        return container;
    }
    /**
     * Displays a notification with the specified message and type.
     * @param {string} message - The message to display in the notification.
     * @param {string} [type='info'] - The type of the notification ('info', 'success', 'error', etc.).
     * @param {number} [duration=3000] - The duration (in milliseconds) for the notification to be visible.
     */
    show(message, type = 'info', duration = 3000) {
        if (this.config && this.config.state && this.config.state.suppressToasts) return;
        // Create the notification element.
        const toast = this._createToast(message, type);
        // Ensure the container is attached.
        if (!document.body.contains(this.container)) {
            document.body.appendChild(this.container);
        }
        // Add the notification to the container and apply the "visible" class for animation.
        this.container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        // Set timers for hiding and removing the notification.
        this._scheduleToastRemoval(toast, duration);
    }
    /**
     * Creates an individual toast element.
     * @private
     * @param {string} message - The message to display.
     * @param {string} type - The type of the notification.
     * @returns {HTMLElement} The toast DOM element.
     */
    _createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast-msg toast-${type}`;
        toast.textContent = message;
        toast.setAttribute('role', 'alert'); // Accessibility: Specify that this is an alert message.
        return toast;
    }
    /**
     * Schedules the removal of the notification after the specified duration.
     * Handles smooth animation states before removing the DOM element.
     * @private
     * @param {HTMLElement} toast - The toast element to remove.
     * @param {number} duration - How long the toast remains visible.
     */
    _scheduleToastRemoval(toast, duration) {
        setTimeout(() => {
            // Trigger fade-out animation by removing the "visible" class.
            toast.classList.remove('visible');
            // Remove the toast element from the DOM after the animation completes.
            setTimeout(() => toast.remove(), 300); // Matches CSS animation transition time.
        }, duration);
    }
}
    // =========================================================================
    // 2.0 CONFIGURATION MANAGER 
    // =========================================================================
// --- UIManager.js ---
class UIManager {
    constructor(c, effects, fonts, notificationMgr, charSelector) {
        // Core dependencies and state
        this.c = c;
        this.effects = effects; // Renamed from this.eff for clarity, consistency
        this.fonts = fonts;
        this.notifications = notificationMgr;
        this.charSelector = charSelector;
        this.dom = this._initializeDOM();
        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 };
        this.ignoreNextClick = false; // Retain existing logic for drag/click distinction
        this.isKeyBindingActive = false; // Flag to suspend global key inputs
        this.defs = this._generateDefinitions();
        // Event subscriptions
        this.c.subscribe((key, state) => this.refresh(key));
        this.fonts.subscribe(() => this.refresh('fontFamily'));
        // Initialization
        this.init();
    }
    /**
     * Establish initial DOM structure using expected selectors and IDs.
     * @private
     */
    _initializeDOM() {
        return {
            panel: document.getElementById('settingsPanel'),
            toggle: document.getElementById('menuToggle'),
            tabs: document.getElementById('navTabs'),
            content: document.getElementById('contentArea'),
            tooltip: document.getElementById('ui-tooltip') || this._createTooltip(),
            keyTrap: document.getElementById('ui-key-trap') || this._createKeyTrap(),
            track: null, // Initialized later in init
        };
    }
    /**
     * Create invisible input trap for key binding.
     * @private
     */
    _createKeyTrap() {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'ui-key-trap';
        // Ensure element is rendered but invisible/unobtrusive
        input.style.position = 'fixed';
        input.style.top = '0';
        input.style.left = '0';
        input.style.width = '1px';
        input.style.height = '1px';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        input.style.zIndex = '-1';
        input.setAttribute('aria-hidden', 'true');
        document.body.appendChild(input);
        return input;
    }
    /**
     * Create the tooltip element and attach to the DOM.
     * @private
     */
    _createTooltip() {
        const tooltip = document.createElement('div');
        tooltip.id = 'ui-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
    }
    /**
     * Generate all UI component definitions for settings dynamically.
     * This method orchestrates the gathering of definitions from category-specific methods.
     * @private
     */
    _generateDefinitions() {
        return [
            ...this._generateGlobalSettings(),
            // APPEARANCE TAB
            ...this._generateAppearanceSettings(),
            // BEHAVIOR TAB
            ...this._generateBehaviorSettings(),
            // FX TAB
            ...this._generateFXSettings(),
            // SYSTEM TAB
            ...this._generateSystemTab()
        ];
    }
    /**
     * Generates definitions for the 'Global' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateGlobalSettings() {
        return [
            { cat: 'Global', type: 'accordion_header', label: 'Code Basics' },
            { cat: 'Global', id: 'backgroundColor', type: 'color', label: 'Background Color' },
            { cat: 'Global', id: 'streamPalette', type: 'color_list', label: 'Code Colors', max: 3 },
            { cat: 'Global', id: 'paletteBias', type: 'range', label: 'Color Mix', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'% Mix', description: "Left: Solid Streams. Right: Random Characters. Middle: Blend." },
            { cat: 'Global', id: 'colorMixType', type: 'range', label: 'Mix Type', min: 0, max: 1, step: 0.05, transform: v => v < 0.3 ? 'Stream Colors' : (v > 0.7 ? 'Character Colors' : 'Mixed'), description: "Controls whether colors are assigned per-stream or per-character." },
            { cat: 'Global', id: 'tracerColor', type: 'color', label: 'Tracer Color', description: "The head of the stream that writes the code to the screen" },
            { cat: 'Global', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, step: 1, unit: 'px' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20, step: 1 },
            { cat: 'Global', id: 'showFpsCounter', type: 'checkbox', label: 'Show FPS Counter', description: "Displays the current frames-per-second in the top-left corner." },
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing', dep: '!shaderEnabled', description: 'Anti-aliasing is automatically disabled when a custom shader is in use.' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: ['smoothingEnabled', '!shaderEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'Appearance' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateAppearanceSettings() {
        return [
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Customization' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Manage Character Sets', action: 'manageCharacters', class: 'btn-info' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' }, // Main Accordion Header
            { cat: 'Appearance', type: 'accordion_subheader', label: 'General' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Allows for brightness variance when characters are written' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Stream Trails' },
            { cat: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 180, unit:'fr' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolving Stream Trails' }, 
            { cat: 'Appearance', id: 'dissolveScalePercent', type: 'range', label: 'Dissolve Scale', min: -100, max: 100, unit: '%', dep: 'dissolveEnabled', description: 'Percentage size change during dissolve. Negative values shrink, positive values grow.' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Trail Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghosting Offset', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Character Overlap' },
            { cat: 'Appearance', id: 'overlapEnabled', type: 'checkbox', label: 'Enable Overlap' },
            { cat: 'Appearance', id: 'overlapColor', type: 'color', label: 'Overlap Color', dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapDensity', type: 'range', label: 'Overlap Density', min: 0.1, max: 1.0, step: 0.1, dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapTarget', type: 'select', label: 'Overlap Target', options: [{label:'Streams Only',value:'stream'},{label:'All Characters',value:'all'}], dep: 'overlapEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.0, max: 1.0, step: 0.01, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -100, max: 100, unit: 'px' },
            { cat: 'Appearance', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -100, max: 100, unit: 'px' },
            // View Window Controls
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        ];
    }
    /**
     * Generates definitions for the 'Behavior' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateBehaviorSettings() {
        return [
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'releaseInterval', type: 'range', label: 'Event Timer', description: "For synchronized events (like tracer release) this is the interval between events.", min: 1, max: 10, step: 1 },
            { cat: 'Behavior', id: 'desyncIntensity', type: 'range', label: 'Tracer Desync', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', description: "Varies the speed and release timing of tracers. 0% is uniform sync." },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Between Erasers', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minGapTypes', type: 'range', label: 'Min Gap Between Types', min: 1, max: 100, unit: 'px', description: "Minimum space between tracer types, preventing short streams" },
            { cat: 'Behavior', id: 'allowTinyStreams', type: 'checkbox', label: 'Allow Tiny Streams', description: "Increases the probability of very short streams spawning." },
            { cat: 'Behavior', id: 'gradualColorStreams', type: 'checkbox', label: 'Gradual Color Streams', description: "Fades tracer brightness gradually over the entire stream length." },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps in Code Stream', min: 0, max: 0.5, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Tracers'},
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1, description: "Maximum number of tracers released per-cycle" },
            { cat: 'Behavior', id: 'preferClusters', type: 'checkbox', label: 'Prefer Clusters', description: "Slightly increases the chance of tracers spawning side-by-side." },
            { cat: 'Behavior', id: 'tracerStopChance', type: 'range', label: 'Tracer Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for a tracer to randomly stop, leaving a hanging stream.'},
            { cat: 'Behavior', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Erasers'},
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, description: "Invisible tracers that start erasing code" },
            { cat: 'Behavior', id: 'eraserStopChance', type: 'range', label: 'Eraser Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for an eraser to randomly stop, leaving a hanging stream.' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Inverted Tracers'},
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Tracers that only write occassional characters" },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Frequency', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%'},
            { cat: 'Behavior', type: 'accordion_header', label: 'Glimmer Tracers'},
            { cat: 'Behavior', id: 'upwardTracerEnabled', type: 'checkbox', label: 'Glimmer Tracers', description: 'Invisible scanners that light up existing code' },
            { cat: 'Behavior', id: 'upwardTracerChance', type: 'range', label: 'Frequency', min: 0, max: 1.0, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerSpeedMult', type: 'range', label: 'Vertical Climb Speed', min: 0.5, max: 4.0, step: 0.1, transform: v=>v+'x', dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerGlimmerSpeed', type: 'range', label: 'Glimmer Blink Speed', min: 0.01, max: 10.0, step: 0.01, dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerGlimmerSize', type: 'range', label: 'Glimmer Grid Size', min: 2, max: 6, step: 1, dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerGlimmerFill', type: 'range', label: 'Glimmer Fill', min: 2, max: 12, step: 1, dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerGlimmerGlow', type: 'range', label: 'Glimmer Glow', min: 0, max: 50, step: 1, dep: 'upwardTracerEnabled' },
            { cat: 'Behavior', id: 'upwardTracerGlimmerFlicker', type: 'range', label: 'Glimmer Flicker', min: 0.0, max: 1.0, step: 0.05, dep: 'upwardTracerEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Symbol Rotator' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 1.0, step: 0.01, dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: "Lock the rotator change to the cycles that move the tracers" },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotateDuringFade', type: 'checkbox', label: 'Rotate during fade', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncEnabled', type: 'checkbox', label: 'Desynchronize Rotators', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncVariance', type: 'range', label: 'Desync Variance', min: 0, max: 100, unit: '%', dep: ['rotatorEnabled', 'rotatorDesyncEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'FX' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateFXSettings() {
        return [
            { cat: 'Effects', type: 'header', label: 'Movie Effects' }, // Using header for main section
            { cat: 'Effects', type: 'header', label: 'Trilogy' }, // Sub-header
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'Effects', id: 'pulseMovieAccurate', type: 'checkbox', label: 'Movie Accurate', dep: 'pulseEnabled', description: "Enables movie-accurate timing and visuals, disabling custom controls." },
            { cat: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDelaySeconds', type: 'range', label: 'Delay', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Preserve Tracer Glow', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDimming', type: 'range', label: 'Initial Dim Amount', min: 0.0, max: 1.0, step: 0.05, dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Start at a full square" },
            { cat: 'Effects', id: 'pulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_header', label: 'Clear Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Clear Pulse Now', action: 'clearpulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'clearPulseEnabled', type: 'checkbox', label: 'Enable Clear Pulse' },
            { cat: 'Effects', id: 'clearPulseMovieAccurate', type: 'checkbox', label: 'Movie Accurate', dep: 'clearPulseEnabled', description: "Enables movie-accurate visual artifacts (tearing/lag) without dimming the screen." },
            { cat: 'Effects', id: 'clearPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseBlend', type: 'checkbox', label: 'Color Blend', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'], description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'], description: "Start at a full square" },
            { cat: 'Effects', id: 'clearPulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse Storm' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Storm Now', action: 'minipulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'Effects', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseThickness', type: 'range', label: 'Wave Width', min: 10, max: 150, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSize', type: 'range', label: 'Blast Size Max', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Deja Vu' },
            { cat: 'Effects', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'Effects', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'Effects', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMinRectHeight', type: 'range', label: 'Minimum Thickness', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Maximum Thickness', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuHoleBrightness', type: 'range', label: 'Intensity', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Enable Color Writing', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuIntensity', type: 'range', label: 'Flash Frequency', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Length', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Length Variance', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Superman' },
            { cat: 'Effects', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'Effects', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman Effects' },
            { cat: 'Effects', id: 'supermanFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanGlow', type: 'range', label: 'Glow amount', min: 1, max: 10, dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFadeSpeed', type: 'range', label: 'Fade Duration', min: 5, max: 60, dep: 'supermanEnabled', description: 'Higher values mean trails last longer.' },
            { cat: 'Effects', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 10, step: 1, dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'Effects', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 10, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'Effects', id: 'supermanSpawnSpeed', type: 'range', label: 'Bolt Speed', min: 10, max: 100, dep: 'supermanEnabled', description: 'Speed from left to right' },
            { cat: 'Effects', type: 'accordion_header', label: 'Boot/Crash' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Boot Sequence' },
            { cat: 'Effects', id: 'bootSequenceEnabled', type: 'checkbox', label: 'Start Code with Boot' },
            { cat: 'Effects', type: 'button', label: 'Trigger Boot Now', action: 'boot', class: 'btn-warn' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Sequence' },
            { cat: 'Effects', id: 'crashEnabled', type: 'checkbox', label: 'Enable Crash' },
            { cat: 'Effects', id: 'crashFrequencySeconds', type: 'range', label: 'Frequency', min: 60, max: 600, step: 10, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashDurationSeconds', type: 'range', label: 'Duration', min: 5, max: 120, step: 5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Visuals', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetCount', type: 'range', label: 'Shadowbox Density', min: 0, max: 200, step: 1, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetSpeed', type: 'range', label: 'Shadowbox Speed', min: 0.1, max: 3.0, step: 0.1, dep: 'crashEnabled', transform: v=>v+'x' },
            { cat: 'Effects', id: 'crashSheetOpacity', type: 'range', label: 'Shadowbox Opacity', min: 0.0, max: 1.0, step: 0.01, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashStationaryChance', type: 'range', label: 'Shadowbox Movement Level', min: 0, max: 100, unit: '%', invert: true, dep: 'crashEnabled', description: "How likely a shadow box is to move when spawned." },
            { cat: 'Effects', id: 'crashFlashDelayMin', type: 'range', label: 'Flash Delay Min', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashFlashDelayMax', type: 'range', label: 'Flash Delay Max', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Features', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashMovieFps', type: 'checkbox', label: 'Movie FPS', dep: 'crashEnabled', description: "When enabled, locks the rendering to 30 fps for most effects." },
            { cat: 'Effects', id: 'crashEnableSmith', type: 'checkbox', label: 'Enable Agent Smith', description: "Randomly introduces agent Smith within the crash. Subtle.", dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableSuperman', type: 'checkbox', label: 'Enable Code Bolts', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableFlash', type: 'checkbox', label: 'Enable Flash/Fade', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'button', label: 'Trigger Crash Now', action: 'crash', class: 'btn-warn', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Macros' },
            { cat: 'Effects', id: 'runBothInOrder', type: 'checkbox', label: 'Run Both in Order', description: 'Automatically triggers the Crash sequence after the Boot sequence completes.' },
            { cat: 'Effects', type: 'button', label: 'Trigger Sequence Now', action: 'boot_crash_sequence', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Resurrections' }, // Sub-header
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Pulse', action: 'quantizedPulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedPulseEnabled', type: 'checkbox', label: 'Enable Quantized Pulse' },
            { cat: 'Effects', id: 'quantizedPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 10, max: 300, step: 5, unit: 's', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseDurationSeconds', type: 'range', label: 'Max Duration', min: 0.5, max: 10, step: 0.1, unit: 's', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseGreenFadeSeconds', type: 'range', label: 'Line Fade Duration', min: 0.0, max: 0.5, step: 0.01, unit: 's', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.0, max: 10.0, step: 0.1, dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', type: 'header', label: 'Special Effects' }, // Header for Special Effects
            { cat: 'Effects', type: 'accordion_header', label: 'Star Power' },
            { cat: 'Effects', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'Effects', id: 'starPowerFreq', type: 'range', label: 'Frequency', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamChance', type: 'range', label: 'Frequency', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Effects', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Time Manipulation' },
            { cat: 'Effects', type: 'button', label: 'Trigger Reverse Time', action: 'reverse_time', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Post Processing' },
            { cat: 'Effects', type: 'accordion_header', label: 'Shader' },
            { cat: 'Effects', type: 'info_description', id: 'currentShaderNameDisplay', text: 'Loaded: No shader.' },
            { cat: 'Effects', id: 'shaderEnabled', type: 'checkbox', label: 'Enable Custom Shader' },
            { cat: 'Effects', id: 'shaderParameter', type: 'range', label: 'Shader Parameter', min: 0.0, max: 1.0, step: 0.01, dep: 'shaderEnabled', description: "A generic 0.0-1.0 value passed to the shader as 'uParameter'." },
            { cat: 'Effects', type: 'button', label: 'Import Fragment Shader (.glsl)', action: 'importShader', class: 'btn-info', dep: 'shaderEnabled' },
            { cat: 'Effects', type: 'info_description', text: 'Uniforms provided: uTexture (sampler2D), uTime (float), uResolution (vec2), uMouse (vec2), uParameter (float). Output to gl_FragColor.', dep: 'shaderEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'System' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateSystemTab() {
        return [
            { cat: 'System', type: 'accordion_header', label: 'Configuration' },
            { cat: 'System', type: 'slot', idx: 0, id: 'slot_0' },
            { cat: 'System', type: 'slot', idx: 1, id: 'slot_1' },
            { cat: 'System', type: 'slot', idx: 2, id: 'slot_2' },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
            { cat: 'System', id: 'hideMenuIcon', type: 'checkbox', label: 'Hide Settings Icon', description: 'Hover your mouse over the top right or press the Toggle UI Panel keybind to show' },
            { cat: 'System', id: 'suppressToasts', type: 'checkbox', label: 'Suppress Toast Messages', description: 'Disable pop-up notifications at the bottom of the screen.' },
            { cat: 'System', type: 'accordion_header', label: 'Key Bindings' },
            { cat: 'System', type: 'info_description', text: 'Click a button to assign a new key. Press Backspace or Delete to clear.' },
            { cat: 'System', type: 'keybinder', id: 'BootSequence', label: 'Boot Animation' },
            { cat: 'System', type: 'keybinder', id: 'CrashSequence', label: 'Crash Animation' },
            { cat: 'System', type: 'keybinder', id: 'BootCrashSequence', label: 'Boot to Crash' },
            { cat: 'System', type: 'keybinder', id: 'Pulse', label: 'Pulse' },
            { cat: 'System', type: 'keybinder', id: 'ClearPulse', label: 'Clear Pulse' },
            { cat: 'System', type: 'keybinder', id: 'MiniPulse', label: 'Pulse Storm' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedPulse', label: 'Quantized Pulse' },
            { cat: 'System', type: 'keybinder', id: 'DejaVu', label: 'Deja Vu' },
            { cat: 'System', type: 'keybinder', id: 'Superman', label: 'Superman' },
            { cat: 'System', type: 'keybinder', id: 'ReverseTime', label: 'Reverse Time' },
            { cat: 'System', type: 'keybinder', id: 'ToggleUI', label: 'Toggle UI Panel' },
            { cat: 'System', type: 'accordion_header', label: 'System Reset' },
            { cat: 'System', type: 'info_description', text: 'Clears the current font cache, and resets all font entries to default' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
            { cat: 'System', type: 'accordion_header', label: 'Debug' },
            { cat: 'System', id: 'debugEnabled', type: 'checkbox', label: 'Enable Debug Messages', description: "Enables verbose console logging and additional metrics." },
            { cat: 'System', id: 'highlightErasers', type: 'checkbox', label: 'Highlight Erasers', description: "Draws a red border around invisible eraser tracers." },
            { cat: 'System', id: 'logErrors', type: 'checkbox', label: 'Log Errors to Console', description: "Allows application errors to be logged to the browser console." },
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' },
            { cat: 'System', type: 'accordion_subheader', label: 'Frequently Asked Questions' },
            { cat: 'System', type: 'faq_item', question: 'What is this?', answer: 'This is a highly customizable Matrix Digital Rain simulation built with HTML5 Canvas and JavaScript.' },
            { cat: 'System', type: 'faq_item', question: 'How do I change the code?', answer: 'Use the settings panel on the right side of the screen to customize various aspects like colors, speeds, and effects.' },
            { cat: 'System', type: 'faq_item', question: 'Can I use my own font?', answer: 'Yes, go to the "Appearance" tab, under "Character Customization" you can import your own TTF or OTF font file.' },
            { cat: 'System', type: 'faq_item', question: 'Why is it sometimes slow?', answer: 'Performance depends on your device and settings. Try reducing "Resolution Scale" or disabling some effects under the "Effects" tab.' },
            { cat: 'System', type: 'faq_item', question: 'Is this more AI slop?', answer: 'Yes and no. LLM\'s were definitely used to make this, but the person who programmed it is a real person, and much of the code was hand-written, not just \'vibe coded\'. It\'s not perfect, but it\'s being slowly improved.' },
            { cat: 'System', type: 'faq_item', question: 'How do I leave feedback or suggestions on your app?', answer: 'Feel free to reach out via github! I\'m definitely open to ideas and suggestions.' }
        ];
    }
    /**
     * Initialize the events, tabs, and UI components.
     */
    init() {
        // Toggle button for the settings panel
        this.dom.toggle.onclick = () => this.togglePanel();
        // Create and populate tabs and content containers
        this._setupTabs();
        // Update footer version
        document.getElementById('globalStatus').textContent = `Matrix Code v${APP_VERSION}`;
        // Initialize File Input Handlers
        this._setupFileHandlers();
        // Handle tab dragging and horizontal scrolling
        this._setupTabScroll();
        // Refresh UI
        this.refresh('ALL');
    }
    /**
     * Toggles the settings panel visibility.
     */
    togglePanel() {
        const isOpen = this.dom.panel.classList.toggle('open');
        this.dom.panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
        this.dom.toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
    /**
     * Sets up the tabs and their corresponding content containers.
     * Creates category tabs and assigns content containers to each.
     * @private
     */
    _setupTabs() {
        this.dom.track = document.createElement('div'); // Initialize track here
        this.dom.track.id = 'tabTrack';
        this.dom.tabs.appendChild(this.dom.track);
        const categories = [...new Set(this.defs.map(def => def.cat))];
        const tabContentContainers = {}; // Mapping of category -> content container div
        // Create tabs and attach event handlers
        categories.forEach((category, index) => {
            const tabButton = this._createTabButton(category, index === 0);
            this.dom.track.appendChild(tabButton);
            // Create corresponding content container for the tab
            const contentContainer = this._createTabContentContainer(category, index === 0);
            this.dom.content.appendChild(contentContainer);
            tabContentContainers[category] = contentContainer;
        });
        // Populate tab content
        this._populateTabContent(tabContentContainers);
    }
    /**
     * Creates a tab button element for a category.
     * @private
     * @param {string} category - The category name for the tab.
     * @param {boolean} isActive - Whether the tab should be active by default.
     * @returns {HTMLElement} The created tab button element.
     */
    _createTabButton(category, isActive) {
        const button = document.createElement('button');
        button.className = `tab-btn ${isActive ? 'active' : ''}`;
        button.textContent = category;
        button.onclick = () => this._handleTabClick(category, button);
        return button;
    }
    /**
     * Handles when a tab is clicked and activates the corresponding tab content.
     * @private
     * @param {string} category - The category associated with the clicked tab.
     * @param {HTMLElement} button - The clicked tab button element.
     */
    _handleTabClick(category, button) {
        // Use this.scrollState.dragDistance for distinguishing drag from click
        if (this.scrollState.dragDistance > 3) {
            this.scrollState.dragDistance = 0; // Reset for next interaction
            return; 
        }
        // Deactivate all tabs and their content
        this.dom.tabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.dom.content.querySelectorAll('.tab-content-group').forEach(content => content.classList.remove('active'));
        // Activate selected tab and content
        button.classList.add('active');
        document.getElementById(`tab-content-${category}`).classList.add('active');
    }
    /**
     * Creates a tab content container for a given category.
     * @private
     * @param {string} category - The category name for the content container.
     * @param {boolean} isActive - Whether the content container should be active by default.
     * @returns {HTMLElement} The created tab content container element.
     */
    _createTabContentContainer(category, isActive) {
        const container = document.createElement('div');
        container.className = `tab-content-group ${isActive ? 'active' : ''}`;
        container.id = `tab-content-${category}`;
        return container;
    }
    /**
     * Populates tabs with content, including accordions and controls.
     * @private
     * @param {Object} tabContentContainers - A map of category names to their content container elements.
     */
    _populateTabContent(tabContentContainers) {
        let currentAccordionBody = null;
        let lastCat = null;
        this.defs.forEach(def => {
            const container = tabContentContainers[def.cat];
            if (!container) return;
            // Reset accordion context when switching tabs/categories
            if (def.cat !== lastCat) {
                currentAccordionBody = null;
                lastCat = def.cat;
            }
            // Handle Accordion Headers (Start new accordion)
            if (def.type === 'accordion_header') {
                currentAccordionBody = this._createAccordion(container, def.label);
                return;
            } 
            // Handle Accordion Subheaders
            else if (def.type === 'accordion_subheader') {
                if (currentAccordionBody) {
                    const el = this.renderControl(def);
                    if (el) currentAccordionBody.appendChild(el);
                }
                return;
            }
            // Handle Section Headers (Break out of accordion)
            // Exception: CAUTION ZONE remains inside for special handling below
            if (def.type === 'header' && def.label !== 'CAUTION ZONE') {
                currentAccordionBody = null;
                const el = this.renderControl(def);
                if (el) container.appendChild(el);
                return;
            }
            // Handle Controls
            if (currentAccordionBody) {
                // Special handling for CAUTION ZONE inside an accordion
                if (def.cat === 'System' && def.label === 'CAUTION ZONE' && def.type === 'header') {
                    const cautionZoneDiv = document.createElement('div');
                    cautionZoneDiv.className = 'caution-zone';
                    const headerEl = this.renderControl(def);
                    cautionZoneDiv.appendChild(headerEl);
                    currentAccordionBody.appendChild(cautionZoneDiv);
                } else {
                    if (def.caution) return; // Skip caution items here, handled separately
                    const controlElement = this.renderControl(def);
                    if (controlElement) currentAccordionBody.appendChild(controlElement);
                }
            } else {
                // Orphan controls (outside any accordion) - e.g. top level buttons or headers
                const controlElement = this.renderControl(def);
                if (controlElement) container.appendChild(controlElement);
            }
        });
        // Post-process: Insert Factory Reset into the created Caution Zone
        const factoryResetDef = this.defs.find(d => d.action === 'reset' && d.caution);
        if (factoryResetDef) {
            const cautionZoneDiv = this.dom.content.querySelector('.caution-zone');
            if (cautionZoneDiv) {
                const controlElement = this.renderControl(factoryResetDef);
                if (controlElement) cautionZoneDiv.appendChild(controlElement);
            }
        }
    }
    /**
     * Creates an accordion section with a header and a container for controls.
     * @private
     * @param {HTMLElement} tabContentGroup - The parent container for the accordion.
     * @param {string} label - The label for the accordion header.
     * @returns {HTMLElement} The body element of the created accordion where controls can be appended.
     */
    _createAccordion(tabContentGroup, label) {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.innerHTML = `
            ${label}
            <span class="accordion-icon">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </span>
        `;
        const body = document.createElement('div');
        body.className = 'accordion-content';
        header.onclick = () => this._toggleAccordion(header, body, tabContentGroup);
        accordionItem.appendChild(header);
        accordionItem.appendChild(body);
        tabContentGroup.appendChild(accordionItem);
        // Default open logic: REMOVED per user request
        // const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
        // if (accordionsInTab.length === 1) { 
        //     body.classList.add('open');
        //     header.classList.add('active');
        //     header.querySelector('.accordion-icon').classList.add('rotated');
        // }
        return body;
    }
    /**
     * Toggles the visibility of an accordion section and manages sibling accordions.
     * @private
     * @param {HTMLElement} header - The header element of the accordion.
     * @param {HTMLElement} body - The body element of the accordion.
     * @param {HTMLElement} group - The parent group containing all accordions (tabContentGroup).
     */
    _toggleAccordion(header, body, group) {
        const isOpen = body.classList.contains('open');
        // Close other accordions in the group
        group.querySelectorAll('.accordion-content').forEach(siblingBody => {
            siblingBody.classList.remove('open');
            siblingBody.previousElementSibling?.classList.remove('active');
            siblingBody.previousElementSibling?.querySelector('.accordion-icon')?.classList.remove('rotated');
        });
        // Toggle the current accordion
        if (isOpen) {
            body.classList.remove('open');
            header.classList.remove('active');
            header.querySelector('.accordion-icon')?.classList.remove('rotated');
        } else {
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon')?.classList.add('rotated');
        }
    }
    /**
     * Setup input handlers for font and config import.
     * @private
     */
    _setupFileHandlers() {
        document.getElementById('importFile').onchange = e => this._handleConfigImport(e);
        document.getElementById('importFontFile').onchange = e => this._handleFontImport(e);
        // Add shader input
        const shaderInput = document.createElement('input');
        shaderInput.type = 'file';
        shaderInput.id = 'importShaderFile';
        shaderInput.accept = '.glsl,.frag,.txt';
        shaderInput.style.display = 'none';
        document.body.appendChild(shaderInput);
        shaderInput.onchange = e => this._handleShaderImport(e);
    }
    /**
     * Handles the import of a shader file.
     * @private
     */
    _handleShaderImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const source = ev.target.result;
            this.c.set('customShader', source);
            this.notifications.show('Shader Imported', 'success');
            event.target.value = '';
        };
        reader.readAsText(file);
    }
    /**
     * Updates the slot name inputs from the current configuration.
     */
    updateSlotNames() {
        if (this.c.slots) {
            this.c.slots.forEach((slot, i) => {
                const slotInput = document.getElementById(`slot-input-${i}`);
                if (slotInput) {
                    slotInput.value = slot.name;
                }
            });
        }
    }
    /**
     * Handles the import of a JSON configuration file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleConfigImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                // Merge loaded config with defaults to ensure all properties exist
                this.c.state = { ...this.c.defaults, ...data.state };
                // Handle Saved Presets
                if (data.savedPresets) {
                    this.c.slots = data.savedPresets;
                    this.c.saveSlots();
                    this.updateSlotNames(); // Force update immediately
                }
                this.c.updateDerivedValues();
                this.c.save();
                this.c.notify('ALL');
                this.notifications.show('Configuration Loaded', 'success');
            } catch (error) {
                console.error("Error loading config:", error);
                this.notifications.show('Invalid Configuration File', 'error');
            }
            event.target.value = ''; // Reset input value to allow re-importing the same file
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a custom font file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleFontImport(event) {
        const file = event.target.files[0];
        if (file) this.fonts.importFont(file);
        event.target.value = ''; // Reset input value
    }
    /**
     * Set up drag and scroll functionality for tabs.
     * @private
     */
    _setupTabScroll() {
        const tabs = this.dom.tabs;
        tabs.addEventListener('mousedown', e => this._startDrag(e));
        tabs.addEventListener('mouseleave', () => this._stopDrag());
        tabs.addEventListener('mouseup', () => this._stopDrag());
        tabs.addEventListener('mousemove', e => this._doDrag(e));
        // Ensure overflow handling matches standard behavior for wheel support
        tabs.style.overflowX = 'auto'; 
        tabs.style.overscrollBehaviorX = 'contain';
        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
        tabs.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaX) >= Math.abs(e.deltaY)) {
                return;
            }
            if (e.deltaY !== 0) {
                // preventDefault stops the browser "back" gesture or vertical page scroll
                e.preventDefault(); 
                tabs.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }
    /**
     * Initiates the drag operation for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse down event.
     */
    _startDrag(e) {
        if (e.button !== 0) return; // Only respond to primary click (left mouse button)
        this.scrollState.isDown = true;
        this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft;
        this.scrollState.scrollLeft = this.dom.tabs.scrollLeft;
        this.scrollState.dragDistance = 0;
        this.ignoreNextClick = false; // Reset flag
        this.dom.tabs.style.cursor = 'grabbing';
    }
    /**
     * Stops the drag operation for tab scrolling.
     * @private
     */
    _stopDrag() {
        this.scrollState.isDown = false;
        this.dom.tabs.style.cursor = 'grab';
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Handles the drag movement for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse move event.
     */
    _doDrag(e) {
        if (!this.scrollState.isDown) return;
        e.preventDefault(); // Prevent text highlighting during drag
        const x = e.pageX - this.dom.tabs.offsetLeft;
        const walk = (x - this.scrollState.startX) * 1.5; // Multiplier for faster scrolling
        this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk;
        this.scrollState.dragDistance = Math.abs(x - this.scrollState.startX); // Update based on actual movement
        if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; // Set flag if dragged enough to be considered a drag
    }
    /**
     * Retrieves the list of available fonts, including embedded and custom fonts.
     * @private
     * @returns {Array<Object>} An array of font objects suitable for select options.
     */
    _getFonts() {
        return [
            ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true}))
        ];
    }
    /**
     * Updates the UI list of custom fonts (used in the font manager section).
     * @param {HTMLElement} el - The DOM element to populate with the font list.
     */
    updateFontList(el) {
        el.innerHTML = '';
        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
            const div = document.createElement('div');
            div.className = 'font-item';
            div.innerHTML = `<span class="font-name">${f.display}</span>`;
            const btn = document.createElement('div');
            btn.className = 'font-delete-btn';
            btn.innerHTML = '';
            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
            div.appendChild(btn);
            el.appendChild(div);
        });
    }
    /**
     * Displays a tooltip with a given text near a target element.
     * @param {string} text - The text to display in the tooltip.
     * @param {HTMLElement} target - The element relative to which the tooltip should be positioned.
     */
    showTooltip(text, target) {
        this.dom.tooltip.textContent = text;
        this.dom.tooltip.classList.add('visible');
        const rect = target.getBoundingClientRect();
        const tipRect = this.dom.tooltip.getBoundingClientRect();
        let top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        let left = rect.left - tipRect.width - 12; // Default to left of target
        // Adjust position if it goes off-screen
        if (top < 10) top = 10;
        if (left < 10) left = rect.right + 12; // Move to right if it's too far left
        this.dom.tooltip.style.top = `${top}px`;
        this.dom.tooltip.style.left = `${left}px`;
    }
    /**
     * Hides the currently displayed tooltip.
     */
    hideTooltip() {
        this.dom.tooltip.classList.remove('visible');
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Updates the text/state of a specific keybinder button.
     * @param {string} id - The ID of the keybinding action (e.g., 'Pulse').
     */
    updateKeyBinderVisuals(id) {
        const btn = document.getElementById(`btn-key-${id}`);
        if (!btn) return;
        const def = this.defs.find(d => d.id === id);
        if (!def) return;
        const bindings = this.c.get('keyBindings') || {};
        const rawKey = bindings[id] || 'None';
        const displayKey = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
        btn.textContent = `${def.label}: [ ${displayKey} ]`;
        btn.className = 'action-btn btn-info'; // Reset class
    }
    /**
     * Creates a styled label group for a UI control, optionally including an info icon with a tooltip.
     * @param {Object} def - The definition object for the UI control.
     * @returns {HTMLElement} The created label group DOM element.
     */
    createLabelGroup(def) {
        const group = document.createElement('div');
        group.className = 'control-label-group';
        const text = document.createElement('span');
        text.textContent = def.label;
        group.appendChild(text);
        if (def.description) {
            const icon = document.createElement('span');
            icon.className = 'info-icon';
            icon.textContent = '?';
            const show = (e) => this.showTooltip(def.description, e.target);
            icon.onmouseenter = show;
            icon.onmouseleave = () => this.hideTooltip();
            // Handle touch events for mobile tooltips
            icon.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                if (this.dom.tooltip.classList.contains('visible')) { 
                    this.hideTooltip(); 
                } else { 
                    show(e); 
                    // Automatically hide tooltip after a short delay on touch devices
                    setTimeout(() => this.hideTooltip(), 3000); 
                } 
            });
            group.appendChild(icon);
        }
        return group;
    }
    /**
     * Renders the content of a color list control into the provided wrapper.
     * @private
     * @param {HTMLElement} wrapper - The container element.
     * @param {Object} def - The control definition.
     */
    _renderColorList(wrapper, def) {
        wrapper.innerHTML = '';
        const palette = this.c.get(def.id) || ["#00FF00"];
        palette.forEach((color, idx) => {
            const item = document.createElement('div');
            item.className = 'color-list-item';
            const cInput = document.createElement('input');
            cInput.type = 'color';
            cInput.value = color;
            // Optimisation: Update state directly on input to allow dragging without re-render
            cInput.oninput = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.state[def.id] = newP; // Direct state mutation
                this.c.updateDerivedValues(); // Force derived update for live preview
            };
            // Commit change on release
            cInput.onchange = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.set(def.id, newP); // Triggers save and refresh
            };
            item.appendChild(cInput);
            if (palette.length > 1 && idx > 0) {
                const delBtn = document.createElement('div');
                delBtn.className = 'btn-icon-remove';
                delBtn.textContent = '';
                delBtn.onclick = () => {
                    const newP = this.c.get(def.id).filter((_, i) => i !== idx);
                    this.c.set(def.id, newP);
                    this._renderColorList(wrapper, def);
                    this.refresh('streamPalette');
                };
                item.appendChild(delBtn);
            }
            wrapper.appendChild(item);
        });
        if (palette.length < (def.max || 3)) {
            const addBtn = document.createElement('div');
            addBtn.className = 'btn-icon-add';
            addBtn.textContent = '+';
            addBtn.onclick = () => {
                const newP = [...this.c.get(def.id), "#ffffff"];
                this.c.set(def.id, newP);
                this._renderColorList(wrapper, def);
                this.refresh('streamPalette');
            };
            wrapper.appendChild(addBtn);
        }
    }
    /**
     * Dynamically renders a UI control element based on its definition.
     * @param {Object} def - The definition object for the control.
     * @returns {HTMLElement|null} The created control element, or null if it's an accordion header.
     */
    renderControl(def) {
        if (def.type === 'accordion_header') { return null; }
        if (def.type === 'accordion_subheader') {
            const el = document.createElement('div');
            el.className = 'accordion-subheader';
            el.textContent = def.label;
            if(def.dep) el.setAttribute('data-dep', JSON.stringify(def.dep));
            return el;
        }
        if (def.type === 'header') {
            const el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; return el;
        }
        if (def.type === 'about_content') {
            const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
            const logoChar = Utils.getRandomKatakanaChar();
            const initialColor = this.c.get('streamColor');
            const initialSvgDataUrl = Utils.generateGlyphSVG(logoChar, initialColor, 48, this.c.get('fontFamily'));
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <img id="matrixLogo" src="${initialSvgDataUrl}" alt="Matrix Logo" style="height: 48px; width: 48px; margin-right: 10px;"/>
                    <h3 style="margin:0; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                </div>
                <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
            return div;
        }
        if (def.type === 'info_description') {
            const div = document.createElement('div');
            div.className = 'info-description';
            div.textContent = def.text;
            if (def.id) div.id = `in-${def.id}`;
            return div;
        }
        if (def.type === 'faq_item') {
            const container = document.createElement('div');
            container.className = 'faq-item';
            const question = document.createElement('div');
            question.className = 'faq-question';
            question.textContent = def.question;
            const answer = document.createElement('div');
            answer.className = 'faq-answer';
            answer.textContent = def.answer;
            container.appendChild(question);
            container.appendChild(answer);
            return container;
        }
        const row = document.createElement('div');
        if (def.type === 'button') {
            const btn = document.createElement('button'); btn.className = `action-btn ${def.class||'btn-info'}`; btn.textContent = def.label; btn.id = `btn-${def.action}`; btn.name = def.action; btn.onclick = () => this.handleAction(def.action); row.appendChild(btn);
        } else if (def.type === 'slot') {
            row.className = 'slot-container';
            const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[def.idx].name; inp.id = `slot-input-${def.idx}`; inp.name = `slot_name_${def.idx}`; inp.onchange = e => this.c.renameSlot(def.idx, e.target.value);
            inp.onfocus = e => e.target.value = '';
            const grp = document.createElement('div'); grp.className = 'slot-btn-group';
            const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${def.idx}`; save.onclick = () => { this.c.saveToSlot(def.idx); };
            const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${def.idx}`; load.onclick = () => { this.c.loadFromSlot(def.idx); };
            grp.append(save, load); row.append(inp, grp);
        } else if (def.type === 'font_list') {
            row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
        } else {
            row.className = def.type === 'checkbox' ? 'checkbox-row' : 'control-row';
            const labelGroup = this.createLabelGroup(def);
            if(def.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
            if(!def.hideValue && def.type === 'range') { const valDisp = document.createElement('span'); valDisp.id = `val-${def.id}`; hdr.appendChild(valDisp); } row.appendChild(hdr); } 
                else { row.appendChild(labelGroup); }
            let inp;
            if(def.type === 'range') { 
                inp = document.createElement('input'); 
                inp.type = 'range'; 
                inp.min=def.min; 
                inp.max=def.max; 
                if(def.step) inp.step=def.step; 
                let isTouching = false;
                inp.value = def.invert ? (def.max+def.min)-this.c.get(def.id) : this.c.get(def.id);                            
                inp.oninput = e => { 
                    if (isTouching) return; // Block native updates during touch interaction
                    const v = parseFloat(e.target.value); 
                    let actual = def.invert ? (def.max+def.min)-v : v; 
                    // Dynamic precision based on step
                    const step = def.step || 1;
                    const decimals = (step.toString().split('.')[1] || '').length;
                    if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                    this.c.set(def.id, actual); 
                    const disp = document.getElementById(`val-${def.id}`); 
                    if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                }; 
                let startX = 0;
                let startY = 0;
                let startValue = 0;
                let isHorizontalDrag = false;
                inp.addEventListener('touchstart', e => {
                    isTouching = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(e.target.value);
                    isHorizontalDrag = false;
                    // Prevent "jump to tap" visually
                    requestAnimationFrame(() => {
                        inp.value = startValue;
                    });
                }, { passive: false });
                inp.addEventListener('touchmove', e => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    const dx = x - startX;
                    const dy = y - startY;
                    if (!isHorizontalDrag && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 5) {
                        isHorizontalDrag = true;
                    }
                    if (isHorizontalDrag) {
                        e.preventDefault(); 
                        const rect = inp.getBoundingClientRect();
                        const relativeX = Math.min(Math.max(0, x - rect.left), rect.width);
                        const percent = relativeX / rect.width;
                        const min = parseFloat(def.min);
                        const max = parseFloat(def.max);
                        let newVal = min + (percent * (max - min));
                        // Dynamic precision based on step
                        const step = parseFloat(def.step || 1);
                        newVal = Math.round(newVal / step) * step;
                        if (newVal < min) newVal = min;
                        if (newVal > max) newVal = max;
                        inp.value = newVal;
                        let actual = def.invert ? (max+min)-newVal : newVal; 
                        const decimals = (step.toString().split('.')[1] || '').length;
                        if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                        this.c.set(def.id, actual); 
                        const disp = document.getElementById(`val-${def.id}`); 
                        if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                    }
                }, { passive: false });
                inp.addEventListener('touchend', () => {
                    isTouching = false;
                    isHorizontalDrag = false;
                });
            }
            else if(def.type === 'color') { 
                const w = document.createElement('div'); 
                w.className = 'color-wrapper'; 
                inp = document.createElement('input'); 
                inp.type = 'color'; 
                inp.value = this.c.get(def.id); 
                inp.id = `in-${def.id}`; 
                inp.name = def.id; 
                inp.oninput = e => { 
                    this.c.state[def.id] = e.target.value; 
                    this.c.updateDerivedValues(); // Force derived update for live preview
                }; 
                inp.onchange = e => { this.c.set(def.id, e.target.value); }; // Commit and refresh
                w.appendChild(inp); row.appendChild(w); 
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`; 
                return row; 
            }
            else if(def.type === 'color_list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'color-list-wrapper';
                wrapper.id = `in-${def.id}`;
                this._renderColorList(wrapper, def);
                row.appendChild(wrapper);
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`;
                return row;
            }
            else if(def.type === 'keybinder') {
                const btn = document.createElement('button');
                // Initial text setup
                const rawKey = (this.c.get('keyBindings') || {})[def.id] || 'None';
                const initialDisplay = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
                btn.className = 'action-btn btn-info';
                btn.id = `btn-key-${def.id}`;
                btn.textContent = `${def.label}: [ ${initialDisplay} ]`;
                btn.onclick = () => {
                    this.isKeyBindingActive = true; 
                    btn.textContent = `${def.label}: [ Press Key... ]`;
                    btn.classList.remove('btn-info');
                    btn.classList.add('btn-warn');
                    // Focus trap to isolate input from global listeners
                    this.dom.keyTrap.focus();
                    const handler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        let newKey = e.key;
                        // Handle special keys
                        if (newKey === 'Backspace' || newKey === 'Delete') {
                            newKey = null;
                        } else if (newKey.length === 1) {
                            newKey = newKey.toLowerCase();
                        }
                        // Save config
                        try {
                            const bindings = { ...this.c.get('keyBindings') };
                            if (newKey) {
                                bindings[def.id] = newKey;
                            } else {
                                delete bindings[def.id];
                            }
                            this.c.set('keyBindings', bindings); // Triggers refresh() -> updateKeyBinderVisuals()
                        } catch (err) {
                            console.error("Failed to save keybinding:", err);
                            btn.textContent = "Error Saving";
                        }
                        // Cleanup
                        this.dom.keyTrap.blur();
                        this.isKeyBindingActive = false;
                        // Force immediate visual update just in case refresh is delayed
                        this.updateKeyBinderVisuals(def.id);
                    };
                    this.dom.keyTrap.addEventListener('keydown', handler, { once: true });
                };
                row.appendChild(btn);
                return row;
            }
            else if(def.type === 'checkbox') { 
                inp = document.createElement('input'); 
                inp.type = 'checkbox'; 
                inp.checked = this.c.get(def.id); 
                inp.onchange = e => { 
                    if(e.target.checked && def.warning) alert(def.warning);
                    this.c.set(def.id, e.target.checked); 
                }; 
                row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; 
            }
            else if(def.type === 'select') { inp = document.createElement('select'); (typeof def.options === 'function' ? def.options() : def.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(def.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(def.id, e.target.value); }
            row.appendChild(inp);
            if(def.id) { inp.id = `in-${def.id}`; inp.name = def.id; }
            if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`;
        }
        return row;
    }
    /**
     * Handles UI actions triggered by buttons or other interactive elements.
     * @param {string} action - The action identifier.
     */
    handleAction(action) {
        if(action === 'reset' && confirm('Reset all settings?')) this.c.reset();
        if(action === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts();
        if(action === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state, savedPresets:this.c.slots}, `matrix_conf_v${APP_VERSION}.json`);
        if(action === 'import') document.getElementById('importFile').click();
        if(action === 'importFont') document.getElementById('importFontFile').click();
        if(action === 'importShader') document.getElementById('importShaderFile').click();
        if(action === 'manageCharacters') this.charSelector.show();
        if(action === 'boot') { if(this.effects.trigger('BootSequence')) this.notifications.show('Boot Sequence Initiated', 'success'); else this.notifications.show('Boot Sequence Active...', 'info'); }
        if(action === 'crash') { if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger'); else this.notifications.show('Crash Sequence Active...', 'info'); }
        if(action === 'boot_crash_sequence') {
            if(this.effects.trigger('BootSequence')) {
                this.notifications.show('Boot Sequence Initiated', 'success');
                setTimeout(() => {
                    if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger');
                }, 4000);
            } else {
                this.notifications.show('Sequence Active...', 'info');
            }
        }
        if(action === 'pulse') { if(this.effects.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
        if(action === 'clearpulse') { if(this.effects.trigger('ClearPulse')) this.notifications.show('Clear Pulse Triggered', 'success'); else this.notifications.show('Clear Pulse active...', 'info'); }
        if(action === 'minipulse') { if(this.effects.trigger('MiniPulse')) this.notifications.show('Pulse Storm Triggered', 'success'); else this.notifications.show('Pulse Storm active...', 'info'); }
        if(action === 'quantizedPulse') { if(this.effects.trigger('QuantizedPulse')) this.notifications.show('Quantized Pulse Triggered', 'success'); else this.notifications.show('Quantized Pulse active...', 'info'); }
        if(action === 'dejavu') { if(this.effects.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
        if(action === 'superman') { if(this.effects.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
        if(action === 'reverse_time') { if(this.effects.trigger('ReverseTime')) this.notifications.show('Time Reversal Initiated', 'success'); else this.notifications.show('Temporal anomaly detected...', 'info'); }
    }
    /**
     * Refreshes the UI to reflect current configuration settings.
     * @param {string} key - The specific configuration key to refresh, or 'ALL' to refresh all controls.
     */
    refresh(key) {
        try {
            if(key === 'ALL') { 
                this.defs.forEach(d => { if(d.id) this.refresh(d.id); }); 
                // Refresh Slot Names
                this.updateSlotNames();
                this.refresh('fontFamily'); // Special refresh for font list
                this.dom.content.querySelectorAll('[data-dep]').forEach(row => {
                    try {
                        const depRule = JSON.parse(row.getAttribute('data-dep')); 
                        const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                        let conditionsMet = true;
                        for (let rule of rules) { 
                            let target = rule; 
                            let expected = true; 
                            if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                            let actualVal = this.c.get(target);
                            if (actualVal === 'true') actualVal = true;
                            if (actualVal === 'false') actualVal = false;
                            const actual = !!actualVal; 
                            if (actual !== expected) { conditionsMet = false; break; } 
                        }
                        if(conditionsMet) row.classList.remove('control-disabled'); 
                        else row.classList.add('control-disabled');
                    } catch(e) { console.warn("Error processing dependency row:", e); }
                });
                return; 
            }
            if (key === 'keyBindings') {
                this.defs.filter(d => d.type === 'keybinder').forEach(d => this.refresh(d.id));
                return;
            }
                        if (key === 'fontFamily' || key === 'fontSettings') { // Now also refreshes on fontSettings changes
                            const sel = document.getElementById('in-fontFamily');
                            if(sel) { 
                                sel.innerHTML = ''; 
                                this._getFonts().forEach(o => { 
                                    const opt = document.createElement('option'); 
                                    opt.value = o.value; 
                                    opt.textContent = o.label; 
                                    if(o.custom) opt.className = 'custom-font-opt'; 
                                    if(this.c.get('fontFamily') === o.value) opt.selected = true; 
                                    sel.appendChild(opt); 
                                }); 
                            }
                            const list = document.getElementById('fontListUI'); 
                            if (list) this.updateFontList(list); 
                            // Update logo and favicon when font family or settings change, re-randomize char
                            const currentPrimaryColor = this.c.get('streamPalette')[0]; // Use primary palette color
                            const logo = document.getElementById('matrixLogo');
                            if (logo) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                logo.src = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 48, this.c.get('fontFamily'));
                            }
                            const favicon = document.getElementById('favicon');
                            if (favicon) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                favicon.href = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                            }
                            return;
                        }
                        // Removed the separate `if (key === 'streamColor')` block as its functionality
                        // is now handled by the 'streamPalette' block, and this 'fontFamily'/'fontSettings' block.
                        // ... the rest of the refresh method ...
                        if (key === 'customShader' || key === 'shaderEnabled' || key === 'ALL') {
                            const shaderNameDisplay = document.getElementById('in-currentShaderNameDisplay');
                if (shaderNameDisplay) {
                    let name = 'No shader loaded.';
                    const customShaderSource = this.c.get('customShader');
                    const shaderEnabled = this.c.get('shaderEnabled');
                    if (shaderEnabled && customShaderSource) {
                        // 1. Try to find a name metadata tag in the first 500 chars
                        // Matches "// Name: My Shader" or "// Shader: My Shader" case-insensitive
                        const nameMatch = customShaderSource.substring(0, 500).match(/^\s*\/\/\s*(?:Name|Shader|Title):\s*(.+)$/im);
                        if (nameMatch && nameMatch[1]) {
                            name = nameMatch[1].trim();
                        } 
                        // 2. Fallback: Check if it's standard code
                        else if (customShaderSource.trim().startsWith('precision')) {
                            name = 'Custom Shader (No Name)';
                        }
                        // 3. Fallback: If it doesn't look like code (maybe it really is a path?)
                        else if (customShaderSource.length < 200 && (customShaderSource.includes('/') || customShaderSource.includes('\\'))) {
                             const parts = customShaderSource.split(/[\/\\]/);
                             name = parts[parts.length - 1];
                        }
                        else {
                             name = 'Custom Shader';
                        }
                    } else if (shaderEnabled) {
                         name = 'Unnamed/Default Shader'; 
                    }
                    shaderNameDisplay.textContent = `Loaded: ${name}`;
                }
            }
            if (key === 'streamPalette') {
                 const palette = this.c.get('streamPalette');
                 const biasRow = document.getElementById('row-paletteBias');
                 if (biasRow) {
                     if (palette && palette.length > 1) {
                         biasRow.classList.remove('control-disabled');
                     } else {
                         biasRow.classList.add('control-disabled');
                     }
                 }
                 // Update UI Elements based on primary color
                 if (palette && palette.length > 0) {
                     const color = palette[0];
                     // Update Settings Wheel
                     const toggle = this.dom.toggle;
                     if (toggle) {
                         toggle.style.setProperty('--accent', color);
                         toggle.style.borderColor = color;
                         // toggle.style.color = color; // Removed to allow CSS hover override
                         toggle.style.boxShadow = `0 0 5px ${color}40`; // Subtle glow using hex alpha
                     }
                     // Update Logo & Favicon
                     const logo = document.getElementById('matrixLogo');
                     if (logo) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        logo.src = Utils.generateGlyphSVG(randomChar, color, 48, this.c.get('fontFamily'));
                     }
                     const favicon = document.getElementById('favicon');
                     if (favicon) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        favicon.href = Utils.generateGlyphSVG(randomChar, color, 32, this.c.get('fontFamily'));
                     }
                 }
            }
            if (key === 'hideMenuIcon' || key === 'ALL') {
                const shouldHide = this.c.get('hideMenuIcon');
                const toggleBtn = this.dom.toggle;
                // Clear any existing listeners/timeouts
                if (this._menuIconTimeout) clearTimeout(this._menuIconTimeout);
                if (this._menuMouseMoveHandler) {
                    document.removeEventListener('mousemove', this._menuMouseMoveHandler);
                    this._menuMouseMoveHandler = null;
                }
                if (shouldHide) {
                    toggleBtn.style.transition = 'opacity 0.5s ease-in-out, transform 0.3s ease';
                    const showIcon = () => {
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.pointerEvents = 'auto';
                        clearTimeout(this._menuIconTimeout);
                        // Hide again after 1s of no activity near it? 
                        // Or just 1s after showing? The prompt says "hide itself after one second".
                        this._menuIconTimeout = setTimeout(() => {
                            // Only hide if panel is CLOSED
                            if (!this.dom.panel.classList.contains('open')) {
                                toggleBtn.style.opacity = '0';
                                toggleBtn.style.pointerEvents = 'none';
                            }
                        }, 1000);
                    };
                    // Initial hide after delay
                    showIcon(); 
                    // Hot-zone detection
                    this._menuMouseMoveHandler = (e) => {
                        // Top right corner hot-zone (100x100px)
                        const isHotZone = (e.clientX > window.innerWidth - 100) && (e.clientY < 100);
                        if (isHotZone || this.dom.panel.classList.contains('open')) {
                            showIcon();
                        }
                    };
                    document.addEventListener('mousemove', this._menuMouseMoveHandler);
                } else {
                    // Reset to always visible
                    toggleBtn.style.opacity = '1';
                    toggleBtn.style.pointerEvents = 'auto';
                }
            }
            if(key) {
                // Keybinder Refresh Logic
                if (document.getElementById(`btn-key-${key}`)) {
                    this.updateKeyBinderVisuals(key);
                }
                const inp = document.getElementById(`in-${key}`);
                if(inp) { 
                    const def = this.defs.find(d=>d.id===key); 
                    if(def) { 
                        const val = this.c.get(key); 
                        if(def.type === 'checkbox') inp.checked = val; 
                        else if(def.type === 'color_list') this._renderColorList(inp, def);
                        else if(def.type === 'range') { 
                            inp.value = def.invert ? (def.max+def.min)-val : val; 
                            const disp = document.getElementById(`val-${key}`); 
                            if(disp) {
                                let displayVal = val;
                                if (!def.transform && typeof val === 'number') {
                                    const step = def.step || 1;
                                    const decimals = (step.toString().split('.')[1] || '').length;
                                    displayVal = parseFloat(val.toFixed(decimals));
                                }
                                disp.textContent = def.transform ? def.transform(val) : displayVal + (def.unit || ''); 
                            }
                        } else {
                            // Handle boolean values in select dropdowns correctly
                            inp.value = String(val);
                        }
                    } 
                }
            }
            // Update dependents
            this.dom.content.querySelectorAll(`[data-dep*="${key}"]`).forEach(row => {
                try {
                    const depRule = JSON.parse(row.getAttribute('data-dep')); 
                    const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                    let conditionsMet = true;
                    for (let rule of rules) { 
                        let target = rule; 
                        let expected = true; 
                        if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                        // Handle boolean vs string "true"/"false" mismatch
                        let actualVal = this.c.get(target);
                        if (actualVal === 'true') actualVal = true;
                        if (actualVal === 'false') actualVal = false;
                        const actual = !!actualVal; 
                        if (actual !== expected) { conditionsMet = false; break; } 
                    }
                    if(conditionsMet) row.classList.remove('control-disabled'); 
                    else row.classList.add('control-disabled');
                } catch(e) { console.warn("Error processing dependency row:", e); }
            });
        } catch(e) { console.warn("UI Refresh Error:", e); }
    }
}
    // =========================================================================
    // 10.0 MATRIX KERNEL
    // =========================================================================
// --- MatrixKernel.js ---
class MatrixKernel {
    constructor() {
        // Initialize core components
        this._initializeManagers();
        this._initializeEffects();
        // Frame handling and rendering variables
        this.frame = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.timestep = 1000 / 60;
        this._effectTimers = {}; // Initialize map for effect timers
        this._supermanTimer = 0; // Initialize Superman effect timer (will be managed in _effectTimers)
        this._setupResizeListener();
        this._setupInputListener();
        // FPS tracking variables
        this.lastFrameTime = 0; // Tracks time of the previous frame
        this.fpsHistory = []; // Used for simple FPS smoothing
        this.fpsDisplayElement = null; // Holds reference to the HTML element
        // Configuration subscription for dynamic updates
        this._setupConfigSubscriptions();
        // Override console.error based on logErrors setting
        const originalError = console.error;
        console.error = (...args) => {
            if (this.config.state.logErrors) {
                originalError.apply(console, args);
            }
        };
    }
    async initAsync() {
        // Asynchronous initialization steps
        await this._initializeRendererAndUI();
        // Perform the initial resize setup and start the loop
        this._resize();
        requestAnimationFrame((time) => this._loop(time));
        this.fpsDisplayElement = document.getElementById('fps-counter');
        // Trigger Boot Sequence on startup if enabled
        if (this.config.get('bootSequenceEnabled')) {
            // Short delay to ensure everything is ready
            setTimeout(() => {
                this.effectRegistry.trigger('BootSequence');
            }, 100);
        }
    }
    /**
     * Initializes core managers (Notification, Config, Grid, Simulation, EffectRegistry).
     * @private
     */
    _initializeManagers() {
        this.config = new ConfigurationManager();
        this.notifications = new NotificationManager(this.config);
        this.config.setNotificationManager(this.notifications);
        this.grid = new CellGrid(this.config);
        this.simulation = new SimulationSystem(this.grid, this.config);
        this.effectRegistry = new EffectRegistry(this.grid, this.config);
    }
    /**
     * Registers all active visual effects with the EffectRegistry.
     * @private
     */
    _initializeEffects() {
        const effects = [
            PulseEffect,
            ClearPulseEffect,
            MiniPulseEffect,
            DejaVuEffect,
            SupermanEffect,
            ReverseEffect,
            BootEffect,
            CrashEffect,
            QuantizedPulseEffect,
            QuantizedRetractEffect
        ];
        effects.forEach((EffectClass) => {
            if (EffectClass === CrashEffect || EffectClass === BootEffect || EffectClass === ReverseEffect) {
                this.effectRegistry.register(new EffectClass(this.grid, this.config, this.effectRegistry));
            } else {
                this.effectRegistry.register(new EffectClass(this.grid, this.config));
            }
        });
    }
    /**
     * Initializes the CanvasRenderer, FontManager, and UIManager.
     * @private
     */
    async _initializeRendererAndUI() {
        if (typeof WebGLRenderer !== 'undefined') {
             this.renderer = new WebGLRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
        } else {
             console.error("WebGLRenderer not found. Application cannot start.");
             this.notifications.show("Critical Error: WebGL Renderer missing.", "error");
             return;
        }
        this.fontMgr = new FontManager(this.config, this.notifications);
        this.charSelector = new CharacterSelectorModal(this.config, this.fontMgr, this.notifications);
        this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications, this.charSelector);
        // Overlay Canvas Setup
        this.overlayCanvas = document.getElementById('overlayCanvas');
        if (this.overlayCanvas) {
            this.overlayCtx = this.overlayCanvas.getContext('2d');
        }
        // Subscribe to font changes to invalidate rendering caches
        this.fontMgr.subscribe(() => {
            if (this.renderer) {
                this.renderer.handleFontChange();
            }
        });
        // Initialize font manager and await its completion
        await this.fontMgr.init();
        // Safety: Reset Shader State on Reload
        if (this.config.get('shaderEnabled')) {
            this.config.set('shaderEnabled', false);
            this.config.set('customShader', null);
        }
    }
    /**
     * Sets up a debounced window resize listener.
     * @private
     */
    _setupResizeListener() {
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this._resize(), 100); // Debounce resize events
        });
    }
    /**
     * Sets up the global input listener for key bindings.
     * @private
     */
    _setupInputListener() {
        window.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field or text area
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Ignore if in key binding mode (Double check flag)
            if (this.ui && this.ui.isKeyBindingActive) return;
            // Ignore if modifier keys are pressed (unless we want to support them later)
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            const bindings = this.config.state.keyBindings || {};
            const key = e.key.toLowerCase();
            for (const [action, boundKey] of Object.entries(bindings)) {
                if (boundKey && boundKey.toLowerCase() === key) {
                    if (action === 'ToggleUI') {
                        this.ui.togglePanel();
                    } else if (action === 'BootSequence' || action === 'CrashSequence') { 
                        if (action === 'CrashSequence' && !this.config.state.crashEnabled) return;
                        this.effectRegistry.trigger(action);
                        this.notifications.show(`${action} Triggered`, 'success');
                    }
                    else {
                        if (this.effectRegistry.trigger(action)) {
                            this.notifications.show(`${action} Triggered`, 'success');
                        }
                    }
                    // Prevent default action only if we matched a binding
                    e.preventDefault();
                    return;
                }
            }
        });
    }
    /**
     * Sets up subscriptions to configuration changes that trigger UI or rendering updates.
     * @private
     */
    _setupConfigSubscriptions() {
        const resizeTriggers = new Set([
            'resolution',
            'stretchX',
            'stretchY',
            'fontSize',
            'horizontalSpacingFactor',
            'verticalSpacingFactor',
            'fontOffsetX',
            'fontOffsetY'
        ]);
        const smoothingTriggers = new Set([
            'smoothingEnabled',
            'smoothingAmount'
        ]);
        const atlasTriggers = new Set([
            'fontWeight',
            'italicEnabled',
            'tracerSizeIncrease',
            'tracerGlow',
            'overlapColor',
            'streamPalette',
            'tracerColor'
        ]);
        const speedTriggers = new Set([
            'streamSpeed',
            'desyncIntensity'
        ]);
        this.config.subscribe((key) => {
            // Resize the canvas and grid on resolution-related changes
            if (resizeTriggers.has(key) || key === 'ALL') {
                this._resize();
            }
            // Recalculate stream speeds when timing settings change
            if ((speedTriggers.has(key) || key === 'ALL') && this.simulation && this.simulation.streamManager) {
                this.simulation.streamManager.recalculateSpeeds();
            }
            // Update renderer when smoothing settings change
            if (smoothingTriggers.has(key)) {
                this.renderer.updateSmoothing();
            }
            // Update Atlas if appearance changes (WebGL optimization)
            if ((atlasTriggers.has(key) || key === 'ALL') && this.renderer && this.renderer.handleAppearanceChange) {
                this.renderer.handleAppearanceChange();
            }
            const autoEffects = [
                { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
                { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
                { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
                { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
                { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
                { enabledKey: 'quantizedPulseEnabled', frequencyKey: 'quantizedPulseFrequencySeconds', effectName: 'QuantizedPulse' },
                { enabledKey: 'quantizedRetractEnabled', frequencyKey: 'quantizedRetractFrequencySeconds', effectName: 'QuantizedRetract' },
                { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
            ];
            autoEffects.forEach(effect => {
                if ((key === effect.enabledKey && this.config.state[effect.enabledKey]) || key === 'ALL') {
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                } else if (key === effect.enabledKey && !this.config.state[effect.enabledKey]) {
                    // If an effect is specifically disabled, remove its timer
                    delete this._effectTimers[effect.effectName];
                }
            });
        });
    }
    /**
     * Resizes the grid and renderer dimensions based on current window size and configuration.
     * @private
     */
    _resize() {
        this.grid.resize(
            (window.innerWidth) / this.config.state.stretchX,
            (window.innerHeight) / this.config.state.stretchY
        );
        this.renderer.resize();
        if (this.overlayCanvas) {
            this.overlayCanvas.width = window.innerWidth;
            this.overlayCanvas.height = window.innerHeight;
        }
    }
    /**
     * The main animation loop, handling updates and rendering.
     * Uses a fixed timestep for consistent simulation speed.
     * @private
     * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
     */
    _loop(time) {
    // 1. Calculate Delta and FPS
    const now = performance.now();
    const deltaFPS = now - this.lastFrameTime;
    this.lastFrameTime = now;
    if (deltaFPS > 0 && this.config.state.showFpsCounter) {
        const fps = 1000 / deltaFPS;
        // Simple 30-frame smoothing
        this.fpsHistory.push(fps);
        if (this.fpsHistory.length > 30) {
            this.fpsHistory.shift();
        }
        const smoothedFps = this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            // 2. Update Display
            if (this.fpsDisplayElement) {
                let text = `FPS: ${Math.round(smoothedFps)}`;
                if (this.config.state.debugEnabled) {
                     if (performance.memory) {
                         const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                         text += ` | Mem: ${used}MB`;
                     }
                     if (this.grid && this.grid.activeIndices) {
                         const cellCount = this.grid.activeIndices.size;
                         const sm = this.simulation.streamManager;
                         // Safety check for streamManager
                         const streams = sm ? sm.activeStreams : [];
                         const tracers = streams.filter(s => !s.isEraser && !s.isUpward).length;
                         const erasers = streams.filter(s => s.isEraser).length;
                         let rotators = 0;
                         for (const idx of this.grid.activeIndices) {
                             if (this.grid.types[idx] === CELL_TYPE.ROTATOR) rotators++;
                         }
                         const shimmers = this.grid.complexStyles.size;
                         text += ` | Cells: ${cellCount}`;
                         text += ` | Tracers: ${tracers}`;
                         text += ` | Erasers: ${erasers}`;
                         text += ` | Rotators: ${rotators}`;
                         text += ` | Shimmers: ${shimmers}`;
                     }
                }
                this.fpsDisplayElement.textContent = text;
                this.fpsDisplayElement.style.display = 'block';
            }
        } else if (this.fpsDisplayElement) {
            // Hide the counter if the setting is disabled
            this.fpsDisplayElement.style.display = 'none';
        }
        // Start main rendering loop
        if (!this.lastTime) this.lastTime = time;
        const delta = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += delta;
        while (this.accumulator >= this.timestep) {
            this._updateFrame();
            this.accumulator -= this.timestep;
        }
        this.renderer.render(this.frame);
        // Render Overlay Effects
        if (this.overlayCtx) {
            this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
            this.effectRegistry.render(this.overlayCtx, this.config.derived);
        }
        requestAnimationFrame((nextTime) => this._loop(nextTime));
    }
    /**
     * Updates the simulation logic for a single frame.
     * @private
     */
    _updateFrame() {
        this.frame++;
        this.effectRegistry.update();
        this.simulation.update(this.frame);
        const autoEffects = [
            { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
            { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
            { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
            { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
            { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
            { enabledKey: 'quantizedPulseEnabled', frequencyKey: 'quantizedPulseFrequencySeconds', effectName: 'QuantizedPulse' },
            { enabledKey: 'quantizedRetractEnabled', frequencyKey: 'quantizedRetractFrequencySeconds', effectName: 'QuantizedRetract' },
            { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
        ];
        autoEffects.forEach(effect => {
            if (this.config.state[effect.enabledKey]) {
                if (!this._effectTimers[effect.effectName]) {
                    // Initialize timer with randomization if not already set
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
                this._effectTimers[effect.effectName]--;
                if (this._effectTimers[effect.effectName] <= 0) {
                    this.effectRegistry.trigger(effect.effectName);
                    // Reset timer with randomization
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5);
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
            } else {
                // If effect is disabled, ensure its timer is reset or cleared
                if (this._effectTimers[effect.effectName]) {
                    delete this._effectTimers[effect.effectName];
                }
            }
        });
    }
}
// Initialize the MatrixKernel on DOMContentLoaded
window.addEventListener('DOMContentLoaded', async () => {
    const kernel = new MatrixKernel();
    // Expose kernel and config globally for debugging/console access
    window.matrix = kernel;
    window.config = kernel.config;
    await kernel.initAsync();
    kernel.lastFrameTime = performance.now(); // Set initial time
});
// --- Patch: Integrate Embedded Assets ---
(function() {
    if (typeof ConfigurationManager !== 'undefined') {
        const orig = ConfigurationManager.prototype._loadSlots;
        ConfigurationManager.prototype._loadSlots = function() {
            let local = null; try { local = orig.call(this); } catch(e) {}
            if (local && local.length > 0 && local[0].name) return local;
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.presets) {
                for (const k in __EMBEDDED_ASSETS__.presets) {
                    const p = __EMBEDDED_ASSETS__.presets[k];
                    if (p && p.savedPresets) return p.savedPresets;
                }
            }
            return local || [];
        };
    }
    if (typeof FontManager !== 'undefined') {
        const orig = FontManager.prototype.init;
        FontManager.prototype.init = async function() {
            await orig.call(this);
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.fonts) {
                for (const [n, d] of Object.entries(__EMBEDDED_ASSETS__.fonts)) {
                    const fam = n.split('.')[0].replace(/-/g, ' ');
                    if (this.loadedFonts.some(f => f.name === fam)) continue;
                    const ok = await this._registerFontFace({ name: fam, sourceUrl: d, formatHint: n.endsWith('woff2')?"format('woff2')":"format('truetype')", canvasPx: 20 });
                    if (ok) this.loadedFonts.push({ name: fam, display: fam, isEmbedded: true });
                }
                this._notify();
            }
        };
    }
    if (typeof PostProcessor !== 'undefined') {
        const orig = PostProcessor.prototype.compileShader;
        PostProcessor.prototype.compileShader = function(src) {
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.shaders && __EMBEDDED_ASSETS__.shaders[src]) {
                src = __EMBEDDED_ASSETS__.shaders[src];
            }
            return orig.call(this, src);
        };
    }
})();
</script>
    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>