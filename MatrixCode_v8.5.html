<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain v8.5</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
:root {
    --bg-color: #000;
    --panel-bg: rgba(10, 12, 16, 0.96);
    --panel-border: rgba(34, 197, 94, 0.3);
    --text-main: #4ade80;
    --text-muted: #86efac;
    --accent: #22c55e;
    --accent-glow: rgba(34, 197, 94, 0.4);
    --danger: #ef4444;
    --info: #3b82f6; /* Preserved from existing */
    --warn: #f59e0b; /* Preserved from existing */
    --safe-top: env(safe-area-inset-top, 20px);
    --safe-right: env(safe-area-inset-right, 20px);
}
#fps-counter {
    position: fixed;
    top: 10px;
    left: 10px;
    color: var(--text-main);
    font-family: monospace;
    font-size: 14px;
    z-index: 10000; /* Ensure it is above the canvas */
    text-shadow: 0 0 5px var(--accent-glow);
    padding: 2px 5px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    user-select: none;
}
        * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        html, body {
    height: 100%;
    font-family: 'Segoe UI', 'Roboto', monospace;
    background-color: var(--bg-color);
    overscroll-behavior: none;
    overflow: hidden; /* Retained from existing style */
}
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; transform: translateZ(0); -webkit-transform: translateZ(0); }
        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 11000;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }
        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }
        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }
        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }
        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        #tabTrack { display: inline-flex; width: max-content; }
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }
        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }
        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }
        .accordion-subheader {
            margin-top: 0.75rem; margin-bottom: 0.2rem;
            font-size: 0.85rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 3px;
            padding-left: 0.25rem;
        }
        .info-description {
            font-size: 1.0rem;
            color: var(--text-muted);
            padding: 0.5rem 0.25rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .faq-item {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        .faq-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .faq-question {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }
        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}
/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1.5rem;
    border-radius: 6px;
    margin-top: 1.5rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
    text-align: center;
    margin-bottom: 0.5rem;
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; margin-right: 10px; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: 25%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px; margin-right: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }
        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 12000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }
        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 12001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }
        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 48px; }
        input[type="color"] { border: none; width: 48px; height: 48px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }
        /* Color List Styling */
        .color-list-wrapper { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; width: 100%; margin-top: 8px; }
        .color-list-item { position: relative; display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; }
        .color-list-item input[type="color"] { width: 48px; height: 48px; border-width: 2px; }
        .btn-icon-remove {
            position: absolute; top: -6px; right: -6px;
            width: 20px; height: 20px; border-radius: 50%;
            background: #ef4444; color: white; border: 1px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; cursor: pointer; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            line-height: 1; padding-bottom: 2px;
        }
        .btn-icon-add {
            width: 48px; height: 48px; border-radius: 50%;
            border: 2px dashed var(--accent);
            background: rgba(34, 197, 94, 0.1);
            color: var(--accent);
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            line-height: 1; padding-bottom: 3px;
        }
        .btn-icon-add:hover { background: rgba(34, 197, 94, 0.3); transform: scale(1.05); }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }
        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }
        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }
        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        #menuToggle {
    position: fixed;
    top: max(0.75em, var(--safe-top));
    right: max(1.2em, var(--safe-right));
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--panel-border);
    background: rgba(10, 12, 16, 0.6);
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 11100;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px); /* Retained from existing style */
    cursor: pointer; /* Retained from existing style */
}
#menuToggle:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 20px var(--accent);
    transform: rotate(30deg);
}
        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
/* --- MODAL UI --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 11500;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
    backdrop-filter: blur(5px);
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
    background: var(--panel-bg); border: 1px solid var(--accent);
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
    width: 90%; max-width: 600px;
    border-radius: 8px;
    display: flex; flex-direction: column;
    max-height: 90vh;
}
.modal-header {
    padding: 1rem; border-bottom: 1px solid var(--panel-border);
    display: flex; justify-content: space-between; align-items: center;
    background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
}
.modal-title { font-size: 1.1rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; margin: 0; }
.modal-close { cursor: pointer; color: var(--text-muted); font-size: 1.5rem; line-height: 1; }
.modal-close:hover { color: var(--danger); }
.modal-body { padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; }
.modal-footer {
    padding: 1rem; border-top: 1px solid var(--panel-border);
    display: flex; justify-content: flex-end; gap: 1rem;
}
textarea.char-input {
    width: 100%; height: 100px; background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1); color: var(--text-main);
    padding: 0.5rem; font-family: monospace; font-size: 1rem;
    resize: vertical;
}
textarea.char-input:focus { outline: none; border-color: var(--accent); }
.modal-label { display: block; margin-bottom: 0.5rem; color: #fff; font-size: 0.9rem; font-weight: bold; }
.modal-desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; }
/* --- CHARACTER SELECTOR REFINEMENTS --- */
/* Fix label colors */
.checkbox-row span {
    color: var(--text-main);
    font-size: 0.95rem;
    font-weight: 600;
}
/* Character Grid */
.char-grid-container {
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 10px;
    max-height: 250px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 8px;
    margin-top: 10px;
}
.char-grid-item {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 20px;
    color: var(--text-muted);
    user-select: none;
    transition: all 0.2s;
}
.char-grid-item:hover {
    border-color: var(--accent);
    background: rgba(34, 197, 94, 0.2);
    color: #fff;
}
.char-grid-item.selected {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent-glow);
}
.char-grid-item.empty {
    opacity: 0.3;
    pointer-events: none;
    background: #000;
}
.char-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.scan-status {
    font-size: 0.8rem;
    color: var(--warn);
    margin-top: 5px;
    min-height: 1.2em;
}
/* --- STANDALONE EDITOR MODE --- */
.editor-window-mode {
    background-color: #111;
}
.editor-window-mode #menuToggle,
.editor-window-mode #settingsPanel,
.editor-window-mode #fps-counter,
.editor-window-mode #toast-container,
.editor-window-mode canvas {
    display: none !important;
}
#quant-editor-ui {
    max-width: 100%;
}
.editor-window-mode #quant-editor-ui {
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    border: none !important;
    box-shadow: none !important;
    background: #000 !important;
    overflow-y: auto;
}
</style>
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E">
</head>
<body>
    <div id="fps-counter" style="display: none;">FPS: 60</div>
    <!-- Primary Canvas for Matrix Animation -->
    <canvas id="matrixCanvas" aria-label="Matrix Digital Rain Animation"></canvas>
    <!-- Overlay Canvas for Vector Effects -->
    <canvas id="overlayCanvas" style="z-index: 3; pointer-events: none;"></canvas>
    <!-- Hidden Bloom Canvas for Layer Effects -->
    <canvas id="bloomCanvas" hidden aria-hidden="true"></canvas>
    <!-- Toggle Button for Opening Settings Menu -->
    <button id="menuToggle" aria-controls="settingsPanel" aria-expanded="false" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03 .66.07 .98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"></path>
        </svg>
    </button>
    <!-- Input for Importing Files -->
    <input type="file" id="importFile" accept=".json" hidden aria-label="Import JSON Configuration" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" hidden aria-label="Import Font Files" />
    <!-- Settings Panel -->
    <aside id="settingsPanel" role="dialog" aria-hidden="true">
        <header id="panelHeader" role="banner">
            <h2 class="panel-title">Settings</h2>
        </header>
        <!-- Navigation Tabs -->
        <nav id="navTabs" role="tablist" aria-label="Settings Navigation"></nav>
        <!-- Content Area -->
        <main id="contentArea">
            <!-- Dynamic content will populate through scripts -->
        </main>
        <!-- Panel Footer -->
        <footer id="panelFooter">
            <p id="globalStatus" class="status-msg"></p>
        </footer>
    </aside>
    <script>const __EMBEDDED_ASSETS__ = {"shaders": {"BASETEMPLATE.glsl": "// base_template.glsl\nprecision highp float;                    // highp for desktop; switch to mediump for mobile if needed\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;            // (width, height)\nuniform float     uTime;                  // seconds\nuniform vec2      uMouse;                 // normalized [0..1]\nuniform float     uParameter;             // UI slider [0..1]\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec4 base = texture2D(uTexture, vTexCoord);\n    gl_FragColor = base;                  // start from base; \n}\n", "crt_monitor.glsl": "// Name: CRT Monitor\n\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = lines closer together, but line thickness is proportional\nconst float LINE_THICKNESS = 0.3;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// CRT Color Shift (Chromatic Aberration) Settings\nconst float SHIFT_AMOUNT = 0.01;       // Magnitude of the color fringe (very small)\n\n// Brightness Boost (Thresholding/Glow) Settings\nconst float BRIGHTNESS_THRESHOLD = 0.3;  // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;      // How much to multiply bright colors by\n\n// --- Barrel Distortion Settings ---\nconst float BARREL_DISTORTION_AMOUNT = 1.0; // Controls the bulge magnitude (0.0 to 1.0)\n\nvoid main() {\n    \n    // --- 1. CRT Barrel Distortion (Warp) ---\n    \n    // A. Center coordinates: shifts vTexCoord from [0.0, 1.0] to [-0.5, 0.5]\n    vec2 centeredCoord = vTexCoord - 0.5;\n    \n    // B. Calculate distance squared from center\n    // The distortion effect should be stronger in the corners than in the middle.\n    // dot(v, v) is a fast way to get length squared (r*r).\n    float r2 = dot(centeredCoord, centeredCoord); \n    \n    // C. Calculate the distortion factor\n    // The factor must be > 1.0 for a convex (bulging) look. \n    // It's calculated by adding a fraction of the distance (r2) to 1.0.\n    float factor = 1.0 + r2 * (BARREL_DISTORTION_AMOUNT * uParameter * 0.25);\n\n    // D. Apply the factor and shift back to 0.0-1.0 range\n    // This coordinate will be our base for sampling the warped image.\n    vec2 warpedTexCoord = centeredCoord * factor + 0.5;\n\n    // --- Boundary Check ---\n    // If the warped coordinate is outside [0.0, 1.0], it's smeared/clipped.\n    // The 'any' function checks if any component (x or y) of the boolean vector is true.\n    if (any(lessThan(warpedTexCoord, vec2(0.0))) || any(greaterThan(warpedTexCoord, vec2(1.0)))) {\n        // If the coordinate is outside the bounds, output black (or transparent)\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return; // Exit the shader immediately to skip all further calculations\n    }\n\n    // --- 2. CRT Chromatic Shift (Red/Blue Fringing) ---\n    \n    // The centerBias calculation remains based on the original vTexCoord \n    // to keep the color shift aligned with the screen's surface.\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord);\n    \n    float centerBias = fractionalPart.x - 0.5; \n    float shiftMagnitude = sin(centerBias * 3.14159265); \n\n    // Sample the texture three times using the **warpedTexCoord** as the base\n    vec2 redCoord   = warpedTexCoord + vec2(-shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);\n    vec2 blueCoord  = warpedTexCoord + vec2( shiftMagnitude * SHIFT_AMOUNT * uParameter, 0.0);\n    \n    // Use the base warped coordinate for the green channel\n    float red   = texture2D(uTexture, redCoord).r;\n    float green = texture2D(uTexture, warpedTexCoord).g; \n    float blue  = texture2D(uTexture, blueCoord).b;\n    \n    vec4 finalColor = vec4(red, green, blue, 1.0);\n\n    // --- 3. Static Grid Overlay ---\n\n    // The grid lines are calculated using the original screen coordinate (vTexCoord)\n    // which simulates the grid being painted onto the curved glass.\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n\n    // Apply the grid\n    vec3 blendedColor = mix(finalColor.rgb, GRID_COLOR, gridMask);\n    finalColor.rgb = mix(finalColor.rgb, blendedColor, GRID_OPACITY);\n\n\n    // --- 4. Brightness Boost (Thresholding/Glow Effect) ---\n\n    float brightness = dot(finalColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);\n    finalColor.rgb *= finalMultiplier;\n\n    \n    // 5. Output Final Color\n    gl_FragColor = finalColor;\n}", "dirty_LCD.glsl": "// Name: Dirty LCD Monitor\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional\nconst float LINE_THICKNESS = 0.4;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// Adding grain dirtyness to the screen\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// Random graininess\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Boosting Pixel Brightness\nconst float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by\n\n\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord);\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);\n    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY);\n\n\n    // 1. Calculate the final grid-processed color's overall brightness (Luminance).\n    float brightness = dot(color.rgb, vec3(0.1126, 0.7152, 0.0522));\n\n    // 2. Determine the boost factor\n    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.\n    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    \n    // 3. Apply the boost to the color channels.\n    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.\n    // mix(Color A, Color B, Factor)\n    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)\n    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)\n    float finalMultiplier = mix(uParameter + 1.0, BRIGHTNESS_BOOST, boostFactor * uParameter);\n    \n    color.rgb *= finalMultiplier;\n    \n    // 5. Calculate static noise    \n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 6. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * GRAIN_AMOUNT;\n    \n    // 7. Output final color\n    gl_FragColor = color;\n}", "double_vision.glsl": "// Name: Double Vision\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Configuration for the effect\nconst float BLUR_SAMPLES = 2.0; // How many times to sample the texture (higher = smoother but slower)\nconst float BLUR_AMOUNT = 0.0001; // How intense the blur is\n\nvoid main() {\n    // 1. Center the coordinates\n    // We shift vTexCoord (0.0 to 1.0) so that the center of the screen is (0.0, 0.0).\n    vec2 center = vec2(0.5, 0.5); // The blur's origin point (center of the screen)\n    vec2 direction = vTexCoord - center; // Vector pointing from center to the current pixel\n\n    // 2. Initialize the final color\n    // We start with a black color (vec4(0.0))\n    vec4 finalColor = vec4(0.0);\n\n    // 3. Loop through samples\n    for (float i = 0.0; i < BLUR_SAMPLES; i++) {\n        // Calculate the current step along the blur ray.\n        // The 'mix' function smoothly interpolates (mixes) between two values.\n        // It's used here to define a position along the ray from 0.0 (center) to 1.0 (current pixel).\n        float step = i / (BLUR_SAMPLES - 1.0);\n\n        // Calculate the new coordinate for this sample.\n        // This coordinate is closer to the center than the original vTexCoord.\n        vec2 sampleCoord = mix(vTexCoord, center, step * BLUR_AMOUNT * (uParameter * 10.0) * 100.0);\n        \n        // --- IMPORTANT LOGIC EXPLAINED BELOW ---\n        // 'mix(A, B, t)' returns A*(1-t) + B*t. \n        // We use 'step * BLUR_AMOUNT * 100.0' to control how much to mix towards the center.\n        // The factor of 100.0 turns the small BLUR_AMOUNT (e.g., 0.005) into a more usable ratio (e.g., 0.5).\n\n        // Sample the color at the new, shifted coordinate\n        vec4 sampledColor = texture2D(uTexture, sampleCoord);\n\n        // Add the sampled color to our final average\n        finalColor += sampledColor;\n    }\n\n    // 4. Calculate the average color\n    // Divide the accumulated colors by the number of samples taken.\n    gl_FragColor = finalColor / BLUR_SAMPLES;\n}", "edge_glow_sobel.glsl": "// Name: Edge Glow (Sobel)\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec2 uv = vTexCoord;\n    vec2 px = 1.0 / uResolution;          // per\u2011pixel offsets\n\n    // Luma samples\n    float tl = dot(texture2D(uTexture, uv + px*vec2(-1,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  l = dot(texture2D(uTexture, uv + px*vec2(-1,  0)).rgb, vec3(0.2126,0.7152,0.0722));\n    float bl = dot(texture2D(uTexture, uv + px*vec2(-1, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  t = dot(texture2D(uTexture, uv + px*vec2( 0,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  b = dot(texture2D(uTexture, uv + px*vec2( 0, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float tr = dot(texture2D(uTexture, uv + px*vec2( 1,  1)).rgb, vec3(0.2126,0.7152,0.0722));\n    float  r = dot(texture2D(uTexture, uv + px*vec2( 1,  0)).rgb, vec3(0.2126,0.7152,0.0722));\n    float br = dot(texture2D(uTexture, uv + px*vec2( 1, -1)).rgb, vec3(0.2126,0.7152,0.0722));\n\n    float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;\n    float gy =  tl + 2.0*t + tr - bl - 2.0*b - br;\n    float edge = sqrt(gx*gx + gy*gy);\n\n    vec4 base = texture2D(uTexture, uv);\n    float glowAmt = mix(0.0, 0.6, uParameter);\n    base.rgb += edge * glowAmt;\n\n    gl_FragColor = clamp(base, 0.0, 1.0);\n}", "film_grain.glsl": "// Name: Dirty Film Grain\nprecision mediump float;\n\n// Uniforms provided by PostProcessor.js\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uTime;\nuniform float uParameter;\n\n// Use vTexCoord from Vertex Shader for correct orientation\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.1; // Intensity of the grain (0.0 to 1.0)\nconst bool ANIMATED = true;      // Whether the grain dances (true) or is static (false)\nconst float SPEED = 2.2;         // Speed of grain animation\n\n// Random function\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // Sample the original texture using standard texture coordinates\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // Calculate noise\n    // We can use gl_FragCoord or vTexCoord for noise seed\n    float t = ANIMATED ? uTime * SPEED : 0.0;\n    \n    // Generate random noise value [-1.0, 1.0]\n    float noise = (random(vTexCoord + t) - 0.5) * 2.0;\n    \n    // Apply grain\n    color.rgb += noise * ((uParameter - 0.1) + GRAIN_AMOUNT);\n    \n    // Output final color\n    gl_FragColor = color;\n}\n", "hue_shift.glsl": "// Name: Hue Shift\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c){\n    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);\n    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.x = fract(hsv.x + uTime * 0.05 * (0.2 + 0.8*uParameter));           // animate hue\n    hsv.y *= mix(1.0, 0.35, uParameter);                                    // desaturate\n    vec3 outc = hsv2rgb(hsv);\n    gl_FragColor = vec4(outc, 1.0);\n}\n", "matrix_blue_hue.glsl": "// Name: Matrix Real-World Blue Hue\nprecision highp float;                    // highp for desktop; switch to mediump for mobile if needed\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;            // (width, height)\nuniform float     uTime;                  // seconds\nuniform vec2      uMouse;                 // normalized [0..1]\nuniform float     uParameter;             // UI slider [0..1]\n\nvarying vec2      vTexCoord;\n\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c){\n    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);\n    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.x = mix(hsv.x, 0.55, uParameter * 0.25);    // Hue change                                       \n    hsv.y = mix(hsv.y, 0.0, uParameter * 0.25);            // Saturation change\n    vec3 outc = hsv2rgb(hsv);\n    gl_FragColor = vec4(outc, 1.0);\n}", "mouse_ripple.glsl": "// Name: Mouse Lens Ripple\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    vec2 uv = vTexCoord;\n    vec2 center = vec2(uMouse.x, 1.0 - uMouse.y);\n    float radius = mix(0.02, 0.60, uParameter);\n    float dist = distance(uv, center);\n    float mask = smoothstep(radius, 0.0, dist);\n\n    // Dynamic ripple offset\n    float wave = sin(24.0*dist - 4.0*uTime) * 0.003 * uParameter;\n    vec2 dir = normalize(uv - center);\n    uv += dir * wave * mask;\n\n    // Mild magnification inside the lens\n    float magnify = mix(1.0, 1.15, uParameter);\n    uv = mix(uv, center + (uv - center)/magnify, mask);\n\n    gl_FragColor = texture2D(uTexture, uv);\n}\n", "pixelate.glsl": "// Name: Pixelate\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\nvoid main() {\n    float scale = mix(1.0, 0.15, uParameter);      // 1.0 no pixelate; 0.15 heavy\n    vec2 grid = floor(vTexCoord * uResolution * scale) / (uResolution * scale);\n    vec4 color = texture2D(uTexture, grid);\n    gl_FragColor = color;\n}\n", "screen_door.glsl": "// Name: Screen Door\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uParameter;\nvarying vec2 vTexCoord;\n\n// Change this value to make the lines denser!\n// It represents the WIDTH/HEIGHT of one grid cell in pixels.\nconst float GRID_CELL_SIZE = 2.0; // Lower numbers = More lines, but thickness is proportional\nconst float LINE_THICKNESS = 0.4;\nconst vec3 GRID_COLOR = vec3(0.0, 0.0, 0.0);\nconst float GRID_OPACITY = 0.5;\n\n// Boosting Pixel Brightness\nconst float BRIGHTNESS_THRESHOLD = 0.4; // Only pixels brighter than this will be boosted\nconst float BRIGHTNESS_BOOST = 1.6;     // How much to multiply the existing bright colors by\n\n\nvoid main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n\n    vec2 pixelCoord = vTexCoord * uResolution.xy;\n    vec2 scaledCoord = pixelCoord / GRID_CELL_SIZE;\n    vec2 fractionalPart = fract(scaledCoord * uParameter);\n    float verticalLine = step(fractionalPart.x, LINE_THICKNESS * uParameter + 0.1);\n    float horizontalLine = step(fractionalPart.y, LINE_THICKNESS * uParameter + 0.1);\n    float gridMask = min(verticalLine + horizontalLine, 1.0);\n    vec3 blendedColor = mix(color.rgb, GRID_COLOR, gridMask);\n    color.rgb = mix(color.rgb, blendedColor, GRID_OPACITY * uParameter);\n\n\n    // 1. Calculate the final grid-processed color's overall brightness (Luminance).\n    float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n    // 2. Determine the boost factor\n    // The 'step' function returns 1.0 if the condition is true, 0.0 if false.\n    // If the pixel's brightness is above the threshold, this 'boostFactor' will be 1.0.\n    float boostFactor = step(BRIGHTNESS_THRESHOLD, brightness);\n    \n    // 3. Apply the boost to the color channels.\n    // We mix between a base factor of 1.0 (no change) and the desired BRIGHTNESS_BOOST.\n    // mix(Color A, Color B, Factor)\n    // If boostFactor is 0.0: returns 1.0 (color.rgb * 1.0)\n    // If boostFactor is 1.0: returns BRIGHTNESS_BOOST (color.rgb * 1.2)\n    float finalMultiplier = mix(1.0, BRIGHTNESS_BOOST, boostFactor);\n    \n    color.rgb *= finalMultiplier;\n\n    gl_FragColor = color;\n}", "smear_LCDgrid.glsl": "// Name: Vertical Smear + LED Grid\n\n// Vertical Smear (upwards only) + LED Matrix Grid (faded, brightness-aware)\n// Uniforms: uTexture, uResolution, uTime, uMouse, uParameter, vTexCoord\n// uParameter drives the smear length in pixels: 0.0 = none, 1.0 = MAX_SMEAR_PX\n\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2      uResolution;\nuniform float     uTime;\nuniform vec2      uMouse;\nuniform float     uParameter;\n\nvarying vec2      vTexCoord;\n\n// ------------------- Tunables -------------------\n\n// If the smear still goes the wrong way, flip this sign to -1.0.\n// +1.0 means \"sample from above\" when vTexCoord.y increases toward the top.\n// -1.0 means \"sample from below\".\nconst float Y_SIGN            = +1.0;\n\nconst float MAX_SMEAR_PX      = 48.0;   // max smear length (pixels) at uParameter=1\nconst float SMEAR_DECAY       = 0.30;   // exponential falloff per tap (higher = faster decay)\nconst int   SMEAR_TAPS_COUNT  = 8;      // unrolled taps count (do not change in code block)\n\n// Smear applies more strongly to bright glyphs.\n// Raise or lower the range to taste.\nconst float SMEAR_LUMA_MIN    = 0.30;   // start applying smear above this luma\nconst float SMEAR_LUMA_MAX    = 0.85;   // full smear by this luma\n\n// LED grid parameters\nconst float GRID_SPACING_PX   = 8.0;    // cell size (pixels)\nconst float GRID_THICKNESS_PX = 1.0;    // seam thickness (pixels)\nconst float GRID_FADE_MAX     = 0.15;   // max darkening on grid lines\nconst float GRID_CROSS_GLOW   = 0.02;   // tiny highlight at intersections\nconst float GRID_LUMA_POWER   = 1.2;    // tie grid visibility to luma (>=1.0 less persistent in dark)\n\n// ------------------- Helpers -------------------\n\nfloat luma(vec3 c) {\n    // Rec.709 luma\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// Sample along vertical with Y_SIGN and clamp to [0,1] range.\nvec3 sampleVertical(vec2 uv, float offsetPx, vec2 px) {\n    float y = clamp(uv.y + Y_SIGN * offsetPx * px.y, 0.0, 1.0);\n    return texture2D(uTexture, vec2(uv.x, y)).rgb;\n}\n\n// Upward-only smear via unrolled taps for WebGL1 stability.\nvec3 smearUp(vec2 uv, float smearLenPx, float brightnessFactor) {\n    // brightnessFactor scales how much we mix the smear in (from 0..1)\n    vec2  px    = 1.0 / uResolution;\n    float stepPx= smearLenPx / float(SMEAR_TAPS_COUNT);\n\n    vec3 accum  = texture2D(uTexture, uv).rgb;\n    float wsum  = 1.0;\n\n    // Unrolled 8 taps with exponential weights\n    {\n        float w1 = exp(-1.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 1.0, px) * w1;\n        wsum  += w1;\n\n        float w2 = exp(-2.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 2.0, px) * w2;\n        wsum  += w2;\n\n        float w3 = exp(-3.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 3.0, px) * w3;\n        wsum  += w3;\n\n        float w4 = exp(-4.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 4.0, px) * w4;\n        wsum  += w4;\n\n        float w5 = exp(-5.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 5.0, px) * w5;\n        wsum  += w5;\n\n        float w6 = exp(-6.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 6.0, px) * w6;\n        wsum  += w6;\n\n        float w7 = exp(-7.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 7.0, px) * w7;\n        wsum  += w7;\n\n        float w8 = exp(-8.0 * SMEAR_DECAY);\n        accum += sampleVertical(uv, stepPx * 8.0, px) * w8;\n        wsum  += w8;\n    }\n\n    vec3 smeared = accum / wsum;\n\n    // Mix based on glyph brightness so darker glyphs retain less shadow,\n    // matching your observation.\n    vec3 base    = texture2D(uTexture, uv).rgb;\n    float lum    = luma(base);\n    float mixAmt = brightnessFactor * smoothstep(SMEAR_LUMA_MIN, SMEAR_LUMA_MAX, lum);\n\n    return mix(base, smeared, mixAmt);\n}\n\n// LED grid mask in pixel space (gl_FragCoord).\n// Returns line intensity in 0..1.\nfloat gridMask(vec2 frag) {\n    float modX  = mod(frag.x, GRID_SPACING_PX);\n    float distX = min(modX, GRID_SPACING_PX - modX);\n\n    float modY  = mod(frag.y, GRID_SPACING_PX);\n    float distY = min(modY, GRID_SPACING_PX - modY);\n\n    float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);\n    float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);\n\n    return max(lineX, lineY);\n}\n\nvoid main() {\n    vec2 uv         = vTexCoord;\n    vec4 base4      = texture2D(uTexture, uv);\n    vec3 base       = base4.rgb;\n    vec2 frag       = gl_FragCoord.xy;\n\n    // Smear length driven by uParameter (pixels)\n    float smearLenPx = clamp(uParameter, 0.0, 1.0) * MAX_SMEAR_PX;\n\n    // Smear strength factor (independent of luma ramp)\n    float smearStrength = 1.0; // keep 1.0; you can expose a second uniform if desired\n\n    // Upward-only smear with brightness-aware mixing\n    vec3 color = smearUp(uv, smearLenPx, smearStrength);\n\n    // LED grid faded by brightness so it is less persistent in dark regions\n    float gridI   = gridMask(frag);\n    float lum     = pow(luma(color), GRID_LUMA_POWER); // make grid respond more to bright glyphs\n    float fadeAmt = GRID_FADE_MAX * lum;               // reduce grid visibility in dark areas\n\n    color *= mix(1.0, 1.0 - fadeAmt, gridI);\n\n    // Tiny intersection glow (also brightness-aware)\n    if (GRID_CROSS_GLOW > 0.0) {\n        float modX  = mod(frag.x, GRID_SPACING_PX);\n        float distX = min(modX, GRID_SPACING_PX - modX);\n        float lineX = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distX);\n\n        float modY  = mod(frag.y, GRID_SPACING_PX);\n        float distY = min(modY, GRID_SPACING_PX - modY);\n        float lineY = 1.0 - smoothstep(GRID_THICKNESS_PX, GRID_THICKNESS_PX + 1.0, distY);\n\n        color += vec3(GRID_CROSS_GLOW) * (lineX * lineY) * lum;\n    }\n\n    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}", "static_grain.glsl": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}"}, "presets": {"matrix_conf_v8.5_Presets.json": {"version": "8.5", "state": {"streamColor": "#65d778", "backgroundColor": "#020509", "streamPalette": ["#00e004", "#75ff1a"], "paletteBias": 0, "colorMixType": 0, "tracerColor": "#d7ffd7", "fontSize": 22, "streamSpeed": 17, "releaseInterval": 2, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": false, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 15, "overlapEnabled": false, "overlapColor": "#fff5b8", "overlapDensity": 0.3, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -2, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.6, "tracerGlow": 6, "clearAlpha": 1, "horizontalSpacingFactor": 0.95, "verticalSpacingFactor": 0.95, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1, "decayFadeDurationFrames": 25, "trailLengthVarianceEnabled": true, "trailLengthVariance": 151, "streamSpawnCount": 3, "eraserSpawnCount": 2, "minStreamGap": 2, "minEraserGap": 2, "minGapTypes": 30, "allowTinyStreams": true, "gradualColorStreams": true, "gradualColorStreamsFrequency": 60, "holeRate": 0, "desyncIntensity": 0.35, "preferClusters": true, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 4, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.81, "upwardTracerAttackFrames": 2, "upwardTracerHoldFrames": 4, "upwardTracerReleaseFrames": 30, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 1.3, "upwardTracerGlimmerSpeed": 3.15, "upwardTracerGlimmerSize": 5, "upwardTracerGlimmerFill": 5, "upwardTracerGlimmerGlow": 6, "upwardTracerGlimmerFlicker": 0.45, "rotatorEnabled": true, "rotatorChance": 0.25, "rotatorSyncToTracer": false, "rotatorSyncMultiplier": 0.3, "rotatorCycleFactor": 16, "rotatorCrossfadeFrames": 4, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 41, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.03, "effectParameter": 0, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 300, "quantizedPulseDurationSeconds": 10, "quantizedPulseSpeed": 5, "quantizedBlockWidthCells": 3, "quantizedBlockHeightCells": 3, "quantizedPulseBorderIllumination": 1.1, "quantizedPulsePerimeterThickness": 0.6, "quantizedPulsePerimeterColor": "#eeff00", "quantizedPulseInnerColor": "#0cd709", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 280, "quantizedAddDurationSeconds": 3.7, "quantizedAddBorderIllumination": 5.6, "quantizedAddSpeed": 5, "quantizedAddBlockWidthCells": 3, "quantizedAddBlockHeightCells": 3, "quantizedAddPerimeterThickness": 0.7, "quantizedAddPerimeterColor": "#d4ff00", "quantizedAddInnerColor": "#000000", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 250, "quantizedRetractDurationSeconds": 5, "quantizedRetractSpeed": 4.3, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 0, "quantizedRetractFadeFrames": 0, "quantizedRetractBorderIllumination": 5.7, "quantizedRetractPerimeterThickness": 0.6, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#0011ff", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 265, "quantizedClimbDurationSeconds": 3.6, "quantizedClimbSpeed": 5, "quantizedClimbBlockWidthCells": 3, "quantizedClimbBlockHeightCells": 3, "quantizedClimbFadeInFrames": 0, "quantizedClimbFadeFrames": 0, "quantizedClimbBorderIllumination": 5.4, "quantizedClimbPerimeterThickness": 0.5, "quantizedClimbPerimeterColor": "#e1ff00", "quantizedClimbInnerColor": "#027a00", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 60, "quantizedZoomFadeFrames": 15, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 1, "quantizedZoomPerimeterColor": "#FFD700", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1, "quantizedGenerateBlockWidthCells": 4, "quantizedGenerateBlockHeightCells": 4, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 7.6, "quantizedGenerateV2Speed": 1, "quantizedGenerateV2BlockWidthCells": 4, "quantizedGenerateV2BlockHeightCells": 4, "quantizedGenerateV2BorderIllumination": 4, "quantizedGenerateV2PerimeterThickness": 1, "quantizedGenerateV2PerimeterColor": "#FFD700", "quantizedGenerateV2InnerColor": "#FFD700", "quantizedGenerateV2FadeInFrames": 0, "quantizedGenerateV2FadeFrames": 0, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 1, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c"}, "hideMenuIcon": true, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 18, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 1, "quantizedPulseGreenFadeSeconds": 0, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "quantizedPulseShowInterior": true, "quantizedPulseBorderColor": "#FFCC00", "quantizedPulseInteriorColor": "#0fe628", "quantizedAddShowInterior": true, "quantizedAddBorderColor": "#002aff", "quantizedAddInteriorColor": "#ff0000", "quantizedRetractShowInterior": true, "quantizedRetractBorderColor": "#FFCC00", "quantizedRetractInteriorColor": "#FFCC00", "quantizedExpansionEnabled": false, "quantizedExpansionFrequencySeconds": 120, "quantizedExpansionDurationSeconds": 3, "quantizedExpansionFadeInFrames": 10, "quantizedExpansionFadeFrames": 20, "quantizedExpansionBorderIllumination": 4, "quantizedExpansionShowInterior": true, "quantizedExpansionBorderColor": "#FFCC00", "quantizedExpansionInteriorColor": "#001eff", "quantizedBlockGridWidth": 10, "quantizedBlockGridHeight": 10, "upwardTracerGlimmerChance": 0, "quantEditorEnabled": false, "streamVisibleLengthScale": 1.2}, "savedPresets": [{"name": "Trilogy", "data": {"streamColor": "#65d778", "backgroundColor": "#000000", "streamPalette": ["#00ff41"], "paletteBias": 0, "colorMixType": 0.45, "tracerColor": "#00ff41", "fontSize": 24, "streamSpeed": 17, "releaseInterval": 3, "resolution": 0.9, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": false, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "MatrixEmbedded", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 15, "overlapEnabled": false, "overlapColor": "#20cb53", "overlapDensity": 0.2, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -15, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.5, "tracerGlow": 3, "clearAlpha": 0.72, "horizontalSpacingFactor": 0.7, "verticalSpacingFactor": 1, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1.1, "decayFadeDurationFrames": 18, "trailLengthVarianceEnabled": false, "trailLengthVariance": 60, "streamSpawnCount": 7, "eraserSpawnCount": 5, "minStreamGap": 2, "minEraserGap": 15, "minGapTypes": 20, "allowTinyStreams": true, "gradualColorStreams": false, "gradualColorStreamsFrequency": 100, "holeRate": 0.1, "desyncIntensity": 0, "preferClusters": true, "eraserStopChance": 1, "tracerStopChance": 1, "tracerAttackFrames": 4, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": true, "invertedTracerChance": 0.07, "upwardTracerEnabled": false, "upwardTracerChance": 0.02, "upwardTracerAttackFrames": 2, "upwardTracerHoldFrames": 30, "upwardTracerReleaseFrames": 30, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 1, "upwardTracerGlimmerSpeed": 2, "upwardTracerGlimmerSize": 3, "upwardTracerGlimmerFill": 3, "upwardTracerGlimmerGlow": 10, "upwardTracerGlimmerFlicker": 0.5, "rotatorEnabled": true, "rotatorChance": 0.25, "rotatorSyncToTracer": true, "rotatorSyncMultiplier": 0.4, "rotatorCycleFactor": 20, "rotatorCrossfadeFrames": 6, "rotateDuringFade": false, "rotatorDesyncEnabled": false, "rotatorDesyncVariance": 0, "shaderEnabled": true, "customShader": "// Name: Matrix Real-World Blue Hue\r\nprecision highp float;                    // highp for desktop; switch to mediump for mobile if needed\r\n\r\nuniform sampler2D uTexture;\r\nuniform vec2      uResolution;            // (width, height)\r\nuniform float     uTime;                  // seconds\r\nuniform vec2      uMouse;                 // normalized [0..1]\r\nuniform float     uParameter;             // UI slider [0..1]\r\n\r\nvarying vec2      vTexCoord;\r\n\r\nvec3 rgb2hsv(vec3 c){\r\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\r\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));\r\n    float d = q.x - min(q.w, q.y);\r\n    float e = 1.0e-10;\r\n    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);\r\n}\r\nvec3 hsv2rgb(vec3 c){\r\n    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);\r\n    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);\r\n}\r\n\r\nvoid main() {\r\n    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;\r\n    vec3 hsv = rgb2hsv(rgb);\r\n    hsv.x = mix(hsv.x, 0.55, uParameter * 0.25);    // Hue change                                       \r\n    hsv.y = mix(hsv.y, 0.0, uParameter * 0.25);            // Saturation change\r\n    vec3 outc = hsv2rgb(hsv);\r\n    gl_FragColor = vec4(outc, 1.0);\r\n}", "effectShader": null, "shaderParameter": 0.69, "effectParameter": 2.8, "pulseEnabled": true, "pulseUseTracerGlow": false, "pulseMovieAccurate": true, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": true, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 1.1, "clearPulsePreserveSpaces": true, "clearPulseBlend": true, "clearPulseWidth": 130, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": true, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 240, "quantizedPulseDurationSeconds": 7.6, "quantizedPulseSpeed": 1, "quantizedBlockWidthCells": 4, "quantizedBlockHeightCells": 4, "quantizedPulseBorderIllumination": 4, "quantizedPulsePerimeterThickness": 1, "quantizedPulsePerimeterColor": "#FFD700", "quantizedPulseInnerColor": "#FFD700", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 300, "quantizedAddDurationSeconds": 10, "quantizedAddBorderIllumination": 4, "quantizedAddSpeed": 1, "quantizedAddBlockWidthCells": 4, "quantizedAddBlockHeightCells": 4, "quantizedAddPerimeterThickness": 1, "quantizedAddPerimeterColor": "#00FF00", "quantizedAddInnerColor": "#00FF00", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 60, "quantizedRetractDurationSeconds": 2, "quantizedRetractSpeed": 1, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 5, "quantizedRetractFadeFrames": 15, "quantizedRetractBorderIllumination": 4, "quantizedRetractPerimeterThickness": 1, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#FFD700", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 60, "quantizedClimbDurationSeconds": 2, "quantizedClimbSpeed": 1, "quantizedClimbBlockWidthCells": 4, "quantizedClimbBlockHeightCells": 4, "quantizedClimbFadeInFrames": 5, "quantizedClimbFadeFrames": 15, "quantizedClimbBorderIllumination": 4, "quantizedClimbPerimeterThickness": 1, "quantizedClimbPerimeterColor": "#FFD700", "quantizedClimbInnerColor": "#FFD700", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 60, "quantizedZoomFadeFrames": 15, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 1, "quantizedZoomPerimeterColor": "#FFD700", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1, "quantizedGenerateBlockWidthCells": 4, "quantizedGenerateBlockHeightCells": 4, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 7.6, "quantizedGenerateV2Speed": 1, "quantizedGenerateV2BlockWidthCells": 4, "quantizedGenerateV2BlockHeightCells": 4, "quantizedGenerateV2BorderIllumination": 4, "quantizedGenerateV2PerimeterThickness": 1, "quantizedGenerateV2PerimeterColor": "#FFD700", "quantizedGenerateV2InnerColor": "#FFD700", "quantizedGenerateV2FadeInFrames": 0, "quantizedGenerateV2FadeFrames": 0, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 1, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": true, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.07, "dejaVuBarDurationFrames": 21, "dejaVuVarianceFrames": 43, "supermanEnabled": true, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 2, "supermanBoltThickness": 5, "supermanFlickerRate": 3, "supermanWidth": 3, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 3, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 33, "crashSheetSpeed": 1.1, "crashSheetOpacity": 0.96, "crashStationaryChance": 17, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": true, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c", "ReverseTime": "u"}, "hideMenuIcon": true, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": true, "useCustomChars": false, "customCharacters": ""}, "CustomFont_5e2697679380fc43": {"active": false, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 19, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 3, "quantizedPulseGreenFadeSeconds": 0.1, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "streamVisibleLengthScale": 1}}, {"name": "Thomas Code", "data": {"streamColor": "#65d778", "backgroundColor": "#000000", "streamPalette": ["#0aff8d"], "paletteBias": 1, "colorMixType": 0.5, "tracerColor": "#70ffa7", "fontSize": 20, "streamSpeed": 17, "releaseInterval": 1, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": false, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": false, "brightnessVariance": 35, "overlapEnabled": false, "overlapColor": "#fff5b8", "overlapDensity": 0.3, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": 20, "deteriorationEnabled": true, "deteriorationStrength": 2, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.65, "tracerGlow": 1, "clearAlpha": 0.34, "horizontalSpacingFactor": 1, "verticalSpacingFactor": 1, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1.1, "decayFadeDurationFrames": 20, "trailLengthVarianceEnabled": true, "trailLengthVariance": 270, "streamSpawnCount": 2, "eraserSpawnCount": 7, "minStreamGap": 9, "minEraserGap": 9, "minGapTypes": 1, "allowTinyStreams": false, "gradualColorStreams": true, "gradualColorStreamsFrequency": 100, "holeRate": 0.01, "desyncIntensity": 0.35000000000000003, "preferClusters": false, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 6, "tracerHoldFrames": 0, "tracerReleaseFrames": 16, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.81, "upwardTracerAttackFrames": 2, "upwardTracerHoldFrames": 4, "upwardTracerReleaseFrames": 30, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 1.3, "upwardTracerGlimmerSpeed": 3.15, "upwardTracerGlimmerSize": 5, "upwardTracerGlimmerFill": 5, "upwardTracerGlimmerGlow": 6, "upwardTracerGlimmerFlicker": 0.45, "rotatorEnabled": true, "rotatorChance": 0.75, "rotatorSyncToTracer": false, "rotatorSyncMultiplier": 0.3, "rotatorCycleFactor": 8, "rotatorCrossfadeFrames": 4, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 78, "shaderEnabled": false, "customShader": "// Name: Static Grain\nprecision mediump float;\n\n// Inputs provided by the application\nuniform sampler2D uTexture;\nuniform float uParameter;\n\n// uniform float uTime; // NOT needed for static grain\nvarying vec2 vTexCoord;\n\n// Shader Configuration\nconst float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable\n\n// 1. Random function\n// Generates a seemingly random float based on the input coordinate 'st'.\nfloat random(vec2 st) {\n    // This uses a \"magic\" dot product and large number to generate noise.\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main() {\n    // 2. Sample the original texture\n    vec4 color = texture2D(uTexture, vTexCoord);\n    \n    // 3. Calculate static noise\n    // The key here is to pass only the coordinate (vTexCoord) to the random function.\n    // We are NOT using 'uTime', so the result for any given coordinate is always the same.\n    float noiseValue = random(vTexCoord);\n    \n    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]\n    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]\n    // * 2.0 expands the range to [-1.0, 1.0]\n    float finalNoise = (noiseValue - 0.5) * 2.0;\n\n    // 4. Apply grain to the color\n    // We only apply the noise to the Red, Green, and Blue channels (.rgb).\n    // The noise value is scaled by the GRAIN_AMOUNT.\n    // A negative noise makes the pixel darker, a positive noise makes it brighter.\n    color.rgb += finalNoise * (uParameter * 0.5);\n    \n    // 5. Output final color\n    gl_FragColor = color;\n}", "effectShader": null, "shaderParameter": 0.11, "effectParameter": 0, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 300, "quantizedPulseDurationSeconds": 10, "quantizedPulseSpeed": 5, "quantizedBlockWidthCells": 3, "quantizedBlockHeightCells": 3, "quantizedPulseBorderIllumination": 1.1, "quantizedPulsePerimeterThickness": 0.3, "quantizedPulsePerimeterColor": "#eeff00", "quantizedPulseInnerColor": "#0040ff", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 280, "quantizedAddDurationSeconds": 3.7, "quantizedAddBorderIllumination": 5.6, "quantizedAddSpeed": 5, "quantizedAddBlockWidthCells": 3, "quantizedAddBlockHeightCells": 3, "quantizedAddPerimeterThickness": 0.2, "quantizedAddPerimeterColor": "#d4ff00", "quantizedAddInnerColor": "#000000", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 250, "quantizedRetractDurationSeconds": 5, "quantizedRetractSpeed": 4.3, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 0, "quantizedRetractFadeFrames": 0, "quantizedRetractBorderIllumination": 5.7, "quantizedRetractPerimeterThickness": 0.6, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#0011ff", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 265, "quantizedClimbDurationSeconds": 3.6, "quantizedClimbSpeed": 5, "quantizedClimbBlockWidthCells": 3, "quantizedClimbBlockHeightCells": 3, "quantizedClimbFadeInFrames": 0, "quantizedClimbFadeFrames": 0, "quantizedClimbBorderIllumination": 5.4, "quantizedClimbPerimeterThickness": 0.5, "quantizedClimbPerimeterColor": "#e1ff00", "quantizedClimbInnerColor": "#027a00", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 0, "quantizedZoomFadeFrames": 0, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 0.6, "quantizedZoomPerimeterColor": "#05c212", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1.8, "quantizedGenerateBlockWidthCells": 3, "quantizedGenerateBlockHeightCells": 3, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 10, "quantizedGenerateV2Speed": 3.1, "quantizedGenerateV2BlockWidthCells": 3, "quantizedGenerateV2BlockHeightCells": 3, "quantizedGenerateV2BorderIllumination": 1.6, "quantizedGenerateV2PerimeterThickness": 0.3, "quantizedGenerateV2PerimeterColor": "#ffd900", "quantizedGenerateV2InnerColor": "#eeff00", "quantizedGenerateV2FadeInFrames": 2, "quantizedGenerateV2FadeFrames": 7, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 2, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "s", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c", "QuantizedGenerateV2": "x", "QuantizedBlockGenerator": "x"}, "hideMenuIcon": false, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": true, "customCharacters": "!|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"'()*+-.012345789:<=>ABCDEFGHIJKLNOPQRSTUVWXYZ^_`cfgntM\\", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 18, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 1, "quantizedPulseGreenFadeSeconds": 0, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "quantizedGenerateV2EnableCluster": true, "quantizedGenerateV2EnableShift": false, "quantizedGenerateV2EnableOverlap": false, "quantizedGenerateV2EnableUnfold": false, "quantizedZoomBlockWidthCells": 3, "quantizedZoomBlockHeightCells": 3, "quantizedPulseShowInterior": true, "quantizedPulseBorderColor": "#FFCC00", "quantizedPulseInteriorColor": "#0fe628", "quantizedAddShowInterior": true, "quantizedAddBorderColor": "#002aff", "quantizedAddInteriorColor": "#ff0000", "quantizedRetractShowInterior": true, "quantizedRetractBorderColor": "#FFCC00", "quantizedRetractInteriorColor": "#FFCC00", "quantizedExpansionEnabled": false, "quantizedExpansionFrequencySeconds": 120, "quantizedExpansionDurationSeconds": 3, "quantizedExpansionFadeInFrames": 10, "quantizedExpansionFadeFrames": 20, "quantizedExpansionBorderIllumination": 4, "quantizedExpansionShowInterior": true, "quantizedExpansionBorderColor": "#FFCC00", "quantizedExpansionInteriorColor": "#001eff", "quantizedBlockGridWidth": 10, "quantizedBlockGridHeight": 10, "upwardTracerGlimmerChance": 0, "quantEditorEnabled": false, "streamVisibleLengthScale": 0.8, "quantizedPulseBlockWidthCells": 3, "quantizedPulseBlockHeightCells": 3, "layerEnableEditorRemovals": false}}, {"name": "Operator1", "data": {"streamColor": "#65d778", "backgroundColor": "#020509", "streamPalette": ["#00e004", "#75ff1a"], "paletteBias": 0, "colorMixType": 0, "tracerColor": "#d7ffd7", "fontSize": 22, "streamSpeed": 17, "releaseInterval": 2, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": false, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 15, "overlapEnabled": false, "overlapColor": "#fff5b8", "overlapDensity": 0.3, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -2, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.6, "tracerGlow": 6, "clearAlpha": 1, "horizontalSpacingFactor": 0.95, "verticalSpacingFactor": 0.95, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1, "decayFadeDurationFrames": 25, "trailLengthVarianceEnabled": true, "trailLengthVariance": 151, "streamSpawnCount": 3, "eraserSpawnCount": 2, "minStreamGap": 2, "minEraserGap": 2, "minGapTypes": 30, "allowTinyStreams": true, "gradualColorStreams": true, "gradualColorStreamsFrequency": 60, "holeRate": 0, "desyncIntensity": 0.35, "preferClusters": true, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 4, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.81, "upwardTracerAttackFrames": 2, "upwardTracerHoldFrames": 4, "upwardTracerReleaseFrames": 30, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 1.3, "upwardTracerGlimmerSpeed": 3.15, "upwardTracerGlimmerSize": 5, "upwardTracerGlimmerFill": 5, "upwardTracerGlimmerGlow": 6, "upwardTracerGlimmerFlicker": 0.45, "rotatorEnabled": true, "rotatorChance": 1, "rotatorSyncToTracer": false, "rotatorSyncMultiplier": 0.3, "rotatorCycleFactor": 16, "rotatorCrossfadeFrames": 4, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 41, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.03, "effectParameter": 0, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 300, "quantizedPulseDurationSeconds": 10, "quantizedPulseSpeed": 5, "quantizedBlockWidthCells": 3, "quantizedBlockHeightCells": 3, "quantizedPulseBorderIllumination": 1.1, "quantizedPulsePerimeterThickness": 0.6, "quantizedPulsePerimeterColor": "#eeff00", "quantizedPulseInnerColor": "#0cd709", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 280, "quantizedAddDurationSeconds": 3.7, "quantizedAddBorderIllumination": 5.6, "quantizedAddSpeed": 5, "quantizedAddBlockWidthCells": 3, "quantizedAddBlockHeightCells": 3, "quantizedAddPerimeterThickness": 0.7, "quantizedAddPerimeterColor": "#d4ff00", "quantizedAddInnerColor": "#000000", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 250, "quantizedRetractDurationSeconds": 5, "quantizedRetractSpeed": 4.3, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 0, "quantizedRetractFadeFrames": 0, "quantizedRetractBorderIllumination": 5.7, "quantizedRetractPerimeterThickness": 0.6, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#0011ff", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 265, "quantizedClimbDurationSeconds": 3.6, "quantizedClimbSpeed": 5, "quantizedClimbBlockWidthCells": 3, "quantizedClimbBlockHeightCells": 3, "quantizedClimbFadeInFrames": 0, "quantizedClimbFadeFrames": 0, "quantizedClimbBorderIllumination": 5.4, "quantizedClimbPerimeterThickness": 0.5, "quantizedClimbPerimeterColor": "#e1ff00", "quantizedClimbInnerColor": "#027a00", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 60, "quantizedZoomFadeFrames": 15, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 1, "quantizedZoomPerimeterColor": "#FFD700", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1, "quantizedGenerateBlockWidthCells": 4, "quantizedGenerateBlockHeightCells": 4, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 7.6, "quantizedGenerateV2Speed": 1, "quantizedGenerateV2BlockWidthCells": 4, "quantizedGenerateV2BlockHeightCells": 4, "quantizedGenerateV2BorderIllumination": 4, "quantizedGenerateV2PerimeterThickness": 1, "quantizedGenerateV2PerimeterColor": "#FFD700", "quantizedGenerateV2InnerColor": "#FFD700", "quantizedGenerateV2FadeInFrames": 0, "quantizedGenerateV2FadeFrames": 0, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 1, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c"}, "hideMenuIcon": false, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 18, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 1, "quantizedPulseGreenFadeSeconds": 0, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "quantizedPulseShowInterior": true, "quantizedPulseBorderColor": "#FFCC00", "quantizedPulseInteriorColor": "#0fe628", "quantizedAddShowInterior": true, "quantizedAddBorderColor": "#002aff", "quantizedAddInteriorColor": "#ff0000", "quantizedRetractShowInterior": true, "quantizedRetractBorderColor": "#FFCC00", "quantizedRetractInteriorColor": "#FFCC00", "quantizedExpansionEnabled": false, "quantizedExpansionFrequencySeconds": 120, "quantizedExpansionDurationSeconds": 3, "quantizedExpansionFadeInFrames": 10, "quantizedExpansionFadeFrames": 20, "quantizedExpansionBorderIllumination": 4, "quantizedExpansionShowInterior": true, "quantizedExpansionBorderColor": "#FFCC00", "quantizedExpansionInteriorColor": "#001eff", "quantizedBlockGridWidth": 10, "quantizedBlockGridHeight": 10, "upwardTracerGlimmerChance": 0, "quantEditorEnabled": false, "streamVisibleLengthScale": 1.2}}, {"name": "Operator2", "data": {"streamColor": "#65d778", "backgroundColor": "#020509", "streamPalette": ["#00e004", "#087715", "#33ff96"], "paletteBias": 1, "colorMixType": 1, "tracerColor": "#d1fff0", "fontSize": 20, "streamSpeed": 17, "releaseInterval": 1, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": true, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 15, "overlapEnabled": true, "overlapColor": "#fff5b8", "overlapDensity": 0.2, "overlapTarget": "stream", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -2, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.55, "tracerGlow": 1, "clearAlpha": 0.86, "horizontalSpacingFactor": 0.85, "verticalSpacingFactor": 0.9, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1, "decayFadeDurationFrames": 25, "trailLengthVarianceEnabled": true, "trailLengthVariance": 101, "streamSpawnCount": 2, "eraserSpawnCount": 2, "minStreamGap": 10, "minEraserGap": 2, "minGapTypes": 50, "allowTinyStreams": true, "gradualColorStreams": true, "gradualColorStreamsFrequency": 10, "holeRate": 0, "desyncIntensity": 0.35, "preferClusters": false, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 5, "tracerHoldFrames": 0, "tracerReleaseFrames": 4, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "upwardTracerEnabled": false, "upwardTracerChance": 0.81, "upwardTracerAttackFrames": 2, "upwardTracerHoldFrames": 4, "upwardTracerReleaseFrames": 30, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 1.3, "upwardTracerGlimmerSpeed": 3.15, "upwardTracerGlimmerSize": 5, "upwardTracerGlimmerFill": 5, "upwardTracerGlimmerGlow": 6, "upwardTracerGlimmerFlicker": 0.45, "rotatorEnabled": true, "rotatorChance": 1, "rotatorSyncToTracer": false, "rotatorSyncMultiplier": 0.3, "rotatorCycleFactor": 16, "rotatorCrossfadeFrames": 4, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 41, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.03, "effectParameter": 0, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 300, "quantizedPulseDurationSeconds": 10, "quantizedPulseSpeed": 5, "quantizedBlockWidthCells": 3, "quantizedBlockHeightCells": 3, "quantizedPulseBorderIllumination": 1.1, "quantizedPulsePerimeterThickness": 0.6, "quantizedPulsePerimeterColor": "#eeff00", "quantizedPulseInnerColor": "#0cd709", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 280, "quantizedAddDurationSeconds": 3.7, "quantizedAddBorderIllumination": 5.6, "quantizedAddSpeed": 5, "quantizedAddBlockWidthCells": 3, "quantizedAddBlockHeightCells": 3, "quantizedAddPerimeterThickness": 0.7, "quantizedAddPerimeterColor": "#d4ff00", "quantizedAddInnerColor": "#000000", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 250, "quantizedRetractDurationSeconds": 5, "quantizedRetractSpeed": 4.3, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 0, "quantizedRetractFadeFrames": 0, "quantizedRetractBorderIllumination": 5.7, "quantizedRetractPerimeterThickness": 0.6, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#0011ff", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 265, "quantizedClimbDurationSeconds": 3.6, "quantizedClimbSpeed": 5, "quantizedClimbBlockWidthCells": 3, "quantizedClimbBlockHeightCells": 3, "quantizedClimbFadeInFrames": 0, "quantizedClimbFadeFrames": 0, "quantizedClimbBorderIllumination": 5.4, "quantizedClimbPerimeterThickness": 0.5, "quantizedClimbPerimeterColor": "#e1ff00", "quantizedClimbInnerColor": "#027a00", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 60, "quantizedZoomFadeFrames": 15, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 1, "quantizedZoomPerimeterColor": "#FFD700", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1, "quantizedGenerateBlockWidthCells": 4, "quantizedGenerateBlockHeightCells": 4, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 7.6, "quantizedGenerateV2Speed": 1, "quantizedGenerateV2BlockWidthCells": 4, "quantizedGenerateV2BlockHeightCells": 4, "quantizedGenerateV2BorderIllumination": 4, "quantizedGenerateV2PerimeterThickness": 1, "quantizedGenerateV2PerimeterColor": "#FFD700", "quantizedGenerateV2InnerColor": "#FFD700", "quantizedGenerateV2FadeInFrames": 0, "quantizedGenerateV2FadeFrames": 0, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 1, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c"}, "hideMenuIcon": false, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 18, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 1, "quantizedPulseGreenFadeSeconds": 0, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "quantizedPulseShowInterior": true, "quantizedPulseBorderColor": "#FFCC00", "quantizedPulseInteriorColor": "#0fe628", "quantizedAddShowInterior": true, "quantizedAddBorderColor": "#002aff", "quantizedAddInteriorColor": "#ff0000", "quantizedRetractShowInterior": true, "quantizedRetractBorderColor": "#FFCC00", "quantizedRetractInteriorColor": "#FFCC00", "quantizedExpansionEnabled": false, "quantizedExpansionFrequencySeconds": 120, "quantizedExpansionDurationSeconds": 3, "quantizedExpansionFadeInFrames": 10, "quantizedExpansionFadeFrames": 20, "quantizedExpansionBorderIllumination": 4, "quantizedExpansionShowInterior": true, "quantizedExpansionBorderColor": "#FFCC00", "quantizedExpansionInteriorColor": "#001eff", "quantizedBlockGridWidth": 10, "quantizedBlockGridHeight": 10, "upwardTracerGlimmerChance": 0, "quantEditorEnabled": false, "streamVisibleLengthScale": 1.1}}, {"name": "Trinity", "data": {"streamColor": "#65d778", "backgroundColor": "#020509", "streamPalette": ["#00e004", "#2db512"], "paletteBias": 0, "colorMixType": 0, "tracerColor": "#d7ffd7", "fontSize": 22, "streamSpeed": 17, "releaseInterval": 2, "resolution": 1, "enableGlyphAtlas": true, "smoothingEnabled": false, "smoothingAmount": 0.1, "showFpsCounter": false, "performanceMode": false, "debugTabEnabled": false, "debugEnabled": false, "highlightErasers": false, "simulationPaused": false, "logErrors": false, "fontFamily": "CustomFont_5e2697679380fc43", "fontWeight": "normal", "italicEnabled": false, "mirrorEnabled": false, "variableBrightnessEnabled": true, "brightnessVariance": 15, "overlapEnabled": true, "overlapColor": "#c3feca", "overlapDensity": 0.1, "overlapTarget": "all", "overlapShimmer": false, "dissolveEnabled": true, "dissolveScalePercent": -2, "deteriorationEnabled": true, "deteriorationStrength": 4, "enableBloom": true, "bloomStrength": 1, "bloomOpacity": 0.6, "tracerGlow": 6, "clearAlpha": 1, "horizontalSpacingFactor": 0.95, "verticalSpacingFactor": 0.95, "fontOffsetX": 0, "fontOffsetY": 0, "stretchX": 1, "stretchY": 1, "decayFadeDurationFrames": 25, "trailLengthVarianceEnabled": true, "trailLengthVariance": 151, "streamSpawnCount": 3, "eraserSpawnCount": 2, "minStreamGap": 2, "minEraserGap": 2, "minGapTypes": 30, "allowTinyStreams": true, "gradualColorStreams": true, "gradualColorStreamsFrequency": 60, "holeRate": 0, "desyncIntensity": 0.35, "preferClusters": true, "eraserStopChance": 0, "tracerStopChance": 0, "tracerAttackFrames": 6, "tracerHoldFrames": 0, "tracerReleaseFrames": 2, "invertedTracerEnabled": false, "invertedTracerChance": 0.1, "upwardTracerEnabled": true, "upwardTracerChance": 0.88, "upwardTracerAttackFrames": 12, "upwardTracerHoldFrames": 0, "upwardTracerReleaseFrames": 18, "upwardTracerGlow": 8, "upwardTracerSpeedMult": 0.9, "upwardTracerGlimmerSpeed": 4.56, "upwardTracerGlimmerSize": 4, "upwardTracerGlimmerFill": 2, "upwardTracerGlimmerGlow": 8, "upwardTracerGlimmerFlicker": 0.45, "rotatorEnabled": true, "rotatorChance": 1, "rotatorSyncToTracer": false, "rotatorSyncMultiplier": 0.3, "rotatorCycleFactor": 16, "rotatorCrossfadeFrames": 4, "rotateDuringFade": true, "rotatorDesyncEnabled": true, "rotatorDesyncVariance": 41, "shaderEnabled": false, "customShader": null, "effectShader": null, "shaderParameter": 0.03, "effectParameter": 0, "pulseEnabled": false, "pulseUseTracerGlow": true, "pulseMovieAccurate": false, "pulseFrequencySeconds": 300, "pulseDelaySeconds": 0.7, "pulseDurationSeconds": 1.2, "pulsePreserveSpaces": true, "pulseIgnoreTracers": true, "pulseDimming": 0.2, "pulseBlend": false, "pulseWidth": 130, "pulseRandomPosition": true, "pulseInstantStart": false, "pulseCircular": false, "clearPulseEnabled": false, "clearPulseMovieAccurate": true, "clearPulseUseTracerGlow": true, "clearPulseFrequencySeconds": 235, "clearPulseDurationSeconds": 0.7, "clearPulsePreserveSpaces": true, "clearPulseBlend": false, "clearPulseWidth": 190, "clearPulseRandomPosition": true, "clearPulseInstantStart": false, "clearPulseCircular": false, "miniPulseEnabled": false, "miniPulseUseTracerGlow": true, "miniPulseFrequencySeconds": 450, "miniPulseDurationSeconds": 5, "miniPulsePreserveSpaces": true, "miniPulseThickness": 100, "miniPulseSpawnChance": 0.06, "miniPulseSpeed": 16, "miniPulseSize": 360, "quantizedPulseEnabled": false, "quantizedPulseFrequencySeconds": 300, "quantizedPulseDurationSeconds": 10, "quantizedPulseSpeed": 5, "quantizedBlockWidthCells": 3, "quantizedBlockHeightCells": 3, "quantizedPulseBorderIllumination": 1.1, "quantizedPulsePerimeterThickness": 0.6, "quantizedPulsePerimeterColor": "#eeff00", "quantizedPulseInnerColor": "#0cd709", "quantizedPulseFadeInFrames": 0, "quantizedPulseFadeFrames": 0, "quantizedAddEnabled": false, "quantizedAddFrequencySeconds": 280, "quantizedAddDurationSeconds": 3.7, "quantizedAddBorderIllumination": 5.6, "quantizedAddSpeed": 5, "quantizedAddBlockWidthCells": 3, "quantizedAddBlockHeightCells": 3, "quantizedAddPerimeterThickness": 0.7, "quantizedAddPerimeterColor": "#d4ff00", "quantizedAddInnerColor": "#000000", "quantizedAddFadeInFrames": 0, "quantizedAddFadeFrames": 0, "quantizedRetractEnabled": false, "quantizedRetractFrequencySeconds": 250, "quantizedRetractDurationSeconds": 5, "quantizedRetractSpeed": 4.3, "quantizedRetractBlockWidthCells": 4, "quantizedRetractBlockHeightCells": 4, "quantizedRetractFadeInFrames": 0, "quantizedRetractFadeFrames": 0, "quantizedRetractBorderIllumination": 5.7, "quantizedRetractPerimeterThickness": 0.6, "quantizedRetractPerimeterColor": "#FFD700", "quantizedRetractInnerColor": "#0011ff", "quantizedClimbEnabled": false, "quantizedClimbFrequencySeconds": 265, "quantizedClimbDurationSeconds": 3.6, "quantizedClimbSpeed": 5, "quantizedClimbBlockWidthCells": 3, "quantizedClimbBlockHeightCells": 3, "quantizedClimbFadeInFrames": 0, "quantizedClimbFadeFrames": 0, "quantizedClimbBorderIllumination": 5.4, "quantizedClimbPerimeterThickness": 0.5, "quantizedClimbPerimeterColor": "#e1ff00", "quantizedClimbInnerColor": "#027a00", "quantizedZoomEnabled": false, "quantizedZoomFrequencySeconds": 60, "quantizedZoomDurationSeconds": 5, "quantizedZoomSpeed": 1, "quantizedZoomExpansionRate": 1, "quantizedZoomZoomRate": 1, "quantizedZoomDelay": 0, "quantizedZoomHoldSeconds": 2, "quantizedZoomFadeInFrames": 60, "quantizedZoomFadeFrames": 15, "quantizedZoomBorderIllumination": 4, "quantizedZoomPerimeterThickness": 1, "quantizedZoomPerimeterColor": "#FFD700", "quantizedZoomInnerColor": "#FFD700", "quantizedGenerateEnabled": false, "quantizedGenerateFrequencySeconds": 240, "quantizedGenerateDurationSeconds": 7.6, "quantizedGenerateSpeed": 1, "quantizedGenerateBlockWidthCells": 4, "quantizedGenerateBlockHeightCells": 4, "quantizedGenerateBorderIllumination": 4, "quantizedGeneratePerimeterThickness": 1, "quantizedGeneratePerimeterColor": "#FFD700", "quantizedGenerateInnerColor": "#FFD700", "quantizedGenerateFadeInFrames": 0, "quantizedGenerateFadeFrames": 0, "quantizedGenerateSimultaneousSpawns": 3, "quantizedGenerateErosionRate": 0.2, "quantizedGenerateInnerLineDuration": 1, "quantizedGenerateGreenFadeSeconds": 0.1, "quantizedGenerateMergeDelay": true, "quantizedGenerateV2Enabled": false, "quantizedGenerateV2EnableRearrange": false, "quantizedGenerateV2EnableThicken": false, "quantizedGenerateV2ThickenQuadrantCount": 1, "quantizedGenerateV2FrequencySeconds": 240, "quantizedGenerateV2DurationSeconds": 7.6, "quantizedGenerateV2Speed": 1, "quantizedGenerateV2BlockWidthCells": 4, "quantizedGenerateV2BlockHeightCells": 4, "quantizedGenerateV2BorderIllumination": 4, "quantizedGenerateV2PerimeterThickness": 1, "quantizedGenerateV2PerimeterColor": "#FFD700", "quantizedGenerateV2InnerColor": "#FFD700", "quantizedGenerateV2FadeInFrames": 0, "quantizedGenerateV2FadeFrames": 0, "quantizedGenerateV2SimultaneousSpawns": 3, "quantizedGenerateV2InnerLineDuration": 1, "quantizedGenerateV2GreenFadeSeconds": 0.1, "quantizedGenerateV2MergeDelay": true, "quantizedPulseCleanInnerDistance": 4, "quantizedAddCleanInnerDistance": 4, "quantizedRetractCleanInnerDistance": 4, "quantizedClimbCleanInnerDistance": 4, "quantizedZoomCleanInnerDistance": 4, "quantizedGenerateCleanInnerDistance": 4, "quantizedGenerateV2CleanInnerDistance": 4, "quantizedPerimeterOffsetX": 0, "quantizedPerimeterOffsetY": 0, "quantizedShadowOffsetX": 0, "quantizedShadowOffsetY": 0, "quantizedSourceGridOffsetX": 0, "quantizedSourceGridOffsetY": 0, "quantizedEditorGridOffsetX": 0, "quantizedEditorGridOffsetY": 0, "quantizedEditorChangesOffsetX": 0, "quantizedEditorChangesOffsetY": 0, "quantizedLineLength": 1, "quantizedLineOffset": 0, "quantizedOffsetProfiles": {}, "quantizedAutoAlign": false, "layerEnableBackground": true, "layerEnablePrimaryCode": true, "layerEnableShadowWorld": true, "layerEnableQuantizedLines": true, "layerEnableQuantizedGridCache": false, "layerEnableEditorGrid": true, "layerEnableEditorOverlay": true, "quantizedSolidPerimeter": false, "dejaVuEnabled": false, "dejaVuFrequencySeconds": 350, "dejaVuDurationSeconds": 5, "dejaVuMinRectHeight": 1, "dejaVuMaxRectHeight": 10, "dejaVuHoleBrightness": 0.02, "dejaVuRandomizeColors": false, "dejaVuIntensity": 0.1, "dejaVuBarDurationFrames": 28, "dejaVuVarianceFrames": 43, "supermanEnabled": false, "supermanFrequencySeconds": 290, "supermanDurationSeconds": 6, "supermanFadeSpeed": 6, "supermanGlow": 4, "supermanBoltThickness": 5, "supermanFlickerRate": 2, "supermanWidth": 4, "supermanSpawnSpeed": 69, "starPowerEnabled": false, "starPowerFreq": 100, "starPowerRainbowMode": "char", "starPowerSaturation": 100, "starPowerIntensity": 51, "starPowerColorCycle": true, "starPowerCycleSpeed": 5, "rainbowStreamEnabled": false, "rainbowStreamChance": 0.5, "rainbowStreamIntensity": 50, "bootSequenceEnabled": false, "crashEnabled": false, "crashFrequencySeconds": 600, "crashDurationSeconds": 30, "crashSheetCount": 25, "crashSheetSpeed": 1, "crashSheetOpacity": 0.5, "crashStationaryChance": 20, "crashFlashDelayMin": 3, "crashFlashDelayMax": 6, "crashEnableSmith": true, "crashEnableSuperman": true, "crashEnableFlash": true, "runBothInOrder": false, "enableKeybinds": true, "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c"}, "hideMenuIcon": false, "doubleClickToReset": true, "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}}, "deteriorationType": "ghost", "tracerSizeIncrease": 1, "supermanProb": 4, "dejaVuAutoMode": true, "clearPulseIgnoreTracers": true, "dejaVuPerformanceMode": false, "pulseDelayFrames": 60, "suppressToasts": false, "supermanIncludeColors": true, "renderingEngine": "canvas", "dissolveMinSize": 18, "crashMovieFps": true, "quantizedPulseSimultaneousSpawns": 1, "quantizedPulseGreenFadeSeconds": 0, "quantizedAddGreenFadeSeconds": 0.5, "quantizedRetractGreenFadeSeconds": 0.5, "starPowerGlitter": false, "firewallEnabled": false, "firewallFrequencySeconds": 150, "firewallRandomColorEnabled": true, "firewallColor": "#00ff00", "firewallReverseDurationFrames": 20, "firewallEraseDurationFrames": 50, "ttlMinSeconds": 1, "ttlMaxSeconds": 8, "renderMode3D": false, "flySpeed": 15, "performanceBackup": null, "quantizedPulseShowInterior": true, "quantizedPulseBorderColor": "#FFCC00", "quantizedPulseInteriorColor": "#0fe628", "quantizedAddShowInterior": true, "quantizedAddBorderColor": "#002aff", "quantizedAddInteriorColor": "#ff0000", "quantizedRetractShowInterior": true, "quantizedRetractBorderColor": "#FFCC00", "quantizedRetractInteriorColor": "#FFCC00", "quantizedExpansionEnabled": false, "quantizedExpansionFrequencySeconds": 120, "quantizedExpansionDurationSeconds": 3, "quantizedExpansionFadeInFrames": 10, "quantizedExpansionFadeFrames": 20, "quantizedExpansionBorderIllumination": 4, "quantizedExpansionShowInterior": true, "quantizedExpansionBorderColor": "#FFCC00", "quantizedExpansionInteriorColor": "#001eff", "quantizedBlockGridWidth": 10, "quantizedBlockGridHeight": 10, "upwardTracerGlimmerChance": 0, "quantEditorEnabled": false, "streamVisibleLengthScale": 1.2}}]}}, "fonts": {"Matrix-Resurrected.woff2": "data:font/woff2;base64,d09GMgABAAAAAC6QAA0AAAAAUuQAAC43AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGh4GYACCYBEICoGRFOp+C4IoAAE2AiQDhDQEIAWEHweCeBvEPSMRtpz2wgzw1wfmGOYMvD1DlDi0h/YHjMJcma0eCNZntbw72/ipezSyJm/QHSHJ7AG5WbNUQUAQLBUEC8VCVew0QayAgDU2LFhbLrZoupdoYkzT1HaKSTfFmFypmnaf3OVTr7T0q7lLzlLTGfJ0BmaW4te/lPYs7ZdfkMeLRTpdteSTuwLTiAJsym6eu1+1K9WlNhWXHpIC8jO3/+essJqBNvoCvFXq+xUiy/jH9Hty859sm21FlJoI5//dqmxhS4K2PAtQfwoVsYQ7M/H/05zvvXZ417qxIlB+LmvH5IAyOptvD1LCAH1IuDCFpMxs77IHCxZmSCK3tOdPmBPyt6LEYrFpjhelwzL2/3SW7fxl7SFUF8Y+Xcp05Xgk2Z6RZ0F7IHnvvbW9JOvI1pFih7RBapG6q1Ia1xTQETt8AFyUqdImRZsURUFU3UvRNXnIVMnB4Enhuy3DiaMT7wSJkkLg90kAgJjwHfn0hrX7vmKsN62zYH9gLiV1cKcoj46F9a+CCSsCgEb/gwwDFgC1BfU5AKz7viTILyBBCPB2B4QKpQ0VSWWgAIB59OV3l0GBJi8vk9A8tEBhpXD0oviGUQB5CnIehYGEWURwAhR3yT0w/+4/APjArnj3uyfvruBWiHmK01KDbkJwDDmRwFEyOXleBACDxeGbRG/j6HWTfjQOYHMCg4JDuDy+IDQsPEIoEkukssgoeXRMbFx8QqJCqVJrkrS6ZH1Kalp6RqbBaMoyW6zZObl5+QWLCouKS0ph+YpVa+Bt2ZrLyqugExproL0aVgK0AFR2PG8MtUsAoN9W31TX/bxLl+E4sy4AGBwaeH/1uuGRtVnQFFgs5yzkHfhBrP+PQIIB4C2A+zYA3xUgwJAO5BOQWhTDxH2Bo86t6DRpYeg6klJ8Zcjed5JypOV+gi/uxDMQLWfMR0WE9D583EjfnDEnbV+JgdPIO8di5Ohchn36UtoQNKvsgsH4cdnBNBIlGhPAcyVhdsU8nJ2dwlhENI9Hdo5wpWoGBovB4NAdnoUN9GKTsBgswc09LMCN7IXFugvE9Lhj3Hl83wDvlQZDx2DcOcHOBExqO8YvWkVfOtfPG8MIciKKOYH+xPhIppzKYaVn8IlUrRuN6ifTUnQUdaKESGUUQzsfi2WzvdzIGm8xPdGLxxB5eQk54V4Kr0AylR3r5x7PFZOl1CB3mqe7B1WqkYpxcWQmkUPmkYkBJBwBS8AEwF4Zg/FLIMooBpbMIPtPrC/KFpHdvDi1Ulw2r65MYpOA2sLmE2GzRBUqcaXKyEjXywgIeN+UziZGMgEaB4M61V1/H7S/al6RQ66WgyHEUpaZ/pXSFjh12Q0Oyvpg23cNyFm7yjgR+2AWAi5JMkBqPTWnxrYSUAhbNPFIUrj5AchW0iHj2krC2RoN9WJG5rhD2AvNY9c63VTkCq1fAB3eyPENUaEbTsCpUd2Gl0gRWTpzezGIfVsyjBRTiT+y6nUpjIwvAqj5Q4fxBhsC2lNc4noJOL7fmdE0UHHI+7xvwclwzcOiKhqQ30lTgWDJZ6TocwAxEPhIeJ0UDsdAULU/wHjqBLQZBYiVy4dBGAPj1KipRlG1y173QKCHYs6HoocMDdrBRJNcFX4Llbd5Dq7Boza1LiptQOKy9JK0tUSBGzotT+CODoirXKAAeEKeqbatuus5n2MuxXcGIj5QTDBnTClQmn1+LTIcN+0K+Ch3xfrF4aZZVJKshVynGPUe6TW0UCZKNfDAmlIoiercCTjfR4SybOKb7Uky7OVjBUw3OIGNl2xFtUSs6hahYadfihorei3nDy9SDAC07DKKKGPTkaJ1bapxjabB/2MRES0phphVswSMFSyCB9U7dp/DXk5PYKfWLO0ofLLyOh+Y3UHJbywHYAhseDi/ktCT4oi4mb+hU0aNz7PsNJ+xebR0VBP3pmoTz7CkNrWa0fvnqhVAjX3OKSViuwvpA0U3rfM8/I8fibc0TYHeHg8FJEYWEODJxTrVdqeQ47JV64u0u8YNitASOf7iwjoPtltNykXxgGK0iTEIA2AkubyP3/zljLW3Z17h+ihVp2reOyexTJ2f5LCUi9yEYn5uNd3e8I+06I63tzLJbp7uCtMhthsK2HXuPntxSS0TMCC/rsWOHgE5s2tbLRcv8CzFfqE4sR/m0bEtTQqXsG+Kj00BugJWs9v2RF43FJegiax1Raxm1d6EdYarjunYkGs7W4RZrwXXfr/z+TqPdpmKJ6ptToYK7RSQhhnJzBFD9WYpnPfho2sFhojaIcVlIY6QFAjwAgIOOPZQUInEktxXSXYIfKwsf+tlLq/ldV575z+SYbqWs1DXkvZnQcklquzJKDLMnXh/subiApVdFzxFleZ4unomv8uiI7v5de0UKm8VDYh5vRYR7ESgnj4QNY6EjehAcmDkk0X0j/hYhDmFGnLckxwehO4hR7Ztn1kKC3F8vs4zd1lrRBu40ZVbnW9f56SKAj0sgsR07g1shM/3zsUmOiKs+NTBWFOl1bhCxR8L2Gpco/fPHZgXsdI2xkh10c8aYNi/AKAH7GrSykDOFjEr6ZOZWlfAzHzqRSvERTNcWbJD7syNtphru7hMTkYxlwMN52oFvQNUUbPVEEWu1shBAZ4Ken7LBh8/RLzMIVKEP5G4IjB11WG3rWdON5ALfDyR32VYV+pVlb31kyjsjw2584uhMZNgZOZofKuirgijJmkH2+FJD4NVrBm47AQOu1IAT1KKsOOPLPXTJBRSoeCGCq2K/s4qHqqfyLPXe96U/Qt4rIkqT1G5oqgiT9gpugt5G6na7Q4X8pUUS2qrmpE+eNgxGn4qarwKxmWV9uJj+v4+jRs0Tuh0F8nGyXC4XvQt+Lzo+oztDEe2kddXqiyTeVVmR4rSTDHVdiPulwV+oQxq0NVycta4tr0lMB3T8y70bXEJQPpQLJlnaoePxUD+YlCaJEo7E5Q9lj1vQNDyCKh05jXtKP/s9mAdap2ALqw+Umx0XEeSUkhg1CcbOX7USpvg+AZDjxmt0fvSpEwqzzNF1Fodi8KzcBJjcIGTfimReXUKiu/Pvq53DYdt9dZ9br+t9S0UG3V9KKaJRSurHRjUKrRcZsaGnLGS9l2y0scTCwnsbv2d8QkOgTJm0Xbm0uKGED5OfklSn49lO5xx57iXV8KUQZzsRGL86ZX6hgQrq6tP/CsBcvV2g/lyb9tgIrO/kjVSkBGgV8SeCngjacRO/wPUoVEn3kHoDmjaVNZV8JrGaVkHCWwk0+TdlHAzyR5Mu9YSXoG2hru7XiKtqs+OICINhRIjDKiFKfHkI06skYp5W4tAAL0kVUSKiHQTshLr8fgIzpzESlMvcWGb56aZJ4vy2ps4DeRu3+k/v17Fod1n0Irc1svWdrrQLTChnJMft4Q2WW4ovfQq6m2jCeXUzlzTyFci/T715GC0J9asWZqoTW1kqWR4yCDUaVsMOk5l0LnmGXb5gtcxG++xa4gAzAOHlmet6COaMnqfAnr/SOuDfni/LB5y0E1XP5G8Bs0s7CMedFqjA7ksHdrZo86MntdsyiD3aqFofHn2IzfyZdMBPT9J+Mm7rENezkPzd1cFz8vOQeyOOLh/+zEBteXeEllhS4htWpnmtoHWcpnBVkFLeke80dbp6yfGZVrQS26SdjIg6aQYKWdwy4oI3zQ4sRONcWLUullkmyEKMLw39qfI3ct6Ux3m1xkopWcFxdnie5I8WRahl6kj6vfxicxT2olOs5t91WwtIQnQzGA99n7n5bZVyodeq2vYGbFNC/vwO2nRqHUP2+SNaJM14xGp9OatRjP1VmdVFkL910xcNZsGgezcY9SNnbcIpZnOr0SpsgmRUbss6HEy7Mq5Il9YvUxIFfZh6RXmdZoMp6nU2lNCnSLWkqmLqRc8n691QYqq+vv4HsAAllpHQuzogERUltVZ5HeyeBTdgt5Uu1QgmCBSdLnWXXhylUd2nTI7uUHWfAT1+EjUWObW/bTDE0rLiiK6eUMORbu+LtnPc0KjpmgO5BPfU9VibOgK0pVtCW9a+HCC04js+8RqAspjZHRF7f2s3cf8q+1emuRkzx3+sV7KPdZ/muXbhyJin15ErsZPn7HBtVVtv4tlVc72L+VQtCadGTGvyvpaD3r/Dm/LNh7dKusNiiinembYpm1hV86dX6V9G9eNDpf2IuHxbtkkzUj9uvAOotRAeHH5P7kslQ5r6UrqXYc0LtpV5+KinJune4My1UXLPIitLsSuuewZrqeeDTsSOvUBKyhCZk9d62J46oRkbOvg4EZaUT/RFq6yqLzh3DRSR/N8FXqYlyXzZ+Ns4RpB9thY8Fmc2zFY+m4xT4QciACDmyboX4oIdhtvaNQUziM2ur2ac4FPtWjn5de2xSxus0sLs+kJzXJGCbqTzie0+kBETPeSdpPecivzWsLr2tZlYvuNvp++svRn6lbbwuWVg4GVbXPo+T8IYra1WK4zdkQAX6qlfL7dmZmVV9cobjOtiChu5nS7dPxZmqkQdneIRbumzEPWyFUB9YrS7lgDNfI7dXY2ptD+nkWnamLRmpnQ2x92DnvSO3KQhBPnsbpxsrEyYXw487MU2H6m/GJ7QbvN3lf235fz0RRycGRj3NVviBj/+oVwBIKFic0rTZ2AcFoJC3Vx1Kk32dGy54yHWE7BblyZ0qrIkKRNfYuiwyDrix1pigJ3Zzg1TkGpzsssby4OrWeTjQyged5nTjU/6zb54Abr7XN0RWwIHCqBXFJXMT+CHTK9LSwCnzv70GpdiJmZsCD2BLGNUXwrl10tRS8FNC/Ub1hFPEi7inqH81ET7xuFiT+PAs13o/6F3ar9q0whucNc4wT0DWFrIpgyE8+6VpStenj8qfIwC/AyURVt93mIU0g66BB0kdOL4QdEqJj8W7YaJeV6TEaP6T8ap2AzNayoAjkb3j8G0elo3BhFi26t6NFQR37ixP6ul3KHxgjtI32ykd+1hrhN0VC68H3+Tq7lUFw120oJ2fvd30Zzc9Dgzol06wqR68qAYqXz6VS8eYgLYfmZaoCpbIorl+1Nq7bLcR/LTtX5sdwCUlRJkQ664d48X+NPlBUrdiBcuQACULuzzaCl4f6bGmirP/leQ6fGqAk16PAFbWNuxTNE10LN6zhyQ8lo/hKZd8DT/sb10OYrf8r96Qk+knwbAmBFgpYvmuSmuWd8GsuGWHeabJqMeaxJgzkgXv+tcxW89Hwnb0Bf506Qct2bk3wcXeo7emyAQAe1+/BV740qCPc8EzJs0i+60RZbKWW0KGsi9YlNBHCM2yxvhG9+pLC8D/cK7Ui9/aN+O2qZbDJonq/TvwEnEBkfhNt7kziNpoA6c64G1b87uf4Wo9XdGSnr2U3CI85Utf4IIgjv3dGWBGj+x+7BQOA83EpehA7bNXvJ5Sp5SITdKFEyJWSOeaVcw22KZ0e4br1/zLsFIDZHa4fTSYTxR1y/rd/ip3pwI10j0Ylb5yHGTNSGdM34iq99Ip/WokCR982wJzjVjQ4R7v429JZkGN1sqxVqXZZZPGO3NXI/kowfkmA4J/Nxf+3v3VNAPgtwm8fT8ph49yXAWWGfdpkD1sCRE28SRISw34iTX0X5rNwKzWOmwCBRIEmJv5o1ZkWRKNZIqrP/MCInURwGHGvxETns1mKigTO6nx2KQ3SXQoFo47LvZ6AGuRwJxZnlIkcV4Aurj1wzltilsueKJOd1SunuvVMABGk6etbimNAvh4qvTpCQLv8M4h2WPj6N5dWj7vdI759P0hhqrt8IKG5IooUPTQMOG9vLxDudeshcIGnZM4k+otIaCU6T+AaOpSgwqO12C2cGP0SenRlM613WBt5vNj3ijZOZFC06GfRMCaz4mO+F+pcL+ZbzFfAwGcR8xyrINyUAnifkleKh9ME4jyn+i5Vg6iS5h7qBFXd+BErGorYNgXk1qmIY9eDbHy03SY77Y3+PKcjt8ycdOy09dXQbsYr4UOGkND8kUZgvWDzAzIrWFVzhUuMFJ0l3kmyCS5r5UXl10C/OdLAdejcTitgqGem+mM/j8odwDyzp7GtS43xt18rDLd10DlVaLrRuTwpaM2ocSUfFwPORNdZlmglaW25Jn2wICFiIm6puSMtG3c35PtIBxNbprMQEF3TCuW009BY9fTEd/Exw+GqH/xe/mO1XnPo/8nbLT6FsJvjr8Pzh8PQYf6X8JMBPjv37O/frv204+f3rQA0gbhv8Uq/QkHkIeiKJrVdFRhmveugpKalpVA9FnjyfnYTXcvuAgyi1wZnHfYcWjUzmhMXcEy/89oeSrFC8uV0SoQlfVAYReyLfU7tWx5B9SQhAgLycrs0+D1Xp+IQ6x7Ur8XUeUrVEVCPR0KqJBEivEVTgXDwDPN/hfNxzHYH7sBPIKXd5Gzf4lGvw3S8YPoYXXl4vDD7FD8cWfQi+LdGHRVrED/qxFswucni+oGRR6AF//4OhjNCDqDb0gN6LJRctP1bhdex2IK8vGRlZr6kldMuKZXgk11ZkoWWe6KXy5BTkEdh7r7j0joPhwLh34C7bhHbmQlnwylWJOrrZO/IoHh9WeekrJKVkXSIvO8e17vxnFyFog0fKlA47R/72QFFHz8aEdS/r//d72ta017vIS2mZKMOh+ARrSJT8Ai1IZzk6cO+PUjL8FSqzrMs7XHH4wG94S/GWIldNLuRmKYKkQ0M7x0bHdq6/aJDTmbE74+uMNxlwgTA4OgibP5z/EOwRzazmnWKWGNaYrwelZkhuKQ0a6ufwSK5JhRS9IyUVZYhN2yg044/3J/cfx1ubPvJvOsF0ujisGb7olN30EXyic9zu6AvN0RpB2ndh/NvPfvj77++P52qCk2rdsXiv0BLmrDBXlt3Ewmctthgea9C91jRUelRqkXdbNpeyEw7ah+3QRxCpdZRcFJNaPotVNqWfwmXhWivxuc3x9UHCyfKg0rFcQrMz2EK7RyqHK0HyWHB/3G4/PHHYvuT2gh2F3ITTVy51JiDjiiz9ZaymK/Px06m6ug1PHic0y0t44Z4jRcGG4YB/LgtCQ3PhKcLXD9sBnRiTZTZle6pwyyyq90z3SDfbxsY0mnoiFMNWp9evFQ0iKAjNiXQ4EpREH3H+dzfzo3TZCixaq9I6puUZuuf0J2X8j4s8E50ENcbvleffnL+QMr/EfrgJZMVTarWzUZpkPmuUgUOuw+SeO6vbMUYUCMaIO3Rnz2FydXIHGGVnzUlSZ6NaPZVRQlSrS4gZX132xMMZqHl+by+Zsvfec6TmDPxptfwOzeMTpa6upRPjSMtrQa4zMOcUMsTvj8h4k5F+S7nTGxj9gb+b/3q4ABls2BG2I+L1kYgjYfDqzx8dSBtbDOwdOSQ4FML0i7RD8BrO/frsbHZxRgFk7DwUfrggm1PsJsgNklY5WdqKM1HfbmhILvxaFptWfQQ5k/2zuuRWyS2QNY3Z2u4jpcXhn4ziVrGElZUjS+2zbiU5WqvVoN+189twU1bsQaM1ocrMfeH7210uAsjqyhKaPC1z190/6FcHDjamJ2dFjVtWUNg/08ags/NhLrKWfTigjM2+m1aljke5sI59iG1mA/jOCS4JCQGFKMe5T656aSu115/eWoBN5vnb/PpvrZfTUHPu6Vd+skFa/OLv4/uG5LeHxmHJwKVlZ0dkafmyqN4RycWLSkUAW3vu2na4o+lqqjtlX9+zfnT9vfW9vwD/cxz8MTI6AqLnZSkaTFWugTO678aE+56dCd6Fp7keKDj0deLdT9UKkYptFoQnMM27RyTDizbOwlZJpbjyWEcDo4HeQYLbN3oXwFZNB12EPaJSkJ9iqa2rObJ6/e7ksDOHNltSEZ/80C/DGoE7IHDQBv0mnJxr/t3+vduhi2KLUbZjKTV/TDyiDoJM8eqXox8NFQ99dPSX7Qe3w6WGzQeJGQuQ7v3Dj2IN0blE4b0Rm4SAOY9Qiof0JxJTovUx/Nzccw52O4SBzwlV7VMB7b9iZRqdoLnaHWbFWDAmoiUdl0nMJCxX3f3GqcS+AOnMwJKTPWsXcsRPQaZleuVNsSVebW9//drVqNXG8IsKnfNFSpgOYvUNDvqUFxbKnuW48IdMAjPIWgT4g9OxhP0n40+GU2g6Dn/ACm2UlcREihXFYg+AVNW5cnrlkVvz0zwlHMZGMZLpus6eOt5xPmkam1KE15P1lEX51HxaPnVP2MxxkB4CIjij6Yv7Fvd2oltJ76+6c4T+e07/yEkGo5aoJrA0W0Sia01L+SL3ak9Gb35fc+bOTBCxAnXlrnNX45fijDgjRmf6hEpLCo2Se6hHly8PUdy4mbB6NG1bWvbSnMH36LcSKxX2ExkWtAVVCsIBwf4llzaEHpnJzd23T0mxaFyjB9CKbyInYyxrLR9ETXZuKF8Cd3FphjIG5PrldRed5J7dn/h02U/WLtOL5S8iNMz8fb4LD9pCdc46ogXKXkMDKysgq6sqm55Nr6NYUoHHjc/+9FPQOE84b1nYsn9iPwJctGDh2MIx/47mP743s+79aryz8BpbrovQRswxK9F2tBaxuFtACVLU0fre+oyDFkYTs4xZtnKsRFAS2vgDTKMqES0riWW101UMFVqbEVzfUw+y9WsdEw7sAZTli3srUgzORucUslmBYlHVSY8eYRSyIcfQEScQlpKHnP39SPnf3G2v3OfocRROF/YjZF9OVGlXaqmlZ7x977RTXijJE/CLfX/8W6KN4a/7axiUGEtxTIxBumWrX2v33um9DUMN26e3d293bC8ZKlkOZ/7eN2yfXOI4X2Qffv9jEA5HFjOKeccrjvN+ZMgT5JCTNzVc4ogad6U4dgB/T8txXpmg0w3Toaol7F/1ARvCus4Nt59VjOefOh2k3b42Ftz5RxfbUPmENKe0wO7JD1Sw+a/AZt5+qEmrLnz+btzvvSLrhQ9KmzX9tPceSFo88buny33GNiUAgnB3nUpza3ZqcrpVmroI9vSNjwbkMlmh27p19BVY9yqjhqFxyyBcwVPwcOxOLP7P9r6K7J/bvHeJ8365TSHPdHUdy/POiQzRRqWlLG36wiUrI+ZUljGuU8Nt6MW3tn7+4kUnx8VFGTe2D4vdv1+VYLtmH36nU/10x8mplv0TLRx1BdayzZ9YAo4xYai5YmYA5znBqspVwVJCtVIB55NOqyuxlTgLwaLGpRHTCD3KZL2zBbvhFnwOXEnMTv4iz7dH3PTZs2jCzDYvKsO5bV9NIFSYAhhocZq9LA0VN1CdVPDIKXVZrKNMQR2IUnSG60ykAZzkv8mruFlD3NtLwJtWxyhgZSJk/zz4pf+tYrriKm+l2crt3zi5SBBXFfBjDaUKjC9eBuWJFov/xO3v6Zn3U6H7zdjk/+HTlsbtAox5Z/LEz1VFXuWyo4M98TnZ7hX+fp2lYRMz1m8Uyo5QFVHtnGJUf/OLiRcadxMqOakPH0pztq52hS9Xk1Ga4GDPlIHm4dnrH5+Y4yQJnbAx9XVFsrbWLxDgT0frFwoVkiKDa/TPq/9dzfrsuYbpjGpE0mryMhD9+kZ9xt2MRv165JcNSQQVk/XZvMpflgJ8Oj9hsi82a9xPAtTnHI9+r58nVvuuSVl9+trTQ3Hf4nW1ckQY2RwHpnHfE27DrD0h/dwtv52L3/bEXrn7fEV60oyTrkveBI5jOF2FfCGcVRMHxgvpiP5T4NGkMAUbeuzfPO7KwGpm8LrF8pKouL64rCPuLKrLA3/XHub3iyk2aHrxPNgSfgVm5mu21G75dlEmR+SAEFMwxux6ZEtLf5om4UpCumbkeL9BGkefAJnYHopTd2a+8pzKKCp/9UpgLmy3W1GexZcNWum/k5c9laf6qJqaFD3K81UmvlTs/pwYptKf38xX/htkXp78V4rfD5q7xKw9D/6Q7grsWO6yIpQpvlZkEVUgqYnNvRe2+p+9rPKXWRAUEr8ciaoyDOpsNl2g0nfx7Z85x81Fjfo9cElU1VP13vX3ouDP7sQbn4F9a9tW0HtmeGTmr3j7NsPJOvTpeffGhAQRRJb8HODiws9MTz8mvYZvBfqrL6plNdf7Zq8X0Z6+Ox0623GaFLyORCPtvYIAICgE16Y0nHKCo32vJWrbGn1ynrNSJRfrQQUIYJvZbCU2BEMG8WPf/cYSPeLYrVqOLrXQSjFRJN88vGLfuKse8TQEjzgK6nDLlkOxJaAUAwjoCe1zMPVYtAkZqGA3YwBBlHqgWZFx12JcAXMF9P7TA1kqSaObhqFRc+l0bKFQKAQyxwWVvthL/1rtfk69MIs0z90kDKBRxeycZCSJFuj609Wb2iSFQUWRrzdscrpST5KObnqzmpFFfl8qDadq8hpWUBX0B8PrT+By41ZlsVZWB50F2SP3sUzanmrl7RYykHUkhNxHopF0ZCopKRmt8yrvqkpjyqT/+t3+Hm8JI/EJAd70xl6mtm9H1nv65HyiSqyQiQggmGUsxw6OwRWj4PGr8qKMqaevOjOx6pVYE3H11IpqsxcGDnLk2Tyem9ESbJAaWgmjGy+bJw+8U1pDmCE0D/n7NgXp8zrjLNs1U/dwPuWpbRWtep2TTfwZkkJbwV8i3DydEqwQi5Zoda46ejoKRI8FaowsIQFnoLFi1Fpbf0mjSQ1rf+6FnCpKlrk8Wufedt/mNI/twFZjKzD4BVMcSuyeyb6uFNj9mboQF+vihizcKW96wJ7rkmUpl9sCt1iCI3CpAItR9Rk3HqFsZVkGC1WUi371UiTaEySDQjD64lepvLQXwwh6zAadpRVgNHz/znuNQdlhNYPRCoDYvo82YwEkc/Hsx0HAICMkHRnIXir8Kl8wQqEsaI9I9PJVLlpEtRiyylC2Rzcy6hejAHCpEcGWwC02ebnFJSvXDj1v1oI6S9xgGyyP1OdHKtDpoLrre8QG0MpgrAaUHczYaBAtTPxYk9fsv6xN0qfM/f8KcsVq5D6SJCa+NfNyk7vhAHagnN2CBQRR6UEsV6nynJOT12T17WBqixvZRCExmkRyst76ngKSFlE9GSHtJyHk/C/sFDKCQuRiVT5Rn/xe1o4+pra3ke4dQIwhEDDGsbG9/gW13UwVRoneZXb534/7nUyQBXw99YJl/8/RvWb7FXyFYrSDqlIak3TXrr1BcWhIclWXna0xP+GyIvD2Hccr3uXWrjG4GKlpfDOh8sfl0vQYy5p8qpb1SOs+C+fdVxI+JyyV8tr2+MCaMUPM6CXOdHEjnJB5jiBmztzP6ge1Hfy5Iv4uTYITnwFLB/9p46z9+nVCpOh/W18UjVY1hvOri9ic/r6jzc1QT0dnxu7ePbKruVkbd+PRWum2vGvGotctDuD09R9pud363XsPuH/iV9JEcj14trs/OUoXNeS4f3+LSmU6s/9Uc2fBot9/Vzw6OtHUfmQbSDMN4kv6ZL1+aBPBSzE7jqa5ythWNiMpXcK2iDHvng/ShcGf4tOPRN4qltB91gpVgSgUMp/egCJdemsJVgwnbjqYoLJlnZ0IkX+7e9fI7SO/b7t759VfP50RXpVTL1NXMFe8CY3TxYb7fanFpPCKIpL7dZwd8CQogfYPR9efzB62IfBPlA0gUlS8VTLfVaSmtZa/xoXE667PDk4FH2x6kGw+64WWsWbq/g7x0Kc0Nx1/NhOEZSblDNWVYA/aCo5qwnSTTndRkShJAmO91yAqyFWaQN/Aa4XT+4sfv+5eEy1rV3C4n7vyMR5UTtimqoVpR0zSwgO/z1MFS0gffWQoiI6OEH6s+8JqdMJbC+bv1lXKIGbr1/ovIDm9LOsPpwDjoycvOen0kWc85V7TLqTaY4Lo7vk8O7mKO5oTe3LlRGVgTRTJ+d5XlydfEs/V//vw/uHD5iyzKuDixRV13dvg7Lr7/38qDWUs3dy07lkAz/oIpuRfVlXn/o+O8krTSLYlR4ycjtQJ1Nsa+OvmTu44HqoC5kGYeJN+3CWp+E9eysA6iSar/452jyilVThIIVHEoa6Na4mifap2ObJEQC/e/rdgo2n35NPf3kpC6QNTAtU+09vfnqpDGUtnfZUnTUDvb7+0ZvYqO8BZ5J8UG/e9Miy1gqz/bVHnfYnO2nN4367t5WditOfOJ0ViMCOhngJvdcx/5Hvw5oH2lz4A8EFMPwJATGapLqK42aRP0mkkv/wjP7xZqbAk5xeQPEuywkFmjCDabNFpE9txJDe2q7XQVxKvRG/Jvx1QXu7p7V2Z99VXikixKFAoke5Y3raUK7d28KwrLEftR8V7kB/rsgLIkmOYZPdhDN/bhl0SHC5ptjf8rLGl0lTLyF3tAbFxFcWc+c5lC37DYb1MOt2wNqi9N6qhXHht9M9qarpWW5VMCNwWad4qE9JOj+wKTUa5Hoa7zr99c08sQDfU3REPqnY/UaJlKuDZBMfuVT30L02XMWwWzLKFtkGk99atK6cfBvu0U8GF0jxBTOuW74x/sVpBMJpPNJT6/0YTuqMQL8hARsqg5StuO2UkSsFncNnPOau4m3k7ZtpMCK1mxYqwZLS+xZ5EbIKHP+hHyMns7qFjNugqQ+yoVUEslkr49rfoYRBw1CTweWxgPHf1oA5QCNdReMDe5SJcUlXkiyh/NfGblJ+FUZTZhRnfMaorNcK2j5S5NPayApJ1r2tr9TUzUG4u7yqDSsJCJ9dK7i9WptEXJp7Rn/j8x+jhf58BS4aOwlXHUq2lhJkRb7698BqbW1e4OcSMmEEJhzDzQ52wezkShHTv+/4/LZa+Rx2T2hT/5EnLovqd/0CwibfkCT4nXuxw8Bf99GOfekx91z5i/wo3pF5JXYW8fnKSl71WwkVT/NPB85Xib5gMq0JCJ+FfbV4mfIpVNKVMPzSiOkudcmoxBSGh7o25gYtORXyyk8vnZwGfH1IA4iuVTHjnbj6c+2esvgRjIjWEJKVFSSi8erXYIyfT2yvlOXQbVBZWa7sjBGW1txVeFSQmWl9/533nE8w5H99UH7f0sJiARWfXdEPI45AI2iqa3nn38p9UAt9yjRdPmM5OxXrtARi1kjjAYSMcl0K56mwMzZwcFYLVrE/vMwuvSx60R+fJ52k99oQZrAZI6uyYE9yPL6M89VUveMK/WdgmQVeMvYdifrzlH1c9n0dL/qdS6ZlUca88m9vnhsayMj1yxNF+RX2KnVjofv7UirTZUiGrLd+KPH3ZmZSfk6/Ev/Q7k2cJMNSmChSJPzEFBJg+cRXZGs/NENlCeVQIRYd/lYKqKEn9z1SRl4LAVR5XgYHSKk2qOaVKY/OaTkkJANfAVI4oduUbP983K5ki0AKpCKyoPvnazvpLA3d+4iYf3hp8JPcIIrFC9wZBxjwWXNU5wBHrQ7KOgster73yLp7FaDWcEKh+XrbbWe+6khYhKOP6Yq+GiV/C4W8cHNsRhSpnuH0No1+BpKrAz2fxtyv2k/Ge4OksiSqO5/KusIxWw17JH5Xrcl8l43ubXkH3L8wkCndGHvkKy+DiHgNc8kRIrA/ZSQHT0tQj4iPtx0r+sPsqhLqO8l3aDc3w78Bs9teFTnZbo0b1KzEuBcJicWktjhm1Th9KzM0Y8AhvZESj9QVRA8WW5VPj2U9y/Lf4swSTacisw3w5EtbjsS6XgXp5iV+BaNYPivBlt6xQICYswiO56slrrHPFLoE14z3je3la7FRvKt3RW+pI/MA25T9OJj1hqkdTEVgqwGSocbOERpy0vFRMLVJjltM8gjH2JE1603TT/cvs2KrcNbXyBWmU3CzY+L7/EJlKnQUc5YWoEB5t+EBvQnhN6kBXuub5MoNLYA3j8ZQMbec3o3Th8b65Zz4uQS34a7Co3ivr48rQvs1dH38YUhljJ9Imqa7e/2d+oXWZxoY0ohS1p0NB2JQdz9Sz0mwTTVoW4OHuUhqf6FYWb8ty0mEcPYWZxdkJtVGllOMzpcEszZ3yUHQtAp3RgpsdOAatH4aW7s4UlE6k71GHle3TCwrCHw3dHLopXRV35LuCbSf6fuy79NOoOtiyUVXrCMweVUnDK8i6QeUMof4OzkXXQbkw5nx983Xwje/J7enuDusJA6O8QMxHqgvejPy6gKXDiWu3XpCebx9zx/IJBQTwICs8Y20YVSAzwgRMt+0TbfikQdl+rN5J6aSIsXOkGTSfNMeKVofmPEhMKKjw1BHFtZiLLxn5+JPS9VErKbqCmjA6VcntMahT8VoyQt57DIPHuL/0UCuNSdprt/9B0DREt7jK3Zz4HTeCdURt31F+8oc8qo71SOtxuTDWMgQKaYSZzrSlprEDEl08v4VIvLfFx8fijagM+XqXDXW6dHO8SnF8Os9ZWdwmvrk+Ccl0wc1FGhMi+9alsk+eDIIHzxcq7t9Xuoey7x6qSmGy4ZpfIi1PLJLtia2GIBLfNTRX8aub268K79O00PBMsVSzWHTbnNC4mpXJ9wz4a/hj/yTtw4aeebQG67/KgTX9uq8kw6rFVudkT203YOlFCJTGly3H+uxGs/pTEIqHywsF48E9vyIofJTuHFQCBuTFuaHtU9k5ddtJa80o2aeI9Ndg0fM9DQ+TtP7eWxvu+t17wFC8cPGgpCD9RSB2LIgrhSXzvxTkMDb9rYzk3LVLtgNiC1Cfa9GzHHw/rjKOSB77eOFhIWWC7HbYM+6gwx4wXRUAxg85uuw2CZVZ6kJlYL6xJ/CN6WnHoWpf3WosviES292ma8Md6hn4jJZPK4nwu/0ZJnAcvrlf6k7tGv2+hnGO1Jyfv4mcwqeR/Iu59oy3r6EigHBppXjZIrePQfIyCm10ToIf8tzmz781hLd4svz0f/3ya4Rp7oRu2ed+O2zxQqVS2ICKKe3fmUWJodJMYMI6qGz0hPK+3y5gGCK9vd588AENT6aRvJ3nd2fvEn3p/tR9z7/zJjcXF8r8fzQdHALI9ZxTPFzOFrksX9zvTn78WjwE10MfXRcAOHkhxV8/xwCClBAgjrexKw6MQSxAgBGGHpYQhMoE2Ik+EBA02iTACTQtIHgIpLk+uAibYRNiNiGD0+BM4Fe+84V4zU0JtgmpEWASkZpgSoAbMA6tsBnOwUXYCA76NcABOAqHoRkm+C4YOMIny8M2mIVL8AFfAc9nv6PTTUg+Q+L03wZf8i1ywuQj99OGHRdMbUYH7IO9fLocHINDgdM4BDgPZ2ErzPGp73zPp5dXtNuCVLkzEywegAHYxDfwD0dhF9yB3XyCJozDSTgD6+Ec/4AH+JTfDPKnj5faPb76bILj0xCiPtDfFni8GR/pAOtCO74OE1bCU7tcrRHxPTediQGzvoYAwAY2WLMZ8O1KFDgOgTkIuAqOX4ICPOgpOlbfQTFQP3kJFpzhm0tw4Bo5SgTvrJWjEMwHgVK4BAUUiKboXm+kGKhffQkW3M1RHNT/UIYI0liQrkSrZr+UMhrGpHzRNh9ttnSbVshTBtL/1uaqzrB/TnRSc3O5rbW8DIpDpV6r5OTwF3p4WgDpwwVMrZ02d9zyN6jHIhJOCH4bkZdLFC4koGgR09aTViYq9eR4CRAGvVSXpuvZMmn6Q8oHw8FvqOb4TSiCelvD/1P9mwBAwTrYBoCgoJBB/+YDQXCCKvsb6gwkIAMFXICKxhUdgxt3Hjx58ebDlx9/TCwB2DgCBQkWgouHTyBUmHARhETEJKRkIkWRixYjVpx4CRIpKKmoaSTR0kmmlyJVmnQZMhkYmWQxs7DKliNXnnwFFilUpFiJPQYtc8GYHy231hoTDtkbxmp3DdgQtut9m6w05//hbXfY7177w27HfOIjx5WyGVbmM+U+9qmvfO4LX/rptR2qEoL8vU40VKkZphLXS1g0AA==", "Matrix-code-bold.woff2": "data:font/woff2;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=", "Matrix-code-light.ttf": "data:application/octet-stream;base64,AAEAAAANAIAAAwBQRkZUTaVjVxkAADbAAAAAHEdERUYCDwHSAAA2ZAAAAFxPUy8yV6KR2wAAAVgAAABgY21hcGdhDKgAAAOoAAACGmdhc3AAAAAQAAA2XAAAAAhnbHlmMdO3vQAABsAAACooaGVhZCLm5AEAAADcAAAANmhoZWEHNARkAAABFAAAACRobXR46KFniAAAAbgAAAHubG9jYXASZVoAAAXEAAAA+m1heHAAgQBRAAABOAAAACBuYW1lpBLaqwAAMOgAAAJYcG9zdFDFB4MAADNAAAADGgABAAAAAQAAj8W99F8PPPUACwQAAAAAANsFkSsAAAAA5VAOWgAA/84DcgOxAAAACAACAAAAAAAAAAEAAAPA/8AAAAQoAAAAAANyAAEAAAAAAAAAAAAAAAAAAAB7AAEAAAB8AE8ABAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwQNAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAUGZFZABAAAAw/APA/8AAQAPAAEAAAAABAAAAAANBAy0AAAAgAAEEAAAAAAAAAAFVAAAAAAAAAgAAAAQAAdwEKAFFBAABFQQAASoEAAD2BAABmAQAAM0EAAGGBAAAvQQAANAEAACeBAAA0AQAANcEAADSBAAA+AQAANgEAAGiBAABIQQAAWsEAAErBCgAsAQAAOIEKADHBCgAkAPYAMYEKADRBCgBAgQAAMYEFADDBAAAyAQoAMcEKACrBAAAzwQAANIEKADHBCgAxwQoANID2AC5BCgA3AQoAMEEAADQBBQAwgQoAMgEFADABCgA0AQAANIEAADHBCgAxwQoAMYD2ADFBCgA1QQUAMwEKADWBCgA0AQAALoEAAHcBAADBAQAAOIEAAAABAABZgQUAMIEFADCBBQAwwQUAMwEFADMBCgAxwQoAMcEFADABBQAwAQoANAEKADHBCgAxwQoANIEKADSBAAA0gQAANIEKADIBCgAyAPYAMUD2ADFBAAAyAQAAMgEKADcBCgA3AQoANwEAADGBAAAxgQoANYEKADHBCgA1QQoAMcEKACrBCgAkAQoANAEKADQBCgA0AQoAMEEKADBBCgAwQQoAQID2AC5BCgAsAQoAMcD2ADGBCgAxgQoAMYEAADPBAAAugQoARcEAADQBAAA0AQoANEEAADIBCgA0AQoAMcEKADQBBQBogQAAPYBBAAAAAAAAwAAAAMAAAAcAAEAAAAAARQAAwABAAAAHAAEAPgAAAAsACAABAAMAAEAIgAuADoAPgBaAF8AaQB8L0cwfzCgMKYwrzC+MMcw1zDkMO8w9jD8//8AAAAAACAAKgAwADwAQQBfAGEAfC9HMH8woDClMKgwszDDMMow2zDpMPIw+///AAD/5AAA/9v/2v/Y/9T/0//B0PfPwM+gz5zPm8+Yz5QAAM+KAADPgs9+AAEALAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAMgAAAAAAAAABAAMABwAIAAAACQAKAFwAXQBeAF8AAABgAAAAAABhAAAAAABiAGMAZABvAHAAcQAAAAAAcgBzAAABBgAAAQMAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAAEBQYAAAAAAAAABwgACQoACwwNDg8QERITFBUAFhcYAAAZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMgAAAAAzADQ1Njc4OTo7PAAAAAAAAAAAAAAAAAAAAAAAAD0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgAEAAYACYAPgBeAHQAggCOANgA6gE6AXIBlgHQAiQCSgK0AwoDHgMyA0YDWgOCA54DuAPuBBYEVgSEBLAEzgT2BQ4FLAVaBYoFwgX2BiYGSAZ4BsoG7gceB2oHjgfMB+YH/Ag6CHQIrgjqCSIJTAl8Ca4JvAnQCewJ7AoACjAKYAp+CrYK7gssC2oLjguyC/AMCgwkDFQMhAy0DOQNMA18DbYN8A4YDkAOcA6gDtAO/A8oD1IPag+mD94P/BAyEGIQkhDCERQRZhG4EeYSCBIwEmQSjBLGEwATLhNgE34TohPGFAYULhReFJwU2hTmFPQVFAAAAAEAAAAAAAAAAAACAAA5AgABAAAAAAAAAAAAAgAAOQIAAQAAAAAAAAAAAAIAADkCAAEB3P/7AigDpAADAAABMxEjAdxMTAOk/FcAAAACAUUBGgLbAqYAAwAHAAABBwM3AQM3EwLbcyxx/sUtcSwBGwEBiwH+dAGLAf51AAABARUA0ALrAsgAEQAAATUjFScHFwcXNxUzNRc3JzcnAilSlyufnyuXUpcrn58rAhaysl9FZGNFXrKyXkVjZEUAAQEqAMYCuAKXAAsAAAE1IzUjFSMVMxUzNQK4j3CPj3ABd2+xsW+xsQAAAAABAPYBhgMXAfUAAwAAExUhNfYCIQH1b28AAAAAAQGYAAACaADGAAMAACUVMzUBmNDGxsYAAwDNABsDNAOgABUAIQAtAAABBgcGFREUFxY/ATY3NjURNCcxNSYjBzYzMhcWFxUXARE0EwYjIicmJzUnAREUAYlONzc3N07vUDQ4ODdN3yU+RR0gDAL+6fMkQkYdHwkBARYDngE3OEz99k43OAEBATc5SwIKTjUBOGckGBsvBAT+QAGwNP1sJBocMAQEAb3+UDMAAAEBhv/mAnwDkwAGAAABMxEzESMHAYZOqE+nAvT88gOtYQAAAAEAvQAHA04DpwA1AAABMhcWFzMmJyYrASIHBh0BFBcWFxYXFjEWFxYXFh0CIRUhNTQnJicmLwEmJyYnJj0BNDc2MwJ3OB8cBlwOMjZg4Vk6Pw0fRig3DzcpUB8P/jwCkQ0YUwRaDzgpeAwNJSFJA1EdGjJeLzI4PVE1Fx9LQycsDCwnS0EgGwkKVV8aHThTBE4NKyd3HCEdNS4kIAAAAAABAND/7QMuA4EAJQAAJSEVISclMzI3Nj0BNCcmKwEiBwYHMzY3NjsBMhcWHQEUBwYrARUCiP5IAl4B/rGJUzo5OjxQ0FkxLw1VBhodNIstIyIcHTnpQFNY30JBQ9FSOjoxL1wxGhwhIDDRGyotWQAAAgCe/+cDNwOvAAIADwAAASEJASUDMzUjEQcBFSETIQI+/qkBV/5iAjACaWmV/mUBoAL+YAGmAa38lAEBWWYCCAH9/mz+xwAAAQDQ/94DLgOBACQAAAEhAyEXIRcjIgcOAR0BFBceATsBMjY3IwYHBisBIicmPQE0NzYCAAEuAf2jAQGgAdtTOB4dOx9EKNFYYA1UBhodNGgwICIiIAHnAZpV8TofRCnRUjkeHWBcMBodIiAv0TAgIgAAAAACANf/6gMhA2oAKwA4AAABFw8BIycmJyYrASIHBgcVFBcWOwEyNzY1ETQnJicmJyYrARUzMhcWFxYXFgM1NDYyFxYdARQGIiYCdwEKEwoBAhg6AWg7STIGOEs50k02ORgYLDg1Uz6IVDgrKh0fDA73SWYkJUhnSQJGSgEBCRMIFDdRNNBaKzc4OEwBbDg8PTM9FiEmGBclJyos/jPQNEgkIzXQM0lJAAABANL/6wMlA4AAFAAAASUVIRUHBgcGHQEzNTQ3Njc2NzY3AyX9rQGgaDQaGrwHEhkVGTQzA34CVXPTaU1NMsXFEiddPzMzaGcAAAAAAwD4/+gDFAOYAC8AQABOAAABNTQnJisBIgcGHQEUFxYfAR0CIyIHBh0BFBcWOwEyNzY9ATQnJisBPQI3Njc2JzAVFAYjIicmPQE0NzYyFxYDNTQ2MhYdARQHBiInJgMUMi9PvU0wMioxNggKOigtMjNKvUwyMispIQoJKS4fnEExMSEgICNdIyHkOnA6ISFfIyACnDhSOjg4O1I4YC42BwEKAwk+RU44QkNDRENCOE9CQAkECgEFQS2NbzFQJyczbjYkJiYk/adtP0REP202JCYmJAACANj/9wMiA3gAKwA4AAABJz8BMxcWFxYxMzI3Njc1NicmKwEGBwYVERQXFhcWFxY7ATUjBicmJyYnJhMVFAYiJyY9ATQ2MhYBggEJFAoBAhg6aDxJMgUBOEs60U02ORgYLDg1Uz6HUzgrKh0fDA72SGYlJUlnSAEcSQEBCRMIFDdRNNFZKzgBNzhM/pM4PD0yPhYhJwEYFyUnKiwBztEzSSQjNdEySUkAAAAAAgGiAAsCXgLPAAMABwAAARUzNQMVMzUBory8vALPs7P977OzAAAAAAEBIQCUAtUCyAAFAAAJAjMJAQJQ/tEBL4X+0AEwAsj+5/7lARsBGQACAWsA8gKWAooAAwAHAAABIRUhByEVIQKW/tYBKgH+1gEqAopxtnEAAQErAJQC3wLIAAUAACUJASMJAQGwAS/+0YUBMP7QlAEbARn+5/7lAAEAsP/zA04DGwATAAAFNjcCAyMSEyYnNjcnAzM2NzYXFgMqEhJQUpxQT6CgODh+sYQGBgEB9gw8LwFbAWH+uP65FwSpoCb93RQJEwQMAAAAAwDiABgDIAM2AAMABwALAAABIREhJyERITUhESEDIP3CAj5u/qABYP6gAWADNvziaAEEMAEwAAABAMf/2AM5Ay0ACwAAASE0NyEQESEmJyEQAVUBoQH90AJyAQH+HQKwNEn+Vf5WSDQBLgAAAQCQAAIDWQOxACIAADczMhczMjc2NzY3NjUQEScUFSAlFBUkBRQVFAcGKwEiJyMUkB9gW21zTkYoKBIZmf7o/ugBLgECL0GNVA6uIwMBGBYuLUVZSwEoARQBboIBR0YICVZWmic3AT0AAAAAAQDG/+UDEAN6ABgAAAE1IRUhFSEVIREUBiMhFSEyNzY1ETM1IzUDEP22AVj+qAFYGCL+4gFYVRgYbGsDCnBwr3D+vSAchxwdVAF5cK8AAAABANEADwMvA3gAJwAAASE1IRYXHgEfAisBDwE3HwEeAxc1JicmLwI3NQcvASYnLgE1AX8BsP2iAh0NKRoHCBAMGwx4BQY1eG9hInpvKB8GBpHFBAUeDwYDAxtdiZ5NcDAODxGCRwYHPlUxGAMoH3orLgkIVX1zCgtHXSo8IwAAAAEBAgA6AxYDRAAbAAABFj8BMxcWFzcmNScjFSIjIicmNzQ9ASEnIRMWAWFycQ4KAQ6iCVEBgg0DSSNDAQGGAf35AgEBLDgIAQl9PWklXf65EiM/4QcKdP6NeAAAAgDG/+MDNwNfABMAFwAAEzMWFx4BFxYXNyYnLgEnJjUhNSERIRUhxpEPHh5qT1ByDmM6OToHCAEr/Y8Ccf2PAbpzUlJwICEPOxcqKWxBQEWGAR+EAAAAAAEAw//yAysC2QARAAAlEBEzNDUhFBUzEBEjFBUhNDUCQMr92srrAmhnAQEBAS5CQi7+//7/MUREMQAAAAIAyP/OAzgDQQAQABQAACQmNREjERQeAhc2NzUmJyYTAyMTAcFWo3yywUYDAzhHRvoyoTLuu3wBEv7uruKIOgUDAUULJSYC1P5bAaUAAAAAAgDHABQDYgMOAAUACQAAJSE2NSEUARUhNQNh/WYBApr9mgIwFElJSQKxg4MAAAAAAgCrAAADcgN7AAUACwAAISMSEzMCAQcSEzcCASV6VVR+VgE6cwTfTLoBvgG9/kMBvAL+G/6XHAF4AAAAAgDP/+wDLANOABQAGAAAATUhNSEVFBcWFx4BMzUiJyYnJicmAQUHJQFdAc/9o0RDWlmpKiw7UDQ8LCwBuP3PCgJAAYlScMKoV1YjIwJBAwMaHEpKAlEBfgEAAAADANL/6AM5A10AAwAHABcAAAEXIScBFyEnAycmJyYnJi8BIxcWFxYXFgH2AQFCAf68AQFCAQUDwXBwOTgOCzEEBDUqjmsCTnR0AQ90dPyLrQJMTV1cTkRkaoRpelwAAAABAMf/4AM4A6EAIgAAASE1IzUjFSMWFxYfAQcVNxEjFSE1IxEXFhcWFycmJyYnJicBhgGy7ZXvAiEgPAeG7u4Cce4ORDo4KgEdbqw8KBMC2HBZWXBcWUYHaZe1/nUgIAEwBhgMCwJIByg+gFFNAAAAAQDH//8DOAL6AB4AABMVNxcWFx4BFxYzNSYnJicmJzc1BS8DIx8CFhfHkgUkNTV/RkNEPTFrQR8W5v7/AQINAqwCBQ4DCgF+hEkKSTs5UxUVOggbNnU4R22Feg8nqB4SRpwrJwAAAAABANL/8AMuA0QAIAAAATM1IzUjFSM1IxUjFTMVFBceARcWFzUuAicmPQEzFTMC5UlJf8x/SUktMIxNQjQmZWIfIcx/AiJysLCwsHKdgU5OVhANBS0HIlNDRGWdwwAAAAAEALkADwMRA1UAAwAEAAgADAAANyU3BQcTJTcFEyU3BcMCSgL9tgwMAkoC/bZGAcwE/jQbQHg/hQKJQH0//kw4bzEAAAMA3AAGA20DdAARABUAGQAAAREnERQeARcWMzI9ASYnJicmJSMTMwETMwMBcZV81Gh1MgatimEXIQHCYjth/pE7YTwCWQERAf7vreKGHiEERSOAWz9aFAF6/oYBev6GAAEAwf/sA0sDnAA2AAAlMSYHExc1JzQ1BxQVIxUzAyMxNDc2NzY/ASMHBgcGBwYdASE1NCcmJyYvASMXFhcWFxYXFhcWA0h9fA7g2nzj3Q6nGRUbDgMCbwIDDRUaFwKKBQUYDgICbQICDwsXCiQcDRIOCgkCnwFmAUREAUREZv1hUEM4jks4LC08SnpRR0MiIkNFQotRNS0rNFA+MBQ/MRomAAAAAQDQ/+wDLgNUABQAAAEhETMRIREUFx4BFxYzNSInLgI1AV4BQo79okNDs1lQKy06RXxXAuP+9gF7/jarVFZGAgE5AwJAk40AAQDC/9sDLAODAB4AAAEhFTMVIxEUFxYXFh8BNScjIicmJyY9ASEVMxEjNTMDLP2W+vpSVWdnVU0yAThUSUFAAWd13t4DgxiW/qOrU1YkIwEBOQIjH0pJjdf9AYOWAAAAAQDI//gDNwNNAC4AAAExITQ1IRQXFhcWFwcGBwYHBgc2FzY3Njc2NzY3Nhc2FxYXFhcWFzQ1JicmJy4BAeQBU/3/AwgSCQsnIiMjCQMESEgCAQUVFhYLCgQEBAMpMFlvKidkQUUnJhwC3C5DQUacfDkjOjRPUjAJEgUEDAUlLzAVEQILAwMMKx46IA0KJhQ0NjRITNYAAAABAMD/8QMoA0YAFQAAASMVMwMjFzMHMzczNSMTMycjNjcjBgG+/vcR5gHeD5IP9/AR3wHXBASSBALBZv73cPHxcAEJZjhNTQABAND/4AMtA4wAKAAAATMXFhcWFzUmJy4CPQIzNSEVIRchFTMVFB4BFxYXNSYnJicmJyY1AdWEAh03LVExFBcUBXT9pAFRAf6vbmOTUks7LjQ3MTMdHgJUBkM9MhU6ISUqYoJBFAoYGJmG14ykVA0LAjoDDQ0mKUJFcQAAAQDS//wDMAN3AAsAABMhFQEVITUhNQE1IegBhP5mAl7+ZgGa/bgDSIf+Cc4whQH3zwAAAAIAxwACAzYAZQAEAAkAADchJyEXITMnIxfIAQAB/wABAXb4AfgBAmNjY2MAAQDH/9gDOgMuACoAAAE1MzUjNDUjFBUhERQWOwE0NSYHJhUmJyY1ETMVFBYXFhcWFzQ1JicmJyYCun5+lf6iNSazJiUBFg8Q0hUgHzs0US0aLwcDAjkKZjlMTDn9gCEwPSgLCgcHAQwMEQHbClfJWVZAOxUmFB02abpWAAEAxgAKAzcDiwAkAAABMzQ1KwE2NyMGByEVFBcWFxYXNS4BNTEhAgMhFBUhNDUmBxITAw8oHwsCApECAv5KEyhcLC9TJQE0Fhb+xwIoLS4VFQLCOU0YKysYtkg4cSwVBy8onHb+tP60BhoaBgoKAUwBTAAAAQDF/98DEwOLACYAAAEROwE1KwE1IRUhFSEVFBcWFxYXNS4BPQEhERQGKwEVMzI3Njc+AQLxChgYCv3yAXn+aRQqXigsSxMBBUlgv85XOTkjJB8BDwE9jrEYmcFMNG4vFAc7J5F2Cv7NdVpzFBQlJnIAAAABANUABgMqA20AIgAAACY9ASEfAR4BFxYXNwMhERQXFhcWFxYXNSYnJicmLwE3NQcBawcBAAIJCCkhIS4aZv4RPT5cXWNhQ21fMScoHQXH9gH6QiOdBxwdVDAvKCYBZv7zr3JyRUQcHQU4Fz8hKis2CWtRNAAAAAABAMz/5gMhA5IAIgAAATUhFTMHIxUzETMRHwIWFxYXFhc1JicmJyYnJj0BITUhNwMh/axdAV1dhxITCiUfLTFRTyksTBUxGh4BHf6RAQN7Fxeucv2LAQoZGw0wGicbLQ0sCyA5J14pLnSRc64AAAAAAQDWABADLgOfABkAAAEVIxUzFRQeARcWFzUmJyYnJicmPQEhNSE1AZC6uk53R0A5JCstJCAZFgEI/vgDn8dwvnubWRMRB0AHExQoJEM3Zr5wxwAAAQDQ//sDMQM8ABsAAAE3ISchFRQXFhcWFxYXMB8BBgczEyMHLwEmJyYBSgEB5gH9oAsJIyFBjB0YAhMRfnR8NwsLfDg1AoFTaLtMWExJRjpfBAEELTgBhrsFBj9vaQAAAgC6//gDLAN1AB0AIQAABSInLgEnJjU0NTwBNTQxMzAVHAEVFBUUFx4BFxYzAxEzEQLbK1tat0VFoioqeEFCMFKjCAEBSFhYrXVYWHUeHTMzklFRO4lHRz4DAgMw/nABkAAAAAEB3P/7AigDhQADAAABMxEjAdxMTAOF/HYAAAACAwT/1AM6A30AAwAHAAABIwMzESMRMwM6NAI0NDQCHAFh/FcBlwAAAwDiABgDIAM2AAMABwALAAABIREhJyERITUhESEDIP3CAj5u/qABYP6gAWADNvziaAEEMAEwAAACAWYA7QKaAnAAAwAHAAABIRUhFSEVIQKa/swBNP7MATQCcHuNewAAAQDC/9sDLAODAB4AAAEhFTMVIxEUFxYXFh8BNScjIicmJyY9ASEVMxEjNTMDLP2W+vpSVWdnVU0yAThUSUFAAWd13t4DgxiW/qOrU1YkIwEBOQIjH0pJjdf9AYOWAAAAAQDC/9sDLAODAB4AAAEhFTMVIxEUFxYXFh8BNScjIicmJyY9ASEVMxEjNTMDLP2W+vpSVWdnVU0yAThUSUFAAWd13t4DgxiW/qOrU1YkIwEBOQIjH0pJjdf9AYOWAAAAAQDD//IDKwLZABEAACUQETM0NSEUFTMQESMUFSE0NQJAyv3ayusCaGcBAQEBLkJCLv7//v8xREQxAAAAAQDM/+YDIQOSACIAAAE1IRUzByMVMxEzER8CFhcWFxYXNSYnJicmJyY9ASE1ITcDIf2sXQFdXYcSEwolHy0xUU8pLEwVMRoeAR3+kQEDexcXrnL9iwEKGRsNMBonGy0NLAsgOSdeKS50kXOuAAAAAAEAzP/mAyEDkgAiAAABNSEVMwcjFTMRMxEfAhYXFhcWFzUmJyYnJicmPQEhNSE3AyH9rF0BXV2HEhMKJR8tMVFPKSxMFTEaHgEd/pEBA3sXF65y/YsBChkbDTAaJxstDSwLIDknXikudJFzrgAAAAABAMf/2AM6Ay4AKgAAATUzNSM0NSMUFSERFBY7ATQ1JgcmFSYnJjURMxUUFhcWFxYXNDUmJyYnJgK6fn6V/qI1JrMmJQEWDxDSFSAfOzRRLRovBwMCOQpmOUxMOf2AITA9KAsKBwcBDAwRAdsKV8lZVkA7FSYUHTZpulYAAQDH/9gDOgMuACoAAAE1MzUjNDUjFBUhERQWOwE0NSYHJhUmJyY1ETMVFBYXFhcWFzQ1JicmJyYCun5+lf6iNSazJiUBFg8Q0hUgHzs0US0aLwcDAjkKZjlMTDn9gCEwPSgLCgcHAQwMEQHbClfJWVZAOxUmFB02abpWAAEAwP/xAygDRgAVAAABIxUzAyMXMwczNzM1IxMzJyM2NyMGAb7+9xHmAd4Pkg/38BHfAdcEBJIEAsFm/vdw8fFwAQlmOE1NAAEAwP/xAygDRgAVAAABIxUzAyMXMwczNzM1IxMzJyM2NyMGAb7+9xHmAd4Pkg/38BHfAdcEBJIEAsFm/vdw8fFwAQlmOE1NAAEA0P/gAy0DjAAoAAABMxcWFxYXNSYnLgI9AjM1IRUhFyEVMxUUHgEXFhc1JicmJyYnJjUB1YQCHTctUTEUFxQFdP2kAVEB/q9uY5NSSzsuNDcxMx0eAlQGQz0yFTohJSpigkEUChgYmYbXjKRUDQsCOgMNDSYpQkVxAAABAMf/2AM5Ay0ACwAAASE0NyEQESEmJyEQAVUBoQH90AJyAQH+HQKwNEn+Vf5WSDQBLgAAAQDH/9gDOQMtAAsAAAEhNDchEBEhJichEAFVAaEB/dACcgEB/h0CsDRJ/lX+Vkg0AS4AAAEA0v/wAy4DRAAgAAABMzUjNSMVIzUjFSMVMxUUFx4BFxYXNS4CJyY9ATMVMwLlSUl/zH9JSS0wjE1CNCZlYh8hzH8CInKwsLCwcp2BTk5WEA0FLQciU0NEZZ3DAAAAAAEA0v/wAy4DRAAgAAABMzUjNSMVIzUjFSMVMxUUFx4BFxYXNS4CJyY9ATMVMwLlSUl/zH9JSS0wjE1CNCZlYh8hzH8CInKwsLCwcp2BTk5WEA0FLQciU0NEZZ3DAAAAAAMA0v/oAzkDXQADAAcAFwAAARchJwEXIScDJyYnJicmLwEjFxYXFhcWAfYBAUIB/rwBAUIBBQPBcHA5OA4LMQQENSqOawJOdHQBD3R0/IutAkxNXVxORGRqhGl6XAAAAAMA0v/oAzkDXQADAAcAFwAAARchJwEXIScDJyYnJicmLwEjFxYXFhcWAfYBAUIB/rwBAUIBBQPBcHA5OA4LMQQENSqOawJOdHQBD3R0/IutAkxNXVxORGRqhGl6XAAAAAEAyP/4AzcDTQAuAAABMSE0NSEUFxYXFhcHBgcGBwYHNhc2NzY3Njc2NzYXNhcWFxYXFhc0NSYnJicuAQHkAVP9/wMIEgkLJyIjIwkDBEhIAgEFFRYWCwoEBAQDKTBZbyonZEFFJyYcAtwuQ0FGnHw5Izo0T1IwCRIFBAwFJS8wFRECCwMDDCseOiANCiYUNDY0SEzWAAAAAQDI//gDNwNNAC4AAAExITQ1IRQXFhcWFwcGBwYHBgc2FzY3Njc2NzY3Nhc2FxYXFhcWFzQ1JicmJy4BAeQBU/3/AwgSCQsnIiMjCQMESEgCAQUVFhYLCgQEBAMpMFlvKidkQUUnJhwC3C5DQUacfDkjOjRPUjAJEgUEDAUlLzAVEQILAwMMKx46IA0KJhQ0NjRITNYAAAABAMX/3wMTA4sAJgAAARE7ATUrATUhFSEVIRUUFxYXFhc1LgE9ASERFAYrARUzMjc2Nz4BAvEKGBgK/fIBef5pFCpeKCxLEwEFSWC/zlc5OSMkHwEPAT2OsRiZwUw0bi8UBzsnkXYK/s11WnMUFCUmcgAAAAEAxf/fAxMDiwAmAAABETsBNSsBNSEVIRUhFRQXFhcWFzUuAT0BIREUBisBFTMyNzY3PgEC8QoYGAr98gF5/mkUKl4oLEsTAQVJYL/OVzk5IyQfAQ8BPY6xGJnBTDRuLxQHOyeRdgr+zXVacxQUJSZyAAAAAgDI/84DOANBABAAFAAAJCY1ESMRFB4CFzY3NSYnJhMDIxMBwVajfLLBRgMDOEdG+jKhMu67fAES/u6u4og6BQMBRQslJgLU/lsBpQAAAAACAMj/zgM4A0EAEAAUAAAkJjURIxEUHgIXNjc1JicmEwMjEwHBVqN8ssFGAwM4R0b6MqEy7rt8ARL+7q7iiDoFAwFFCyUmAtT+WwGlAAAAAAMA3AAGA20DdAARABUAGQAAAREnERQeARcWMzI9ASYnJicmJSMTMwETMwMBcZV81Gh1MgatimEXIQHCYjth/pE7YTwCWQERAf7vreKGHiEERSOAWz9aFAF6/oYBev6GAAMA3AAGA20DdAARABUAGQAAAREnERQeARcWMzI9ASYnJicmJSMTMwETMwMBcZV81Gh1MgatimEXIQHCYjth/pE7YTwCWQERAf7vreKGHiEERSOAWz9aFAF6/oYBev6GAAMA3AAGA20DdAARABUAGQAAAREnERQeARcWMzI9ASYnJicmJSMTMwETMwMBcZV81Gh1MgatimEXIQHCYjth/pE7YTwCWQERAf7vreKGHiEERSOAWz9aFAF6/oYBev6GAAIAxv/jAzcDXwATABcAABMzFhceARcWFzcmJy4BJyY1ITUhESEVIcaRDx4eak9Qcg5jOjk6BwgBK/2PAnH9jwG6c1JScCAhDzsXKilsQUBFhgEfhAAAAAACAMb/4wM3A18AEwAXAAATMxYXHgEXFhc3JicuAScmNSE1IREhFSHGkQ8eHmpPUHIOYzo5OgcIASv9jwJx/Y8BunNSUnAgIQ87FyopbEFARYYBH4QAAAAAAQDWABADLgOfABkAAAEVIxUzFRQeARcWFzUmJyYnJicmPQEhNSE1AZC6uk53R0A5JCstJCAZFgEI/vgDn8dwvnubWRMRB0AHExQoJEM3Zr5wxwAAAgDHABQDYgMOAAUACQAAJSE2NSEUARUhNQNh/WYBApr9mgIwFElJSQKxg4MAAAAAAQDVAAYDKgNtACIAAAAmPQEhHwEeARcWFzcDIREUFxYXFhcWFzUmJyYnJi8BNzUHAWsHAQACCQgpISEuGmb+ET0+XF1jYUNtXzEnKB0Fx/YB+kIjnQccHVQwLygmAWb+869yckVEHB0FOBc/ISorNglrUTQAAAAAAQDH/+ADOAOhACIAAAEhNSM1IxUjFhcWHwEHFTcRIxUhNSMRFxYXFhcnJicmJyYnAYYBsu2V7wIhIDwHhu7uAnHuDkQ6OCoBHW6sPCgTAthwWVlwXFlGB2mXtf51ICABMAYYDAsCSAcoPoBRTQAAAAIAqwAAA3IDewAFAAsAACEjEhMzAgEHEhM3AgElelVUflYBOnME30y6Ab4Bvf5DAbwC/hv+lxwBeAAAAAEAkAACA1kDsQAiAAA3MzIXMzI3Njc2NzY1EBEnFBUgJRQVJAUUFRQHBisBIicjFJAfYFttc05GKCgSGZn+6P7oAS4BAi9BjVQOriMDARgWLi1FWUsBKAEUAW6CAUdGCAlWVponNwE9AAAAAAEA0P/7AzEDPAAbAAABNyEnIRUUFxYXFhcWFzAfAQYHMxMjBy8BJicmAUoBAeYB/aALCSMhQYwdGAITEX50fDcLC3w4NQKBU2i7TFhMSUY6XwQBBC04AYa7BQY/b2kAAAEA0P/7AzEDPAAbAAABNyEnIRUUFxYXFhcWFzAfAQYHMxMjBy8BJicmAUoBAeYB/aALCSMhQYwdGAITEX50fDcLC3w4NQKBU2i7TFhMSUY6XwQBBC04AYa7BQY/b2kAAAEA0P/7AzEDPAAbAAABNyEnIRUUFxYXFhcWFzAfAQYHMxMjBy8BJicmAUoBAeYB/aALCSMhQYwdGAITEX50fDcLC3w4NQKBU2i7TFhMSUY6XwQBBC04AYa7BQY/b2kAAAEAwf/sA0sDnAA2AAAlMSYHExc1JzQ1BxQVIxUzAyMxNDc2NzY/ASMHBgcGBwYdASE1NCcmJyYvASMXFhcWFxYXFhcWA0h9fA7g2nzj3Q6nGRUbDgMCbwIDDRUaFwKKBQUYDgICbQICDwsXCiQcDRIOCgkCnwFmAUREAUREZv1hUEM4jks4LC08SnpRR0MiIkNFQotRNS0rNFA+MBQ/MRomAAAAAQDB/+wDSwOcADYAACUxJgcTFzUnNDUHFBUjFTMDIzE0NzY3Nj8BIwcGBwYHBh0BITU0JyYnJi8BIxcWFxYXFhcWFxYDSH18DuDafOPdDqcZFRsOAwJvAgMNFRoXAooFBRgOAgJtAgIPCxcKJBwNEg4KCQKfAWYBREQBRERm/WFQQziOSzgsLTxKelFHQyIiQ0VCi1E1LSs0UD4wFD8xGiYAAAABAMH/7ANLA5wANgAAJTEmBxMXNSc0NQcUFSMVMwMjMTQ3Njc2PwEjBwYHBgcGHQEhNTQnJicmLwEjFxYXFhcWFxYXFgNIfXwO4Np8490OpxkVGw4DAm8CAw0VGhcCigUFGA4CAm0CAg8LFwokHA0SDgoJAp8BZgFERAFERGb9YVBDOI5LOCwtPEp6UUdDIiJDRUKLUTUtKzRQPjAUPzEaJgAAAAEBAgA6AxYDRAAbAAABFj8BMxcWFzcmNScjFSIjIicmNzQ9ASEnIRMWAWFycQ4KAQ6iCVEBgg0DSSNDAQGGAf35AgEBLDgIAQl9PWklXf65EiM/4QcKdP6NeAAABAC5AA8DEQNVAAMABAAIAAwAADclNwUHEyU3BRMlNwXDAkoC/bYMDAJKAv22RgHMBP40G0B4P4UCiUB9P/5MOG8xAAABALD/8wNOAxsAEwAABTY3AgMjEhMmJzY3JwMzNjc2FxYDKhISUFKcUE+goDg4frGEBgYBAfYMPC8BWwFh/rj+uRcEqaAm/d0UCRMEDAAAAAEAx///AzgC+gAeAAATFTcXFhceARcWMzUmJyYnJic3NQUvAyMfAhYXx5IFJDU1f0ZDRD0xa0EfFub+/wECDQKsAgUOAwoBfoRJCkk7OVMVFToIGzZ1OEdthXoPJ6geEkacKycAAAAAAQDG/+UDEAN6ABgAAAE1IRUhFSEVIREUBiMhFSEyNzY1ETM1IzUDEP22AVj+qAFYGCL+4gFYVRgYbGsDCnBwr3D+vSAchxwdVAF5cK8AAAABAMYACgM3A4sAJAAAATM0NSsBNjcjBgchFRQXFhcWFzUuATUxIQIDIRQVITQ1JgcSEwMPKB8LAgKRAgL+ShMoXCwvUyUBNBYW/scCKC0uFRUCwjlNGCsrGLZIOHEsFQcvKJx2/rT+tAYaGgYKCgFMAUwAAAEAxgAKAzcDiwAkAAABMzQ1KwE2NyMGByEVFBcWFxYXNS4BNTEhAgMhFBUhNDUmBxITAw8oHwsCApECAv5KEyhcLC9TJQE0Fhb+xwIoLS4VFQLCOU0YKysYtkg4cSwVBy8onHb+tP60BhoaBgoKAUwBTAAAAgDP/+wDLANOABQAGAAAATUhNSEVFBcWFx4BMzUiJyYnJicmAQUHJQFdAc/9o0RDWlmpKiw7UDQ8LCwBuP3PCgJAAYlScMKoV1YjIwJBAwMaHEpKAlEBfgEAAAACALr/+AMsA3UAHQAhAAAFIicuAScmNTQ1PAE1NDEzMBUcARUUFRQXHgEXFjMDETMRAtsrW1q3RUWiKip4QUIwUqMIAQFIWFitdVhYdR4dMzOSUVE7iUdHPgMCAzD+cAGQAAAAAgEXAAADTwN7AAUACwAAISMSEzMCAQcSEzcCAZF6Hh9+IQEIcwS5TJQBvgG9/kMBtgL93/7WHAEsAAAAAQDQ/+wDLgNUABQAAAEhETMRIREUFx4BFxYzNSInLgI1AV4BQo79okNDs1lQKy06RXxXAuP+9gF7/jarVFZGAgE5AwJAk40AAQDQ/+wDLgNUABQAAAEhETMRIREUFx4BFxYzNSInLgI1AV4BQo79okNDs1lQKy06RXxXAuP+9gF7/jarVFZGAgE5AwJAk40AAQDRAA8DLwN4ACcAAAEhNSEWFx4BHwIrAQ8BNx8BHgMXNSYnJi8CNzUHLwEmJy4BNQF/AbD9ogIdDSkaBwgQDBsMeAUGNXhvYSJ6bygfBgaRxQQFHg8GAwMbXYmeTXAwDg8RgkcGBz5VMRgDKB96Ky4JCFV9cwoLR10qPCMAAAACAMj/zgM4A0EAEAAUAAAkJjURIxEUHgIXNjc1JicmEwMjEwHBVqN8ssFGAwM4R0b6MqEy7rt8ARL+7q7iiDoFAwFFCyUmAtT+WwGlAAAAAAEA0P/7AzEDPAAbAAABNyEnIRUUFxYXFhcWFzAfAQYHMxMjBy8BJicmAUoBAeYB/aALCSMhQYwdGAITEX50fDcLC3w4NQKBU2i7TFhMSUY6XwQBBC04AYa7BQY/b2kAAAEAx//YAzoDLgAqAAABNTM1IzQ1IxQVIREUFjsBNDUmByYVJicmNREzFRQWFxYXFhc0NSYnJicmArp+fpX+ojUmsyYlARYPENIVIB87NFEtGi8HAwI5CmY5TEw5/YAhMD0oCwoHBwEMDBEB2wpXyVlWQDsVJhQdNmm6VgABAND/4AMtA4wAKAAAATMXFhcWFzUmJy4CPQIzNSEVIRchFTMVFB4BFxYXNSYnJicmJyY1AdWEAh03LVExFBcUBXT9pAFRAf6vbmOTUks7LjQ3MTMdHgJUBkM9MhU6ISUqYoJBFAoYGJmG14ykVA0LAjoDDQ0mKUJFcQAAAQGi//YCcgC8AAMAAAUzNSMBotDQCsYAAQD2AYYDFwH1AAMAABMVITX2AiEB9W9vAAAAAAEBBAAAAvsDdwAQAAABBRUhERczNTMTFxUjAyMvAQEFAfb+oCw1fgFrVY15Ok0DdwGW/uZi3P7Cwz8BBzylAAAAAA4ArgABAAAAAAABABYALgABAAAAAAACAAcAVQABAAAAAAADACQApwABAAAAAAAEAAsA5AABAAAAAAAFAAsBCAABAAAAAAAGABYBQgABAAAAAAAKABoBjwADAAEECQABACwAAAADAAEECQACAA4ARQADAAEECQADAEgAXQADAAEECQAEABYAzAADAAEECQAFABYA8AADAAEECQAGACwBFAADAAEECQAKADQBWQBlAG4AaQBnAG0AYQBoAGEAYwBrAC0AbQBhAHQAcgBpAHgALQBjAG8AZABlAABlbmlnbWFoYWNrLW1hdHJpeC1jb2RlAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABGAG8AbgB0AEYAbwByAGcAZQAgADoAIABtAGEAdAByAGkAeAAtAGMAbwBkAGUAIAA6ACAAMgA3AC0AMQAxAC0AMgAwADIANQAARm9udEZvcmdlIDogbWF0cml4LWNvZGUgOiAyNy0xMS0yMDI1AABtAGEAdAByAGkAeAAtAGMAbwBkAGUAAG1hdHJpeC1jb2RlAABWAGUAcgBzAGkAbwBuACAAMQAuADAAAFZlcnNpb24gMS4wAABlAG4AaQBnAG0AYQBoAGEAYwBrAC0AbQBhAHQAcgBpAHgALQBjAG8AZABlAABlbmlnbWFoYWNrLW1hdHJpeC1jb2RlAABGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAEZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwAAAECAAIBAwADAAQABQANAA4AEAARABMAFAAVABYAFwAYABkAGgAbABwAHQAfACAAIQAkACUAJgAnACgAKQEEACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0AQgBEAEUARgBHAEgASQBKAEsATABfAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEAKgd1bmkwMDAwB3VuaTAwMDEHZ2x5cGgzMAd1bmkyRjQ3B3VuaTMwN0YHdW5pMzBBMAd1bmkzMEE1B3VuaTMwQTYHdW5pMzBBOAd1bmkzMEE5B3VuaTMwQUEHdW5pMzBBQgd1bmkzMEFDB3VuaTMwQUQHdW5pMzBBRQd1bmkzMEFGB3VuaTMwQjMHdW5pMzBCNAd1bmkzMEI1B3VuaTMwQjYHdW5pMzBCNwd1bmkzMEI4B3VuaTMwQjkHdW5pMzBCQQd1bmkzMEJCB3VuaTMwQkMHdW5pMzBCRAd1bmkzMEJFB3VuaTMwQzMHdW5pMzBDNAd1bmkzMEM1B3VuaTMwQzYHdW5pMzBDNwd1bmkzMENBB3VuaTMwQ0IHdW5pMzBDQwd1bmkzMENEB3VuaTMwQ0YHdW5pMzBEMgd1bmkzMEQ1B3VuaTMwRDYHdW5pMzBENwd1bmkzMERCB3VuaTMwREMHdW5pMzBERAd1bmkzMERFB3VuaTMwREYHdW5pMzBFMAd1bmkzMEUxB3VuaTMwRTIHdW5pMzBFMwd1bmkzMEU0B3VuaTMwRTkHdW5pMzBFQQd1bmkzMEVCB3VuaTMwRUUHdW5pMzBFRgd1bmkzMEYyB3VuaTMwRjMHdW5pMzBGNAd1bmkzMEY1B3VuaTMwRjYHdW5pMzBGQgd1bmkzMEZDAAAAAQAB//8ADwABAAAADAAAAEwAVAACAAoABQAFAAEAEQARAAEAGQAcAAEAHgAgAAEAIgAmAAEAKwArAAEALgAuAAEAMAAwAAEAMgAyAAEAPgB7AAEABAAAAAIAAAABAAAAAQAAAAAAAQAAAADlDbeTAAAAANsFkSsAAAAA5VAOWg=="}};</script>
<script id="simulation-worker-source" type="javascript/worker">
// --- Worker Dep: Utils.js ---
// =========================================================================
// CORE UTILITIES / CONSTANTS
// =========================================================================
const APP_VERSION = "8.5";
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a color string (Hex "#RRGGBB" or "rgb(r,g,b)") to an { r, g, b } object.
     * @param {string} input - The color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (input) => {
        if (typeof input !== "string") return { r: 0, g: 255, b: 0 };
        // Handle Hex (6 or 8 digits)
        const hexMatch = input.match(/^#?([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/);
        if (hexMatch) {
            const value = parseInt(hexMatch[1], 16);
            return {
                r: (value >> 16) & 0xFF,
                g: (value >> 8) & 0xFF,
                b: value & 0xFF
            };
        }
        // Handle RGB / RGBA
        const match = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            return {
                r: parseInt(match[1], 10),
                g: parseInt(match[2], 10),
                b: parseInt(match[3], 10)
            };
        }
        // Fallback
        return { r: 0, g: 255, b: 0 }; 
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Packs RGB components into a single 32-bit integer (0xAABBGGRR) for Little Endian (RR GG BB AA in memory).
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @param {number} a - Alpha (0-255), defaults to 255.
     * @returns {number} The packed 32-bit integer.
     */
    packAbgr: (r, g, b, a = 255) => {
        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
    },
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: '',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Shuffles an array in place using the Fisher-Yates algorithm.
     * @param {Array} array - The array to shuffle.
     * @returns {Array} The shuffled array.
     */
    shuffle: (array) => {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3,
    UPWARD_TRACER: 4
};
const CELL_TYPE_MASK = 0x7F; // 127
const CELL_FLAGS = {
    GRADUAL: 0x80 // 128
};
// --- Worker Dep: CellGrid.js ---
// =========================================================================
// CELL GRID
// =========================================================================
// Constants for Cell State and Render Modes
const CELL_STATE = {
    INACTIVE: 0,
    ACTIVE: 1
    // OVERRIDE state is determined by the overrideActive flag
};
const RENDER_MODE = {
    STANDARD: 0, // Mix between Primary and Secondary based on 'mix'
    OVERLAP: 1,  // Visual Overlap (both visible)
    ADDITIVE: 2  // Additive blending (future proofing)
};
const OVERRIDE_MODE = {
    NONE: 0,
    CHAR: 1,
    SOLID: 2,
    FULL: 3
};
class CellGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // --- Core State ---
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.state = null; // Uint8: INACTIVE / ACTIVE
        // --- Primary Layer ---
        this.chars = null;        // Uint16
        this.colors = null;       // Uint32 (0xAABBGGRR) - Current Display Color
        this.baseColors = null;   // Uint32 (0xAABBGGRR) - Target/Stream Color
        this.alphas = null;       // Float32
        this.glows = null;        // Float32
        this.fontIndices = null;  // Uint8
        // --- Secondary Layer (Rotators / Overlaps) ---
        this.secondaryChars = null; // Uint16
        this.secondaryColors = null; // Uint32
        this.secondaryAlphas = null; // Float32
        this.secondaryGlows = null;  // Float32
        this.secondaryFontIndices = null; // Uint8
        // --- Mixing & Rendering ---
        this.mix = null;        // Float32 (0.0 = Primary, 1.0 = Secondary)
        this.renderMode = null; // Uint8 (RENDER_MODE)
        // --- Override Layer (Effects) ---
        this.overrideActive = null; // Uint8 (OVERRIDE_MODE)
        this.overrideChars = null;  // Uint16
        this.overrideColors = null; // Uint32
        this.overrideAlphas = null; // Float32
        this.overrideGlows = null;  // Float32
        this.overrideMix = null;    // Float32 (New: For FULL mode)
        this.overrideNextChars = null; // Uint16 (New: For FULL mode rotators)
        this.overrideFontIndices = null; // Uint8
        // --- Passive Layer (Effects) ---
        this.effectActive = null;   // Uint8
        this.effectChars = null;    // Uint16
        this.effectColors = null;   // Uint32
        this.effectAlphas = null;   // Float32
        this.effectGlows = null;    // Float32
        this.effectFontIndices = null; // Uint8
        // --- Simulation Logic Storage ---
        this.types = null;      // Uint8 (Tracer, Rotator, Empty)
        this.decays = null;     // Uint8
        this.maxDecays = null;  // Uint16 (Per-cell fade duration)
        this.ages = null;       // Int32
        this.brightness = null; // Float32
        this.rotatorOffsets = null; // Uint8 (Static noise for desync)
        // Auxiliary
        this.cellLocks = null;  // Uint8 (Prevent updates)
        // Sparse Data (Maps for memory efficiency)
        this.complexStyles = new Map(); // Dynamic styling data
        // Rotator Targets (Dense for GPU upload)
        this.nextChars = null;     // Uint16Array
        this.nextOverlapChars = null; // Uint16Array
    }
    /**
     * Resizes the grid based on new width and height.
     */
    resize(width, height, buffers = null) {
        const d = this.config.derived;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
        if (!d || !d.cellWidth || !d.cellHeight) return;
        // Snap to Fit: Round columns (width is primary), Ceil rows (height allows partial)
        const newCols = Math.round(width / d.cellWidth);
        const newRows = Math.ceil(height / d.cellHeight);
        if (newCols !== this.cols || newRows !== this.rows || buffers) {
            this._resizeGrid(newCols, newRows, buffers);
        }
    }
    getIndex(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return -1;
        return y * this.cols + x;
    }
    // --- Primary Layer Modifiers ---
    setPrimary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.chars[idx] = charStr.charCodeAt(0);
        this.colors[idx] = colorUint32;
        this.alphas[idx] = alpha;
        this.glows[idx] = glow;
        this.fontIndices[idx] = fontIndex;
        this.state[idx] = CELL_STATE.ACTIVE;
        this.activeIndices.add(idx);
    }
    setRotatorTarget(idx, charStr, isSecondary = false) {
        const code = charStr.charCodeAt(0);
        if (isSecondary) {
            this.nextOverlapChars[idx] = code;
        } else {
            this.nextChars[idx] = code;
        }
    }
    getRotatorTarget(idx, isSecondary = false) {
        const code = isSecondary ? this.nextOverlapChars[idx] : this.nextChars[idx];
        return (code > 0) ? String.fromCharCode(code) : null;
    }
    // --- Secondary Layer Modifiers ---
    setSecondary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.secondaryChars[idx] = charStr.charCodeAt(0);
        this.secondaryColors[idx] = colorUint32;
        this.secondaryAlphas[idx] = alpha;
        this.secondaryGlows[idx] = glow;
        this.secondaryFontIndices[idx] = fontIndex;
    }
    // --- Override Layer Modifiers ---
    // This is a 'permanent' or hard override - it directly changes state
    setOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.overrideChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideGlows[idx] = glow;
        this.overrideFontIndices[idx] = fontIndex;
        this.overrideActive[idx] = OVERRIDE_MODE.CHAR;
    }
    // This is a soft override 
    setEffectOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 1;
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Overlay Override (Mixes Effect Char on top of Primary)
    setEffectOverlay(idx, charStr, color, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 2; // 2 = Overlay Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = color;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // High Priority Override (Ignores Shadows/Masks)
    setHighPriorityEffect(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 4; // 4 = High Priority Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Shadow Overlay (Mixes Black Block on top of Primary)
    setEffectShadow(idx, alpha) {
        this.effectActive[idx] = 3; // 3 = Shadow Mode
        this.effectAlphas[idx] = alpha;
    }
    setSolidOverride(idx, colorUint32, alpha) {
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideActive[idx] = OVERRIDE_MODE.SOLID;
    }
    clearOverride(idx) {
        this.overrideActive[idx] = OVERRIDE_MODE.NONE;
    }
    clearEffectOverride(idx) {
        this.effectActive[idx] = 0;
    }
    clearAllOverrides() {
        if (this.overrideActive) {
            this.overrideActive.fill(0);
        }
    }
    clearAllEffects(){
        if (this.effectActive){
            this.effectActive.fill(0);
        }
    }
    // --- General State Management ---
    clearCell(idx) {
        this.state[idx] = CELL_STATE.INACTIVE;
        this.chars[idx] = 32; // Space
        this.alphas[idx] = 0;
        this.glows[idx] = 0;
        this.mix[idx] = 0;
        this.renderMode[idx] = RENDER_MODE.STANDARD;
        // Clear simulation data
        this.types[idx] = 0;
        this.ages[idx] = 0;
        this.decays[idx] = 0;
        this.maxDecays[idx] = 0;
        // Also clear secondary to be safe
        this.secondaryChars[idx] = 32;
        this.secondaryAlphas[idx] = 0;
        this.activeIndices.delete(idx);
        // Clear maps
        this.complexStyles.delete(idx);
        this.nextChars[idx] = 0;
        this.nextOverlapChars[idx] = 0;
    }
    getChar(idx) {
        // Helper for simulation reading
        return String.fromCharCode(this.chars[idx]);
    }
    getState(idx){
        // Helper for getting cell state
        return this.state[idx];
    }
    _resizeGrid(newCols, newRows, buffers = null) {
        const total = newCols * newRows;
        if (buffers) {
            // Adopt provided buffers (SharedArrayBuffer views)
            this.state = buffers.state;
            this.chars = buffers.chars;
            this.colors = buffers.colors;
            this.baseColors = buffers.baseColors;
            this.alphas = buffers.alphas;
            this.glows = buffers.glows;
            this.fontIndices = buffers.fontIndices;
            this.secondaryChars = buffers.secondaryChars;
            this.secondaryColors = buffers.secondaryColors;
            this.secondaryAlphas = buffers.secondaryAlphas;
            this.secondaryGlows = buffers.secondaryGlows;
            this.secondaryFontIndices = buffers.secondaryFontIndices;
            this.mix = buffers.mix;
            this.renderMode = buffers.renderMode;
            this.overrideActive = buffers.overrideActive;
            this.overrideChars = buffers.overrideChars;
            this.overrideColors = buffers.overrideColors;
            this.overrideAlphas = buffers.overrideAlphas;
            this.overrideGlows = buffers.overrideGlows;
            this.overrideMix = buffers.overrideMix;
            this.overrideNextChars = buffers.overrideNextChars;
            this.overrideFontIndices = buffers.overrideFontIndices;
            this.effectActive = buffers.effectActive;
            this.effectChars = buffers.effectChars;
            this.effectColors = buffers.effectColors;
            this.effectAlphas = buffers.effectAlphas;
            this.effectFontIndices = buffers.effectFontIndices;
            this.effectGlows = buffers.effectGlows;
            this.types = buffers.types;
            this.decays = buffers.decays;
            this.maxDecays = buffers.maxDecays;
            this.ages = buffers.ages;
            this.brightness = buffers.brightness;
            this.rotatorOffsets = buffers.rotatorOffsets;
            this.cellLocks = buffers.cellLocks;
            this.nextChars = buffers.nextChars;
            this.nextOverlapChars = buffers.nextOverlapChars;
            this.envGlows = buffers.envGlows;
        } else {
            // Core
            this.state = new Uint8Array(total);
            // Primary
            this.chars = new Uint16Array(total);
            this.colors = new Uint32Array(total);
            this.baseColors = new Uint32Array(total);
            this.alphas = new Float32Array(total);
            this.glows = new Float32Array(total);
            this.fontIndices = new Uint8Array(total);
            // Secondary
            this.secondaryChars = new Uint16Array(total);
            this.secondaryColors = new Uint32Array(total);
            this.secondaryAlphas = new Float32Array(total);
            this.secondaryGlows = new Float32Array(total);
            this.secondaryFontIndices = new Uint8Array(total);
            // Mix / Mode
            this.mix = new Float32Array(total);
            this.renderMode = new Uint8Array(total);
            // Override
            this.overrideActive = new Uint8Array(total);
            this.overrideChars = new Uint16Array(total);
            this.overrideColors = new Uint32Array(total);
            this.overrideAlphas = new Float32Array(total);
            this.overrideGlows = new Float32Array(total);
            this.overrideMix = new Float32Array(total);
            this.overrideNextChars = new Uint16Array(total);
            this.overrideFontIndices = new Uint8Array(total);
            // Effects
            this.effectActive = new Uint8Array(total)
            this.effectChars = new Uint16Array(total);
            this.effectColors = new Uint32Array(total);
            this.effectAlphas = new Float32Array(total);
            this.effectFontIndices = new Uint8Array(total);
            this.effectGlows = new Float32Array(total);
            // Simulation
            this.types = new Uint8Array(total);
            this.decays = new Uint16Array(total);
            this.maxDecays = new Uint16Array(total);
            this.ages = new Int32Array(total);
            this.brightness = new Float32Array(total);
            this.rotatorOffsets = new Uint8Array(total);
            this.cellLocks = new Uint8Array(total);
            // Rotators
            this.nextChars = new Uint16Array(total);
            this.nextOverlapChars = new Uint16Array(total);
            // Environmental Glows (Additive, per frame)
            this.envGlows = new Float32Array(total);
        }
        // Initialize static data
        if (!buffers) {
            const activeFonts = this.config.derived ? this.config.derived.activeFonts : null;
            const fallbackChars = "012345789Z:<=>\"*+-._!|";
            for (let i = 0; i < total; i++) {
                this.rotatorOffsets[i] = (Math.random() * 255) | 0;
                let charCode = 32; 
                if (activeFonts && activeFonts.length > 0) {
                    const f = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                    if (f.chars && f.chars.length > 0) {
                        charCode = f.chars.charCodeAt(Math.floor(Math.random() * f.chars.length));
                    }
                } else {
                    charCode = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
                }
                this.chars[i] = charCode;
            }
        }
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- Worker Dep: StreamModes.js ---
// =========================================================================
// STREAM MODE
// =========================================================================
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        let hue;
        if (state.starPowerRainbowMode === 'char') {
            hue = (frame + (stream.x * 10)) % 360; // Character-based hue
        } else {
            // Full Stream Mode: Sync hue start time so they cycle together
            // If cycling is enabled, offset the base hue by the current frame * speed
            hue = stream.baseHue;
            if (state.starPowerColorCycle) {
                 hue = (hue + (frame * state.starPowerCycleSpeed)) % 360;
            }
        }
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed);
    }
    _createStyle(hue, saturation, lightness, cycle, speed) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, isEffect: true, type: 'star_glimmer' };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, isEffect: true };
    }
}
// --- Worker Dep: StreamManager.js ---
// =========================================================================
// STREAM MANAGER
// =========================================================================
class StreamManager {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this._activeStreams = []; // Backing field
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(grid.cols).fill(null);
        this.columnSpeeds = new Float32Array(grid.cols);
        this.streamsPerColumn = new Int16Array(grid.cols); // Track active streams count
        this.modes = this._initializeModes(config);
        this.nextSpawnFrame = 0;
        // Reusable columns pool to avoid per-spawn allocation
        this._columnsPool = new Array(this.grid.cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    get activeStreams() {
        return this._activeStreams;
    }
    set activeStreams(val) {
        const oldLen = this._activeStreams ? this._activeStreams.length : 0;
        const newLen = val ? val.length : 0;
        // Critical Log: Catch assignment-based wipe
        if (oldLen > 20 && newLen === 0 && this.config.state.logErrors) {
            console.error(`[StreamManager] ActiveStreams REPLACED! Count dropped from ${oldLen} to ${newLen}.`);
            console.trace();
        }
        this._activeStreams = val;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    resize(cols) {
        // Critical Log: Catch resize-based wipe
        if (this._activeStreams && this._activeStreams.length > 0 && this.config.state.logErrors) {
            console.warn(`[StreamManager] Resize triggered (cols: ${cols}). Clearing ${this._activeStreams.length} streams.`);
            console.trace();
        }
        this.lastStreamInColumn = new Array(cols).fill(null);
        this.lastEraserInColumn = new Array(cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(cols).fill(null);
        this.columnSpeeds = new Float32Array(cols);
        this.streamsPerColumn = new Int16Array(cols);
        this.activeStreams = []; // Triggers setter
        // Rebuild columns pool
        this._columnsPool = new Array(cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    update(frame, timeScale) {
        // Only resize if grid dimensions have actually changed
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            if (this.config.state.logErrors) console.warn(`[StreamManager] Auto-resize triggered. Old: ${this.lastStreamInColumn.length}, New: ${this.grid.cols}`);
            this.resize(this.grid.cols);
        }
        if (timeScale > 0) {
            this._manageStreams(frame, timeScale);
        } else if (timeScale < 0) {
            this._processActiveStreams(frame, timeScale);
        }
        // If timeScale == 0, pause
    }
    _manageStreams(frame, timeScale) {
        const { state: s, derived: d } = this.config;
        // Independent Glimmer Management (Runs every frame)
        this._manageGlimmer(s);
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2;
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        this._processActiveStreams(frame, timeScale);
    }
    _manageGlimmer(s) {
        if (!s.upwardTracerEnabled || s.upwardTracerChance <= 0) return;
        // 1. Calculate Active Density per Column
        const colCounts = new Uint8Array(this.grid.cols);
        for (let i = 0; i < this.activeStreams.length; i++) {
            const stream = this.activeStreams[i];
            if (stream.isUpward && stream.active) {
                colCounts[stream.x]++;
            }
        }
        // 2. Determine Density Limit (1, 2, or 3)
        const limit = Math.ceil(s.upwardTracerChance * 3.0);
        // 3. Spawn Logic
        // Since this runs every frame, we use a low probability to fill gaps organically.
        const spawnChance = 0.05; 
        const columns = this._columnsPool;
        // Shuffle for random distribution
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (colCounts[col] < limit) {
                if (Math.random() < spawnChance) {
                    this._spawnUpwardTracerAt(col);
                    return; // Prevent clustering: Max 1 spawn per frame
                }
            }
        }
    }
    _spawnStreams(s, d) {
        const columns = this._columnsPool;
        // Fisher-Yates Shuffle
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
            }
            const lastStream = this.lastStreamInColumn[col];
            // Resolve Speed for this column (Chain Consistency)
            let colSpeed = this.columnSpeeds[col];
            // Only generate a new speed if the column is completely empty of active streams
            if (this.streamsPerColumn[col] === 0) {
                // New chain, new random speed
                colSpeed = this._generateSpeed(s);
                this.columnSpeeds[col] = colSpeed;
            }
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true, colSpeed);
                eraserCount--;
                continue; 
            } 
            if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false, colSpeed);
                streamCount--;
                // Cluster Logic: 10-20% chance to spawn a neighbor
                if (s.preferClusters && streamCount > 0 && Math.random() < 0.15) {
                    // Try Right Neighbor (wrapping handled by modulo if needed, but here we just clamp)
                    const neighbor = col + 1;
                    if (neighbor < this.grid.cols) {
                        const idxN = this.grid.getIndex(neighbor, 0);
                        let blockedN = false;
                        if (idxN !== -1 && this.grid.decays[idxN] > 0) blockedN = true;
                        const lastStreamN = this.lastStreamInColumn[neighbor];
                        // Resolve Neighbor Speed
                        let neighborSpeed = this.columnSpeeds[neighbor];
                        if (!lastStreamN || !lastStreamN.active) {
                            neighborSpeed = this._generateSpeed(s);
                            this.columnSpeeds[neighbor] = neighborSpeed;
                        }
                        if (!blockedN && this._canSpawnTracer(lastStreamN, s.minStreamGap, s.minGapTypes)) {
                            this._spawnStreamAt(neighbor, false, neighborSpeed);
                            streamCount--;
                        }
                    }
                }
                continue; 
            }
        }
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        if (!lastStream || !lastStream.active) return true;
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastStream = this.lastStreamInColumn[col];
        // Prevent spawning an eraser if the column is empty or the last spawn was already an eraser.
        if (!lastStream || lastStream.isEraser) return false;
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        if (lastStream.active) {
            if (this.config.state.allowTinyStreams) {
                const s = this.config.state;
                const tinyGap = s.tracerAttackFrames + s.tracerHoldFrames + s.tracerReleaseFrames + 3;
                if (lastStream.y <= tinyGap) return false;
            } else {
                if (lastStream.y <= minGapTypes) return false;
            }
        }
        return true;
    }
    _processActiveStreams(frame, timeScale) {
        const grid = this.grid;
        const rows = grid.rows;
        const cellLocks = grid.cellLocks;
        const decays = grid.decays;
        // --- MASS EXTINCTION WATCHDOG ---
        if (this.activeStreams.length > 50) {
            this._lastHighCount = this.activeStreams.length;
        }
        const prevCount = this.activeStreams.length;
        // --------------------------------
        if (Math.abs(timeScale) < 0.01) return;
        const isReverse = timeScale < 0;
        const speedMult = Math.abs(timeScale);
                for (let i = this.activeStreams.length - 1; i >= 0; i--) {
                    const stream = this.activeStreams[i];
                    if (!stream.active) {
                        if (this.streamsPerColumn[stream.x] > 0) this.streamsPerColumn[stream.x]--;
                        this.activeStreams.splice(i, 1);
                        continue;
                    }
            const headIdx = grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && cellLocks && cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.tickTimer -= speedMult;
            if (stream.tickTimer > 0) {
                continue; 
            }
            stream.tickTimer = stream.tickInterval;
            // Handle Upward Tracers (Scanners)
            if (stream.isUpward) {
                if (isReverse) {
                    stream.y++; // Move down in reverse
                    if (stream.y > rows + 5) {
                        stream.active = false;
                        continue;
                    }
                } else {
                    stream.y--; // Move up in forward
                    if (stream.y < -5) {
                        stream.active = false;
                        continue;
                    }
                }
                this._writeHead(stream, frame);
                continue; 
            }
            if (isReverse) {
                stream.y--;
                // REWIND LOGIC: Clear the "future" (the cell we just left, which was stream.y + 1)
                // This creates the effect of the stream being sucked back up.
                const oldHeadY = stream.y + 1;
                if (oldHeadY < rows) {
                    const oldIdx = grid.getIndex(stream.x, oldHeadY);
                    if (oldIdx !== -1) {
                         grid.clearCell(oldIdx);
                    }
                }
                if (stream.y < -5) {
                    stream.active = false;
                    continue;
                }
                this._writeHead(stream, frame);
            } else {
                // Drop-off logic
                if (stream.isEraser) {
                    const stopChance = this.config.state.eraserStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                } else {                    
                    const stopChance = this.config.state.tracerStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                    // In 3D mode, ignore collision with existing trails to allow high density
                    // 3D mode is gone, but we keep this check for future modes
                    const nextY = stream.y + 1;
                    if (nextY < rows) {
                        const nextIdx = grid.getIndex(stream.x, nextY);
                        if (nextIdx !== -1 && decays[nextIdx] > 0) {
                            stream.active = false;
                            continue; 
                        }
                    }
                } 
                stream.age++;
                if (stream.age >= stream.visibleLen) {
                    this._handleStreamCompletion(stream);
                    continue;
                }
                if (stream.y < stream.len) {
                    // Debug: Clean up previous eraser position to prevent trails
                    if (stream.isEraser && this.config.state.highlightErasers) {
                        const prevIdx = grid.getIndex(stream.x, stream.y);
                        if (prevIdx !== -1) grid.clearEffectOverride(prevIdx);
                    }
                    stream.y++;
                    this._writeHead(stream, frame);
                }
            }
        }
        // --- WATCHDOG CHECK ---
        // If count dropped to 0 from a healthy state in one frame (or close to it)
        if (prevCount > 20 && this.activeStreams.length === 0 && this.config.state.logErrors) {
            console.error(`[StreamManager] MASS EXTINCTION DETECTED! Streams dropped from ${prevCount} to 0 in one frame.`);
            console.trace(); // Log stack to see who called update() or if this logic caused it
            // Log Config State to see if a kill-switch was hit
            console.log("Config State at Extinction:", JSON.parse(JSON.stringify(this.config.state)));
            // Attempt to diagnose "Natural" vs "Forced"
            // If they died in the loop above, it's natural (age/collision).
            // But ALL of them?
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        const autoErase = this.config.state.autoEraserEnabled !== false;
        // Prevent auto-eraser if an eraser is already running in this column
        const last = this.lastStreamInColumn[stream.x];
        const isBlocked = last && last !== stream && last.active && last.isEraser;
        if (!stream.isEraser && autoErase && !isBlocked) {
            this._spawnStreamAt(stream.x, true, stream.tickInterval);
        }
    }
    _spawnStreamAt(x, forceEraser, forcedSpeed) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s, forcedSpeed);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _generateSpeed(s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        if (s.desyncIntensity > 0) {
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            return Math.max(1, baseTick + offset);
        }
        return baseTick;
    }
    recalculateSpeeds() {
        const s = this.config.state;
        for (let col = 0; col < this.grid.cols; col++) {
            const newSpeed = this._generateSpeed(s);
            this.columnSpeeds[col] = newSpeed;
        }
        // Update active streams to match new column speeds immediately
        for (const stream of this.activeStreams) {
            if (stream.x >= 0 && stream.x < this.columnSpeeds.length) {
                stream.tickInterval = this.columnSpeeds[stream.x];
            }
        }
    }
    _initializeStream(x, forceEraser, s, forcedSpeed) {
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        let tickInterval = forcedSpeed;
        // Enforce Column Speed Consistency
        // If the column has an assigned speed, strictly use it to ensure Tracers and Erasers remain synchronized
        if (this.columnSpeeds[x] > 0) {
            tickInterval = this.columnSpeeds[x];
        }
        if (!tickInterval) {
            tickInterval = this._generateSpeed(s);
            // Ensure this new speed is recorded for the column
            this.columnSpeeds[x] = tickInterval;
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsUint32?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval,
            tickTimer: 0
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        // Erasers should always finish their job of clearing the column.
        // We ignore scale here to ensure they reach the bottom regardless of tracer settings.
        stream.visibleLen = (stream.len + 2) * stream.tickInterval; 
        return stream;
    }
    _initializeTracerStream(stream, s) {
        stream.len = this.grid.rows; 
        // Variable Fade Duration Logic
        stream.maxDecay = 0; 
        if (s.trailLengthVarianceEnabled) {
            const baseFade = s.decayFadeDurationFrames || 24;
            const varianceVal = s.trailLengthVariance || 0;
            // The additional length is random between [FadeSpeed, Variance]
            // Ensure bounds are valid (min <= max)
            const minAdd = baseFade;
            const maxAdd = Math.max(baseFade, varianceVal);
            const additional = Utils.randomInt(minAdd, maxAdd);
            stream.maxDecay = baseFade + additional;
        }
        const travelDuration = stream.len * stream.tickInterval;
        const scale = (s.streamVisibleLengthScale !== undefined) ? s.streamVisibleLengthScale : 1.0;
        // visibleLen = Travel Time + small buffer (5 frames)
        stream.visibleLen = (travelDuration + (5 * stream.tickInterval)) * scale;
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        stream.isGradual = s.gradualColorStreams && (Math.random() * 100 < s.gradualColorStreamsFrequency);
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    injectStream(x, y, forceEraser) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s);
        stream.y = y;
        // Approximate age based on Y
        stream.age = Math.floor(Math.max(0, y * stream.tickInterval));
        stream.tickTimer = Math.random() * stream.tickInterval;
        this.modes[stream.mode].spawn(stream);
        this.addActiveStream(stream);
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isUpward) {
            this._handleUpwardHead(idx, this.config.state);
            return;
        }
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        const decays = this.grid.decays;
        if (decays[idx] >= 2) return;
        if (decays[idx] > 0 && (this.grid.types[idx] & CELL_TYPE_MASK) !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            decays[idx] = 2;
        } else {
            this.grid.clearCell(idx);
        }
        if (this.config.state.highlightErasers) {
            // Debug: Show Eraser as Red 'W' using High Priority Effect layer (0xFF0000FF = Red)
            // This overlays the 'W' without destroying the underlying simulation state (decay/clear)
            this.grid.setHighPriorityEffect(idx, 'W', 0xFF0000FF, 1.0, 0, 0);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const s = this.config.state;
            const d = this.config.derived;
            const grid = this.grid;
            let cellType = s.rotatorEnabled && Math.random() < (s.rotatorChance / 100)
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            if (stream.isGradual) {
                cellType |= CELL_FLAGS.GRADUAL;
            }
            grid.types[idx] = cellType;
            grid.ages[idx] = 1;
            grid.decays[idx] = 1;
            // Store per-stream max decay (fade duration)
            if (grid.maxDecays) {
                grid.maxDecays[idx] = stream.maxDecay || 0; 
            }
            grid.mix[idx] = 0; // Reset Rotator/Mix Progress
            grid.renderMode[idx] = RENDER_MODE.STANDARD;
            grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = d.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const charStr = charSet[Math.floor(Math.random() * charSet.length)];
            // Resolve Color
            let colorUint32;
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                // Complex Style (Effect)
                grid.complexStyles.set(idx, style);
                // Convert style to color immediately
                if (style.h !== undefined) {
                    const rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    colorUint32 = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                } else {
                     // Fallback
                     colorUint32 = d.tracerColorUint32;
                }
            } else {
                grid.complexStyles.delete(idx);
                // Standard Color
                // colorMixType: 0 = Stream, 1 = Character
                const isPerChar = Math.random() < s.colorMixType;
                if (isPerChar || Math.random() < s.paletteBias) {
                    const pLen = d.paletteColorsUint32?.length || 1;
                    colorUint32 = d.paletteColorsUint32[Math.floor(Math.random() * pLen)];
                } else {
                    colorUint32 = d.paletteColorsUint32[stream.pIdx] || d.paletteColorsUint32[0];
                }
            }
            // Brightness / Alpha
            const b = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            grid.brightness[idx] = b;
            // Set Primary (Visual = Tracer Color initially)
            const tracerColor = d.tracerColorUint32;
            grid.setPrimary(idx, charStr, tracerColor, b, stream.fontIndex, s.tracerGlow);
            grid.baseColors[idx] = colorUint32; // Store Stream Color for fade target
            // Handle Overlap (Secondary)
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                const overlapChar = charSet[Math.floor(Math.random() * charSet.length)];
                const ovRgb = Utils.hexToRgb(s.overlapColor);
                const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
                grid.setSecondary(idx, overlapChar, ovColor, b, stream.fontIndex, s.tracerGlow);
                grid.renderMode[idx] = RENDER_MODE.OVERLAP;
            }
        } else {
            this.grid.clearCell(idx);
        }
    }
    _spawnUpwardTracerAt(x) {
        const s = this.config.state;
        const stream = this._initializeUpwardTracerStream(x, s);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastUpwardTracerInColumn[x] = stream;
    }
    _initializeUpwardTracerStream(x, s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        // Apply speed multiplier (faster scanners look better)
        const speedMult = s.upwardTracerSpeedMult || 1.5; 
        const tickInterval = Math.max(1, baseTick / speedMult);
        return {
            x,
            // Random start position: throughout screen or delayed from bottom
            y: Utils.randomInt(0, this.grid.rows + 15), 
            active: true,
            delay: 0, // Remove delay for immediate feedback
            age: 0,
            len: 1, // Conceptually length 1 head
            isUpward: true,
            visibleLen: 1000, // Long life
            mode: 'STANDARD',
            tickInterval: tickInterval,
            tickTimer: 0
        };
    }
    addActiveStream(stream) {
        if (!stream) return;
        this.activeStreams.push(stream);
        this.streamsPerColumn[stream.x]++;
        this.lastStreamInColumn[stream.x] = stream;
        if (stream.isEraser) {
            this.lastEraserInColumn[stream.x] = stream;
        } else if (stream.isUpward) {
            this.lastUpwardTracerInColumn[stream.x] = stream;
        }
    }
    _handleUpwardHead(idx, s) {
        // Only interact if the cell is ACTIVE (has a character) AND visible
        // Prevents "resurrecting" fully faded characters which looks like spawning new ones
        if (this.grid.state[idx] === CELL_STATE.ACTIVE && this.grid.alphas[idx] > 0.1) {
            // 25% chance to leave a "blank" (gap) in the glimmer trail
            if (Math.random() < 0.25) return;
            // Mark as Glimmering immediately and store lifecycle state in complexStyles
            this.grid.mix[idx] = 30.0; 
            this.grid.complexStyles.set(idx, { type: 'glimmer', age: 1 });
        }
    }
}
// --- Worker Dep: GlowSystem.js ---
class GlowSystem {
    constructor(grid) {
        this.grid = grid;
        this.sources = [];
    }
    /**
     * Adds a transient radial glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} radius - Radius in cells.
     * @param {number} intensity - Peak intensity.
     * @param {number|null} color - Tint color (Uint32).
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential', 'none'.
     */
    add(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.addRadial(x, y, radius, intensity, color, duration, decayFn);
    }
    addRadial(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.sources.push({
            type: 'radial', x, y, radius, intensity, color, 
            duration: Math.max(1, duration), 
            maxDuration: Math.max(1, duration), 
            decayFn, 
            age: 0
        });
    }
    /**
     * Adds a transient rectangular glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} width - Full Width in cells.
     * @param {number} height - Full Height in cells.
     * @param {number} intensity - Peak intensity (inside box).
     * @param {number|null} color - Tint color.
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential'.
     * @param {number} falloff - Soft edge radius outside the box (0 = hard edge).
     */
    addRect(x, y, width, height, intensity, color = null, duration = 0, decayFn = 'linear', falloff = 2) {
        this.sources.push({
            type: 'rect', x, y, w: width, h: height, falloff, intensity, color,
            duration: Math.max(1, duration),
            maxDuration: Math.max(1, duration),
            decayFn,
            age: 0
        });
    }
    update() {
        // Lifecycle Management
        for (let i = this.sources.length - 1; i >= 0; i--) {
            const s = this.sources[i];
            s.age++;
            if (s.age >= s.duration) {
                this.sources.splice(i, 1);
            }
        }
    }
    apply() {
        if (this.sources.length === 0) return;
        const grid = this.grid;
        const cols = grid.cols;
        const rows = grid.rows;
        const gEnvGlows = grid.envGlows;
        const gColors = grid.colors;
        for (const s of this.sources) {
            // Calculate lifecycle intensity
            let currentIntensity = s.intensity;
            if (s.decayFn === 'linear') {
                currentIntensity *= 1.0 - (s.age / s.maxDuration);
            } else if (s.decayFn === 'exponential') {
                const prog = s.age / s.maxDuration;
                currentIntensity *= (1.0 - (prog * prog));
            }
            if (currentIntensity <= 0.01) continue;
            // Determine Bounds
            let minX, maxX, minY, maxY;
            if (s.type === 'rect') {
                const halfW = s.w / 2;
                const halfH = s.h / 2;
                const margin = s.falloff;
                minX = Math.floor(s.x - halfW - margin);
                maxX = Math.ceil(s.x + halfW + margin);
                minY = Math.floor(s.y - halfH - margin);
                maxY = Math.ceil(s.y + halfH + margin);
            } else {
                // Radial
                const r = s.radius;
                minX = Math.floor(s.x - r);
                maxX = Math.ceil(s.x + r);
                minY = Math.floor(s.y - r);
                maxY = Math.ceil(s.y + r);
            }
            // Clamp to grid
            minX = Math.max(0, minX); maxX = Math.min(cols - 1, maxX);
            minY = Math.max(0, minY); maxY = Math.min(rows - 1, maxY);
            for (let cy = minY; cy <= maxY; cy++) {
                for (let cx = minX; cx <= maxX; cx++) {
                    const idx = cy * cols + cx;
                    if (grid.state[idx] === 0) continue; 
                    let boost = 0;
                    if (s.type === 'rect') {
                        // Signed Distance Field logic for Box
                        // distance from center relative to half-size
                        const dx = Math.abs(cx - s.x) - (s.w / 2);
                        const dy = Math.abs(cy - s.y) - (s.h / 2);
                        // dist > 0 means outside. dist <= 0 means inside.
                        // We only care about outside distance for falloff.
                        // Inside is full intensity.
                        const outsideDist = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
                        if (outsideDist <= 0) {
                            boost = currentIntensity; // Inside box
                        } else if (outsideDist < s.falloff) {
                            // Fade out
                            boost = currentIntensity * (1.0 - (outsideDist / s.falloff));
                        }
                    } else {
                        // Radial
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < s.radius) {
                            boost = currentIntensity * (1.0 - (dist / s.radius));
                        }
                    }
                    if (boost > 0.01) {
                        gEnvGlows[idx] += boost;
                        if (s.color !== null) {
                            const blendFactor = Math.min(1.0, boost * 0.5);
                            const cur = gColors[idx];
                            const cR = cur & 0xFF;
                            const cG = (cur >> 8) & 0xFF;
                            const cB = (cur >> 16) & 0xFF;
                            const sR = s.color & 0xFF;
                            const sG = (s.color >> 8) & 0xFF;
                            const sB = (s.color >> 16) & 0xFF;
                            const nR = cR + (sR - cR) * blendFactor;
                            const nG = cG + (sG - cG) * blendFactor;
                            const nB = cB + (sB - cB) * blendFactor;
                            const nA = (cur >> 24) & 0xFF;
                            gColors[idx] = ((nA & 0xFF) << 24) | ((Math.floor(nB) & 0xFF) << 16) | ((Math.floor(nG) & 0xFF) << 8) | (Math.floor(nR) & 0xFF);
                        }
                    }
                }
            }
        }
    }
}
// --- SimulationWorker.js ---
// =========================================================================
// SIMULATION WORKER
// =========================================================================
// Handles physics/simulation logic in a separate thread.
// 1. Import Dependencies (Synchronous in Workers)
// 2. Global State
let grid = null;
let streamManager = null;
let glowSystem = null;
let config = { 
    state: {}, 
    derived: {} 
}; 
// Mock ConfigurationManager interface for StreamManager
const configManagerMock = {
    get state() { return config.state; },
    get derived() { return config.derived; }
};
// 3. Simulation System (Simplified for Worker)
class WorkerSimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.streamManager = new StreamManager(grid, config);
        this.glowSystem = new GlowSystem(grid);
        this.grid.glowSystem = this.glowSystem;
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.timeScale = 1.0;
        this.rotatorSpeedMap = new Float32Array(60);
        for (let i = 0; i < 60; i++) {
            this.rotatorSpeedMap[i] = 0.5 + Math.random() * 2.5; 
        }
    }
    update(frame) {
        this.streamManager.update(frame, this.timeScale);
        this._manageOverlapGrid(frame);
        this._updateCells(frame, this.timeScale);
        // Glimmer Lifecycles (Refactored to method)
        this._updateGlimmerLifecycle();
        // Apply Glows
        if (this.grid.envGlows) this.grid.envGlows.fill(0);
        this.glowSystem.update();
        this.glowSystem.apply();
        if (this.grid.cellLocks) {
            this.grid.cellLocks.fill(0);
        }
    }
    _updateGlimmerLifecycle() {
        const s = this.config.state;
        const d = this.config.derived;
        // Glimmer Speed now controls the shader animation (blink/shimmer), not character rotation.
        // We iterate over a copy of keys to safely mutate the map during iteration (for movement)
        const indices = Array.from(this.grid.complexStyles.keys());
        for (const idx of indices) {
            const style = this.grid.complexStyles.get(idx);
            if (!style || style.type !== 'glimmer') continue;
            // Initialize Mobility (One-time)
            if (style.mobile === undefined) {
                // 20% chance to be a "Moving" glimmer
                if (Math.random() < 0.2) {
                    style.mobile = true;
                    // Move every 4-8 frames
                    style.moveInterval = Utils.randomInt(4, 8);
                    style.nextMove = style.age + style.moveInterval;
                    style.moveDir = -1; 
                } else {
                    style.mobile = false;
                }
            }
            const attack = s.upwardTracerAttackFrames;
            const hold = s.upwardTracerHoldFrames;
            const release = s.upwardTracerReleaseFrames;
            const totalDuration = attack + hold + release;
            style.age++;
            const activeAge = style.age - 1;
            // --- Vertical Movement Logic ---
            let currentIdx = idx;
            if (style.mobile && activeAge >= style.nextMove && activeAge < totalDuration) {
                const col = currentIdx % this.grid.cols;
                const row = Math.floor(currentIdx / this.grid.cols);
                const nextRow = row + style.moveDir;
                if (nextRow >= 0 && nextRow < this.grid.rows) {
                    const nextIdx = currentIdx + (style.moveDir * this.grid.cols);
                    if (!this.grid.complexStyles.has(nextIdx)) {
                        // Move State
                        this.grid.complexStyles.set(nextIdx, style);
                        this.grid.complexStyles.delete(currentIdx);
                        // Move Mix Value
                        this.grid.mix[nextIdx] = this.grid.mix[currentIdx];
                        this.grid.mix[currentIdx] = 0;
                        // Move Effect Char
                        this.grid.effectChars[nextIdx] = this.grid.effectChars[currentIdx];
                        this.grid.effectChars[currentIdx] = 0;
                        currentIdx = nextIdx;
                        style.nextMove = activeAge + style.moveInterval;
                    }
                }
            }
            // Ensure we use the underlying character
            this.grid.effectChars[currentIdx] = 0;
            // --- Lifecycle / Fade Logic ---
            let alpha = 0.0;
            if (activeAge <= attack) {
                alpha = (attack > 0) ? (activeAge / attack) : 1.0;
            } else if (activeAge <= attack + hold) {
                alpha = 1.0;
            } else if (activeAge <= totalDuration) {
                const releaseAge = activeAge - (attack + hold);
                alpha = (release > 0) ? (1.0 - (releaseAge / release)) : 0.0;
            }
            if (activeAge <= totalDuration) {
                this.grid.mix[currentIdx] = 30.0 + alpha;
            } else {
                this.grid.mix[currentIdx] = 0;
                this.grid.complexStyles.delete(currentIdx);
            }
        }
    }
    // Copied from SimulationSystem.js (Logic is identical)
    _manageOverlapGrid(frame) {
        const s = this.config.state;
        if (!s.overlapEnabled) {
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                if (this.grid.secondaryChars && typeof this.grid.secondaryChars.fill === 'function') {
                    this.grid.secondaryChars.fill(32); 
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = s.overlapDensity;
        const ovRgb = Utils.hexToRgb(s.overlapColor);
        const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
        const setOverlapChar = (i) => {
            let fIdx;
            if ((this.grid.types[i] & CELL_TYPE_MASK) === CELL_TYPE.EMPTY) {
                fIdx = Math.floor(Math.random() * numFonts);
            } else {
                fIdx = this.grid.fontIndices[i];
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            let code = 32;
            if (chars && chars.length > 0) {
                const r = Math.floor(Math.random() * chars.length);
                code = chars[r].charCodeAt(0);
            }
            this.grid.secondaryChars[i] = code;
            this.grid.secondaryColors[i] = ovColor;
        };
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            const N = this.grid.secondaryChars.length;
            for (let i = 0; i < N; i++) {
                if (this.grid.overrideActive[i] !== 0) continue;
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.secondaryChars[i] = 32; 
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _updateCells(frame, timeScale = 1.0) {
        if (timeScale <= 0) return;
        if (timeScale < 1.0) {
            if (Math.random() > timeScale) return;
        }
        const s = this.config.state;
        const d = this.config.derived;
        const grid = this.grid;
        for (const idx of grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const grid = this.grid;
        if (grid.cellLocks && grid.cellLocks[idx] === 1) return;
        if (grid.overrideActive[idx] !== 0) return;
        const decay = grid.decays[idx];
        if (decay === 0) return;
        let age = grid.ages[idx];
        if (age > 0) {
            age = age + 1;
            grid.ages[idx] = age;
        }
        const type = grid.types[idx];
        const baseType = type & CELL_TYPE_MASK;
        const isGradual = (type & CELL_FLAGS.GRADUAL) !== 0;
        const isTracer = (baseType === CELL_TYPE.TRACER || baseType === CELL_TYPE.ROTATOR);
        const isUpward = (baseType === CELL_TYPE.UPWARD_TRACER);
        if (decay < 2 && isTracer) {
            const attack = s.tracerAttackFrames;
            const hold = s.tracerHoldFrames;
            const release = s.tracerReleaseFrames;
            const targetGlow = s.tracerGlow;
            const tracerColor = d.tracerColorUint32;
            const baseColor = grid.baseColors[idx];
            let ratio = 0; 
            const activeAge = age - 1;
            if (isGradual && !isUpward) {
                const fadeStart = attack + hold;
                const fadeLen = 45.0; 
                if (activeAge > fadeStart) {
                    ratio = Math.min(1.0, (activeAge - fadeStart) / fadeLen);
                }
            } else {
                if (activeAge > attack + hold) {
                    if (release > 0) {
                        ratio = Math.min(1.0, (activeAge - (attack + hold)) / release);
                    } else {
                        ratio = 1.0;
                    }
                }
            }
            if (ratio >= 1.0) {
                grid.colors[idx] = baseColor;
                grid.glows[idx] = 0; 
                if (grid.mix[idx] >= 2.0) grid.mix[idx] = 0; 
            } else if (ratio > 0) {
                const tR = tracerColor & 0xFF;
                const tG = (tracerColor >> 8) & 0xFF;
                const tB = (tracerColor >> 16) & 0xFF;
                const bR = baseColor & 0xFF;
                const bG = (baseColor >> 8) & 0xFF;
                const bB = (baseColor >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * ratio);
                const mG = Math.floor(tG + (bG - tG) * ratio);
                const mB = Math.floor(tB + (bB - tB) * ratio);
                grid.colors[idx] = Utils.packAbgr(mR, mG, mB);
                if (isGradual && !isUpward) {
                    grid.glows[idx] = 0;
                } else {
                    grid.glows[idx] = targetGlow * (1.0 - ratio);
                }
            } else {
                grid.colors[idx] = tracerColor;
                grid.glows[idx] = targetGlow;
            }
        }
        if ((s.rotatorEnabled || grid.mix[idx] > 0) && baseType === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        if (grid.complexStyles.has(idx)) {
            const style = grid.complexStyles.get(idx);
            if (style.cycle) {
                const newHue = (style.h + style.speed) % 360;
                style.h = newHue; 
                const rgb = Utils.hslToRgb(newHue, style.s, style.l);
                grid.colors[idx] = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
            }
        }
        if (decay >= 2) {
            let useBase = true;
            if (grid.complexStyles.has(idx)) {
                const style = grid.complexStyles.get(idx);
                if (style.cycle) useBase = false;
            }
            if (useBase) {
                 grid.colors[idx] = grid.baseColors[idx];
                 grid.glows[idx] = 0;
            } else {
                grid.glows[idx] = 0;
            }
            grid.decays[idx]++;
            const newDecay = grid.decays[idx];
            // Use per-cell max decay if set, otherwise use global config
            const maxFade = (grid.maxDecays && grid.maxDecays[idx] > 0) ? grid.maxDecays[idx] : s.decayFadeDurationFrames;
            if (newDecay > maxFade + 2) {
                grid.clearCell(idx);
                return;
            }
            grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, maxFade);
        } else {
            const maxFade = (grid.maxDecays && grid.maxDecays[idx] > 0) ? grid.maxDecays[idx] : s.decayFadeDurationFrames;
            grid.alphas[idx] = this._calculateAlpha(idx, age, decay, maxFade);
        }
        // Run Glimmer Lifecycle (Rotation/Fade)
        this._updateGlimmerLifecycle();
    }
    _handleRotator(idx, frame, s, d) {
        const grid = this.grid;
        const mix = grid.mix[idx]; 
        const decay = grid.decays[idx];
        if (mix > 0) {
            const step = 1.0 / Math.max(1, s.rotatorCrossfadeFrames);
            const newMix = mix + step;
            if (newMix >= 1.0) {
                const target = grid.getRotatorTarget(idx, false); 
                if (target) {
                    grid.chars[idx] = target.charCodeAt(0);
                    if (s.overlapEnabled) {
                        const ovTarget = grid.getRotatorTarget(idx, true);
                        if (ovTarget) grid.secondaryChars[idx] = ovTarget.charCodeAt(0);
                    }
                }
                grid.mix[idx] = 0;
                grid.nextChars[idx] = 0;
                grid.nextOverlapChars[idx] = 0;
            } else {
                grid.mix[idx] = newMix;
            }
        } else if (s.rotatorEnabled && (decay === 1 || (s.rotateDuringFade && decay > 1))) {
            let effectiveCycle = d.rotatorCycleFrames;
            if (s.rotatorRandomSpeedEnabled) {
                const approxRotationCount = Math.floor(frame / (d.rotatorCycleFrames * 1.5));
                const speedIdx = (approxRotationCount + grid.rotatorOffsets[idx]) % 60;
                effectiveCycle = Math.round(d.rotatorCycleFrames * this.rotatorSpeedMap[speedIdx]);
            } else if (s.rotatorDesyncEnabled) {
                const variancePercent = s.rotatorDesyncVariance / 100;
                const maxVariance = d.rotatorCycleFrames * variancePercent;
                const offsetNorm = (grid.rotatorOffsets[idx] / 127.5) - 1.0;
                effectiveCycle = Math.max(1, Math.round(d.rotatorCycleFrames + (offsetNorm * maxVariance)));
            }
            effectiveCycle = Math.max(1, effectiveCycle);
            if (frame % effectiveCycle === 0) {
                const fontIdx = grid.fontIndices[idx];
                const activeFonts = this.config.derived.activeFonts;
                const fontData = activeFonts[fontIdx] || activeFonts[0];
                const charSet = fontData.chars;
                const nextChar = Utils.getUniqueChar(grid.getChar(idx), charSet); // Use Utils directly
                // Note: Utils.getUniqueChar takes (exclude, charSet) but Utils signature is (exclude) because Utils.CHARS is default.
                let nextCode = 32;
                if (nextChar) nextCode = nextChar.charCodeAt(0);
                else {
                    // Fallback
                     const r = Math.floor(Math.random() * charSet.length);
                     nextCode = charSet[r].charCodeAt(0);
                }
                let nextOvCode = 0;
                if (s.overlapEnabled) {
                    const r2 = Math.floor(Math.random() * charSet.length);
                    nextOvCode = charSet[r2].charCodeAt(0);
                }
                if (s.rotatorCrossfadeFrames <= 1) {
                    grid.chars[idx] = nextCode;
                    if (nextOvCode) grid.secondaryChars[idx] = nextOvCode;
                } else {
                    grid.mix[idx] = 0.01; 
                    grid.setRotatorTarget(idx, String.fromCharCode(nextCode), false);
                    if (nextOvCode) {
                        grid.setRotatorTarget(idx, String.fromCharCode(nextOvCode), true);
                    }
                }
            }
        }
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        const s = this.config.state;
        const b = this.grid.brightness[idx];
        if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            const fade = Math.pow(Math.max(0, 1.0 - ratio), 2.0);
            return 0.95 * fade * b;
        }
        let attack = s.tracerAttackFrames;
        if ((this.grid.types[idx] & CELL_TYPE_MASK) === CELL_TYPE.UPWARD_TRACER) {
            attack = s.upwardTracerAttackFrames;
        }
        if (age <= attack && attack > 0) {
            return 0.95 * (age / attack) * b;
        }
        return 0.95 * b;
    }
}
let simSystem = null;
// 4. Message Handler
self.onmessage = function(e) {
    const msg = e.data;
    switch(msg.type) {
        case 'init':
            // 1. Setup Config
            config.state = msg.config.state;
            config.derived = msg.config.derived;
            // 2. Setup Grid with Shared Buffers
            grid = new CellGrid(configManagerMock);
            // Reconstruct Views
            grid.resize(msg.width, msg.height, msg.buffers);
            // 3. Setup Simulation
            simSystem = new WorkerSimulationSystem(grid, configManagerMock);
            // console.log("[SimulationWorker] Initialized");
            break;
        case 'config':
            config.state = msg.config.state;
            config.derived = msg.config.derived;
            // Handle resizes if necessary?
            // Usually init handles resize via buffer swap, but dynamic resize sends 'init' again?
            // If just config tweak, we update state.
            break;
        case 'resize':
             // Re-bind buffers if they changed
             if (grid) {
                 config.state = msg.config.state; // Ensure latest state for resize calc
                 config.derived = msg.config.derived;
                 grid.resize(msg.width, msg.height, msg.buffers);
                 if (simSystem) simSystem.streamManager.resize(grid.cols);
             }
             break;
        case 'replace_state':
            console.log("[SimulationWorker] Received replace_state request");
            if (simSystem && msg.state) {
                const sm = simSystem.streamManager;
                const s = msg.state;
                // Rehydrate Active Streams (Array -> Set for holes)
                // Note: The objects in s.activeStreams are clones created by postMessage.
                // We modify them in place to restore functionality.
                const rehydratedStreams = (s.activeStreams || []).map(st => {
                     if (Array.isArray(st.holes)) {
                         st.holes = new Set(st.holes);
                     }
                     return st;
                });
                sm.activeStreams = rehydratedStreams;
                sm.nextSpawnFrame = s.nextSpawnFrame || 0;
                // Typed Arrays need explicit copy if not shared (passed as ArrayBuffer usually)
                if (s.columnSpeeds) sm.columnSpeeds = new Float32Array(s.columnSpeeds);
                // Reconstruct Column References
                if (s.lastStreamInColumn) sm.lastStreamInColumn = s.lastStreamInColumn;
                if (s.lastEraserInColumn) sm.lastEraserInColumn = s.lastEraserInColumn;
                if (s.lastUpwardTracerInColumn) sm.lastUpwardTracerInColumn = s.lastUpwardTracerInColumn;
                // Sync Overlap State
                if (s.overlapInitialized !== undefined) simSystem.overlapInitialized = s.overlapInitialized;
                if (s._lastOverlapDensity !== undefined) simSystem._lastOverlapDensity = s._lastOverlapDensity;
                // Sync Streams Per Column (Critical for speed logic)
                if (s.streamsPerColumn && sm.streamsPerColumn) {
                    sm.streamsPerColumn.set(s.streamsPerColumn);
                }
                // Clear Cell Locks to prevent stuck streams/rotators from Shadow World blocking Main World
                if (grid.cellLocks) {
                    grid.cellLocks.fill(0);
                }
                // Sync Complex Styles (Glimmer/Upward Tracers)
                if (s.complexStyles && Array.isArray(s.complexStyles)) {
                    simSystem.grid.complexStyles.clear();
                    for (const [key, value] of s.complexStyles) {
                        simSystem.grid.complexStyles.set(key, value);
                    }
                }
                // We prefer the explicit list sent from main thread to avoid SAB race conditions.
                if (grid && grid.state) {
                    grid.activeIndices.clear();
                    if (s.activeIndices && Array.isArray(s.activeIndices)) {
                        for (const idx of s.activeIndices) {
                            grid.activeIndices.add(idx);
                        }
                        console.log(`[SimulationWorker] Replaced activeIndices with ${s.activeIndices.length} entries.`);
                    } else {
                        // Fallback: Scan SAB (May be risky if not propagated)
                        console.warn("[SimulationWorker] activeIndices missing in replace_state! Scanning SAB...");
                        const total = grid.cols * grid.rows;
                        for(let i=0; i<total; i++) {
                            if (grid.state[i] === 1) { // CELL_STATE.ACTIVE
                                grid.activeIndices.add(i);
                            }
                        }
                        console.log(`[SimulationWorker] Scanned ${grid.activeIndices.size} active cells.`);
                    }
                }
                console.log("[SimulationWorker] State Swap Complete.");
            }
            break;
        case 'update':
            if (simSystem) {
                simSystem.update(msg.frame);
                // No need to post back data, it's in SharedArrayBuffer
            }
            break;
    }
};
</script>
<script>
// --- Utils.js ---
// =========================================================================
// CORE UTILITIES / CONSTANTS
// =========================================================================
const APP_VERSION = "8.5";
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a color string (Hex "#RRGGBB" or "rgb(r,g,b)") to an { r, g, b } object.
     * @param {string} input - The color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (input) => {
        if (typeof input !== "string") return { r: 0, g: 255, b: 0 };
        // Handle Hex (6 or 8 digits)
        const hexMatch = input.match(/^#?([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/);
        if (hexMatch) {
            const value = parseInt(hexMatch[1], 16);
            return {
                r: (value >> 16) & 0xFF,
                g: (value >> 8) & 0xFF,
                b: value & 0xFF
            };
        }
        // Handle RGB / RGBA
        const match = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            return {
                r: parseInt(match[1], 10),
                g: parseInt(match[2], 10),
                b: parseInt(match[3], 10)
            };
        }
        // Fallback
        return { r: 0, g: 255, b: 0 }; 
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Packs RGB components into a single 32-bit integer (0xAABBGGRR) for Little Endian (RR GG BB AA in memory).
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @param {number} a - Alpha (0-255), defaults to 255.
     * @returns {number} The packed 32-bit integer.
     */
    packAbgr: (r, g, b, a = 255) => {
        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
    },
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: '',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Shuffles an array in place using the Fisher-Yates algorithm.
     * @param {Array} array - The array to shuffle.
     * @returns {Array} The shuffled array.
     */
    shuffle: (array) => {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3,
    UPWARD_TRACER: 4
};
const CELL_TYPE_MASK = 0x7F; // 127
const CELL_FLAGS = {
    GRADUAL: 0x80 // 128
};
// --- ConfigurationManager.js ---
class ConfigurationManager {
    constructor() {
        this.storageKey = 'matrix_config_v8.5';
        this.slotsKey = 'matrix_slots_v8.5';
        this.defaults = this._initializeDefaults();
        this.state = { ...this.defaults };
        this.derived = {};
        this.slots = this._loadSlots();
        this.subscribers = [];
        this._previousSmoothingEnabled = undefined;
        this._previousSmoothingAmount = undefined;
        // Define keys that are shared across all profiles (Global Settings)
        this.SHARED_KEYS = new Set([
            'showFpsCounter',
            'debugEnabled',
            'highlightErasers',
            'logErrors',
            'enableKeybinds',
            'keyBindings',
            'hideMenuIcon',
            'doubleClickToReset',
            'suppressToasts',
            'renderingEngine',
            // 'savedPresets' is handled by this.slots
        ]);
        // Keys that affect derived values (safe superset to ensure correctness)
        this._derivedKeys = new Set([
            'streamSpeed',
            'horizontalSpacingFactor',
            'verticalSpacingFactor',
            'rotatorSyncToTracer',
            'rotatorSyncMultiplier',
            'rotatorCycleFactor',
            'tracerAttackFrames',
            'tracerReleaseFrames',
            'tracerHoldFrames',
            'fontSize',
            'brightnessVariance',
            'backgroundColor',
            'streamColor',
            'tracerColor',
            'streamPalette',
            'fontFamily',
            'fontWeight',
            'italicEnabled',
            'fontSettings'
        ]);
        this._loadState();
        this.updateDerivedValues();
        // Listen for changes from other windows (e.g. standalone editor)
        window.addEventListener('storage', (e) => {
            if (e.key === this.storageKey) {
                this._loadState();
                this.updateDerivedValues();
                this.notify('ALL');
            }
        });
    }
    // ====================
    // Initialization Helpers
    // ====================
    /**
     * Initializes the default configuration settings.
     * @private
     * @returns {Object} An object containing all default configuration properties.
     */
        _initializeDefaults() {
        return {
            "streamColor": "#65d778",
            "backgroundColor": "#020509",
            "streamPalette": ["#00e004", "#75ff1a"],
            "paletteBias": 0,
            "colorMixType": 0,
            "tracerColor": "#d7ffd7",
            "fontSize": 22,
            "streamSpeed": 17,
            "releaseInterval": 2,
            "resolution": 1,
            "enableGlyphAtlas": true,
            "smoothingEnabled": false,
            "smoothingAmount": 0.1,
            "showFpsCounter": false,
            "performanceMode": false,
            "debugTabEnabled": false,
            "debugEnabled": false,
            "highlightErasers": false,
            "simulationPaused": false,
            "logErrors": false,
            "fontFamily": "CustomFont_5e2697679380fc43",
            "fontWeight": "normal",
            "italicEnabled": false,
            "mirrorEnabled": false,
            "variableBrightnessEnabled": true,
            "brightnessVariance": 15,
            "overlapEnabled": false,
            "overlapColor": "#fff5b8",
            "overlapDensity": 0.3,
            "overlapTarget": "stream",
            "overlapShimmer": false,
            "dissolveEnabled": true,
            "dissolveScalePercent": -2,
            "deteriorationEnabled": true,
            "deteriorationStrength": 4,
            "enableBloom": true,
            "bloomStrength": 1,
            "bloomOpacity": 0.6,
            "tracerGlow": 6,
            "clearAlpha": 1,
            "horizontalSpacingFactor": 0.95,
            "verticalSpacingFactor": 0.95,
            "stretchX": 1,
            "stretchY": 1,
            "decayFadeDurationFrames": 25,
            "trailLengthVarianceEnabled": true,
            "trailLengthVariance": 151,
            "streamSpawnCount": 3,
            "eraserSpawnCount": 2,
            "minStreamGap": 2,
            "minEraserGap": 2,
            "minGapTypes": 30,
            "allowTinyStreams": true,
            "gradualColorStreams": true,
            "gradualColorStreamsFrequency": 60,
            "holeRate": 0,
            "desyncIntensity": 0.35,
            "preferClusters": true,
            "eraserStopChance": 0,
            "tracerStopChance": 0,
            "tracerAttackFrames": 4,
            "tracerHoldFrames": 0,
            "tracerReleaseFrames": 4,
            "invertedTracerEnabled": false,
            "invertedTracerChance": 0.1,
            "upwardTracerEnabled": false,
            "upwardTracerChance": 0.81,
            "upwardTracerAttackFrames": 2,
            "upwardTracerHoldFrames": 4,
            "upwardTracerReleaseFrames": 30,
            "upwardTracerGlow": 8,
            "upwardTracerSpeedMult": 1.3,
            "upwardTracerGlimmerSpeed": 3.15,
            "upwardTracerGlimmerSize": 5,
            "upwardTracerGlimmerFill": 5,
            "upwardTracerGlimmerGlow": 6,
            "upwardTracerGlimmerFlicker": 0.45,
            "rotatorEnabled": true,
            "rotatorChance": 100,
            "rotatorSyncToTracer": false,
            "rotatorSyncMultiplier": 0.3,
            "rotatorCycleFactor": 16,
            "rotatorCrossfadeFrames": 4,
            "rotateDuringFade": true,
            "rotatorDesyncEnabled": true,
            "rotatorDesyncVariance": 41,
            "rotatorRandomSpeedEnabled": false,
            "shaderEnabled": false,
            "customShader": null,
            "effectShader": null,
            "shaderParameter": 0.03,
            "effectParameter": 0,
            "pulseEnabled": false,
            "pulseUseTracerGlow": true,
            "pulseMovieAccurate": false,
            "pulseFrequencySeconds": 300,
            "pulseDelaySeconds": 0.7,
            "pulseDurationSeconds": 1.2,
            "pulsePreserveSpaces": true,
            "pulseIgnoreTracers": true,
            "pulseDimming": 0.2,
            "pulseBlend": false,
            "pulseWidth": 130,
            "pulseRandomPosition": true,
            "pulseInstantStart": false,
            "pulseCircular": false,
            "clearPulseEnabled": false,
            "clearPulseMovieAccurate": true,
            "clearPulseUseTracerGlow": true,
            "clearPulseFrequencySeconds": 235,
            "clearPulseDurationSeconds": 0.7,
            "clearPulsePreserveSpaces": true,
            "clearPulseBlend": false,
            "clearPulseWidth": 190,
            "clearPulseRandomPosition": true,
            "clearPulseInstantStart": false,
            "clearPulseCircular": false,
            "miniPulseEnabled": false,
            "miniPulseUseTracerGlow": true,
            "miniPulseFrequencySeconds": 300,
            "miniPulseDurationSeconds": 5,
            "miniPulsePreserveSpaces": true,
            "miniPulseThickness": 100,
            "miniPulseSpawnChance": 0.06,
            "miniPulseSpeed": 16,
            "miniPulseSize": 360,
            "quantizedPulseEnabled": false,
            "quantizedPulseFrequencySeconds": 300,
            "quantizedPulseDurationSeconds": 10,
            "quantizedPulseSpeed": 5,
            "quantizedBlockWidthCells": 4,
            "quantizedBlockHeightCells": 4,
            "quantizedPulseBorderIllumination": 1.1,
            "quantizedPulsePerimeterThickness": 0.6,
            "quantizedPulseInnerThickness": 0.6,
            "quantizedPulsePerimeterColor": "#eeff00",
            "quantizedPulseInnerColor": "#0cd709",
            "quantizedLineGfxEnabled": false,
            "quantizedLineGfxThickness": 1.0,
            "quantizedLineGfxColor": "#ffffff",
            "quantizedLineGfxIntensity": 1.0,
            "quantizedLineGfxGlow": 1.0,
            "quantizedLineGfxOffsetX": 0,
            "quantizedLineGfxOffsetY": 0,
            "quantizedLineGfxPersistence": 0.0,
            "quantizedPulseFadeInFrames": 0,
            "quantizedPulseFadeFrames": 0,
            "quantizedAddEnabled": false,
            "quantizedAddFrequencySeconds": 280,
            "quantizedAddDurationSeconds": 3.7,
            "quantizedAddBorderIllumination": 5.6,
            "quantizedAddSpeed": 5,
            "quantizedAddBlockWidthCells": 4,
            "quantizedAddBlockHeightCells": 4,
            "quantizedAddPerimeterThickness": 0.7,
            "quantizedAddInnerThickness": 0.7,
            "quantizedAddPerimeterColor": "#d4ff00",
            "quantizedAddInnerColor": "#000000",
            "quantizedAddFadeInFrames": 0,
            "quantizedAddFadeFrames": 0,
            "quantizedRetractEnabled": false,
            "quantizedRetractFrequencySeconds": 250,
            "quantizedRetractDurationSeconds": 5,
            "quantizedRetractSpeed": 4.3,
            "quantizedRetractBlockWidthCells": 4,
            "quantizedRetractBlockHeightCells": 4,
            "quantizedRetractFadeInFrames": 0,
            "quantizedRetractFadeFrames": 0,
            "quantizedRetractBorderIllumination": 5.7,
            "quantizedRetractPerimeterThickness": 0.6,
            "quantizedRetractInnerThickness": 0.6,
            "quantizedRetractPerimeterColor": "#FFD700",
            "quantizedRetractInnerColor": "#0011ff",
            "quantizedClimbEnabled": false,
            "quantizedClimbFrequencySeconds": 265,
            "quantizedClimbDurationSeconds": 3.6,
            "quantizedClimbSpeed": 5,
            "quantizedClimbBlockWidthCells": 4,
            "quantizedClimbBlockHeightCells": 4,
            "quantizedClimbFadeInFrames": 0,
            "quantizedClimbFadeFrames": 0,
            "quantizedClimbBorderIllumination": 5.4,
            "quantizedClimbPerimeterThickness": 0.5,
            "quantizedClimbInnerThickness": 0.5,
            "quantizedClimbPerimeterColor": "#e1ff00",
            "quantizedClimbInnerColor": "#027a00",
            "quantizedZoomEnabled": false,
            "quantizedZoomFrequencySeconds": 60,
            "quantizedZoomDurationSeconds": 5,
            "quantizedZoomSpeed": 1,
            "quantizedZoomExpansionRate": 1,
            "quantizedZoomZoomRate": 1,
            "quantizedZoomDelay": 0,
            "quantizedZoomHoldSeconds": 2,
            "quantizedZoomFadeInFrames": 60,
            "quantizedZoomFadeFrames": 15,
            "quantizedZoomBorderIllumination": 4,
            "quantizedZoomPerimeterThickness": 1,
            "quantizedZoomInnerThickness": 1,
            "quantizedZoomPerimeterColor": "#FFD700",
            "quantizedZoomInnerColor": "#FFD700",
            "quantizedGenerateV2Enabled": false,
            "quantizedGenerateV2EnableUnfold": false,
            "quantizedGenerateV2EnableNudge": false,
            "quantizedGenerateV2EnableRearrange": false,
            "quantizedGenerateV2EnableThicken": false,
            "quantizedGenerateV2ThickenQuadrantCount": 1,
            "quantizedGenerateV2EnableShift": false,
            "quantizedGenerateV2ShiftFrequency": 5,
            "quantizedGenerateV2ShiftMaxThickness": 5,
            "quantizedGenerateV2RearrangeFrequency": 0.5,
            "quantizedGenerateV2EnableRNGGrowth": false,
            "quantizedGenerateV2EnableSyncSubLayers": true,
            "quantizedGenerateV2EnableAutoFillHoles": true,
            "quantizedGenerateV2EnableAutoConnectIslands": true,
            "quantizedGenerateV2EnableLayerShoving": true,
            "quantizedGenerateV2EnableAxisBalancing": false,
            "quantizedGenerateV2EnableSubLayerAnchoring": false,
            "quantizedGenerateV2EnableScaledGrowth": false,
            "quantizedGenerateV2EnableEventScaling": false,
            "quantizedGenerateV2EventScalingMin": 1,
            "quantizedGenerateV2SubLayerAnchorDistance": 2,
            "quantizedGenerateV2FrequencySeconds": 240,
            "quantizedGenerateV2DurationSeconds": 7.6,
            "quantizedGenerateV2Speed": 1,
            "quantizedGenerateV2BlockWidthCells": 4,
            "quantizedGenerateV2BlockHeightCells": 4,
            "quantizedGenerateV2BorderIllumination": 4,
            "quantizedGenerateV2PerimeterThickness": 1,
            "quantizedGenerateV2InnerThickness": 1,
            "quantizedGenerateV2PerimeterColor": "#FFD700",
            "quantizedGenerateV2InnerColor": "#FFD700",
            "quantizedGenerateV2Mode": "default",
            "quantizedGenerateV2FadeInFrames": 0,
            "quantizedGenerateV2FadeFrames": 0,
            "quantizedGenerateV2LayerCount": 2,
            "quantizedGenerateV2MinBlockWidth": 1,
            "quantizedGenerateV2MaxBlockWidth": 3,
            "quantizedGenerateV2MinBlockHeight": 1,
            "quantizedGenerateV2MaxBlockHeight": 3,
            "quantizedGenerateV2SimultaneousSpawns": 3,
            "quantizedGenerateV2GreenFadeSeconds": 0.1,
            "quantizedGenerateV2MergeDelay": true,
            "quantizedPulseCleanInnerDistance": 4,
            "quantizedAddCleanInnerDistance": 4,
            "quantizedRetractCleanInnerDistance": 4,
            "quantizedClimbCleanInnerDistance": 4,
            "quantizedZoomCleanInnerDistance": 4,
            "quantizedGenerateV2CleanInnerDistance": 4,
            "quantizedPerimeterOffsetX": 0,
            "quantizedPerimeterOffsetY": 0,
            "quantizedShadowOffsetX": 0,
            "quantizedShadowOffsetY": 0,
            "quantizedSourceGridOffsetX": 0,
            "quantizedSourceGridOffsetY": 0,
            "quantizedEditorGridOffsetX": 0,
            "quantizedEditorGridOffsetY": 0,
            "quantizedEditorChangesOffsetX": 0,
            "quantizedEditorChangesOffsetY": 0,
            "quantizedLineLength": 1,
            "quantizedLineOffset": 0,
            "quantizedOffsetProfiles": {},
            "quantizedAutoAlign": false,
            "layerEnableBackground": true,
            "layerEnablePrimaryCode": true,
            "layerEnableShadowWorld": true,
            "layerEnableQuantizedLines": true,
            "layerEnableQuantizedGridCache": false,
            "layerEnableEditorGrid": true,
            "layerEnableEditorOverlay": true,
            "quantizedSolidPerimeter": false,
            "dejaVuEnabled": false,
            "dejaVuFrequencySeconds": 350,
            "dejaVuDurationSeconds": 5,
            "dejaVuMinRectHeight": 1,
            "dejaVuMaxRectHeight": 10,
            "dejaVuHoleBrightness": 0.02,
            "dejaVuRandomizeColors": false,
            "dejaVuIntensity": 0.1,
            "dejaVuBarDurationFrames": 28,
            "dejaVuVarianceFrames": 43,
            "supermanEnabled": false,
            "supermanFrequencySeconds": 290,
            "supermanDurationSeconds": 6,
            "supermanFadeSpeed": 6,
            "supermanGlow": 4,
            "supermanBoltThickness": 5,
            "supermanFlickerRate": 2,
            "supermanWidth": 4,
            "supermanSpawnSpeed": 69,
            "starPowerEnabled": false,
            "starPowerFreq": 100,
            "starPowerRainbowMode": "char",
            "starPowerSaturation": 100,
            "starPowerIntensity": 51,
            "starPowerColorCycle": true,
            "starPowerCycleSpeed": 5,
            "rainbowStreamEnabled": false,
            "rainbowStreamChance": 0.5,
            "rainbowStreamIntensity": 50,
            "bootSequenceEnabled": false,
            "crashEnabled": false,
            "crashFrequencySeconds": 300,
            "crashDurationSeconds": 30,
            "crashSheetCount": 25,
            "crashSheetSpeed": 1,
            "crashSheetOpacity": 0.5,
            "crashStationaryChance": 20,
            "crashFlashDelayMin": 3,
            "crashFlashDelayMax": 6,
            "crashEnableSmith": true,
            "crashEnableSuperman": true,
            "crashEnableFlash": true,
            "runBothInOrder": false,
            "enableKeybinds": true,
            "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "v", "BootCrashSequence": "b", "QuantizedPulse": "q", "QuantizedAdd": "a", "QuantizedRetract": "z", "QuantizedClimb": "c", "QuantizedZoom": "x", "QuantizedBlockGenerator": "g"},
            "hideMenuIcon": true,
            "doubleClickToReset": true,
            "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}},
            "deteriorationType": "ghost",
            "tracerSizeIncrease": 1,
            "supermanProb": 4,
            "dejaVuAutoMode": true,
            "clearPulseIgnoreTracers": true,
            "dejaVuPerformanceMode": false,
            "pulseDelayFrames": 60,
            "suppressToasts": false,
            "supermanIncludeColors": true,
            "renderingEngine": "canvas",
            "dissolveMinSize": 18,
            "crashMovieFps": true,
            "quantizedPulseSimultaneousSpawns": 1,
            "quantizedPulseGreenFadeSeconds": 0,
            "quantizedPulseAutoGenerateRemaining": true,
            "quantizedAddGreenFadeSeconds": 0.5,
            "quantizedAddAutoGenerateRemaining": true,
            "quantizedRetractGreenFadeSeconds": 0.5,
            "quantizedRetractAutoGenerateRemaining": true,
            "starPowerGlitter": false,
            "quantizedClimbAutoGenerateRemaining": true,
            "quantizedZoomAutoGenerateRemaining": true,
            "firewallEnabled": false,
            "firewallFrequencySeconds": 150,
            "firewallRandomColorEnabled": true,
            "firewallColor": "#00ff00",
            "firewallReverseDurationFrames": 20,
            "firewallEraseDurationFrames": 50,
            "ttlMinSeconds": 1,
            "ttlMaxSeconds": 8,
            "renderMode3D": false,
            "flySpeed": 15,
            "performanceBackup": null,
            "quantizedPulseShowInterior": true,
            "quantizedPulseBorderColor": "#FFCC00",
            "quantizedPulseInteriorColor": "#0fe628",
            "quantizedAddShowInterior": true,
            "quantizedAddBorderColor": "#002aff",
            "quantizedAddInteriorColor": "#ff0000",
            "quantizedRetractShowInterior": true,
            "quantizedRetractBorderColor": "#FFCC00",
            "quantizedRetractInteriorColor": "#FFCC00",
            "quantizedExpansionEnabled": false,
            "quantizedExpansionFrequencySeconds": 120,
            "quantizedExpansionDurationSeconds": 3,
            "quantizedExpansionFadeInFrames": 10,
            "quantizedExpansionFadeFrames": 20,
            "quantizedExpansionBorderIllumination": 4,
            "quantizedExpansionShowInterior": true,
            "quantizedExpansionBorderColor": "#FFCC00",
            "quantizedExpansionInteriorColor": "#001eff",
            "quantizedBlockGridWidth": 10,
            "quantizedBlockGridHeight": 10,
            "upwardTracerGlimmerChance": 0,
            "quantEditorEnabled": false,
            "streamVisibleLengthScale": 0.8
        };
    }
    /**
     * Deep clone utility to minimize allocations and handle future structuredClone availability.
     * @private
     */
    _deepClone(obj) {
        if (typeof structuredClone === 'function') {
            return structuredClone(obj);
        }
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * Loads configuration slots from local storage.
     * @private
     * @returns {Array<Object>} An array of slot data.
     */
    _loadSlots() {
        let loadedSlots = [];
        try {
            const storedSlots = localStorage.getItem(this.slotsKey);
            if (storedSlots) {
                loadedSlots = JSON.parse(storedSlots);
            }
        } catch (e) {
            console.warn('Failed to load slots:', e);
        }
        const defaults = [
            {
                name: "Trilogy",
                data: {
                    "streamColor": "#65d778",
                    "backgroundColor": "#000000",
                    "streamPalette": ["#00ff41"],
                    "paletteBias": 0,
                    "colorMixType": 0.45,
                    "tracerColor": "#ccffcc",
                    "fontSize": 24,
                    "streamSpeed": 17,
                    "releaseInterval": 3,
                    "resolution": 0.9,
                    "enableGlyphAtlas": true,
                    "smoothingEnabled": false,
                    "smoothingAmount": 0.1,
                    "showFpsCounter": false,
                    "debugEnabled": false,
                    "highlightErasers": false,
                    "logErrors": false,
                    "fontFamily": "MatrixEmbedded",
                    "fontWeight": "normal",
                    "italicEnabled": false,
                    "mirrorEnabled": false,
                    "variableBrightnessEnabled": true,
                    "brightnessVariance": 15,
                    "overlapEnabled": false,
                    "overlapColor": "#20cb53",
                    "overlapDensity": 0.2,
                    "overlapTarget": "stream",
                    "overlapShimmer": false,
                    "dissolveEnabled": true,
                    "dissolveScalePercent": -15,
                    "deteriorationEnabled": true,
                    "deteriorationStrength": 6,
                    "enableBloom": true,
                    "bloomStrength": 1,
                    "bloomOpacity": 0.5,
                    "tracerGlow": 5,
                    "clearAlpha": 0.72,
                    "horizontalSpacingFactor": 0.7,
                    "verticalSpacingFactor": 1,
                    "stretchX": 1,
                    "stretchY": 1.1,
                    "decayFadeDurationFrames": 15,
                    "trailLengthVarianceEnabled": false,
                    "trailLengthVariance": 60,
                    "streamSpawnCount": 7,
                    "eraserSpawnCount": 5,
                    "minStreamGap": 2,
                    "minEraserGap": 15,
                    "minGapTypes": 20,
                    "allowTinyStreams": true,
                    "gradualColorStreams": false,
                    "gradualColorStreamsFrequency": 100,
                    "holeRate": 0.1,
                    "desyncIntensity": 0,
                    "preferClusters": true,
                    "eraserStopChance": 1,
                    "tracerStopChance": 1,
                    "tracerAttackFrames": 4,
                    "tracerHoldFrames": 0,
                    "tracerReleaseFrames": 4,
                    "invertedTracerEnabled": true,
                    "invertedTracerChance": 0.07,
                    "upwardTracerEnabled": false,
                    "upwardTracerChance": 0.02,
                    "upwardTracerAttackFrames": 2,
                    "upwardTracerHoldFrames": 30,
                    "upwardTracerReleaseFrames": 30,
                    "upwardTracerGlow": 8,
                    "upwardTracerSpeedMult": 1,
                    "upwardTracerGlimmerSpeed": 2,
                    "upwardTracerGlimmerSize": 3,
                    "upwardTracerGlimmerFill": 3,
                    "upwardTracerGlimmerGlow": 10,
                    "upwardTracerGlimmerFlicker": 0.5,
                                "rotatorEnabled": true,
                                "rotatorChance": 25,
                                "rotatorSyncToTracer": true,                    "rotatorSyncMultiplier": 0.4,
                    "rotatorCycleFactor": 20,
                    "rotatorCrossfadeFrames": 6,
                    "rotateDuringFade": false,
                    "rotatorDesyncEnabled": false,
                    "rotatorDesyncVariance": 0,
                    "shaderEnabled": true,
                    "customShader": `// Name: Matrix Real-World Blue Hue
precision highp float;                    // highp for desktop; switch to mediump for mobile if needed
uniform sampler2D uTexture;
uniform vec2      uResolution;            // (width, height)
uniform float     uTime;                  // seconds
uniform vec2      uMouse;                 // normalized [0..1]
uniform float     uParameter;             // UI slider [0..1]
varying vec2      vTexCoord;
vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);
}
vec3 hsv2rgb(vec3 c){
    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}
void main() {
    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;
    vec3 hsv = rgb2hsv(rgb);
    hsv.x = mix(hsv.x, 0.55, uParameter * 0.25);    // Hue change                                       
    hsv.y = mix(hsv.y, 0.0, uParameter * 0.25);            // Saturation change
    vec3 outc = hsv2rgb(hsv);
    gl_FragColor = vec4(outc, 1.0);
}`,
                    "effectShader": null,
                    "shaderParameter": 0.69,
                    "effectParameter": 2.8,
                    "pulseEnabled": true,
                    "pulseUseTracerGlow": false,
                    "pulseMovieAccurate": true,
                    "pulseFrequencySeconds": 300,
                    "pulseDelaySeconds": 0.7,
                    "pulseDurationSeconds": 1.2,
                    "pulsePreserveSpaces": true,
                    "pulseIgnoreTracers": true,
                    "pulseDimming": 0.2,
                    "pulseBlend": false,
                    "pulseWidth": 130,
                    "pulseRandomPosition": true,
                    "pulseInstantStart": false,
                    "pulseCircular": false,
                    "clearPulseEnabled": true,
                    "clearPulseMovieAccurate": true,
                    "clearPulseUseTracerGlow": true,
                    "clearPulseFrequencySeconds": 235,
                    "clearPulseDurationSeconds": 1.1,
                    "clearPulsePreserveSpaces": true,
                    "clearPulseBlend": true,
                    "clearPulseWidth": 130,
                    "clearPulseRandomPosition": true,
                    "clearPulseInstantStart": false,
                    "clearPulseCircular": false,
                    "miniPulseEnabled": true,
                    "miniPulseUseTracerGlow": true,
                    "miniPulseFrequencySeconds": 450,
                    "miniPulseDurationSeconds": 5,
                    "miniPulsePreserveSpaces": true,
                    "miniPulseThickness": 100,
                    "miniPulseSpawnChance": 0.06,
                    "miniPulseSpeed": 16,
                    "miniPulseSize": 360,
                    "quantizedPulseEnabled": false,
                    "quantizedPulseFrequencySeconds": 240,
                    "quantizedPulseDurationSeconds": 7.6,
                    "quantizedPulseSpeed": 1,
                    "quantizedBlockWidthCells": 4,
                    "quantizedBlockHeightCells": 4,
                    "quantizedPulseBorderIllumination": 4,
                    "quantizedPulsePerimeterThickness": 1.0,
                    "quantizedPulseFadeInFrames": 0,
                    "quantizedPulseFadeFrames": 0,
                    "quantizedAddEnabled": false,
                    "quantizedAddFrequencySeconds": 300,
                    "quantizedAddDurationSeconds": 10,
                    "quantizedAddBorderIllumination": 4,
            "quantizedAddSpeed": 1,
            "quantizedAddPerimeterThickness": 1.0,
                    "quantizedAddFadeInFrames": 0,
                    "quantizedAddFadeFrames": 0,
                    "quantizedRetractEnabled": false,
                    "quantizedRetractFrequencySeconds": 60,
                    "quantizedRetractDurationSeconds": 2,
                    "quantizedRetractFadeInFrames": 5,
                    "quantizedRetractFadeFrames": 15,
                    "quantizedRetractBorderIllumination": 4,
                    "dejaVuEnabled": true,
                    "dejaVuFrequencySeconds": 350,
                    "dejaVuDurationSeconds": 5,
                    "dejaVuMinRectHeight": 1,
                    "dejaVuMaxRectHeight": 10,
                    "dejaVuHoleBrightness": 0.02,
                    "dejaVuRandomizeColors": false,
                    "dejaVuIntensity": 0.07,
                    "dejaVuBarDurationFrames": 21,
                    "dejaVuVarianceFrames": 43,
                    "supermanEnabled": true,
                    "supermanFrequencySeconds": 290,
                    "supermanDurationSeconds": 6,
                    "supermanFadeSpeed": 6,
                    "supermanGlow": 2,
                    "supermanBoltThickness": 5,
                    "supermanFlickerRate": 3,
                    "supermanWidth": 3,
                    "supermanSpawnSpeed": 69,
                    "starPowerEnabled": false,
                    "starPowerFreq": 100,
                    "starPowerRainbowMode": "char",
                    "starPowerSaturation": 100,
                    "starPowerIntensity": 51,
                    "starPowerColorCycle": true,
                    "starPowerCycleSpeed": 3,
                    "rainbowStreamEnabled": false,
                    "rainbowStreamChance": 0.5,
                    "rainbowStreamIntensity": 50,
                    "bootSequenceEnabled": false,
                    "crashEnabled": false,
                    "crashFrequencySeconds": 600,
                    "crashDurationSeconds": 30,
                    "crashSheetCount": 33,
                    "crashSheetSpeed": 1.1,
                    "crashSheetOpacity": 0.96,
                    "crashStationaryChance": 17,
                    "crashFlashDelayMin": 3,
                    "crashFlashDelayMax": 6,
                    "crashEnableSmith": true,
                    "crashEnableSuperman": true,
                    "crashEnableFlash": true,
                    "runBothInOrder": true,
                    "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c"},
                    "hideMenuIcon": true,
                    "fontSettings": {"MatrixEmbedded": {"active": true, "useCustomChars": false, "customCharacters": ""}, "CustomFont_5e2697679380fc43": {"active": false, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5", "useAllChars": false}},
                    "deteriorationType": "ghost",
                    "tracerSizeIncrease": 1,
                    "supermanProb": 4,
                    "dejaVuAutoMode": true,
                    "clearPulseIgnoreTracers": true,
                    "dejaVuPerformanceMode": false,
                    "pulseDelayFrames": 60,
                    "suppressToasts": false,
                    "supermanIncludeColors": true,
                    "renderingEngine": "canvas",
                    "dissolveMinSize": 19,
                    "crashMovieFps": true,
                    "quantizedPulseSimultaneousSpawns": 3,
                    "quantizedPulseGreenFadeSeconds": 0.1,
                    "quantizedAddGreenFadeSeconds": 0.5,
                    "quantizedRetractGreenFadeSeconds": 0.5,
                    "starPowerGlitter": false,
                    "firewallEnabled": false,
                    "firewallFrequencySeconds": 150,
                    "firewallRandomColorEnabled": true,
                    "firewallColor": "#00ff00",
                    "firewallReverseDurationFrames": 20,
                    "firewallEraseDurationFrames": 50,
                    "ttlMinSeconds": 1,
                    "ttlMaxSeconds": 8,
                    "renderMode3D": false,
                    "flySpeed": 15
                }
            },
            {
                name: "Neo Code",
                data: {
                    "streamColor": "#65d778",
                    "backgroundColor": "#000500",
                    "streamPalette": ["#00cc4e"],
                    "paletteBias": 0.5,
                    "colorMixType": 0.65,
                    "tracerColor": "#90e88d",
                    "fontSize": 28,
                    "streamSpeed": 16,
                    "releaseInterval": 1,
                    "resolution": 1,
                    "enableGlyphAtlas": true,
                    "smoothingEnabled": false,
                    "smoothingAmount": 0.1,
                    "showFpsCounter": true,
                    "debugEnabled": false,
                    "highlightErasers": false,
                    "logErrors": true,
                    "fontFamily": "CustomFont_5e2697679380fc43",
                    "fontWeight": "normal",
                    "italicEnabled": false,
                    "mirrorEnabled": false,
                    "variableBrightnessEnabled": true,
                    "brightnessVariance": 20,
                    "overlapEnabled": false,
                    "overlapColor": "#fff5b8",
                    "overlapDensity": 0.3,
                    "overlapTarget": "stream",
                    "overlapShimmer": false,
                    "dissolveEnabled": true,
                    "dissolveScalePercent": 13,
                    "deteriorationEnabled": true,
                    "deteriorationStrength": 4,
                    "enableBloom": true,
                    "bloomStrength": 2,
                    "bloomOpacity": 0.15,
                    "tracerGlow": 3,
                    "clearAlpha": 1,
                    "horizontalSpacingFactor": 1,
                    "verticalSpacingFactor": 0.95,
                    "stretchX": 0.8,
                    "stretchY": 1,
                    "decayFadeDurationFrames": 20,
                    "trailLengthVarianceEnabled": true,
                    "trailLengthVariance": 135,
                    "streamSpawnCount": 1,
                    "eraserSpawnCount": 3,
                    "minStreamGap": 6,
                    "minEraserGap": 6,
                    "allowTinyStreams": true,
                    "gradualColorStreams": true,
                    "gradualColorStreamsFrequency": 100,
                    "holeRate": 0,
                    "desyncIntensity": 0.45,
                    "preferClusters": false,
                    "eraserStopChance": 0,
                    "tracerStopChance": 0,
                    "tracerAttackFrames": 2,
                    "tracerHoldFrames": 4,
                    "tracerReleaseFrames": 0,
                    "invertedTracerEnabled": false,
                    "invertedTracerChance": 0.1,
                    "upwardTracerEnabled": false,
                    "upwardTracerChance": 0.67,
                    "upwardTracerAttackFrames": 2,
                    "upwardTracerHoldFrames": 4,
                    "upwardTracerReleaseFrames": 20,
                    "upwardTracerGlow": 8,
                    "upwardTracerSpeedMult": 1.2,
                    "upwardTracerGlimmerSpeed": 4.31,
                    "upwardTracerGlimmerSize": 5,
                    "upwardTracerGlimmerFill": 5,
                    "upwardTracerGlimmerGlow": 0,
                    "upwardTracerGlimmerFlicker": 0.5,
                                "rotatorEnabled": true,
                                "rotatorChance": 100,
                                "rotatorSyncToTracer": false,                    "rotatorSyncMultiplier": 0.3,
                    "rotatorCycleFactor": 16,
                    "rotatorCrossfadeFrames": 2,
                    "rotateDuringFade": true,
                    "rotatorDesyncEnabled": true,
                    "rotatorDesyncVariance": 41,
                    "shaderEnabled": true,
                    "customShader": `// Name: Static Grain
precision mediump float;
// Inputs provided by the application
uniform sampler2D uTexture;
uniform float uParameter;
// uniform float uTime; // NOT needed for static grain
varying vec2 vTexCoord;
// Shader Configuration
const float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable
// 1. Random function
// Generates a seemingly random float based on the input coordinate 'st'.
float random(vec2 st) {
    // This uses a "magic" dot product and large number to generate noise.
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
void main() {
    // 2. Sample the original texture
    vec4 color = texture2D(uTexture, vTexCoord);
    // 3. Calculate static noise
    // The key here is to pass only the coordinate (vTexCoord) to the random function.
    // We are NOT using 'uTime', so the result for any given coordinate is always the same.
    float noiseValue = random(vTexCoord);
    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]
    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]
    // * 2.0 expands the range to [-1.0, 1.0]
    float finalNoise = (noiseValue - 0.5) * 2.0;
    // 4. Apply grain to the color
    // We only apply the noise to the Red, Green, and Blue channels (.rgb).
    // The noise value is scaled by the GRAIN_AMOUNT.
    // A negative noise makes the pixel darker, a positive noise makes it brighter.
    color.rgb += finalNoise * (uParameter * 0.5);
    // 5. Output final color
    gl_FragColor = color;
}`,
                    "effectShader": null,
                    "shaderParameter": 0.07,
                    "effectParameter": 0,
                    "pulseEnabled": false,
                    "pulseUseTracerGlow": true,
                    "pulseMovieAccurate": false,
                    "pulseFrequencySeconds": 300,
                    "pulseDelaySeconds": 0.7,
                    "pulseDurationSeconds": 1.2,
                    "pulsePreserveSpaces": true,
                    "pulseIgnoreTracers": true,
                    "pulseDimming": 0.2,
                    "pulseBlend": false,
                    "pulseWidth": 130,
                    "pulseRandomPosition": true,
                    "pulseInstantStart": false,
                    "pulseCircular": false,
                    "clearPulseEnabled": false,
                    "clearPulseMovieAccurate": true,
                    "clearPulseUseTracerGlow": true,
                    "clearPulseFrequencySeconds": 235,
                    "clearPulseDurationSeconds": 0.7,
                    "clearPulsePreserveSpaces": true,
                    "clearPulseBlend": false,
                    "clearPulseWidth": 190,
                    "clearPulseRandomPosition": true,
                    "clearPulseInstantStart": false,
                    "clearPulseCircular": false,
                    "miniPulseEnabled": false,
                    "miniPulseUseTracerGlow": true,
                    "miniPulseFrequencySeconds": 450,
                    "miniPulseDurationSeconds": 5,
                    "miniPulsePreserveSpaces": true,
                    "miniPulseThickness": 100,
                    "miniPulseSpawnChance": 0.06,
                    "miniPulseSpeed": 16,
                    "miniPulseSize": 360,
                    "quantizedPulseEnabled": false,
                    "quantizedPulseFrequencySeconds": 40,
                    "quantizedPulseDurationSeconds": 6.5,
                    "quantizedPulseSpeed": 1,
                    "quantizedBlockWidthCells": 4,
                    "quantizedBlockHeightCells": 4,
                    "quantizedPulseBorderIllumination": 1.6,
                    "quantizedPulsePerimeterThickness": 1.0,
                    "quantizedPulseFadeInFrames": 0,
                    "quantizedPulseFadeFrames": 0,
                    "quantizedAddEnabled": false,
                    "quantizedAddFrequencySeconds": 40,
                    "quantizedAddDurationSeconds": 2,
                    "quantizedAddBorderIllumination": 4,
            "quantizedAddSpeed": 1,
            "quantizedAddPerimeterThickness": 1.0,
                    "quantizedAddFadeInFrames": 0,
                    "quantizedAddFadeFrames": 0,
                    "quantizedRetractEnabled": false,
                    "quantizedRetractFrequencySeconds": 60,
                    "quantizedRetractDurationSeconds": 2,
                    "quantizedRetractFadeInFrames": 5,
                    "quantizedRetractFadeFrames": 15,
                    "quantizedRetractBorderIllumination": 4,
                    "dejaVuEnabled": false,
                    "dejaVuFrequencySeconds": 350,
                    "dejaVuDurationSeconds": 5,
                    "dejaVuMinRectHeight": 1,
                    "dejaVuMaxRectHeight": 10,
                    "dejaVuHoleBrightness": 0.02,
                    "dejaVuRandomizeColors": false,
                    "dejaVuIntensity": 0.1,
                    "dejaVuBarDurationFrames": 28,
                    "dejaVuVarianceFrames": 43,
                    "supermanEnabled": false,
                    "supermanFrequencySeconds": 290,
                    "supermanDurationSeconds": 6,
                    "supermanFadeSpeed": 6,
                    "supermanGlow": 4,
                    "supermanBoltThickness": 5,
                    "supermanFlickerRate": 2,
                    "supermanWidth": 4,
                    "supermanSpawnSpeed": 69,
                    "starPowerEnabled": false,
                    "starPowerFreq": 100,
                    "starPowerRainbowMode": "char",
                    "starPowerSaturation": 100,
                    "starPowerIntensity": 51,
                    "starPowerColorCycle": true,
                    "starPowerCycleSpeed": 5,
                    "rainbowStreamEnabled": false,
                    "rainbowStreamChance": 0.5,
                    "rainbowStreamIntensity": 50,
                    "bootSequenceEnabled": false,
                    "crashEnabled": false,
                    "crashFrequencySeconds": 600,
                    "crashDurationSeconds": 30,
                    "crashSheetCount": 25,
                    "crashSheetSpeed": 1,
                    "crashSheetOpacity": 0.5,
                    "crashStationaryChance": 20,
                    "crashFlashDelayMin": 3,
                    "crashFlashDelayMax": 6,
                    "crashEnableSmith": true,
                    "crashEnableSuperman": true,
                    "crashEnableFlash": true,
                    "runBothInOrder": false,
                    "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c"},
                    "hideMenuIcon": true,
                    "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"'()*+-.0123456789:<=>ABCDEFGHIJKLNOPQRSTUVWXYZ^_c|Mfg", "useAllChars": false}},
                    "deteriorationType": "ghost",
                    "tracerSizeIncrease": 1,
                    "supermanProb": 4,
                    "dejaVuAutoMode": true,
                    "clearPulseIgnoreTracers": true,
                    "dejaVuPerformanceMode": false,
                    "pulseDelayFrames": 60,
                    "suppressToasts": false,
                    "supermanIncludeColors": true,
                    "renderingEngine": "canvas",
                    "dissolveMinSize": 18,
                    "crashMovieFps": true,
                    "streamLengthVarianceEnabled": true,
                                "streamLengthVariance": 100,
                                "streamVisibleLengthScale": 0.1,
                                "quantizedPulseGreenFadeSeconds": 0.2,                    "starPowerGlitter": false,
                    "firewallEnabled": false,
                    "firewallFrequencySeconds": 150,
                    "firewallRandomColorEnabled": true,
                    "firewallColor": "#00ff00",
                    "firewallReverseDurationFrames": 20,
                    "firewallEraseDurationFrames": 50,
                    "ttlMinSeconds": 1,
                    "ttlMaxSeconds": 8,
                    "renderMode3D": false,
                    "flySpeed": 15,
                    "upwardTracerGlimmerChance": 0
                }
            },
            {
                name: "Trinity",
                data: {
                    "streamColor": "#65d778",
                    "backgroundColor": "#020509",
                    "streamPalette": ["#00e004", "#00ad14", "#33ff70"],
                    "paletteBias": 1,
                    "colorMixType": 1,
                    "tracerColor": "#d7ffd7",
                    "fontSize": 24,
                    "streamSpeed": 17,
                    "releaseInterval": 3,
                    "resolution": 1,
                    "enableGlyphAtlas": true,
                    "smoothingEnabled": false,
                    "smoothingAmount": 0.1,
                    "showFpsCounter": true,
                    "debugEnabled": false,
                    "highlightErasers": false,
                    "logErrors": false,
                    "fontFamily": "CustomFont_5e2697679380fc43",
                    "fontWeight": "normal",
                    "italicEnabled": false,
                    "mirrorEnabled": false,
                    "variableBrightnessEnabled": true,
                    "brightnessVariance": 35,
                    "overlapEnabled": false,
                    "overlapColor": "#fff5b8",
                    "overlapDensity": 0.3,
                    "overlapTarget": "stream",
                    "overlapShimmer": false,
                    "dissolveEnabled": true,
                    "dissolveScalePercent": -2,
                    "deteriorationEnabled": true,
                    "deteriorationStrength": 4,
                    "enableBloom": true,
                    "bloomStrength": 2,
                    "bloomOpacity": 0.4,
                    "tracerGlow": 6,
                    "clearAlpha": 0.89,
                    "horizontalSpacingFactor": 0.95,
                    "verticalSpacingFactor": 0.95,
                    "stretchX": 0.9,
                    "stretchY": 0.9,
                    "decayFadeDurationFrames": 60,
                    "trailLengthVarianceEnabled": true,
                    "trailLengthVariance": 135,
                    "streamSpawnCount": 3,
                    "eraserSpawnCount": 3,
                    "minStreamGap": 2,
                    "minEraserGap": 50,
                    "minGapTypes": 10,
                    "allowTinyStreams": true,
                    "gradualColorStreams": true,
                    "holeRate": 0,
                    "desyncIntensity": 0.45,
                    "preferClusters": true,
                    "eraserStopChance": 0,
                    "tracerStopChance": 0,
                    "tracerAttackFrames": 3,
                    "tracerHoldFrames": 2,
                    "tracerReleaseFrames": 1,
                    "invertedTracerEnabled": false,
                    "invertedTracerChance": 0.1,
                    "upwardTracerEnabled": false,
                    "upwardTracerChance": 0.81,
                    "upwardTracerAttackFrames": 2,
                    "upwardTracerHoldFrames": 4,
                    "upwardTracerReleaseFrames": 30,
                    "upwardTracerGlow": 8,
                    "upwardTracerSpeedMult": 1.3,
                    "upwardTracerGlimmerSpeed": 3.15,
                    "upwardTracerGlimmerSize": 5,
                    "upwardTracerGlimmerFill": 5,
                    "upwardTracerGlimmerGlow": 6,
                    "upwardTracerGlimmerFlicker": 0.45,
                                "rotatorEnabled": true,
                                "rotatorChance": 100,
                                "rotatorSyncToTracer": false,                    "rotatorSyncMultiplier": 0.3,
                    "rotatorCycleFactor": 16,
                    "rotatorCrossfadeFrames": 4,
                    "rotateDuringFade": true,
                    "rotatorDesyncEnabled": true,
                    "rotatorDesyncVariance": 41,
                    "shaderEnabled": true,
                    "customShader": `// Name: Static Grain
precision mediump float;
// Inputs provided by the application
uniform sampler2D uTexture;
uniform float uParameter;
// uniform float uTime; // NOT needed for static grain
varying vec2 vTexCoord;
// Shader Configuration
const float GRAIN_AMOUNT = 0.05; // Increase this value (0.0 to 1.0) to make the grain more noticeable
// 1. Random function
// Generates a seemingly random float based on the input coordinate 'st'.
float random(vec2 st) {
    // This uses a "magic" dot product and large number to generate noise.
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
void main() {
    // 2. Sample the original texture
    vec4 color = texture2D(uTexture, vTexCoord);
    // 3. Calculate static noise
    // The key here is to pass only the coordinate (vTexCoord) to the random function.
    // We are NOT using 'uTime', so the result for any given coordinate is always the same.
    float noiseValue = random(vTexCoord);
    // Map the random value from [0.0, 1.0] to a useful noise range, e.g., [-1.0, 1.0]
    // (noiseValue - 0.5) shifts the range to [-0.5, 0.5]
    // * 2.0 expands the range to [-1.0, 1.0]
    float finalNoise = (noiseValue - 0.5) * 2.0;
    // 4. Apply grain to the color
    // We only apply the noise to the Red, Green, and Blue channels (.rgb).
    // The noise value is scaled by the GRAIN_AMOUNT.
    // A negative noise makes the pixel darker, a positive noise makes it brighter.
    color.rgb += finalNoise * (uParameter * 0.5);
    // 5. Output final color
    gl_FragColor = color;
}`,
                    "effectShader": null,
                    "shaderParameter": 0.03,
                    "effectParameter": 0,
                    "pulseEnabled": false,
                    "pulseUseTracerGlow": true,
                    "pulseMovieAccurate": false,
                    "pulseFrequencySeconds": 300,
                    "pulseDelaySeconds": 0.7,
                    "pulseDurationSeconds": 1.2,
                    "pulsePreserveSpaces": true,
                    "pulseIgnoreTracers": true,
                    "pulseDimming": 0.2,
                    "pulseBlend": false,
                    "pulseWidth": 130,
                    "pulseRandomPosition": true,
                    "pulseInstantStart": false,
                    "pulseCircular": false,
                    "clearPulseEnabled": false,
                    "clearPulseMovieAccurate": true,
                    "clearPulseUseTracerGlow": true,
                    "clearPulseFrequencySeconds": 235,
                    "clearPulseDurationSeconds": 0.7,
                    "clearPulsePreserveSpaces": true,
                    "clearPulseBlend": false,
                    "clearPulseWidth": 190,
                    "clearPulseRandomPosition": true,
                    "clearPulseInstantStart": false,
                    "clearPulseCircular": false,
                    "miniPulseEnabled": false,
                    "miniPulseUseTracerGlow": true,
                    "miniPulseFrequencySeconds": 450,
                    "miniPulseDurationSeconds": 5,
                    "miniPulsePreserveSpaces": true,
                    "miniPulseThickness": 100,
                    "miniPulseSpawnChance": 0.06,
                    "miniPulseSpeed": 16,
                    "miniPulseSize": 360,
                    "quantizedPulseEnabled": true,
                    "quantizedPulseFrequencySeconds": 295,
                    "quantizedPulseDurationSeconds": 10,
                    "quantizedPulseSpeed": 1,
                    "quantizedBlockWidthCells": 5,
                    "quantizedBlockHeightCells": 4,
                    "quantizedPulseBorderIllumination": 6.3,
                    "quantizedPulsePerimeterThickness": 1.0,
                    "quantizedPulseFadeInFrames": 0,
                    "quantizedPulseFadeFrames": 0,
                    "quantizedAddEnabled": false,
                    "quantizedAddFrequencySeconds": 40,
                    "quantizedAddDurationSeconds": 2,
                    "quantizedAddBorderIllumination": 4,
            "quantizedAddSpeed": 1,
            "quantizedAddPerimeterThickness": 1.0,
                    "quantizedAddFadeInFrames": 0,
                    "quantizedAddFadeFrames": 0,
                    "quantizedRetractEnabled": false,
                    "quantizedRetractFrequencySeconds": 60,
                    "quantizedRetractDurationSeconds": 2,
                    "quantizedRetractFadeInFrames": 5,
                    "quantizedRetractFadeFrames": 15,
                    "quantizedRetractBorderIllumination": 4,
                    "dejaVuEnabled": false,
                    "dejaVuFrequencySeconds": 350,
                    "dejaVuDurationSeconds": 5,
                    "dejaVuMinRectHeight": 1,
                    "dejaVuMaxRectHeight": 10,
                    "dejaVuHoleBrightness": 0.02,
                    "dejaVuRandomizeColors": false,
                    "dejaVuIntensity": 0.1,
                    "dejaVuBarDurationFrames": 28,
                    "dejaVuVarianceFrames": 43,
                    "supermanEnabled": false,
                    "supermanFrequencySeconds": 290,
                    "supermanDurationSeconds": 6,
                    "supermanFadeSpeed": 6,
                    "supermanGlow": 4,
                    "supermanBoltThickness": 5,
                    "supermanFlickerRate": 2,
                    "supermanWidth": 4,
                    "supermanSpawnSpeed": 69,
                    "starPowerEnabled": false,
                    "starPowerFreq": 100,
                    "starPowerRainbowMode": "char",
                    "starPowerSaturation": 100,
                    "starPowerIntensity": 51,
                    "starPowerColorCycle": true,
                    "starPowerCycleSpeed": 5,
                    "rainbowStreamEnabled": false,
                    "rainbowStreamChance": 0.5,
                    "rainbowStreamIntensity": 50,
                    "bootSequenceEnabled": false,
                    "crashEnabled": false,
                    "crashFrequencySeconds": 600,
                    "crashDurationSeconds": 30,
                    "crashSheetCount": 25,
                    "crashSheetSpeed": 1,
                    "crashSheetOpacity": 0.5,
                    "crashStationaryChance": 20,
                    "crashFlashDelayMin": 3,
                    "crashFlashDelayMax": 6,
                    "crashEnableSmith": true,
                    "crashEnableSuperman": true,
                    "crashEnableFlash": true,
                    "runBothInOrder": false,
                    "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c", "QuantizedPulse": "q", "QuantizedAdd": "a"},
                    "hideMenuIcon": true,
                    "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}},
                    "deteriorationType": "ghost",
                    "tracerSizeIncrease": 1,
                    "supermanProb": 4,
                    "dejaVuAutoMode": true,
                    "clearPulseIgnoreTracers": true,
                    "dejaVuPerformanceMode": false,
                    "pulseDelayFrames": 60,
                    "suppressToasts": true,
                    "supermanIncludeColors": true,
                    "renderingEngine": "canvas",
                    "dissolveMinSize": 18,
                    "crashMovieFps": true,
                    "quantizedPulseSimultaneousSpawns": 1,
                    "quantizedPulseGreenFadeSeconds": 0,
                    "quantizedAddGreenFadeSeconds": 0.5,
                    "quantizedRetractGreenFadeSeconds": 0.5,
                    "quantizedBlockGridWidth": 10,
                    "quantizedBlockGridHeight": 10,
                    "starPowerGlitter": false,
                    "ttlMinSeconds": 1,
                    "ttlMaxSeconds": 8,
                    "firewallEnabled": false,
                    "firewallFrequencySeconds": 150,
                    "firewallRandomColorEnabled": true,
                    "firewallColor": "#00ff00",
                    "firewallReverseDurationFrames": 20,
                    "firewallEraseDurationFrames": 50,
                    "renderMode3D": false,
                    "flySpeed": 15,
                    "upwardTracerGlimmerChance": 0
                }
            },
            {
                name: "PowerTrin",
                data: {
                    "streamColor": "#65d778",
                    "backgroundColor": "#020509",
                    "streamPalette": ["#00e004", "#2db61b", "#33ff70"],
                    "paletteBias": 1,
                    "colorMixType": 0,
                    "tracerColor": "#d7ffd7",
                    "fontSize": 24,
                    "streamSpeed": 17,
                    "releaseInterval": 3,
                    "resolution": 1,
                    "enableGlyphAtlas": true,
                    "smoothingEnabled": false,
                    "smoothingAmount": 0.1,
                    "showFpsCounter": true,
                    "debugEnabled": false,
                    "highlightErasers": false,
                    "logErrors": false,
                    "fontFamily": "CustomFont_5e2697679380fc43",
                    "fontWeight": "normal",
                    "italicEnabled": false,
                    "mirrorEnabled": false,
                    "variableBrightnessEnabled": true,
                    "brightnessVariance": 35,
                    "overlapEnabled": true,
                    "overlapColor": "#fff5b8",
                    "overlapDensity": 0.2,
                    "overlapTarget": "stream",
                    "overlapShimmer": false,
                    "dissolveEnabled": true,
                    "dissolveScalePercent": -2,
                    "deteriorationEnabled": true,
                    "deteriorationStrength": 4,
                    "enableBloom": true,
                    "bloomStrength": 2,
                    "bloomOpacity": 0.4,
                    "tracerGlow": 6,
                    "clearAlpha": 0.89,
                    "horizontalSpacingFactor": 0.95,
                    "verticalSpacingFactor": 0.95,
                    "stretchX": 0.9,
                    "stretchY": 0.9,
                    "decayFadeDurationFrames": 60,
                    "trailLengthVarianceEnabled": true,
                    "trailLengthVariance": 135,
                    "streamSpawnCount": 3,
                    "eraserSpawnCount": 3,
                    "minStreamGap": 2,
                    "minEraserGap": 23,
                    "minGapTypes": 60,
                    "allowTinyStreams": true,
                    "gradualColorStreams": true,
                    "holeRate": 0,
                    "desyncIntensity": 0.2,
                    "preferClusters": true,
                    "eraserStopChance": 0,
                    "tracerStopChance": 0,
                    "tracerAttackFrames": 3,
                    "tracerHoldFrames": 2,
                    "tracerReleaseFrames": 1,
                    "invertedTracerEnabled": false,
                    "invertedTracerChance": 0.1,
                    "upwardTracerEnabled": true,
                    "upwardTracerChance": 1,
                    "upwardTracerAttackFrames": 4,
                    "upwardTracerHoldFrames": 4,
                    "upwardTracerReleaseFrames": 50,
                    "upwardTracerGlow": 8,
                    "upwardTracerSpeedMult": 2.4,
                    "upwardTracerGlimmerSpeed": 5.48,
                    "upwardTracerGlimmerSize": 6,
                    "upwardTracerGlimmerFill": 2,
                    "upwardTracerGlimmerGlow": 3,
                    "upwardTracerGlimmerFlicker": 0.45,
                                "rotatorEnabled": true,
                                "rotatorChance": 100,
                                "rotatorSyncToTracer": false,                    "rotatorSyncMultiplier": 0.3,
                    "rotatorCycleFactor": 16,
                    "rotatorCrossfadeFrames": 4,
                    "rotateDuringFade": true,
                    "rotatorDesyncEnabled": true,
                    "rotatorDesyncVariance": 41,
                    "shaderEnabled": false,
                    "customShader": null,
                    "effectShader": null,
                    "shaderParameter": 0.03,
                    "effectParameter": 0,
                    "pulseEnabled": false,
                    "pulseUseTracerGlow": true,
                    "pulseMovieAccurate": false,
                    "pulseFrequencySeconds": 300,
                    "pulseDelaySeconds": 0.7,
                    "pulseDurationSeconds": 1.2,
                    "pulsePreserveSpaces": true,
                    "pulseIgnoreTracers": true,
                    "pulseDimming": 0.2,
                    "pulseBlend": false,
                    "pulseWidth": 130,
                    "pulseRandomPosition": true,
                    "pulseInstantStart": false,
                    "pulseCircular": false,
                    "clearPulseEnabled": false,
                    "clearPulseMovieAccurate": true,
                    "clearPulseUseTracerGlow": true,
                    "clearPulseFrequencySeconds": 235,
                    "clearPulseDurationSeconds": 0.7,
                    "clearPulsePreserveSpaces": true,
                    "clearPulseBlend": false,
                    "clearPulseWidth": 190,
                    "clearPulseRandomPosition": true,
                    "clearPulseInstantStart": false,
                    "clearPulseCircular": false,
                    "miniPulseEnabled": false,
                    "miniPulseUseTracerGlow": true,
                    "miniPulseFrequencySeconds": 450,
                    "miniPulseDurationSeconds": 5,
                    "miniPulsePreserveSpaces": true,
                    "miniPulseThickness": 100,
                    "miniPulseSpawnChance": 0.06,
                    "miniPulseSpeed": 16,
                    "miniPulseSize": 360,
                    "quantizedPulseEnabled": true,
                    "quantizedPulseFrequencySeconds": 295,
                    "quantizedPulseDurationSeconds": 10,
                    "quantizedPulseSpeed": 1,
                    "quantizedBlockWidthCells": 5,
                    "quantizedBlockHeightCells": 4,
                    "quantizedPulseBorderIllumination": 6.3,
                    "quantizedPulsePerimeterThickness": 1.0,
                    "quantizedPulseFadeInFrames": 0,
                    "quantizedPulseFadeFrames": 0,
                    "quantizedAddEnabled": false,
                    "quantizedAddFrequencySeconds": 40,
                    "quantizedAddDurationSeconds": 2,
                    "quantizedAddBorderIllumination": 4,
            "quantizedAddSpeed": 1,
            "quantizedAddPerimeterThickness": 1.0,
                    "quantizedAddFadeInFrames": 0,
                    "quantizedAddFadeFrames": 0,
                    "quantizedRetractEnabled": false,
                    "quantizedRetractFrequencySeconds": 60,
                    "quantizedRetractDurationSeconds": 2,
                    "quantizedRetractFadeInFrames": 5,
                    "quantizedRetractFadeFrames": 15,
                    "quantizedRetractBorderIllumination": 4,
                    "dejaVuEnabled": false,
                    "dejaVuFrequencySeconds": 350,
                    "dejaVuDurationSeconds": 5,
                    "dejaVuMinRectHeight": 1,
                    "dejaVuMaxRectHeight": 10,
                    "dejaVuHoleBrightness": 0.02,
                    "dejaVuRandomizeColors": false,
                    "dejaVuIntensity": 0.1,
                    "dejaVuBarDurationFrames": 28,
                    "dejaVuVarianceFrames": 43,
                    "supermanEnabled": false,
                    "supermanFrequencySeconds": 290,
                    "supermanDurationSeconds": 6,
                    "supermanFadeSpeed": 6,
                    "supermanGlow": 4,
                    "supermanBoltThickness": 5,
                    "supermanFlickerRate": 2,
                    "supermanWidth": 4,
                    "supermanSpawnSpeed": 69,
                    "starPowerEnabled": false,
                    "starPowerFreq": 100,
                    "starPowerRainbowMode": "char",
                    "starPowerSaturation": 100,
                    "starPowerIntensity": 51,
                    "starPowerColorCycle": true,
                    "starPowerCycleSpeed": 5,
                    "rainbowStreamEnabled": false,
                    "rainbowStreamChance": 0.5,
                    "rainbowStreamIntensity": 50,
                    "bootSequenceEnabled": false,
                    "crashEnabled": false,
                    "crashFrequencySeconds": 600,
                    "crashDurationSeconds": 30,
                    "crashSheetCount": 25,
                    "crashSheetSpeed": 1,
                    "crashSheetOpacity": 0.5,
                    "crashStationaryChance": 20,
                    "crashFlashDelayMin": 3,
                    "crashFlashDelayMax": 6,
                    "crashEnableSmith": true,
                    "crashEnableSuperman": true,
                    "crashEnableFlash": true,
                    "runBothInOrder": false,
                    "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c", "QuantizedPulse": "q", "QuantizedAdd": "a"},
                    "hideMenuIcon": true,
                    "fontSettings": {"MatrixEmbedded": {"active": false, "useCustomChars": false, "customCharacters": "!\"*+-.012345789:<=>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi|"}, "CustomFont_5e2697679380fc43": {"active": true, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", "useAllChars": false}},
                    "deteriorationType": "ghost",
                    "tracerSizeIncrease": 1,
                    "supermanProb": 4,
                    "dejaVuAutoMode": true,
                    "clearPulseIgnoreTracers": true,
                    "dejaVuPerformanceMode": false,
                    "pulseDelayFrames": 60,
                    "suppressToasts": true,
                    "supermanIncludeColors": true,
                    "renderingEngine": "canvas",
                    "dissolveMinSize": 18,
                    "crashMovieFps": true,
                    "quantizedPulseSimultaneousSpawns": 1,
                    "quantizedPulseGreenFadeSeconds": 0,
                    "quantizedAddGreenFadeSeconds": 0.5,
                    "quantizedRetractGreenFadeSeconds": 0.5,
                    "quantizedBlockGridWidth": 10,
                    "quantizedBlockGridHeight": 10,
                    "starPowerGlitter": false,
                    "ttlMinSeconds": 1,
                    "ttlMaxSeconds": 8,
                    "firewallEnabled": false,
                    "firewallFrequencySeconds": 150,
                    "firewallRandomColorEnabled": true,
                    "firewallColor": "#00ff00",
                    "firewallReverseDurationFrames": 20,
                    "firewallEraseDurationFrames": 50,
                    "renderMode3D": false,
                    "flySpeed": 15,
                    "upwardTracerGlimmerChance": 0
                }
            },
            {
                name: "RainbowRoad",
                data: {
                    "streamColor": "#65d778",
                    "backgroundColor": "#000000",
                    "streamPalette": ["#00ff41"],
                    "paletteBias": 0,
                    "colorMixType": 0.45,
                    "tracerColor": "#ccffcc",
                    "fontSize": 20,
                    "streamSpeed": 15,
                    "releaseInterval": 3,
                    "resolution": 1,
                    "enableGlyphAtlas": true,
                    "smoothingEnabled": false,
                    "smoothingAmount": 0.1,
                    "showFpsCounter": false,
                    "debugEnabled": false,
                    "highlightErasers": false,
                    "logErrors": false,
                    "fontFamily": "MatrixEmbedded",
                    "fontWeight": "normal",
                    "italicEnabled": false,
                    "mirrorEnabled": false,
                    "variableBrightnessEnabled": false,
                    "brightnessVariance": 15,
                    "overlapEnabled": false,
                    "overlapColor": "#20cb53",
                    "overlapDensity": 0.2,
                    "overlapTarget": "stream",
                    "overlapShimmer": false,
                    "dissolveEnabled": false,
                    "dissolveScalePercent": -15,
                    "deteriorationEnabled": false,
                    "deteriorationStrength": 6,
                    "enableBloom": true,
                    "bloomStrength": 2,
                    "bloomOpacity": 0.2,
                    "tracerGlow": 24,
                    "clearAlpha": 0.7,
                    "horizontalSpacingFactor": 0.75,
                    "verticalSpacingFactor": 1,
                    "stretchX": 1,
                    "stretchY": 1,
                    "decayFadeDurationFrames": 33,
                    "trailLengthVarianceEnabled": false,
                    "trailLengthVariance": 60,
                    "streamSpawnCount": 7,
                    "eraserSpawnCount": 5,
                    "minStreamGap": 2,
                    "minEraserGap": 2,
                    "minGapTypes": 1,
                    "allowTinyStreams": true,
                    "gradualColorStreams": false,
                    "gradualColorStreamsFrequency": 100,
                    "holeRate": 0,
                    "desyncIntensity": 0,
                    "preferClusters": true,
                    "eraserStopChance": 0,
                    "tracerStopChance": 1,
                    "tracerAttackFrames": 3,
                    "tracerHoldFrames": 2,
                    "tracerReleaseFrames": 3,
                    "invertedTracerEnabled": false,
                    "invertedTracerChance": 0.07,
                    "upwardTracerEnabled": true,
                    "upwardTracerChance": 0.02,
                    "upwardTracerAttackFrames": 2,
                    "upwardTracerHoldFrames": 30,
                    "upwardTracerReleaseFrames": 30,
                    "upwardTracerGlow": 8,
                    "upwardTracerSpeedMult": 1,
                    "upwardTracerGlimmerSpeed": 2,
                    "upwardTracerGlimmerSize": 3,
                    "upwardTracerGlimmerFill": 3,
                    "upwardTracerGlimmerGlow": 19,
                    "upwardTracerGlimmerFlicker": 0.5,
                                "rotatorEnabled": true,
                                "rotatorChance": 25,
                                "rotatorSyncToTracer": true,                    "rotatorSyncMultiplier": 0.4,
                    "rotatorCycleFactor": 20,
                    "rotatorCrossfadeFrames": 6,
                    "rotateDuringFade": false,
                    "rotatorDesyncEnabled": false,
                    "rotatorDesyncVariance": 0,
                    "shaderEnabled": false,
                    "customShader": `// Name: Matrix Real-World Blue Hue
precision highp float;                    // highp for desktop; switch to mediump for mobile if needed
uniform sampler2D uTexture;
uniform vec2      uResolution;            // (width, height)
uniform float     uTime;                  // seconds
uniform vec2      uMouse;                 // normalized [0..1]
uniform float     uParameter;             // UI slider [0..1]
varying vec2      vTexCoord;
vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.x, p.y, p.w, c.r), vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);
}
vec3 hsv2rgb(vec3 c){
    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0))*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}
void main() {
    vec3 rgb = texture2D(uTexture, vTexCoord).rgb;
    vec3 hsv = rgb2hsv(rgb);
    hsv.x = mix(hsv.x, 0.55, uParameter * 0.25);    // Hue change                                       
    hsv.y = mix(hsv.y, 0.0, uParameter * 0.25);            // Saturation change
    vec3 outc = hsv2rgb(hsv);
    gl_FragColor = vec4(outc, 1.0);
}`,
                    "effectShader": null,
                    "shaderParameter": 0.69,
                    "effectParameter": 2.8,
                    "pulseEnabled": true,
                    "pulseUseTracerGlow": false,
                    "pulseMovieAccurate": true,
                    "pulseFrequencySeconds": 300,
                    "pulseDelaySeconds": 0.7,
                    "pulseDurationSeconds": 1.2,
                    "pulsePreserveSpaces": true,
                    "pulseIgnoreTracers": true,
                    "pulseDimming": 0.2,
                    "pulseBlend": false,
                    "pulseWidth": 130,
                    "pulseRandomPosition": true,
                    "pulseInstantStart": false,
                    "pulseCircular": false,
                    "clearPulseEnabled": true,
                    "clearPulseMovieAccurate": true,
                    "clearPulseUseTracerGlow": true,
                    "clearPulseFrequencySeconds": 235,
                    "clearPulseDurationSeconds": 1.1,
                    "clearPulsePreserveSpaces": true,
                    "clearPulseBlend": true,
                    "clearPulseWidth": 130,
                    "clearPulseRandomPosition": true,
                    "clearPulseInstantStart": false,
                    "clearPulseCircular": false,
                    "miniPulseEnabled": true,
                    "miniPulseUseTracerGlow": true,
                    "miniPulseFrequencySeconds": 450,
                    "miniPulseDurationSeconds": 5,
                    "miniPulsePreserveSpaces": true,
                    "miniPulseThickness": 100,
                    "miniPulseSpawnChance": 0.06,
                    "miniPulseSpeed": 16,
                    "miniPulseSize": 360,
                    "quantizedPulseEnabled": false,
                    "quantizedPulseFrequencySeconds": 240,
                    "quantizedPulseDurationSeconds": 7.6,
                    "quantizedPulseSpeed": 1,
                    "quantizedBlockWidthCells": 4,
                    "quantizedBlockHeightCells": 4,
                    "quantizedPulseBorderIllumination": 4,
                    "quantizedPulsePerimeterThickness": 1.0,
                    "quantizedPulseFadeInFrames": 0,
                    "quantizedPulseFadeFrames": 0,
                    "quantizedAddEnabled": false,
                    "quantizedAddFrequencySeconds": 300,
                    "quantizedAddDurationSeconds": 10,
                    "quantizedAddBorderIllumination": 4,
            "quantizedAddSpeed": 1,
            "quantizedAddPerimeterThickness": 1.0,
                    "quantizedAddFadeInFrames": 0,
                    "quantizedAddFadeFrames": 0,
                    "quantizedRetractEnabled": false,
                    "quantizedRetractFrequencySeconds": 60,
                    "quantizedRetractDurationSeconds": 2,
                    "quantizedRetractFadeInFrames": 5,
                    "quantizedRetractFadeFrames": 15,
                    "quantizedRetractBorderIllumination": 4,
                    "dejaVuEnabled": true,
                    "dejaVuFrequencySeconds": 350,
                    "dejaVuDurationSeconds": 5,
                    "dejaVuMinRectHeight": 1,
                    "dejaVuMaxRectHeight": 10,
                    "dejaVuHoleBrightness": 0.02,
                    "dejaVuRandomizeColors": false,
                    "dejaVuIntensity": 0.07,
                    "dejaVuBarDurationFrames": 21,
                    "dejaVuVarianceFrames": 43,
                    "supermanEnabled": true,
                    "supermanFrequencySeconds": 290,
                    "supermanDurationSeconds": 6,
                    "supermanFadeSpeed": 6,
                    "supermanGlow": 2,
                    "supermanBoltThickness": 5,
                    "supermanFlickerRate": 3,
                    "supermanWidth": 3,
                    "supermanSpawnSpeed": 69,
                    "starPowerEnabled": true,
                    "starPowerFreq": 100,
                    "starPowerRainbowMode": "char",
                    "starPowerSaturation": 100,
                    "starPowerIntensity": 50,
                    "starPowerColorCycle": true,
                    "starPowerCycleSpeed": 14,
                    "rainbowStreamEnabled": false,
                    "rainbowStreamChance": 0.5,
                    "rainbowStreamIntensity": 50,
                    "bootSequenceEnabled": false,
                    "crashEnabled": false,
                    "crashFrequencySeconds": 600,
                    "crashDurationSeconds": 30,
                    "crashSheetCount": 33,
                    "crashSheetSpeed": 1.1,
                    "crashSheetOpacity": 0.96,
                    "crashStationaryChance": 17,
                    "crashFlashDelayMin": 3,
                    "crashFlashDelayMax": 6,
                    "crashEnableSmith": true,
                    "crashEnableSuperman": true,
                    "crashEnableFlash": true,
                    "runBothInOrder": true,
                    "keyBindings": {"Pulse": "p", "ClearPulse": "w", "MiniPulse": "e", "DejaVu": "r", "Superman": "t", "Firewall": "y", "ToggleUI": " ", "BootSequence": "b", "CrashSequence": "x", "BootCrashSequence": "c"},
                    "hideMenuIcon": true,
                    "fontSettings": {"MatrixEmbedded": {"active": true, "useCustomChars": false, "customCharacters": ""}, "CustomFont_5e2697679380fc43": {"active": false, "useCustomChars": true, "customCharacters": "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5", "useAllChars": false}},
                    "deteriorationType": "ghost",
                    "tracerSizeIncrease": 1,
                    "supermanProb": 4,
                    "dejaVuAutoMode": true,
                    "clearPulseIgnoreTracers": true,
                    "dejaVuPerformanceMode": false,
                    "pulseDelayFrames": 60,
                    "suppressToasts": false,
                    "supermanIncludeColors": true,
                    "renderingEngine": "canvas",
                    "dissolveMinSize": 19,
                    "crashMovieFps": true,
                    "quantizedPulseSimultaneousSpawns": 3,
                    "quantizedPulseGreenFadeSeconds": 0.1,
                    "quantizedAddGreenFadeSeconds": 0.5,
                    "quantizedRetractGreenFadeSeconds": 0.5,
                    "starPowerGlitter": false,
                    "firewallEnabled": false,
                    "firewallFrequencySeconds": 150,
                    "firewallRandomColorEnabled": true,
                    "firewallColor": "#00ff00",
                    "firewallReverseDurationFrames": 20,
                    "firewallEraseDurationFrames": 50,
                    "ttlMinSeconds": 1,
                    "ttlMaxSeconds": 8,
                    "renderMode3D": false,
                    "flySpeed": 15
                }
            },
        ];
        // Ensure we have at least the default number of slots (migration for existing users)
        if (!Array.isArray(loadedSlots) || loadedSlots.length === 0) {
            return defaults;
        }
        while (loadedSlots.length < defaults.length) {
            loadedSlots.push(defaults[loadedSlots.length]);
        }
        return loadedSlots;
    }
    /**
     * Saves configuration slots to local storage.
     */
    saveSlots() {
        try {
            localStorage.setItem(this.slotsKey, JSON.stringify(this.slots));
        } catch (e) {
            console.warn('Failed to save slots:', e);
        }
    }
    /**
     * Loads the application state from local storage.
     * @private
     */
    _loadState() {
        try {
            let storedState = localStorage.getItem(this.storageKey);
            // Fallback to previous version if current version not found
            if (!storedState) {
                const legacyKey = 'matrix_config_v7.5';
                storedState = localStorage.getItem(legacyKey);
            }
            if (storedState) {
                const parsed = JSON.parse(storedState);
                delete parsed.customFonts; // Remove unsupported keys if present
                // Handle new profile structure vs legacy flat structure
                if (parsed.profiles) {
                    // Flatten profiles - prioritize 2D if exists, otherwise take state
                    const p2d = parsed.profiles['2D'] || {};
                    this.state = { ...this.defaults, ...parsed.state, ...p2d };
                } else if (parsed.state) {
                    // Correctly unwrap 'state' property from saved JSON
                    this.state = { ...this.defaults, ...parsed.state };
                } else {
                    // Legacy flat structure
                    this.state = { ...this.defaults, ...parsed };
                }
                // Migration: Ensure streamPalette exists
                if (!this.state.streamPalette) {
                    this.state.streamPalette = [this.state.streamColor];
                }
                // Migration: Convert eraserStopChance from float to integer if needed
                if (this.state.eraserStopChance > 0 && this.state.eraserStopChance < 1) {
                    this.state.eraserStopChance = Math.round(this.state.eraserStopChance * 100);
                }
                // Clamp to max 25
                if (this.state.eraserStopChance > 25) {
                    this.state.eraserStopChance = 25;
                }
            } else {
                // First run: Clone defaults
                this.state = this._deepClone(this.defaults);
            }
        } catch (e) {
            console.warn('Failed to load configuration:', e);
        }
    }
    /**
     * Saves the current application state to local storage.
     */
    save() {
        try {
            // Save state
            const data = {
                state: this.state
            };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (e) {
            console.warn('Failed to save configuration:', e);
        }
    }
    /**
     * Retrieves the value of a specific configuration key.
     * @param {string} key - The key of the configuration setting.
     * @returns {*} The value of the configuration setting.
     */
    get(key) {
        return this.state[key];
    }
    /**
     * Resets all shader-related state to defaults.
     * Used on startup to prevent persistence of old shaders.
     */
    clearShaderState() {
        this.state.shaderEnabled = false;
        this.state.customShader = null;
        this.state.effectShader = null;
        this.save();
    }
    /**
     * Sets the value of a configuration key and triggers updates.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The new value for the setting.
     */
    set(key, value) {
        if (this.state[key] === value) return; // Skip if no change in value
        // Special handling for performanceMode
        if (key === 'performanceMode') {
            if (value === true) {
                // Enable Performance Mode - Backup current settings
                this.state.performanceBackup = {
                    fontSize: this.state.fontSize,
                    enableBloom: this.state.enableBloom,
                    shaderEnabled: this.state.shaderEnabled,
                    resolution: this.state.resolution,
                    smoothingEnabled: this.state.smoothingEnabled
                };
                // Apply Performance Settings
                // 1. Min Font Size 24 (Larger font = fewer cells = better performance)
                this.state.fontSize = Math.max(24, this.state.fontSize);
                // 2. Disable Effects
                this.state.enableBloom = false;
                this.state.shaderEnabled = false;
                this.state.smoothingEnabled = false;
                // 3. Lower Resolution
                this.state.resolution = 0.75;
                this.state.performanceMode = true;
            } else {
                // Disable Performance Mode - Restore settings
                if (this.state.performanceBackup) {
                    const b = this.state.performanceBackup;
                    if (b.fontSize !== undefined) this.state.fontSize = b.fontSize;
                    if (b.enableBloom !== undefined) this.state.enableBloom = b.enableBloom;
                    if (b.shaderEnabled !== undefined) this.state.shaderEnabled = b.shaderEnabled;
                    if (b.resolution !== undefined) this.state.resolution = b.resolution;
                    if (b.smoothingEnabled !== undefined) this.state.smoothingEnabled = b.smoothingEnabled;
                    this.state.performanceBackup = null;
                }
                this.state.performanceMode = false;
            }
            this.updateDerivedValues();
            this.save();
            this.notify('ALL');
            return;
        }
        // Special handling for shaderEnabled
        if (key === 'shaderEnabled') {
            if (value === true) { // Shader is being enabled
                // Store current smoothing values only if they are not already forced
                if (this.state.smoothingEnabled !== false) {
                    this._previousSmoothingEnabled = this.state.smoothingEnabled;
                } else {
                    this._previousSmoothingEnabled = undefined; // No previous value to restore
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this._previousSmoothingAmount = this.state.smoothingAmount;
                } else {
                    this._previousSmoothingAmount = undefined; // No previous value to restore
                }
                // Force smoothing off
                if (this.state.smoothingEnabled !== false) {
                    this.state.smoothingEnabled = false;
                    this.notify('smoothingEnabled');
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this.state.smoothingAmount = 0.1; // Minimum value as per UI definition
                    this.notify('smoothingAmount');
                }
            } else { // Shader is being disabled
                // Restore previous smoothing values if they were stored
                if (this._previousSmoothingEnabled !== undefined && this.state.smoothingEnabled !== this._previousSmoothingEnabled) {
                    this.state.smoothingEnabled = this._previousSmoothingEnabled;
                    this.notify('smoothingEnabled');
                }
                if (this._previousSmoothingAmount !== undefined && this.state.smoothingAmount !== this._previousSmoothingAmount) {
                    this.state.smoothingAmount = this._previousSmoothingAmount;
                    this.notify('smoothingAmount');
                }
                // Clear stored previous values
                this._previousSmoothingEnabled = undefined;
                this._previousSmoothingAmount = undefined;
            }
        }
        // Special handling for fontFamily: Enforce single active font in settings
        if (key === 'fontFamily') {
            const settings = this.state.fontSettings; // Reference current settings
            if (settings && settings[value]) {
                let changed = false;
                // Create a new settings object to trigger reactivity if needed, or mutate copy
                const newSettings = { ...settings };
                for (const fName in newSettings) {
                    if (Object.prototype.hasOwnProperty.call(newSettings, fName)) {
                        const isActive = (fName === value);
                        if (newSettings[fName].active !== isActive) {
                            // Clone the specific font config to avoid mutation side-effects
                            newSettings[fName] = { ...newSettings[fName], active: isActive };
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    this.state.fontSettings = newSettings;
                    this.notify('fontSettings');
                }
            }
        }
        this.state[key] = value; // Update the actual key's value
        // Only recompute derived values when relevant keys change (preserves behavior, improves perf)
        if (this._derivedKeys.has(key) || key === 'ALL') {
            this.updateDerivedValues();
        }
        this.save();
        this.notify(key);
    }
    /**
     * Resets the application state to its default values.
     */
    reset() {
        // Load the "Trilogy" preset (slot 0) after a factory reset
        // This ensures the desired default configuration is applied consistently.
        this.loadFromSlot(0);
        this._showToast("Configuration Reset", "info");
    }
    /**
     * Saves the current application state to a specific slot.
     * @param {number} index - The index of the slot (0-2).
     */
    saveToSlot(index) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index] = {
                name: this.slots[index].name,
                data: this._deepClone(this.state) // Deep clone state
            };
            this.saveSlots();
            this._showToast(`Saved to Slot ${index + 1}: ${this.slots[index].name}`, "success");
        } else {
            console.warn(`Attempted to save to non-existent slot index: ${index}`);
            this._showToast(`Failed to save slot ${index + 1}`, "error");
        }
    }
    /**
     * Loads the application state from a specific slot.
     * @param {number} index - The index of the slot (0-2).
     * @returns {boolean} True if the state was loaded successfully, false otherwise.
     */
    loadFromSlot(index) {
        if (!this.slots[index]?.data) return false; // Use optional chaining for safety
        this.state = { ...this.defaults, ...this.slots[index].data };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
        this._showToast(`Loaded Preset: ${this.slots[index].name}`, "success");
        return true;
    }
    /**
     * Renames a specific configuration slot.
     * @param {number} index - The index of the slot (0-2).
     * @param {string} name - The new name for the slot.
     */
    renameSlot(index, name) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index].name = name;
            this.saveSlots();
            this._showToast(`Renamed Slot ${index + 1} to "${name}"`, "success");
        } else {
            console.warn(`Attempted to rename non-existent slot index: ${index}`);
            this._showToast(`Failed to rename slot ${index + 1}`, "error");
        }
    }
    /**
     * Subscribes a callback function to configuration changes.
     * @param {Function} callback - The function to call when configuration changes.
     */
    subscribe(callback) {
        if (typeof callback === "function") {
            this.subscribers.push(callback);
        }
    }
    /**
     * Notifies all subscribed listeners about a configuration change.
     * @param {string} key - The key of the changed configuration setting.
     */
    notify(key) {
        // Guard each subscriber to prevent one failing listener from breaking the chain
        for (let i = 0; i < this.subscribers.length; i++) {
            const callback = this.subscribers[i];
            try {
                callback(key, this.state);
            } catch (e) {
                console.warn('Subscriber callback failed:', e);
            }
        }
    }
    /**
     * Updates all derived configuration values based on the current state.
     * These are values calculated from base settings for performance or convenience.
     */
    updateDerivedValues() {
        const s = this.state;
        const cycleDuration = 21 - s.streamSpeed;
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const rotatorCycleFrames = s.rotatorSyncToTracer
            ? Math.max(1, Math.floor(cycleDuration / s.rotatorSyncMultiplier))
            : Math.max(10, Math.round(60 - s.rotatorCycleFactor * 2.5));
        // Precompute common color conversions only once
        const streamRgb = Utils.hexToRgb(s.streamColor);
        const bgRgb = Utils.hexToRgb(s.backgroundColor);
        const tracerRgb = Utils.hexToRgb(s.tracerColor);
        // Palette conversions done once and reused
        const paletteHexes = (s.streamPalette && s.streamPalette.length > 0)
            ? s.streamPalette
            : [s.streamColor];
        const paletteRgbs = new Array(paletteHexes.length);
        for (let i = 0; i < paletteHexes.length; i++) {
            paletteRgbs[i] = Utils.hexToRgb(paletteHexes[i]);
        }
        const paletteColorsStr = paletteRgbs.map(Utils.createRGBString);
        const paletteColorsUint32 = paletteRgbs.map(c => Utils.packAbgr(c.r, c.g, c.b));
        this.derived = {
            cycleDuration,
            safeAttack: Math.min(Math.max(1, s.tracerAttackFrames), cycleDuration),
            safeRelease: Math.min(s.tracerReleaseFrames, cycleDuration),
            holdFrames: Math.max(0, s.tracerHoldFrames),
            maxState: cycleDuration + Math.max(0, s.tracerHoldFrames) + cycleDuration,
            rotatorCycleFrames,
            cellWidth: s.fontSize * hFactor,
            cellHeight: s.fontSize * vFactor,
            varianceMin: 1.0 - s.brightnessVariance / 100,
            streamRgb,
            bgRgb,
            tracerRgb,
            streamColorStr: Utils.createRGBString(streamRgb),
            paletteRgbs,
            paletteColorsStr,
            paletteColorsUint32,
            streamColorUint32: Utils.packAbgr(streamRgb.r, streamRgb.g, streamRgb.b),
            tracerColorUint32: Utils.packAbgr(tracerRgb.r, tracerRgb.g, tracerRgb.b),
            tracerColorStr: Utils.createRGBString(tracerRgb),
            fontBaseStr: `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
        };
        // Active Fonts Logic
        const fontSettings = s.fontSettings || {};
        const activeFonts = [];
        for (const name in fontSettings) {
            if (!Object.prototype.hasOwnProperty.call(fontSettings, name)) continue;
            const conf = fontSettings[name];
            if (conf && conf.active) {
                let chars;
                if (conf.useCustomChars) {
                    // Respect user's setting, even if empty (clean slate).
                    // Fallback to " " (space) if effectively empty to prevent simulation errors.
                    const clean = (conf.customCharacters || "").replace(/\s+/g, '');
                    chars = clean.length > 0 ? clean : " ";
                } else {
                    // Use Default
                    chars = Utils.CHARS;
                }
                activeFonts.push({ name, chars });
            }
        }
        // Fallback if no fonts are active
        if (activeFonts.length === 0) activeFonts.push({ name: 'MatrixEmbedded', chars: Utils.CHARS });
        this.derived.activeFonts = activeFonts;
    }
    /**
     * Sets the NotificationManager instance for toast messages.
     * @param {NotificationManager} notifications 
     */
    setNotificationManager(notifications) {
        this.notifications = notifications;
    }
    /**
     * Helper to show toast messages if NotificationManager is available.
     * @param {string} message 
     * @param {string} type 
     */
    _showToast(message, type = 'info') {
        if (this.notifications) {
            this.notifications.show(message, type);
        }
    }
}
// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=";
// --- CellGrid.js ---
// =========================================================================
// CELL GRID
// =========================================================================
// Constants for Cell State and Render Modes
const CELL_STATE = {
    INACTIVE: 0,
    ACTIVE: 1
    // OVERRIDE state is determined by the overrideActive flag
};
const RENDER_MODE = {
    STANDARD: 0, // Mix between Primary and Secondary based on 'mix'
    OVERLAP: 1,  // Visual Overlap (both visible)
    ADDITIVE: 2  // Additive blending (future proofing)
};
const OVERRIDE_MODE = {
    NONE: 0,
    CHAR: 1,
    SOLID: 2,
    FULL: 3
};
class CellGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // --- Core State ---
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.state = null; // Uint8: INACTIVE / ACTIVE
        // --- Primary Layer ---
        this.chars = null;        // Uint16
        this.colors = null;       // Uint32 (0xAABBGGRR) - Current Display Color
        this.baseColors = null;   // Uint32 (0xAABBGGRR) - Target/Stream Color
        this.alphas = null;       // Float32
        this.glows = null;        // Float32
        this.fontIndices = null;  // Uint8
        // --- Secondary Layer (Rotators / Overlaps) ---
        this.secondaryChars = null; // Uint16
        this.secondaryColors = null; // Uint32
        this.secondaryAlphas = null; // Float32
        this.secondaryGlows = null;  // Float32
        this.secondaryFontIndices = null; // Uint8
        // --- Mixing & Rendering ---
        this.mix = null;        // Float32 (0.0 = Primary, 1.0 = Secondary)
        this.renderMode = null; // Uint8 (RENDER_MODE)
        // --- Override Layer (Effects) ---
        this.overrideActive = null; // Uint8 (OVERRIDE_MODE)
        this.overrideChars = null;  // Uint16
        this.overrideColors = null; // Uint32
        this.overrideAlphas = null; // Float32
        this.overrideGlows = null;  // Float32
        this.overrideMix = null;    // Float32 (New: For FULL mode)
        this.overrideNextChars = null; // Uint16 (New: For FULL mode rotators)
        this.overrideFontIndices = null; // Uint8
        // --- Passive Layer (Effects) ---
        this.effectActive = null;   // Uint8
        this.effectChars = null;    // Uint16
        this.effectColors = null;   // Uint32
        this.effectAlphas = null;   // Float32
        this.effectGlows = null;    // Float32
        this.effectFontIndices = null; // Uint8
        // --- Simulation Logic Storage ---
        this.types = null;      // Uint8 (Tracer, Rotator, Empty)
        this.decays = null;     // Uint8
        this.maxDecays = null;  // Uint16 (Per-cell fade duration)
        this.ages = null;       // Int32
        this.brightness = null; // Float32
        this.rotatorOffsets = null; // Uint8 (Static noise for desync)
        // Auxiliary
        this.cellLocks = null;  // Uint8 (Prevent updates)
        // Sparse Data (Maps for memory efficiency)
        this.complexStyles = new Map(); // Dynamic styling data
        // Rotator Targets (Dense for GPU upload)
        this.nextChars = null;     // Uint16Array
        this.nextOverlapChars = null; // Uint16Array
    }
    /**
     * Resizes the grid based on new width and height.
     */
    resize(width, height, buffers = null) {
        const d = this.config.derived;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
        if (!d || !d.cellWidth || !d.cellHeight) return;
        // Snap to Fit: Round columns (width is primary), Ceil rows (height allows partial)
        const newCols = Math.round(width / d.cellWidth);
        const newRows = Math.ceil(height / d.cellHeight);
        if (newCols !== this.cols || newRows !== this.rows || buffers) {
            this._resizeGrid(newCols, newRows, buffers);
        }
    }
    getIndex(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return -1;
        return y * this.cols + x;
    }
    // --- Primary Layer Modifiers ---
    setPrimary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.chars[idx] = charStr.charCodeAt(0);
        this.colors[idx] = colorUint32;
        this.alphas[idx] = alpha;
        this.glows[idx] = glow;
        this.fontIndices[idx] = fontIndex;
        this.state[idx] = CELL_STATE.ACTIVE;
        this.activeIndices.add(idx);
    }
    setRotatorTarget(idx, charStr, isSecondary = false) {
        const code = charStr.charCodeAt(0);
        if (isSecondary) {
            this.nextOverlapChars[idx] = code;
        } else {
            this.nextChars[idx] = code;
        }
    }
    getRotatorTarget(idx, isSecondary = false) {
        const code = isSecondary ? this.nextOverlapChars[idx] : this.nextChars[idx];
        return (code > 0) ? String.fromCharCode(code) : null;
    }
    // --- Secondary Layer Modifiers ---
    setSecondary(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.secondaryChars[idx] = charStr.charCodeAt(0);
        this.secondaryColors[idx] = colorUint32;
        this.secondaryAlphas[idx] = alpha;
        this.secondaryGlows[idx] = glow;
        this.secondaryFontIndices[idx] = fontIndex;
    }
    // --- Override Layer Modifiers ---
    // This is a 'permanent' or hard override - it directly changes state
    setOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.overrideChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideGlows[idx] = glow;
        this.overrideFontIndices[idx] = fontIndex;
        this.overrideActive[idx] = OVERRIDE_MODE.CHAR;
    }
    // This is a soft override 
    setEffectOverride(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 1;
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Overlay Override (Mixes Effect Char on top of Primary)
    setEffectOverlay(idx, charStr, color, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 2; // 2 = Overlay Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = color;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // High Priority Override (Ignores Shadows/Masks)
    setHighPriorityEffect(idx, charStr, colorUint32, alpha, fontIndex = 0, glow = 0) {
        this.effectActive[idx] = 4; // 4 = High Priority Mode
        this.effectChars[idx] = charStr ? charStr.charCodeAt(0) : 32;
        this.effectColors[idx] = colorUint32;
        this.effectAlphas[idx] = alpha;
        this.effectFontIndices[idx] = fontIndex;
        this.effectGlows[idx] = glow;
    }
    // Shadow Overlay (Mixes Black Block on top of Primary)
    setEffectShadow(idx, alpha) {
        this.effectActive[idx] = 3; // 3 = Shadow Mode
        this.effectAlphas[idx] = alpha;
    }
    setSolidOverride(idx, colorUint32, alpha) {
        this.overrideColors[idx] = colorUint32;
        this.overrideAlphas[idx] = alpha;
        this.overrideActive[idx] = OVERRIDE_MODE.SOLID;
    }
    clearOverride(idx) {
        this.overrideActive[idx] = OVERRIDE_MODE.NONE;
    }
    clearEffectOverride(idx) {
        this.effectActive[idx] = 0;
    }
    clearAllOverrides() {
        if (this.overrideActive) {
            this.overrideActive.fill(0);
        }
    }
    clearAllEffects(){
        if (this.effectActive){
            this.effectActive.fill(0);
        }
    }
    // --- General State Management ---
    clearCell(idx) {
        this.state[idx] = CELL_STATE.INACTIVE;
        this.chars[idx] = 32; // Space
        this.alphas[idx] = 0;
        this.glows[idx] = 0;
        this.mix[idx] = 0;
        this.renderMode[idx] = RENDER_MODE.STANDARD;
        // Clear simulation data
        this.types[idx] = 0;
        this.ages[idx] = 0;
        this.decays[idx] = 0;
        this.maxDecays[idx] = 0;
        // Also clear secondary to be safe
        this.secondaryChars[idx] = 32;
        this.secondaryAlphas[idx] = 0;
        this.activeIndices.delete(idx);
        // Clear maps
        this.complexStyles.delete(idx);
        this.nextChars[idx] = 0;
        this.nextOverlapChars[idx] = 0;
    }
    getChar(idx) {
        // Helper for simulation reading
        return String.fromCharCode(this.chars[idx]);
    }
    getState(idx){
        // Helper for getting cell state
        return this.state[idx];
    }
    _resizeGrid(newCols, newRows, buffers = null) {
        const total = newCols * newRows;
        if (buffers) {
            // Adopt provided buffers (SharedArrayBuffer views)
            this.state = buffers.state;
            this.chars = buffers.chars;
            this.colors = buffers.colors;
            this.baseColors = buffers.baseColors;
            this.alphas = buffers.alphas;
            this.glows = buffers.glows;
            this.fontIndices = buffers.fontIndices;
            this.secondaryChars = buffers.secondaryChars;
            this.secondaryColors = buffers.secondaryColors;
            this.secondaryAlphas = buffers.secondaryAlphas;
            this.secondaryGlows = buffers.secondaryGlows;
            this.secondaryFontIndices = buffers.secondaryFontIndices;
            this.mix = buffers.mix;
            this.renderMode = buffers.renderMode;
            this.overrideActive = buffers.overrideActive;
            this.overrideChars = buffers.overrideChars;
            this.overrideColors = buffers.overrideColors;
            this.overrideAlphas = buffers.overrideAlphas;
            this.overrideGlows = buffers.overrideGlows;
            this.overrideMix = buffers.overrideMix;
            this.overrideNextChars = buffers.overrideNextChars;
            this.overrideFontIndices = buffers.overrideFontIndices;
            this.effectActive = buffers.effectActive;
            this.effectChars = buffers.effectChars;
            this.effectColors = buffers.effectColors;
            this.effectAlphas = buffers.effectAlphas;
            this.effectFontIndices = buffers.effectFontIndices;
            this.effectGlows = buffers.effectGlows;
            this.types = buffers.types;
            this.decays = buffers.decays;
            this.maxDecays = buffers.maxDecays;
            this.ages = buffers.ages;
            this.brightness = buffers.brightness;
            this.rotatorOffsets = buffers.rotatorOffsets;
            this.cellLocks = buffers.cellLocks;
            this.nextChars = buffers.nextChars;
            this.nextOverlapChars = buffers.nextOverlapChars;
            this.envGlows = buffers.envGlows;
        } else {
            // Core
            this.state = new Uint8Array(total);
            // Primary
            this.chars = new Uint16Array(total);
            this.colors = new Uint32Array(total);
            this.baseColors = new Uint32Array(total);
            this.alphas = new Float32Array(total);
            this.glows = new Float32Array(total);
            this.fontIndices = new Uint8Array(total);
            // Secondary
            this.secondaryChars = new Uint16Array(total);
            this.secondaryColors = new Uint32Array(total);
            this.secondaryAlphas = new Float32Array(total);
            this.secondaryGlows = new Float32Array(total);
            this.secondaryFontIndices = new Uint8Array(total);
            // Mix / Mode
            this.mix = new Float32Array(total);
            this.renderMode = new Uint8Array(total);
            // Override
            this.overrideActive = new Uint8Array(total);
            this.overrideChars = new Uint16Array(total);
            this.overrideColors = new Uint32Array(total);
            this.overrideAlphas = new Float32Array(total);
            this.overrideGlows = new Float32Array(total);
            this.overrideMix = new Float32Array(total);
            this.overrideNextChars = new Uint16Array(total);
            this.overrideFontIndices = new Uint8Array(total);
            // Effects
            this.effectActive = new Uint8Array(total)
            this.effectChars = new Uint16Array(total);
            this.effectColors = new Uint32Array(total);
            this.effectAlphas = new Float32Array(total);
            this.effectFontIndices = new Uint8Array(total);
            this.effectGlows = new Float32Array(total);
            // Simulation
            this.types = new Uint8Array(total);
            this.decays = new Uint16Array(total);
            this.maxDecays = new Uint16Array(total);
            this.ages = new Int32Array(total);
            this.brightness = new Float32Array(total);
            this.rotatorOffsets = new Uint8Array(total);
            this.cellLocks = new Uint8Array(total);
            // Rotators
            this.nextChars = new Uint16Array(total);
            this.nextOverlapChars = new Uint16Array(total);
            // Environmental Glows (Additive, per frame)
            this.envGlows = new Float32Array(total);
        }
        // Initialize static data
        if (!buffers) {
            const activeFonts = this.config.derived ? this.config.derived.activeFonts : null;
            const fallbackChars = "012345789Z:<=>\"*+-._!|";
            for (let i = 0; i < total; i++) {
                this.rotatorOffsets[i] = (Math.random() * 255) | 0;
                let charCode = 32; 
                if (activeFonts && activeFonts.length > 0) {
                    const f = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                    if (f.chars && f.chars.length > 0) {
                        charCode = f.chars.charCodeAt(Math.floor(Math.random() * f.chars.length));
                    }
                } else {
                    charCode = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
                }
                this.chars[i] = charCode;
            }
        }
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- EffectRegistry.js ---
// =========================================================================
// EFFECT REGISTRY
// =========================================================================
class EffectRegistry {
            constructor(grid, config) { 
                this.grid = grid; 
                this.config = config; 
                this.effects = []; 
            }
            register(effect) { this.effects.push(effect); }
            registerDefaults() {
                // ... (Load dynamically or manually)
            }
            get(name) { return this.effects.find(e => e.name === name); }
            _isEditorActive() {
                if (window.matrix && window.matrix.ui && window.matrix.ui.quantEditor) {
                    return window.matrix.ui.quantEditor.active;
                }
                return false;
            }
            trigger(name, ...args) {
                const fx = this.effects.find(e => e.name === name);
                if (!fx) return false;
                // 1. Prevent running ANY effects while in the editor
                if (this._isEditorActive()) {
                    return false;
                }
                // 2. Prevent two quantized effects from running at the same time
                const isQuantized = name.startsWith('Quantized');
                if (isQuantized) {
                    const activeQuantized = this.effects.find(e => e.active && e.name.startsWith('Quantized'));
                    if (activeQuantized && activeQuantized !== fx) {
                        return false;
                    }
                }
                return fx.trigger(...args);
            }
            _getEditedEffect() {
                if (window.matrix && window.matrix.ui && window.matrix.ui.quantEditor && window.matrix.ui.quantEditor.active) {
                    return window.matrix.ui.quantEditor.effect;
                }
                return null;
            }
            update() { 
                this.grid.clearAllOverrides();
                this.grid.clearAllEffects();
                const isEditorActive = this._isEditorActive();
                const editedEffect = this._getEditedEffect();
                this.effects.forEach(e => {
                    // If editor is active, only allow the currently edited effect to update
                    if (isEditorActive && e !== editedEffect) {
                        return;
                    }
                    e.update(); 
                    if (!e.active) return;
                    if (typeof e.applyToGrid === 'function') {
                        e.applyToGrid(this.grid);
                    } else if (typeof e.getOverride === 'function') {
                        this._applyLegacyOverride(e);
                    }
                }); 
            }
            _applyLegacyOverride(e) {
                const indices = e.getActiveIndices();
                const apply = (i) => {
                    const over = e.getOverride(i);
                    if (over) {
                        if (over.solid) {
                            // Parse Color & Alpha
                            let r=0, g=0, b=0, a=255;
                            if (over.bgColor) {
                                // Try Hex first (Utils handles it)
                                if (over.bgColor.startsWith('#')) {
                                    const rgb = Utils.hexToRgb(over.bgColor);
                                    r=rgb.r; g=rgb.g; b=rgb.b;
                                    // Hex alpha not supported by Utils.hexToRgb currently
                                } else {
                                    // Parse rgba()
                                    const match = over.bgColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                                    if (match) {
                                        r = parseInt(match[1]);
                                        g = parseInt(match[2]);
                                        b = parseInt(match[3]);
                                        if (match[4]) a = Math.floor(parseFloat(match[4]) * 255);
                                    }
                                }
                            }
                            const color = Utils.packAbgr(r, g, b, a);
                            this.grid.setSolidOverride(i, color, a / 255.0);
                        } else {
                            // Char Override
                            let color = 0xFFFFFFFF; 
                            if (over.color) {
                                 const rgb = Utils.hexToRgb(over.color);
                                 // Alpha from property
                                 const a = over.alpha !== undefined ? over.alpha * 255 : 255;
                                 color = Utils.packAbgr(rgb.r, rgb.g, rgb.b, a);
                            }
                            let fontIdx = 0;
                            if (over.font) {
                                 const activeFonts = this.config.derived.activeFonts;
                                 const idx = activeFonts.findIndex(f => f.name === over.font);
                                 if (idx !== -1) fontIdx = idx;
                            }
                            this.grid.setOverride(i, over.char, color, over.alpha || 1.0, fontIdx, over.glow || 0);
                        }
                    }
                };
                if (indices) {
                    for (const idx of indices) apply(idx);
                } else {
                    const total = this.grid.cols * this.grid.rows;
                    for (let i = 0; i < total; i++) apply(i);
                }
            }
            render(ctx, derived) {
                const cw = derived.cellWidth;
                const ch = derived.cellHeight;
                ctx.save();
                // ctx.translate(-cw, -ch); // Removed: Grid now starts at 0,0 (Snap-to-Fit Refactor)
                this.effects.forEach(e => {
                    if (e.active && typeof e.render === 'function') {
                        e.render(ctx, derived);
                    }
                });
                ctx.restore();
            }
        }
        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; this.active = false; }
            trigger() { return false; }
            update() {}
            getActiveIndices() { return new Set(); }
        }
// --- BootEffect.js ---
class BootEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry;
        this.name = "BootSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = 3.5; 
        this.originalShader = null; 
        this.originalShaderEnabled = false; 
        this.originalShaderParameter = 0.5; 
    }
    trigger() {
        if (this.active) return false;
        // Set Effect Shader (Pass 1)
        this.c.set('effectShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; // 0.0 to 1.0 over 3.5s
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) {
    return fract(sin(n * 12.9898) * 43758.5453123);
}
float noise(float p) {
    float i = floor(p);
    float f = fract(p);
    return mix(random(i), random(i + 1.0), f * f * (3.0 - 2.0 * f));
}
float sdRoundedBox(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
float vignetteRect(vec2 uv, float margin) {
    vec2 v = smoothstep(0.0, margin, uv) * smoothstep(1.0, 1.0 - margin, uv);
    return v.x * v.y;
}
float smoothstep_custom(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * (3.0 - 2.0 * x);
}
// "Scanner Sheet" with subtle torn edges
// axis: 0 = none, 1 = jagged horizontal edges, 2 = jagged vertical edges
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    // Torn edge effect
    float jagged = 0.0;
    if (axis == 1) {
        jagged = (noise(uv.x * 50.0) - 0.5) * 0.005; 
        pos.y += jagged;
    } else if (axis == 2) {
        jagged = (noise(uv.y * 50.0) - 0.5) * 0.005;
        pos.x += jagged;
    }
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
// Asymmetrical Scanner Scenes (Full Span + Torn Edges)
vec3 getScannerScene(int pattern, vec2 uv) {
    vec3 col = vec3(1.0); 
    // Pattern 0: Split Scan (Full Width)
    if (pattern == 0) {
        float top = scannerSheet(uv, vec2(0.5, 0.75), vec2(1.0, 0.25), 0.02, 1);
        float bot = scannerSheet(uv, vec2(0.5, 0.25), vec2(1.0, 0.25), 0.02, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.6), vec2(1.0, 0.05), 0.01, 1); 
        vec3 cTop = vec3(0.85, 0.9, 0.95);
        vec3 cBot = vec3(1.0);
        col = mix(vec3(0.9), cBot, bot);
        col = mix(col, cTop, top);
        col = mix(col, vec3(0.7), art);
    }
    // Pattern 1: Faded Gradient + Full Height Side Bar
    if (pattern == 1) {
        float grad = smoothstep(0.0, 1.0, uv.y);
        col = vec3(mix(0.6, 1.0, grad));
        float bar = scannerSheet(uv, vec2(0.15, 0.5), vec2(0.08, 1.0), 0.05, 2); 
        col = mix(col, vec3(0.95), bar);
    }
    // Pattern 2: Bottom Bar (Full Width)
    if (pattern == 2) {
        col = vec3(0.85);
        float bar = scannerSheet(uv, vec2(0.5, 0.15), vec2(1.0, 0.15), 0.03, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.85), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), bar);
        col = mix(col, vec3(0.9), art);
    }
    // Pattern 3: Thick Vertical Block (Full Height)
    if (pattern == 3) {
        col = vec3(1.0);
        float side = scannerSheet(uv, vec2(0.9, 0.5), vec2(0.15, 1.0), 0.08, 2);
        float block = scannerSheet(uv, vec2(0.3, 0.5), vec2(0.15, 1.0), 0.01, 2); 
        vec3 blueLeak = vec3(0.7, 0.85, 1.0);
        col = mix(col, blueLeak, side);
        col = mix(col, vec3(0.8), block);
    }
    // Pattern 4: Top Header (Full Width)
    if (pattern == 4) {
        col = vec3(0.95);
        float head = scannerSheet(uv, vec2(0.5, 0.9), vec2(1.0, 0.1), 0.02, 1);
        float bar = scannerSheet(uv, vec2(0.5, 0.1), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), head);
        col = mix(col, vec3(0.85), bar);
    }
    // Pattern 5: Corner Heavy (Full Span components)
    if (pattern == 5) {
        col = vec3(0.9);
        float vStrip = scannerSheet(uv, vec2(0.1, 0.5), vec2(0.15, 1.0), 0.1, 2);
        float hStrip = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.08), 0.02, 1);
        col = mix(col, vec3(1.0), vStrip);
        col = mix(col, vec3(0.8), hStrip);
    }
    // Pattern 6: Wide Horizontal Split (Full Width)
    if (pattern == 6) {
        col = vec3(1.0);
        float mid = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.15), 0.05, 1);
        col = mix(vec3(0.85), vec3(1.0), mid);
    }
    return col;
}
void main() {
    vec4 origColor = texture2D(uTexture, vTexCoord);
    vec2 uv = vTexCoord;
    vec2 p = uv * 2.0 - 1.0;
    float aspect = uResolution.x / uResolution.y;
    p.x *= aspect;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0); 
    // --- TIMING ---
    float t_dot = smoothstep_custom(0.15, 0.25, uParameter);
    float t_v_stretch = smoothstep_custom(0.25, 0.35, uParameter);
    float t_h_stretch = smoothstep_custom(0.35, 0.45, uParameter);
    vec3 whiteLayer = vec3(0.0);
    float whiteAlpha = 0.0;
    if (uParameter < 0.45) {
        if (uParameter > 0.15) {
            float line_thickness = 0.008; 
            float max_height = 2.0; 
            float max_width = 2.0 * aspect;
            float current_radius = line_thickness * t_dot;
            float added_height = mix(0.0, max_height, t_v_stretch * t_v_stretch);
            float added_width = mix(0.0, max_width, t_h_stretch * t_h_stretch);
            float active_radius = mix(current_radius, 0.0, t_h_stretch);
            float d = sdRoundedBox(p, vec2(added_width, added_height), active_radius);
            float glow = 1.0 - smoothstep(0.0, 0.015, d);
            float core = 1.0 - smoothstep(0.0, 0.0005, d);
            whiteAlpha = max(glow, core);
            if (t_h_stretch < 0.1) {
                 float total_h = added_height + active_radius;
                 float v_fade = smoothstep(total_h, total_h * 0.5, abs(p.y));
                 whiteAlpha *= v_fade;
            } else {
                 whiteAlpha = mix(whiteAlpha, 1.0, t_h_stretch);
            }
            whiteLayer = vec3(1.0);
        }
    } else {
        // --- FLASHES ---
        float t_flash_phase = (uParameter - 0.45) / 0.55; 
        float cycle_count = 22.0; 
        float raw_cycle = t_flash_phase * cycle_count;
        float cycle_index = floor(raw_cycle);
        float rnd = random(cycle_index + 123.45); 
        int pattern = int(rnd * 7.0); 
        whiteLayer = getScannerScene(pattern, uv);
        whiteAlpha = 1.0; 
        float fade_out = smoothstep_custom(0.90, 1.0, uParameter);
        whiteAlpha *= (1.0 - fade_out);
    }
    // --- COMPOSITE ---
    // Tighter, less intense vignette
    float border = vignetteRect(uv, 0.01); // 1% margin
    whiteAlpha *= border;
    vec3 background = vec3(0.0);
    if (uParameter > 0.90) {
         background = origColor.rgb;
    }
    finalColor.rgb = mix(background, whiteLayer, whiteAlpha);
    gl_FragColor = finalColor;
}
`); 
        this.c.set('effectParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        // console.log("BootEffect Triggered");
        return true;
    }
    update() {
        if (!this.active) return;
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        let progress = elapsedTime / this.durationSeconds;
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('effectShader', null);
            this.c.set('effectParameter', 0.0);
            // console.log("BootEffect Finished");
            if (this.c.get('runBothInOrder') && this.registry) {
                this.registry.trigger('CrashSequence');
            }
            return;
        }
        this.c.set('effectParameter', progress);
    }
    getOverride(i) {
        return null;
    }
}
// --- ClearPulseEffect.js ---
class ClearPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "ClearPulse";
        this.active = false;
        this.origin = { x: 0, y: 0 };
        this.radius = 0;
        this.snap = null;
        const s = this._getEffectiveState();
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        this.autoTimer = s.clearPulseFrequencySeconds * fps;
        this.renderData = null;
        this.chunks = []; // For Movie Accurate Lag
        this.frameAccumulator = 0;
    }
    _getEffectiveState() {
        const s = this.c.state;
        if (!s.clearPulseMovieAccurate) return s;
        // Movie Accurate Overrides
        return {
            ...s,
            clearPulseFrequencySeconds: 235, 
            clearPulseDurationSeconds: 1.4,
            clearPulseWidth: 80, // Approx 7 chars width (depending on font size)
            clearPulseRandomPosition: false,
            clearPulseInstantStart: false,
            clearPulseCircular: false,
            clearPulsePreserveSpaces: false,
            clearPulseUseTracerGlow: false, 
            clearPulseBlend: true
        };
    }
    trigger() {
        if (this.active) return false;
        const total = this.g.cols * this.g.rows;
        const d = this.c.derived;
        const s = this._getEffectiveState();
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = "MATRIX";
        // Snapshot colors and fill chars
        this.snap = { 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total),
            colors: new Uint32Array(this.g.colors),
            tracers: new Uint8Array(total) // Track tracers for center finding
        };
        const holdEnd = d.cycleDuration + d.holdFrames;
        for (let i = 0; i < total; i++) {
            // Identify Tracer State (for center finding)
            const type = this.g.types[i] & CELL_TYPE_MASK; 
            const age = this.g.ages[i];
            let isTracer = false;
            if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                const at = age - 1; 
                if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                    isTracer = true;
                } 
            }
            this.snap.tracers[i] = isTracer ? 1 : 0;
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                 this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                 this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.clearPulseMovieAccurate) {
             // Find Tracer closest to center
             const cx = Math.floor(this.g.cols / 2);
             const cy = Math.floor(this.g.rows / 2);
             let minDist = 99999999;
             let bestX = cx; 
             let bestY = cy;
             for(let i=0; i<total; i++) {
                 if (this.snap.tracers[i] === 1) {
                     const x = i % this.g.cols;
                     const y = Math.floor(i / this.g.cols);
                     const dx = (x - cx);
                     const dy = (y - cy);
                     const dist = dx*dx + dy*dy;
                     if (dist < minDist) {
                         minDist = dist;
                         bestX = x;
                         bestY = y;
                     }
                 }
             }
             ox = bestX;
             oy = bestY;
        } else if (s.clearPulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols * 0.2, this.g.cols * 0.8);
            oy = Utils.randomInt(this.g.rows * 0.2, this.g.rows * 0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.clearPulseWidth && pxDistY < s.clearPulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols / 2);
            oy = Math.floor(this.g.rows / 2);
        }
        this.origin = { x: ox, y: oy };
        this.active = true;
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        // Radius Init
        if (s.clearPulseMovieAccurate) {
            this.radius = 2 * d.cellWidth * s.stretchX; 
        } else {
            this.radius = s.clearPulseInstantStart ? s.clearPulseWidth * 2 : 0;
        }
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * fps);
        // Reset Chunks
        this.chunks = [];
        this.spawnedCount = 0;
        this.spawnCooldown = 0;
        return true;
    }
    update() {
        const s = this._getEffectiveState();
        const fps = s.clearPulseMovieAccurate ? 30 : 60;
        if (s.clearPulseMovieAccurate) {
             this.frameAccumulator++;
             if (this.frameAccumulator < 2) return;
             this.frameAccumulator = 0;
        } else {
             this.frameAccumulator = 0;
        }
        if (!this.active && s.clearPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.clearPulseFrequencySeconds * fps;
        }
        if (!this.active) { this.renderData = null; return; }
        const d = this.c.derived;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * fps);
        this.radius += this.speed;
        if (this.radius > maxDim + 400) { 
            this.active = false; 
            this.snap = null; 
            this.renderData = null; 
            return; 
        }
        // --- Chunk Lifecycle & Spawning (Movie Accurate) ---
        if (s.clearPulseMovieAccurate) {
            // 1. Update existing chunks
            for (let i = this.chunks.length - 1; i >= 0; i--) {
                this.chunks[i].life--;
                if (this.chunks[i].life <= 0) {
                    this.chunks.splice(i, 1);
                }
            }
            // 2. Cooldown
            if (this.spawnCooldown > 0) this.spawnCooldown--;
            // 3. Spawn Logic
            const progress = this.radius / maxDim;
            if (progress > 0.15 && this.spawnedCount < 4 && this.spawnCooldown <= 0) {
                const w = Utils.randomInt(Math.floor(this.g.cols * 0.5), this.g.cols);
                let h = Utils.randomInt(6, 13);
                let y = Utils.randomInt(Math.floor(this.g.rows * 0.2), Math.floor(this.g.rows * 0.8));
                const x = Utils.randomInt(0, this.g.cols - w);
                y = Math.max(0, Math.min(this.g.rows - h, y));
                const delayPixels = 4 * d.cellWidth * s.stretchX; 
                const oneCharTime = (d.cellWidth * s.stretchX) / this.speed;
                const duration = Math.ceil(delayPixels / this.speed) + Math.ceil(oneCharTime) + 2;
                this.chunks.push({
                    x, y, w, h,
                    lag: delayPixels,
                    life: duration
                });
                this.spawnedCount++;
                this.spawnCooldown = duration + 5; 
            }
        }
        // --- Optimization Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX);
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        const width = s.clearPulseWidth * 2;
        const innerEdge = this.radius - width;
        let ratio = 1;
        if (s.clearPulseMovieAccurate) {
             ratio = 1.0; // Locked 1:1 for Movie Accurate
        } else if (!s.clearPulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        let minX, maxX, minY, maxY;
        if (s.clearPulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, radiusSq: this.radius*this.radius, innerEdge, innerEdgeSq: innerEdge*innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this._getEffectiveState();
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        const aspect = 1.0; 
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: AABB Check (Skip if definitely outside)
            const x = i % grid.cols; 
            const y = Math.floor(i / grid.cols);
            const cx = Math.floor(x * d.cellWidth * s.stretchX);
            const cy = Math.floor(y * d.cellHeight * s.stretchY);
            if (cx < rd.minX || cx > rd.maxX || cy < rd.minY || cy > rd.maxY) continue;
            // Apply Catching Lag (Movie Accurate)
            let curLag = 0;
            if (s.clearPulseMovieAccurate && this.chunks) {
                for (const chunk of this.chunks) {
                    if (x >= chunk.x && x < chunk.x + chunk.w &&
                        y >= chunk.y && y < chunk.y + chunk.h) {
                        curLag = chunk.lag;
                        break;
                    }
                }
            }
            // Effective Radius for this cell
            const localRadius = Math.max(0, rd.radius - curLag);
            const localInnerEdge = Math.max(0, rd.innerEdge - curLag);
            // Distance Calc
            let dist;
            if (s.clearPulseCircular) {
                const dx = cx - rd.ox; const dy = cy - rd.oy;
                dist = Math.sqrt(dx * dx + dy * dy);
            } else {
                const dx = Math.abs(cx - rd.ox);
                const dy = Math.abs(cy - rd.oy);
                dist = Math.max(dx, dy * rd.ratio);
            }
            if (dist < localInnerEdge || dist > localRadius) continue;
            // --- Apply Override ---
            const alpha = grid.alphas[i];
            const isGap = (alpha <= 0.01);
            if (s.clearPulsePreserveSpaces && isGap) continue;
            let charCode, fontIdx, color;
            // Use LIVE grid data to prevent freezing
            if (isGap) {
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
                color = d.streamColorUint32;
            } else {
                charCode = grid.chars[i];
                fontIdx = grid.fontIndices[i];
                color = grid.colors[i];
            }
            const rel = Math.max(0, Math.min(1, (localRadius - dist) / rd.width));
            // Apply Glow Toggle
            const baseGlow = Math.max(s.tracerGlow, 30 * (1.0 - rel));
            const actualGlow = (s.clearPulseUseTracerGlow) ? baseGlow : 0;
            let finalColor;
            if (!s.clearPulseBlend) {
                // Blend OFF: Solid Tracer Color & Glow
                finalColor = tColorInt;
            } else {
                // Blend ON: Linear fade across the entire wave
                const bR = color & 0xFF;
                const bG = (color >> 8) & 0xFF;
                const bB = (color >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * rel);
                const mG = Math.floor(tG + (bG - tG) * rel);
                const mB = Math.floor(tB + (bB - tB) * rel);
                finalColor = Utils.packAbgr(mR, mG, mB);
            }
            // For lagged chunks in Movie Accurate mode, dim the wave slightly
            let finalAlpha = 1.0;
            if (s.clearPulseMovieAccurate) {
                // Movie Accurate Edge Fading, Variance & Holes
                // 1. Holes (10% chance to skip rendering the wave for this cell)
                const holeHash = Math.abs((Math.sin(i * 13.1234) * 43758.5453) % 1);
                if (holeHash < 0.1) {
                    grid.clearEffectOverride(i);
                    continue;
                }
                // 2. Brightness Variance (80% full, 20% vary)
                const varHash = Math.abs((Math.sin(i * 12.9898) * 43758.5453) % 1);
                if (varHash < 0.8) {
                    finalAlpha = 1.0;
                } else {
                    // Vary between 0.4 and 0.8
                    finalAlpha = 0.4 + ((varHash - 0.8) / 0.2) * 0.4;
                }
                // 3. Edge Fading (Outer 20% and Inner 20%)
                if (rel < 0.2) {
                    // Outer Edge
                    finalAlpha *= (rel / 0.2);
                } else if (rel > 0.8) {
                    // Inner Edge
                    finalAlpha *= ((1.0 - rel) / 0.2);
                }
                if (curLag > 0) {
                    finalAlpha *= 0.6; // Additional dimming for lag
                }
            } else {
                // Standard mode solid alpha
                finalAlpha = 1.0;
            }
            // Use Overlay Mode to preserve background simulation movement
            grid.setEffectOverlay(i, String.fromCharCode(charCode), finalColor, finalAlpha, fontIdx, actualGlow);
        }
    }
}
// --- CrashEffect.js ---
class CrashEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry; 
        this.name = "CrashSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30; 
        this.originalShader = null;
        this.originalShaderEnabled = false;
        this.originalShaderParameter = 0.5;
        this.originalFade = 0; // To store/restore fade speed
        this.frame = 0;
        this.snapshotOverlay = new Map(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.shadowMap = null;
        this.supermanState = {
            active: false,
            type: 0, 
            cells: new Set(), 
            fadingReveals: [], // Store active reveal zones
            flickerTimer: 0,
            globalTimer: 0,
            boltId: 0
        };
        this.shaderState = {
            activeId: 0, 
            timer: 0,
            duration: 0
        };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.flashState = {
            active: false,
            timer: 0,
            duration: 40, 
            nextFlash: 60, 
            cycleDuration: 240
        };
        this.MAX_BLACK_LEVEL = 0.5; 
        this.baseBlackLevel = this.MAX_BLACK_LEVEL; 
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
    }
    trigger() {
        if (this.active) return false;
        // Snapshot for Deja Vu bars to respect spaces
        this.snap = {
            alphas: new Float32Array(this.g.alphas),
            chars: new Uint16Array(this.g.chars)
        };
        // Get Stream Color for the Splash
        const colorStr = this.c.derived.streamColorStr || this.c.defaults.streamColor;
        const rgb = Utils.hexToRgb(colorStr);
        const vec3Color = `vec3(${rgb.r/255.0}, ${rgb.g/255.0}, ${rgb.b/255.0})`;
        // Set Effect Shader (Pass 1) - Leaves Custom Shader (Pass 2) intact
        this.c.set('effectShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; 
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) { return fract(sin(n) * 43758.5453123); }
float rect(vec2 uv, vec2 pos, vec2 size) {
    vec2 d = abs(uv - pos) - size;
    return 1.0 - step(0.0, max(d.x, d.y));
}
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
void main() {
    vec2 uv = vTexCoord;
    float phase_idx = floor(uParameter + 0.001);
    float progress = fract(uParameter); 
    vec4 finalColor = texture2D(uTexture, uv);
    vec3 splashColor = ${vec3Color};
    // --- PHASE 10: SPLASH EFFECT ---
    if (phase_idx == 10.0) {
         float t = progress; 
         float bar = scannerSheet(uv, vec2(0.5, 0.5), vec2(1.0, 0.2), 0.3, 1);
         float flashAlpha = bar * (1.0 - smoothstep(0.0, 0.6, t));
         if (flashAlpha > 0.0) {
            finalColor.rgb += splashColor * flashAlpha * 3.0; 
         }
    }
    // --- PHASE 2: DISTORTION ---
    if (phase_idx == 2.0) {
        vec2 center = vec2(0.5, 0.5);
        vec2 dist = uv - center;
        dist.y *= 0.02; 
        vec4 distColor = texture2D(uTexture, center + dist);
        distColor.rgb *= 1.5;
        float active = 1.0 - ((progress - 0.66) / 0.34);
        if (active > 0.0) finalColor = mix(finalColor, distColor, 0.5 * active);
    }
    // --- PHASE 9: STRETCH ---
    if (phase_idx == 9.0) {
        float sampleX = 0.3;
        vec4 stretchColor = texture2D(uTexture, vec2(sampleX, uv.y));
        float flicker = 0.5 + 0.5 * sin(progress * 30.0); 
        if (abs(uv.x - 0.33) < 0.05) { stretchColor.rgb *= 0.3; }
        stretchColor.rgb *= (1.0 + flicker);
        float alpha = (0.5 + 0.5 * flicker) * (1.0 - progress); 
        finalColor = mix(finalColor, stretchColor, alpha);
    }
    gl_FragColor = finalColor;
}
`);
        this.c.set('effectParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        this.frame = 0;
        this.snapshotOverlay.clear(); 
        this.blackSheets = []; 
        this.crashBars = [];
        this.supermanState = { 
            active: false, 
            type: 0, 
            cells: new Set(), 
            illuminatedCells: new Set(), 
            fadingReveals: [], // Ensure this is initialized!
            flickerTimer: 0, 
            globalTimer: 0, 
            boltId: 0 
        };
        this.shaderState = { activeId: 0, timer: 0, duration: 0 };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.sheetState = { spawning: true, timer: 600 };
        this.endFlashTriggered = false;
        this.sheetFadeVal = 1.0;
        this.flashState.active = false;
        this.flashState.nextFlash = 30; 
        this.MAX_BLACK_LEVEL = 0.5;
        this.baseBlackLevel = this.c.get('crashEnableFlash') ? this.MAX_BLACK_LEVEL : 0.0; 
        // Immediate Spawn of all sheets
        const maxSheets = this.c.get('crashSheetCount');
        this.blackSheets = [];
        this._updateBlackSheets(maxSheets); // Force fill
        return true;
    }
    update() {
        if (!this.active) return;
        this.frame++;
        let step = 1;
        if (this.c.get('crashMovieFps')) {
             if (this.frame % 2 !== 0) return; // Skip update on odd frames to simulate 30fps visual hold
             step = 2; // Advance state by 2x to maintain duration
        }
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        this.durationSeconds = this.c.get('crashDurationSeconds') || 30;
        const progress = elapsedTime / this.durationSeconds;
        this.sheetFadeVal = Math.min(1.0, this.sheetFadeVal + (step / 45.0));
        const sheetOpacity = this.c.get('crashSheetOpacity');
        this.MAX_BLACK_LEVEL = sheetOpacity; 
        // Trigger End Effect (Deja Vu)
        if (progress > 0.92 && !this.endFlashTriggered) {
            this.endFlashTriggered = true;
            if (this.registry) {
                const remainingSeconds = (1.0 - progress) * this.durationSeconds;
                // Add small buffer to ensure overlap/fade out completes smoothly
                this.registry.trigger('DejaVu', remainingSeconds + 1.0);
            }
        }
        // --- END ---
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('effectShader', null); // Clear Effect Shader
            this.snapshotOverlay.clear();
            this.blackSheets = [];
            this.crashBars = [];
            this.supermanState.cells.clear();
            this.supermanState.illuminatedCells.clear();
            this.supermanState.geometry = null;
            return;
        }
        // --- FLASH & FADE LOGIC ---
        const enableFlash = this.c.get('crashEnableFlash');
        if (enableFlash) {
            this.baseBlackLevel = this.MAX_BLACK_LEVEL * this.sheetFadeVal;
            if (this.flashState.active) {
                this.flashState.timer += step;
                const p = Math.min(1.0, this.flashState.timer / this.flashState.duration);
                this.c.set('effectParameter', 10.0 + p);
                if (this.flashState.timer >= 1 && this.flashState.timer < 1 + step) this.sheetFadeVal = 0.0; // Trigger once
                if (this.flashState.timer >= this.flashState.duration) {
                    this.flashState.active = false;
                    this.c.set('effectParameter', 0.0);
                }
            } else {
                this.flashState.nextFlash -= step;
                if (this.flashState.nextFlash <= 0) this._triggerFlash();
            }
        } else {
            this.baseBlackLevel = 0.0;
            this.c.set('effectParameter', 0.0);
        }
        // --- SHADERS ---
        if (!this.flashState.active) {
            if (this.shaderState.activeId === 0) {
                 if (Math.random() < 0.01 * step) { // Adjust probability for step
                    const r = Math.random();
                    let id = 0; let dur = 0;
                    if (r < 0.3) { id = 3; dur = 20; } // These IDs need to match shader code or be unused
                    else if (r < 0.6) { id = 9; dur = 30; } // Phase 9 is implemented
                    else { id = 2; dur = 40; } // Phase 2 is implemented
                    if (id === 2 || id === 9) {
                        this.shaderState.activeId = id;
                        this.shaderState.duration = dur;
                        this.shaderState.timer = 0;
                    }
                 }
            } else {
                this.shaderState.timer += step;
                if (this.shaderState.timer >= this.shaderState.duration) {
                    this.shaderState.activeId = 0;
                    this.c.set('effectParameter', 0.0);
                } else {
                    const p = this.shaderState.timer / this.shaderState.duration;
                    this.c.set('effectParameter', this.shaderState.activeId + p);
                }
            }
        }
        // --- BLACK SHEETS ---
        const maxSheets = this.c.get('crashSheetCount');
        this.sheetState.timer -= step;
        if (this.sheetState.timer <= 0) {
            this.sheetState.spawning = !this.sheetState.spawning;
            this.sheetState.timer = this.sheetState.spawning ? 400 : 200; 
        }
        // Always call _updateBlackSheets to handle movement/wrapping, even if not spawning
        this._updateBlackSheets(this.sheetState.spawning ? maxSheets : 0, step);
        if (this.blackSheets.length > maxSheets) this.blackSheets.splice(maxSheets);
        // --- SUPERMAN (Lightning) ---
        if (this.c.get('crashEnableSuperman')) {
            if (this.supermanState.active) {
                this.supermanState.globalTimer -= step;
                // Update at 30fps logic matches our update frequency now
                this._generateSupermanBolt();
                if (this.supermanState.globalTimer <= 0) {
                    // Transition Active Reveal to Fading
                    if (this.supermanState.activeReveal) {
                        this.supermanState.fadingReveals.push(this.supermanState.activeReveal);
                        this.supermanState.activeReveal = null;
                    }
                    this.supermanState.active = false;
                    this.supermanState.cells.clear();
                    this.supermanState.geometry = null;
                }
            } else {
                // Random trigger
                if (Math.random() < 0.02 * step) { // Adjust prob
                    const type = Math.random() < 0.5 ? 0 : 1; 
                    this._triggerSuperman(type);
                }
            }
        } else {
            this.supermanState.active = false;
        }
        // Update Fading Triangles (Reveals)
        for (let i = this.supermanState.fadingReveals.length - 1; i >= 0; i--) {
            const t = this.supermanState.fadingReveals[i];
            t.alpha -= 0.01 * step; // Fade out speed adjusted
            if (t.alpha <= 0) {
                this.supermanState.fadingReveals.splice(i, 1);
            }
        }
        // --- OTHER ELEMENTS ---
        this._updateSnapshots();
        // Update Crash Bars
        for (let i = this.crashBars.length - 1; i >= 0; i--) {
            const b = this.crashBars[i];
            b.age += step;
            if (b.age > b.maxAge) {
                this.crashBars.splice(i, 1);
            }
        }
        if (Math.random() < 0.02 * step) this._triggerWhiteBlock(); 
        if (Math.random() < 0.02 * step) this._triggerColumnBurst(); 
        if (this.c.get('crashEnableSmith')) {
            if (!this.smithState.triggered && Math.random() < 0.001 * step) { 
                this._triggerSmith();
            }
            if (this.smithState.active) {
                this.smithState.timer -= step;
                if (this.smithState.timer <= 0) this.smithState.active = false;
            }
        }
        if (this.registry) {
            if (Math.random() < 0.001 * step) this.registry.trigger('ClearPulse');
        }
    }
    applyToGrid(grid) {
        if (!this.active) return;
        const cols = grid.cols;
        const rows = grid.rows;
        // 1. Black Sheets - GPU HANDLED (Mask Texture)
        // 2. Superman Lightning (Updated)
        if (this.supermanState.active) {
            const tracerColor = this.c.derived.tracerColorUint32;
            // Triangle Reveals are now GPU HANDLED via getReveals() / Shadow Mask Punch-out
            // Render Main Bolt (Foreground)
            if (this.supermanState.cells.size > 0) {
                for (const idx of this.supermanState.cells) {
                    const char = grid.getChar(idx);
                    if (char !== ' ') {
                        // Bolt: Tracer Color, High Glow
                        grid.setHighPriorityEffect(idx, char, tracerColor, 1.0, grid.fontIndices[idx], 1.0);
                    }
                }
            }
        }
        // 3. Crash Bars (Deja Vu Bars) - Updated Logic
        if (this.crashBars.length > 0) {
            // Requirement: "White again" -> Pure White Target
            const tR = 255; 
            const tG = 255; 
            const tB = 255;
            for (const bar of this.crashBars) {
                // Render Blocks function
                const renderBlock = (y, h, currentAge, isTopBlock) => {
                    if (currentAge < 0) return;
                    const glitchDuration = 9; 
                    const flashDuration = 4;
                    const fadeStart = glitchDuration + flashDuration;
                    let blockAlpha = 0;
                    let isGlitching = false;
                    let isFlashing = false;
                    // Phase Logic
                    if (currentAge < glitchDuration) {
                        // Phase 1: Glitch In
                        isGlitching = bar.shouldGlitch;
                        blockAlpha = 1.0;
                    } else if (currentAge < fadeStart) {
                        // Phase 2: Flash / Distortion
                        isFlashing = true;
                        blockAlpha = 1.0;
                    } else {
                        // Phase 3: Fade Out
                        // Fixed fade duration to ensure consistency regardless of offsets
                        const fadeLen = 15; 
                        blockAlpha = 1.0 - ((currentAge - fadeStart) / fadeLen);
                    }
                    if (blockAlpha <= 0) return;
                    const limitY = Math.min(rows, y + h);
                    const limitX = Math.min(cols, bar.x + bar.w);
                    for (let r = y; r < limitY; r++) {
                        // GLITCH GEOMETRY LOGIC
                        if (isGlitching) {
                            // 1. A/B Toggle for Split blocks (Type 1)
                            if (bar.type === 1) {
                                const phase = Math.floor(currentAge / 3) % 2; 
                                if (isTopBlock && phase === 1) continue;
                                if (!isTopBlock && phase === 0) continue;
                            }
                            // 2. Partial Row Rendering (Scanline/Noise) - REMOVED per user request
                            // if ((r + currentAge) % 3 !== 0) continue; 
                        }
                        const rowOffset = r * cols;
                        for (let x = bar.x; x < limitX; x++) {
                            // DISTORTION LOGIC (Flash Phase)
                            let targetX = x;
                            if (isFlashing) {
                                // Horizontal Shredding
                                if (Math.random() < 0.3) {
                                    targetX = x + (Math.random() < 0.5 ? -1 : 1) * Utils.randomInt(1, 3);
                                }
                                // Vertical Jitter (Row shift)
                                if (Math.random() < 0.1) {
                                    // Visual effect only, doesn't change `idx` calc below unless we refactor
                                    // For now, let's stick to X distortion to avoid bounds checking hell
                                }
                            }
                            if (targetX < 0 || targetX >= cols) continue;
                            const idx = rowOffset + targetX;
                            // 1. Alpha Variance
                            const hash = Math.sin(idx * 12.9898 + bar.id) * 43758.5453;
                            const rnd = hash - Math.floor(hash);
                            let finalAlpha = blockAlpha; 
                            // Add slight noise to edges
                            if (!isFlashing && rnd > 0.9) finalAlpha *= 0.8;
                            if (finalAlpha <= 0.01) continue;
                            // 2. Flash in together
                            const liveAlpha = grid.alphas[idx];
                            const liveChar = grid.chars[idx];
                            const liveColor = grid.colors[idx];
                            const fontIdx = grid.fontIndices[idx];
                            let charStr, displayFont;
                            if (liveAlpha > 0.01) {
                                charStr = String.fromCharCode(liveChar);
                                displayFont = fontIdx;
                            } else if (this.snap && this.snap.alphas[idx] > 0.01) {
                                const charSeed = (idx ^ Math.floor(bar.id)) * 7.123;
                                const charCode = Utils.CHARS.charCodeAt(Math.floor((charSeed - Math.floor(charSeed)) * Utils.CHARS.length));
                                charStr = String.fromCharCode(charCode);
                                displayFont = 0;
                            } else {
                                continue; 
                            }
                            // 3. Bright White Blending
                            let mR, mG, mB;
                            if (isFlashing) {
                                // Pure White during flash
                                mR = 255; mG = 255; mB = 255;
                            } else {
                                const lR = liveColor & 0xFF; 
                                const lG = (liveColor >> 8) & 0xFF; 
                                const lB = (liveColor >> 16) & 0xFF;
                                const blendWeight = 0.9; // Mostly Target (White)
                                mR = Math.floor(lR + (tR - lR) * blendWeight);
                                mG = Math.floor(lG + (tG - lG) * blendWeight);
                                mB = Math.floor(lB + (tB - lB) * blendWeight);
                            }
                            const finalColor = Utils.packAbgr(mR, mG, mB);
                            // Force High Alpha for "White" look
                            grid.setHighPriorityEffect(idx, charStr, finalColor, 1.0, displayFont, 1.0 * finalAlpha); 
                        }
                    }
                };
                // Render based on Type
                if (bar.type === 1) {
                    renderBlock(bar.y, bar.subH, bar.age, true); // Top (Normal time)
                    renderBlock(bar.y + bar.subH + 17, bar.subH, bar.age - 6, false); // Bottom (Offset by 6 frames)
                } else if (bar.type === 2) {
                    let renderY = bar.y;
                    if (bar.age > 8) renderY = bar.y + 6;
                    renderBlock(renderY, bar.subH, bar.age, true);
                } else {
                    renderBlock(bar.y, bar.subH, bar.age, true);
                }
            }
        }
        // 4. Snapshots (Smith)
        for (const [idx, snap] of this.snapshotOverlay) {
             if (snap.alpha <= 0.01) continue;
             // Smith is now handled as a Shadow Mask, do not render as override
             if (snap.isSmith) continue; 
             const char = snap.char;
             // Snap color is stored as hex string
             const color = Utils.hexToRgb(snap.color);
             const packedColor = Utils.packAbgr(color.r, color.g, color.b);
             grid.setOverride(idx, char, packedColor, snap.alpha, grid.fontIndices[idx], snap.isSmith ? 0 : 8.0);
        }
    }
    _triggerFlash() {
        this.flashState.active = true;
        this.flashState.timer = 0;
        this.flashState.duration = 40; 
        const minS = this.c.get('crashFlashDelayMin');
        const maxS = this.c.get('crashFlashDelayMax');
        this.flashState.nextFlash = (minS + Math.random() * (maxS - minS)) * 60; 
    }
    _updateBlackSheets(maxSheets, step = 1) {
        // Fill up to maxSheets immediately
        while (this.blackSheets.length < maxSheets) { 
            const grid = this.g;
            // Generate dimensions (4 to 16)
            const w = Utils.randomInt(4, 16);
            const h = Utils.randomInt(4, 16);
            let c = Math.floor(Math.random() * (grid.cols - w));
            let row = Math.floor(Math.random() * (grid.rows - h));
            // Orthogonal Movement Logic
            const speedScale = (Math.random() * 1.5 + 0.5); 
            let dx = 0;
            let dy = 0;
            // Configurable Chance to be stationary
            const stationaryChance = this.c.get('crashStationaryChance') / 100.0;
            if (Math.random() > stationaryChance) {
                const axis = Math.random() < 0.5 ? 'x' : 'y';
                const dir = Math.random() < 0.5 ? 1 : -1;
                dx = axis === 'x' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
                dy = axis === 'y' ? (0.2 + Math.random() * 0.3) * speedScale * dir : 0;
            }
            const maxAlpha = this.c.get('crashSheetOpacity');
            this.blackSheets.push({ 
                c, r: row, w, h,
                posX: c, posY: row, 
                baseDx: dx, 
                baseDy: dy, 
                targetW: w, targetH: h, 
                // Requirement 1: Immediate Spawn (No Fade In)
                currentAlpha: maxAlpha, 
                targetAlpha: maxAlpha, 
                maxAlpha: maxAlpha,
                blur: 0.0
            });
        }
        // Update Position & Wrapping
        for (const s of this.blackSheets) {
            // Update Alpha (Fade Out logic handled by sheetFadeVal globally, but per-sheet fade-in removed)
            s.maxAlpha = this.c.get('crashSheetOpacity') * this.sheetFadeVal;
            s.currentAlpha = s.maxAlpha; 
            // Move
            s.posX += s.baseDx * this.c.get('crashSheetSpeed') * step;
            s.posY += s.baseDy * this.c.get('crashSheetSpeed') * step;
            // Wrapping Logic (Requirement 2)
            if (s.posX > this.g.cols) s.posX -= this.g.cols;
            if (s.posX + s.w < 0) s.posX += this.g.cols;
            if (s.posY > this.g.rows) s.posY -= this.g.rows;
            if (s.posY + s.h < 0) s.posY += this.g.rows;
        }
    }
    // New Generic Interface for Renderer (Requirement 4: Layering/Wrapping Visuals)
    getMasks() {
        if (!this.active) return [];
        const masks = [];
        const cols = this.g.cols;
        const rows = this.g.rows;
        // 1. Black Sheets
        for (const s of this.blackSheets) {
            // Main Body
            masks.push({
                x: s.posX, y: s.posY, w: s.w, h: s.h,
                alpha: s.currentAlpha, blur: s.blur
            });
            // Horizontal Wrapping Ghost
            if (s.posX + s.w > cols) {
                masks.push({
                    x: s.posX - cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posX < 0) {
                 masks.push({
                    x: s.posX + cols, y: s.posY, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
            // Vertical Wrapping Ghost
            if (s.posY + s.h > rows) {
                masks.push({
                    x: s.posX, y: s.posY - rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            } else if (s.posY < 0) {
                masks.push({
                    x: s.posX, y: s.posY + rows, w: s.w, h: s.h,
                    alpha: s.currentAlpha, blur: s.blur
                });
            }
        }
        // 2. Smith Shadow Masks
        for (const [idx, snap] of this.snapshotOverlay) {
            if (snap.isSmith && snap.alpha > 0.01) {
                const x = idx % cols;
                const y = Math.floor(idx / cols);
                // Combine fade alpha (snap.alpha) with density alpha (snap.densityAlpha)
                const combinedAlpha = snap.alpha * (snap.densityAlpha || 0.5);
                masks.push({
                    x: x, y: y, w: 1, h: 1,
                    alpha: combinedAlpha, 
                    blur: 0.1 // Crisp blocks for pixelated look
                });
            }
        }
        return masks;
    }
    _getFontName(i) {
        const fontIdx = this.g.fontIndices[i];
        const fonts = this.c.derived.activeFonts;
        return (fonts && fonts[fontIdx]) ? fonts[fontIdx].name : this.c.state.fontFamily;
    }
    _triggerSmith() {
        this.smithState.triggered = true;
        this.smithState.active = true;
        this.smithState.timer = 30; // Halved
        this._triggerFlash();
        // Mapping ASCII density to Shadow Mask Alpha
        // @ (100) -> 1.0 (Darkest/Solid)
        // . (5)   -> 0.1 (Lightest)
        const densityAlphaMap = {
            '@': 1.0, '%': 0.9, '#': 0.8,
            '*': 0.6, '+': 0.5, '=': 0.4,
            ':': 0.3, '-': 0.2, '.': 0.1
        };
        const asciiArt = [
            "                                      *##*#*####+                                        ",
            "                                   # @@@%%#%%%%%##*-                                      ",
            "                                  % @%%#*+**+=::=*+-=:                                    ",
            "                                 % @#+                -#                                  ",
            "                                = @#=                  .%                                 ",
            "                                @@#-                   +=                                ",
            "                               = @@%*-:                 + @                                ",
            "                               * @@@#=:.               .+ @                                ",
            "                               * @@@*-                  = @                                ",
            "                               : @@@+-=#@@@@@@@*-+%@@@@@%=                                ",
            "                               -+%%+-*% @@@@@@@.  % @@@%%%%                                ",
            "                              :***%+-:-% @@@@%=   .#%%#*#=                                ",
            "                               :-:*+-:..-++-=     ===-:+:                                ",
            "                                --*#+++=-...-+%###:-===+                                 ",
            "                                 :=**++=--.  :*#*.   :+                                  ",
            "                                   =*+++=-    -===.  .-                                  ",
            "                                   *##**+-+**+.     :-                                   ",
            "                                   **#####**########*                                    ",
            "                                   +*######*+=--.  -*                                    ",
            "                                   +*+*#####********+                                    ",
            "                                   # -++########*#*++ .                                  ",
            "                                 .%*    =*#######*+-  ++                                 ",
            "                              .*#%%#-      =####**    ++=-=.                             ",
            "                         :=+***##%%##        .***     +++=--===--:                       ",
            "                  +++++++++*+*########       :###%    ++++==-+======--                   ",
            "               +***++++++++++****####**      #%**#+    *+++***+====+++++==               ",
            "            =*+*+++++++++++++*%%#*##***+      #**      =++++*++==+********+              ",
            "            %#*++++*++++**+++++*#*#****+      ++*       +++++++++******####*             ",
            "            ###*+++**+++***+++*+++******+     ++*#      -=+++++++*****#%%%##:            ",
            "            ####**+***+++***++#*+++*****+:    =+*##     .=++++==+*****#%%%#%%            ",
            "           -#####******+++****+*++++*****+    =+*##*     =+++===+*#**##%%%#%%-           ",
            "           *%#######***+++*****+*+++++****+   -***#**    =+++===+*#**##%%%% @%%           ",
            "           #%#*###*##***+++*****+#+++++****=  :*#####=   -=++===**#*##%%%%%%%%           ",
            "           #%#*##%##%#**++++****++#+++++***+   =++++++    =++===*#####%%%% @@%%           "
        ];
        const grid = this.g;
        const artHeight = asciiArt.length;
        const artWidth = asciiArt[0].length; 
        const startR = Math.floor((grid.rows - artHeight) / 2);
        const startC = Math.floor((grid.cols - artWidth) / 2);
        const endFrame = this.frame + 90;
        const borderMap = new Map(); // Store border indices to avoid duplicates
        for (let r = 0; r < artHeight; r++) {
            const line = asciiArt[r];
            const rowIdx = startR + r;
            if (rowIdx < 0 || rowIdx >= grid.rows) continue;
            for (let c = 0; c < line.length; c++) {
                const char = line[c];
                const colIdx = startC + c;
                if (colIdx < 0 || colIdx >= grid.cols) continue;
                const i = rowIdx * grid.cols + colIdx;
                if (char === ' ') {
                    // Check if this empty space is a border (has a non-empty neighbor)
                    // We check purely based on the source ASCII art for shape consistency
                    let isBorder = false;
                    const neighbors = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];
                    for (const [dr, dc] of neighbors) {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < artHeight && nc >= 0 && nc < artWidth) {
                            if (asciiArt[nr][nc] !== ' ') {
                                isBorder = true;
                                break;
                            }
                        }
                    }
                    if (isBorder) {
                         borderMap.set(i, {
                            densityAlpha: 0.15, // Subtle outline
                            alpha: 1.0, 
                            endFrame: endFrame, 
                            isSmith: true
                        });
                    }
                    continue; 
                }
                // Get Density Alpha
                const density = densityAlphaMap[char] || 0.2;
                this.snapshotOverlay.set(i, {
                    densityAlpha: density,
                    alpha: 1.0, // Fade Alpha
                    endFrame: endFrame, 
                    isSmith: true
                });
            }
        }
        // Apply borders
        for (const [key, val] of borderMap) {
            if (!this.snapshotOverlay.has(key)) {
                this.snapshotOverlay.set(key, val);
            }
        }
    }
    _getStaticChar(idx) {
        // Deterministic pseudo-random character based on index and current bolt
        // Simple hash: (idx * magic1 + boltId * magic2) % len
        const seed = Math.floor(idx * 137 + this.supermanState.boltId * 997);
        const charSet = Utils.CHARS;
        return charSet[seed % charSet.length];
    }
    _triggerSuperman(type) {
        this.supermanState.active = true;
        this.supermanState.type = type; 
        this.supermanState.globalTimer = 30; // Halved
        this.supermanState.flickerTimer = 0;
        this.supermanState.boltId = Math.random() * 1000; // Unique ID for this bolt instance
        this._generateSupermanBolt();
    }
    _generateSupermanBolt() {
        const s = this.supermanState;
        s.cells.clear();
        if (!s.geometry) {
            this._initSupermanGeometry();
            // Initialize active reveal for this new bolt
            s.activeReveal = { 
                type: 'rects', 
                rects: [], 
                alpha: 1.0 
            };
        }
        const g = s.geometry;
        // Draw Main Path (Populates s.cells)
        this._drawJaggedLine(g.start.x, g.start.y, g.end.x, g.end.y, s.cells, 2);
        // Draw Branches (Populates s.cells)
        if (g.branches) {
            for (const b of g.branches) {
                this._drawJaggedLine(g.split.x, g.split.y, b.x, b.y, s.cells, 1);
            }
        }
        // Calculate Border Cells (1 char away)
        if (s.activeReveal) {
            const cols = this.g.cols;
            const rows = this.g.rows;
            const borderSet = new Set();
            const borderRects = [];
            for (const idx of s.cells) {
                const cx = idx % cols;
                const cy = Math.floor(idx / cols);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            const nIdx = ny * cols + nx;
                            if (!s.cells.has(nIdx) && !borderSet.has(nIdx)) {
                                borderSet.add(nIdx);
                                borderRects.push({ x: nx, y: ny, w: 1, h: 1 });
                            }
                        }
                    }
                }
            }
            s.activeReveal.rects = borderRects;
        }
    }
    _initSupermanGeometry() {
        const grid = this.g;
        const s = this.supermanState;
        // 1. Pick Start/End Corners
        const corners = [
            { x: 0, y: 0 }, // TL
            { x: grid.cols - 1, y: 0 }, // TR
            { x: grid.cols - 1, y: grid.rows - 1 }, // BR
            { x: 0, y: grid.rows - 1 } // BL
        ];
        const startIdx = Utils.randomInt(0, 3);
        const endIdx = (startIdx + 2) % 4; // Opposite corner
        const start = corners[startIdx];
        const end = corners[endIdx];
        s.geometry = { start, end };
        // Type 1: Branching
        if (s.type === 1) {
            // Split Point (35-40%)
            const splitT = 0.35 + (Math.random() * 0.05);
            const splitX = Math.floor(start.x + (end.x - start.x) * splitT);
            const splitY = Math.floor(start.y + (end.y - start.y) * splitT);
            s.geometry.split = { x: splitX, y: splitY };
            // Calculate Main Bolt Angle
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const mainAngle = Math.atan2(dy, dx);
            const branches = [];
            const numBranches = Utils.randomInt(1, 3);
            let furthestBranch = null;
            let maxDist = -1;
            // Define adjacent edges for the END corner
            for (let i = 0; i < numBranches; i++) {
                let tx, ty;
                let attempts = 0;
                let valid = false;
                while (!valid && attempts < 10) {
                    attempts++;
                    const useHorizontal = Math.random() < 0.5;
                    if (useHorizontal) {
                        ty = end.y;
                        tx = Utils.randomInt(0, grid.cols - 1);
                    } else {
                        tx = end.x;
                        ty = Utils.randomInt(0, grid.rows - 1);
                    }
                    // Check Angle Constraint (< 50 deg)
                    const bDx = tx - splitX;
                    const bDy = ty - splitY;
                    const branchAngle = Math.atan2(bDy, bDx);
                    let diff = Math.abs(branchAngle - mainAngle);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff; // Normalize to 0..PI
                    const deg = diff * (180 / Math.PI);
                    if (deg < 50) {
                        valid = true;
                    }
                }
                if (valid) {
                    const bPoint = { x: tx, y: ty };
                    branches.push(bPoint);
                    const d = Math.hypot(tx - splitX, ty - splitY);
                    if (d > maxDist) {
                        maxDist = d;
                        furthestBranch = bPoint;
                    }
                }
            }
            s.geometry.branches = branches;
        }
    }
    getReveals() {
        const reveals = [...this.supermanState.fadingReveals];
        if (this.supermanState.activeReveal) {
            reveals.push(this.supermanState.activeReveal);
        }
        return reveals;
    }
    _drawJaggedLine(x0, y0, x1, y1, set, baseThickness = 1) {
        const points = [];
        // Elastic / Arcing Lightning with Time-Based Animation
        const dist = Math.hypot(x1 - x0, y1 - y0);
        const steps = Math.ceil(dist * 0.8); // High resolution for smooth arcs
        // Perpendicular Vector for displacement
        const dx = x1 - x0;
        const dy = y1 - y0;
        const nx = -dy / dist; // Normalized Perpendicular X
        const ny = dx / dist;  // Normalized Perpendicular Y
        let px = x0;
        let py = y0;
        const time = this.frame * 0.3; 
        const seed = this.supermanState.boltId; 
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            let tx = x0 + dx * t;
            let ty = y0 + dy * t;
            const thickness = baseThickness;
            // Chaotic Displacement
            const arc1 = Math.sin(t * Math.PI + seed + time * 0.5) * 4.0;
            const arc2 = Math.sin(t * Math.PI * 4.0 + seed * 2.0 - time * 1.5) * 2.0;
            const jitter = Math.sin(t * Math.PI * 25.0 + time * 8.0) * 0.8;
            const noise = (Math.random() - 0.5) * 1.2;
            const envelope = Math.sin(t * Math.PI); 
            const displacement = (arc1 + arc2 + jitter + noise) * envelope * 2.0;
            tx += nx * displacement;
            ty += ny * displacement;
            points.push({x: tx, y: ty}); // Capture point
            if (i > 0) {
                this._drawLine(px, py, tx, ty, set, thickness);
            }
            px = tx;
            py = ty;
        }
        return points;
    }
    _drawLine(x0, y0, x1, y1, set, thickness = 1) {
        // Bresenham-like algorithm for connected line
        let x = Math.floor(x0);
        let y = Math.floor(y0);
        const endX = Math.floor(x1);
        const endY = Math.floor(y1);
        const dx = Math.abs(endX - x);
        const dy = Math.abs(endY - y);
        const sx = (x < endX) ? 1 : -1;
        const sy = (y < endY) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            // Apply thickness by adding neighbors
            for (let ox = 0; ox < thickness; ox++) {
                for (let oy = 0; oy < thickness; oy++) {
                    const cx = x + ox;
                    const cy = y + oy;
                    if (cx >= 0 && cx < this.g.cols && cy >= 0 && cy < this.g.rows) {
                        set.add(cy * this.g.cols + cx);
                    }
                }
            }
            if (x === endX && y === endY) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                y += sy;
            }
        }
    }
    _triggerWhiteBlock() {
        if (this.crashBars.length > 0) return;
        const grid = this.g;
        // Random Type: 0, 1, 2
        const type = Math.floor(Math.random() * 3);
        // Requirement: Blocks strictly 10-12 chars high
        const subH = Utils.randomInt(10, 12);
        let h = subH;
        if (type === 1) h = subH * 2 + 17; // Two blocks + gap
        const r = Math.floor(Math.random() * (grid.rows - h));
        // Requirement: Always span the full width, random height only
        const w = grid.cols;
        const x = 0;
        let duration = 15; // Shorter duration for standard blocks
        if (type === 1) duration = 40; // Longer duration for split blocks to accommodate offset & flash phases
        this.crashBars.push({
            x: x, 
            y: r,
            w: w, 
            h: h,
            subH: subH, // Store the actual block height
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000,
            type: type,
            // User Request: Flickering happens only occasionally
            shouldGlitch: Math.random() < 0.3
        });
    }
    _triggerColumnBurst() {
        const grid = this.g;
        const col = Math.floor(Math.random() * grid.cols);
        let startRow = Math.floor(Math.random() * (grid.rows / 2)); 
        let height = Math.floor(Math.random() * (grid.rows / 2)) + (grid.rows / 4);
        if (Math.random() < 0.3) { startRow = 0; height = grid.rows; }
        const duration = 4; // Halved
        this.crashBars.push({
            x: col, 
            y: startRow,
            w: 1, 
            h: height,
            age: 0,
            maxAge: duration,
            id: Math.random() * 10000 
        });
    }
    _updateSnapshots() {
        const currentFrame = this.frame; 
        for (const [index, snapshot] of this.snapshotOverlay.entries()) {
            if (currentFrame > snapshot.endFrame) this.snapshotOverlay.delete(index);
            else {
                const rem = snapshot.endFrame - currentFrame;
                if (snapshot.isSmith) { 
                    // Slower fade for Smith to stand out in the dark (40 frame fade)
                    if (rem < 40) snapshot.alpha = rem / 40.0; 
                } 
                else { if (rem < 10) snapshot.alpha = rem / 10.0; }
            }
        }
    }
}
// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); 
        this.name = "DejaVu"; 
        this.active = false; 
        this.autoTimer = c.state.dejaVuFrequencySeconds * 60; 
        this.map = null;
        this.bars = [];
        // Sub-effect states
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Shader State
        this.shaderActive = false;
    }
    trigger(durationSeconds = null) { 
        if(this.active) return false; 
        this.active = true; 
        const seconds = durationSeconds || this.c.state.dejaVuDurationSeconds;
        this.timer = seconds * 60; 
        this.bars = []; 
        this.map = new Uint8Array(this.g.rows); 
        // Reset sub-effects
        this.vertGlitch = { active: false, timer: 0, srcX: 0, width: 4 };
        this.doubleGlitch = { active: false, timer: 0, startY: 0, h: 0, shiftX: 0 };
        this.horizGlitch = { active: false, timer: 0, rows: [], shift: 0, flash: false };
        // Enable Glitch Shader
        this._enableShader();
        return true; 
    }
    _enableShader() {
        if (this.shaderActive) return;
        const glitchShader = `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
varying vec2 vTexCoord;
float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
void main() {
    vec2 uv = vTexCoord;
    vec4 color = texture2D(uTexture, uv);
    float t = floor(uTime * 15.0);
    if (rand(vec2(t, 1.0)) > 0.95) {
        float ry = rand(vec2(t, 2.0));
        float rh = rand(vec2(t, 3.0)) * 0.15; 
        if (uv.y > ry && uv.y < ry + rh) {
             float shift = (rand(vec2(t, 4.0)) - 0.5) * 0.02;
             float r = texture2D(uTexture, vec2(uv.x + shift + 0.003, uv.y)).r;
             float g = texture2D(uTexture, vec2(uv.x + shift, uv.y)).g;
             float b = texture2D(uTexture, vec2(uv.x + shift - 0.003, uv.y)).b;
             float a = texture2D(uTexture, vec2(uv.x + shift, uv.y)).a;
             color = vec4(r, g, b, a);
             if (rand(vec2(t, 5.0)) > 0.8) {
                float dir = (rand(vec2(t, 6.0)) > 0.5) ? 1.0 : -1.0;
                float jump = dir * (0.03 + rand(vec2(t, 7.0)) * 0.04);
                color = texture2D(uTexture, vec2(uv.x + jump, uv.y));
             }
        }
    }
    gl_FragColor = color;
}
`;
        this.c.set('effectShader', glitchShader);
        this.shaderActive = true;
    }
    _disableShader() {
        if (!this.shaderActive) return;
        this.c.set('effectShader', null);
        this.shaderActive = false;
    }
    update() {
        const s = this.c.state;
        if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
        if(!this.active) return;
        if(this.timer-- <= 0) { 
            this.active = false; 
            this.bars = []; 
            this.map = null; 
            this._disableShader();
            return; 
        }
        this.map.fill(0);
        if(Math.random() < s.dejaVuIntensity) {
            const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); 
            const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
            const duration = s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10);
            this.bars.push({ y, h, age: 0, maxAge: duration });
            if (this.g.glowSystem) {
                this.g.glowSystem.addRect(
                    this.g.cols / 2, y + (h / 2), this.g.cols, h, 2.0, this.c.derived.streamColorUint32, duration, 'linear', 4
                );
            }
        }
        const activeFonts = this.c.derived.activeFonts;
        const glitchCount = Math.max(1, Math.floor(this.g.cols * 0.05));
        const cols = this.g.cols;
        const rows = this.g.rows;
        const randomizeColors = s.dejaVuRandomizeColors;
        for(let i=this.bars.length-1; i>=0; i--) {
            const b = this.bars[i]; 
            b.age++;
            if(b.age > b.maxAge) { this.bars.splice(i, 1); continue; } 
            const limit = Math.min(rows, b.y + b.h);
            for(let r=b.y; r < limit; r++) {
                this.map[r] = 1; 
                for(let k=0; k<glitchCount; k++) {
                    const x = (Math.random() * cols) | 0;
                    const idx = r * cols + x;
                    this.g.mix[idx] = 0; 
                    const fontIdx = (Math.random() * activeFonts.length) | 0;
                    const fontData = activeFonts[fontIdx];
                    if (fontData.chars.length > 0) {
                        const char = fontData.chars[(Math.random() * fontData.chars.length) | 0];
                        let color = this.g.colors[idx];
                        const alpha = this.g.alphas[idx];
                        const glow = this.g.glows[idx];
                        if(randomizeColors) {
                            const h = (Math.random() * 360) | 0;
                            const rgb = Utils.hslToRgb(h, 90, 70);
                            color = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                            this.g.complexStyles.set(idx, { h, s: 90, l: 70, glitched: true });
                            this.g.baseColors[idx] = color;
                        }
                        this.g.setPrimary(idx, char, color, alpha, fontIdx, glow);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            this.vertGlitch.timer--;
            if (this.vertGlitch.timer <= 0) this.vertGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.vertGlitch.active = true;
                this.vertGlitch.timer = 15; 
                this.vertGlitch.width = Utils.randomInt(4, 7);
                this.vertGlitch.srcX = Utils.randomInt(0, this.g.cols - this.vertGlitch.width);
            }
        }
        if (this.doubleGlitch.active) {
            this.doubleGlitch.timer--;
            if (this.doubleGlitch.timer <= 0) this.doubleGlitch.active = false;
        } else {
            if (Math.random() < 0.015) {
                this.doubleGlitch.active = true;
                this.doubleGlitch.timer = Utils.randomInt(5, 15);
                this.doubleGlitch.h = Math.floor(this.g.rows / 3);
                this.doubleGlitch.startY = Utils.randomInt(0, this.g.rows - this.doubleGlitch.h);
                this.doubleGlitch.shiftX = Utils.randomInt(5, 20) * (Math.random() < 0.5 ? 1 : -1);
            }
        }
        if (this.horizGlitch.active) {
            this.horizGlitch.timer--;
            if (this.horizGlitch.timer <= 0) this.horizGlitch.active = false;
        } else {
            if (Math.random() < 0.005) {
                this.horizGlitch.active = true;
                this.horizGlitch.timer = Utils.randomInt(5, 10);
                this.horizGlitch.shift = Utils.randomInt(3, 10) * (Math.random() < 0.5 ? 1 : -1);
                this.horizGlitch.flash = Math.random() < 0.5;
                this.horizGlitch.rows = [];
                const count = Utils.randomInt(5, 20);
                for(let i=0; i<count; i++) {
                    this.horizGlitch.rows.push(Utils.randomInt(0, this.g.rows-1));
                }
            }
        }
    }
    applyToGrid(grid) {
        if(!this.active) return;
        if (!this.map) return;
        const s = this.c.state; 
        const d = this.c.derived;
        const cols = grid.cols;
        const tracerColor = d.tracerColorUint32;
        const holeBrightness = s.dejaVuHoleBrightness;
        const activeFonts = d.activeFonts;
        const fallbackFontIdx = 0;
        const fallbackChars = activeFonts[0].chars;
        const timeSeed = Math.floor(Date.now() / 150);
        for (let y = 0; y < grid.rows; y++) {
            if (this.map[y] === 1) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const baseAlpha = grid.alphas[i];
                    const char = grid.getChar(i);
                    const fontIdx = grid.fontIndices[i];
                    if (baseAlpha < 0.01) {
                        if (holeBrightness > 0.01) {
                            if (fallbackChars && fallbackChars.length > 0) {
                                const hash = (i ^ timeSeed) * 2654435761;
                                const rndIdx = (hash & 0x7FFFFFFF) % fallbackChars.length;
                                grid.setOverride(i, fallbackChars[rndIdx], tracerColor, holeBrightness, fallbackFontIdx, 0);
                            } else {
                                grid.setOverride(i, char, tracerColor, holeBrightness, fallbackFontIdx, 0);
                            }
                        }
                    } else {
                        grid.setOverride(i, char, tracerColor, baseAlpha, fontIdx, 0);
                    }
                }
            }
        }
        if (this.vertGlitch.active) {
            const { srcX, width } = this.vertGlitch;
            for (let y = 0; y < grid.rows; y++) {
                if (this.map[y] !== 1) continue;
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    const readX = srcX + (x % width);
                    if (readX >= cols) continue;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor; 
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.doubleGlitch.active) {
            const { startY, h, shiftX } = this.doubleGlitch;
            const endY = Math.min(grid.rows, startY + h);
            for (let y = startY; y < endY; y++) {
                const rowOffset = y * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shiftX;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    const char = grid.getChar(readIdx);
                    const alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    const color = tracerColor;
                    grid.setOverride(i, char, color, alpha, fontIdx, grid.glows[readIdx]);
                }
            }
        }
        if (this.horizGlitch.active) {
            const { rows, shift, flash } = this.horizGlitch;
            for (const r of rows) {
                if (r >= grid.rows) continue;
                const rowOffset = r * cols;
                for (let x = 0; x < cols; x++) {
                    const i = rowOffset + x;
                    let readX = x - shift;
                    if (readX < 0) readX += cols;
                    if (readX >= cols) readX -= cols;
                    const readIdx = rowOffset + readX;
                    let char = grid.getChar(readIdx);
                    let alpha = grid.alphas[readIdx];
                    const fontIdx = grid.fontIndices[readIdx];
                    let color = grid.colors[readIdx];
                    let glow = grid.glows[readIdx];
                    const needsRandom = flash || (alpha < 0.1);
                    if (needsRandom && fallbackChars && fallbackChars.length > 0) {
                         const rndIdx = (Math.random() * fallbackChars.length) | 0;
                         char = fallbackChars[rndIdx];
                    }
                    if (flash) {
                        color = 0xFFFFFFFF; 
                        alpha = 1.0;
                        glow = 5.0; 
                    } else {
                         color = tracerColor;
                    }
                    grid.setOverride(i, char, color, alpha, fontIdx, glow);
                }
            }
        }
    }
}
// --- GlowSystem.js ---
class GlowSystem {
    constructor(grid) {
        this.grid = grid;
        this.sources = [];
    }
    /**
     * Adds a transient radial glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} radius - Radius in cells.
     * @param {number} intensity - Peak intensity.
     * @param {number|null} color - Tint color (Uint32).
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential', 'none'.
     */
    add(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.addRadial(x, y, radius, intensity, color, duration, decayFn);
    }
    addRadial(x, y, radius, intensity, color = null, duration = 0, decayFn = 'linear') {
        this.sources.push({
            type: 'radial', x, y, radius, intensity, color, 
            duration: Math.max(1, duration), 
            maxDuration: Math.max(1, duration), 
            decayFn, 
            age: 0
        });
    }
    /**
     * Adds a transient rectangular glow source.
     * @param {number} x - Center Column.
     * @param {number} y - Center Row.
     * @param {number} width - Full Width in cells.
     * @param {number} height - Full Height in cells.
     * @param {number} intensity - Peak intensity (inside box).
     * @param {number|null} color - Tint color.
     * @param {number} duration - Frames.
     * @param {string} decayFn - 'linear', 'exponential'.
     * @param {number} falloff - Soft edge radius outside the box (0 = hard edge).
     */
    addRect(x, y, width, height, intensity, color = null, duration = 0, decayFn = 'linear', falloff = 2) {
        this.sources.push({
            type: 'rect', x, y, w: width, h: height, falloff, intensity, color,
            duration: Math.max(1, duration),
            maxDuration: Math.max(1, duration),
            decayFn,
            age: 0
        });
    }
    update() {
        // Lifecycle Management
        for (let i = this.sources.length - 1; i >= 0; i--) {
            const s = this.sources[i];
            s.age++;
            if (s.age >= s.duration) {
                this.sources.splice(i, 1);
            }
        }
    }
    apply() {
        if (this.sources.length === 0) return;
        const grid = this.grid;
        const cols = grid.cols;
        const rows = grid.rows;
        const gEnvGlows = grid.envGlows;
        const gColors = grid.colors;
        for (const s of this.sources) {
            // Calculate lifecycle intensity
            let currentIntensity = s.intensity;
            if (s.decayFn === 'linear') {
                currentIntensity *= 1.0 - (s.age / s.maxDuration);
            } else if (s.decayFn === 'exponential') {
                const prog = s.age / s.maxDuration;
                currentIntensity *= (1.0 - (prog * prog));
            }
            if (currentIntensity <= 0.01) continue;
            // Determine Bounds
            let minX, maxX, minY, maxY;
            if (s.type === 'rect') {
                const halfW = s.w / 2;
                const halfH = s.h / 2;
                const margin = s.falloff;
                minX = Math.floor(s.x - halfW - margin);
                maxX = Math.ceil(s.x + halfW + margin);
                minY = Math.floor(s.y - halfH - margin);
                maxY = Math.ceil(s.y + halfH + margin);
            } else {
                // Radial
                const r = s.radius;
                minX = Math.floor(s.x - r);
                maxX = Math.ceil(s.x + r);
                minY = Math.floor(s.y - r);
                maxY = Math.ceil(s.y + r);
            }
            // Clamp to grid
            minX = Math.max(0, minX); maxX = Math.min(cols - 1, maxX);
            minY = Math.max(0, minY); maxY = Math.min(rows - 1, maxY);
            for (let cy = minY; cy <= maxY; cy++) {
                for (let cx = minX; cx <= maxX; cx++) {
                    const idx = cy * cols + cx;
                    if (grid.state[idx] === 0) continue; 
                    let boost = 0;
                    if (s.type === 'rect') {
                        // Signed Distance Field logic for Box
                        // distance from center relative to half-size
                        const dx = Math.abs(cx - s.x) - (s.w / 2);
                        const dy = Math.abs(cy - s.y) - (s.h / 2);
                        // dist > 0 means outside. dist <= 0 means inside.
                        // We only care about outside distance for falloff.
                        // Inside is full intensity.
                        const outsideDist = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
                        if (outsideDist <= 0) {
                            boost = currentIntensity; // Inside box
                        } else if (outsideDist < s.falloff) {
                            // Fade out
                            boost = currentIntensity * (1.0 - (outsideDist / s.falloff));
                        }
                    } else {
                        // Radial
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < s.radius) {
                            boost = currentIntensity * (1.0 - (dist / s.radius));
                        }
                    }
                    if (boost > 0.01) {
                        gEnvGlows[idx] += boost;
                        if (s.color !== null) {
                            const blendFactor = Math.min(1.0, boost * 0.5);
                            const cur = gColors[idx];
                            const cR = cur & 0xFF;
                            const cG = (cur >> 8) & 0xFF;
                            const cB = (cur >> 16) & 0xFF;
                            const sR = s.color & 0xFF;
                            const sG = (s.color >> 8) & 0xFF;
                            const sB = (s.color >> 16) & 0xFF;
                            const nR = cR + (sR - cR) * blendFactor;
                            const nG = cG + (sG - cG) * blendFactor;
                            const nB = cB + (sB - cB) * blendFactor;
                            const nA = (cur >> 24) & 0xFF;
                            gColors[idx] = ((nA & 0xFF) << 24) | ((Math.floor(nB) & 0xFF) << 16) | ((Math.floor(nG) & 0xFF) << 8) | (Math.floor(nR) & 0xFF);
                        }
                    }
                }
            }
        }
    }
}
// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "MiniPulse";
        this.active = false;
        this.sessionTimer = 0;
        this.autoTimer = c.state.miniPulseFrequencySeconds * 60;
        this.pulses = [];
        this.renderPulses = [];
    }
    trigger() {
        if (this.active) return false;
        this.active = true;
        this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60;
        this.pulses = [];
        return true;
    }
    update() {
        const s = this.c.state;
        const d = this.c.derived;
        if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.miniPulseFrequencySeconds * 60;
        }
        if (this.active) {
            this.sessionTimer--;
            if (Math.random() < s.miniPulseSpawnChance) {
                this.pulses.push({
                    x: Utils.randomInt(0, this.g.cols),
                    y: Utils.randomInt(0, this.g.rows),
                    r: 0,
                    maxR: s.miniPulseSize,
                    speed: s.miniPulseSpeed
                });
            }
            if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
        }
        this.renderPulses = [];
        for (let i = this.pulses.length - 1; i >= 0; i--) {
            const p = this.pulses[i];
            p.r += p.speed;
            if (p.r > p.maxR + 100) {
                this.pulses.splice(i, 1);
                continue;
            }
            const ox = (p.x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5);
            const oy = (p.y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
            const minX = ox - p.r;
            const maxX = ox + p.r;
            const minY = oy - p.r;
            const maxY = oy + p.r;
            const rSq = p.r * p.r;
            const innerEdge = Math.max(0, p.r - s.miniPulseThickness);
            const innerEdgeSq = innerEdge * innerEdge;
            this.renderPulses.push({
                ox, oy,
                minX, maxX, minY, maxY,
                r: p.r,
                rSq,
                innerEdge,
                innerEdgeSq,
                maxR: p.maxR
            });
        }
    }
    applyToGrid(grid) {
        if (!this.active || this.renderPulses.length === 0) return;
        const s = this.c.state;
        const d = this.c.derived;
        const cW = d.cellWidth * s.stretchX;
        const cH = d.cellHeight * s.stretchY;
        const tracerColor = d.tracerColorUint32;
        // Unpack Tracer Color for blending
        const tR = tracerColor & 0xFF;
        const tG = (tracerColor >> 8) & 0xFF;
        const tB = (tracerColor >> 16) & 0xFF;
        for (const p of this.renderPulses) {
            const startCol = Math.max(0, Math.floor(p.minX / cW));
            const endCol = Math.min(grid.cols, Math.ceil(p.maxX / cW));
            const startRow = Math.max(0, Math.floor(p.minY / cH));
            const endRow = Math.min(grid.rows, Math.ceil(p.maxY / cH));
            for (let y = startRow; y < endRow; y++) {
                const rowOffset = y * grid.cols;
                for (let x = startCol; x < endCol; x++) {
                    const i = rowOffset + x;
                    // Skip empty cells (No scrambling)
                    const baseAlpha = grid.alphas[i];
                    if (baseAlpha <= 0.01) continue;
                    const cx = (x * cW) + (cW * 0.5);
                    const cy = (y * cH) + (cH * 0.5);
                    if (s.pulseCircular !== false) {
                        const dx = cx - p.ox;
                        const dy = cy - p.oy;
                        const distSq = (dx * dx) + (dy * dy);
                        if (distSq > p.rSq || distSq < p.innerEdgeSq) continue;
                    } else {
                        const dist = Math.max(Math.abs(cx - p.ox), Math.abs(cy - p.oy));
                        if (dist > p.r || dist < p.innerEdge) continue;
                    }
                    // Hit!
                    let lifeFade = 1.0;
                    if (p.r > p.maxR) lifeFade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                    if (lifeFade <= 0.01) continue;
                    // Blend Tracer Color -> Stream Color
                    // Ratio: lifeFade. 1.0 = Tracer. 0.0 = Stream.
                    const streamColor = grid.colors[i];
                    const sR = streamColor & 0xFF;
                    const sG = (streamColor >> 8) & 0xFF;
                    const sB = (streamColor >> 16) & 0xFF;
                    const mR = Math.floor(sR + (tR - sR) * lifeFade);
                    const mG = Math.floor(sG + (tG - sG) * lifeFade);
                    const mB = Math.floor(sB + (tB - sB) * lifeFade);
                    const finalColor = Utils.packAbgr(mR, mG, mB);
                    const baseGlow = s.tracerGlow * lifeFade;
                    const glow = (s.miniPulseUseTracerGlow) ? baseGlow : 0;
                    // Override acts as a "Lighting" layer here.
                    // We use existing char and font.
                    // We use existing alpha to preserve fade state.
                    grid.setOverride(i, grid.getChar(i), finalColor, baseAlpha, grid.fontIndices[i], glow);
                }
            }
        }
    }
}
// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
    constructor(g, c) { 
        super(g, c); this.name = "Pulse"; 
        this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
        this.snap = null; 
        const s = this._getEffectiveState();
        const fps = s.pulseMovieAccurate ? 30 : 60;
        this.autoTimer = s.pulseFrequencySeconds * fps;
        this.renderData = null; 
        this.frameAccumulator = 0;
    }
    _getEffectiveState() {
        const s = this.c.state;
        if (!s.pulseMovieAccurate) return s;
        // Movie Accurate Overrides
        return {
            ...s,
            pulseFrequencySeconds: 300, 
            pulseDelaySeconds: 1.0,      // Dark delay of 1 second
            pulseDurationSeconds: 1.4,   // Wave expands for 1.4 seconds
            pulseWidth: 150,             // Ignored in MA custom logic but kept for safety
            pulseRandomPosition: false,  // We calculate specific start
            pulseInstantStart: false,
            pulseCircular: false,        // Rectangular
            pulseAspectRatio: 1.6,       // 16:10 Aspect Ratio (Width / Height)
            pulsePreserveSpaces: true,
            pulseIgnoreTracers: true,
            pulseUseTracerGlow: true,    // Always use glow in movie accurate mode
            pulseDimming: 0.2,
            pulseBlend: false
        };
    }
    trigger() {
        if(this.active) return false;
        const total = this.g.cols * this.g.rows;
        // Snapshot the current grid state
        this.snap = { 
            chars: new Uint16Array(this.g.chars), 
            fontIndices: new Uint8Array(this.g.fontIndices),
            alphas: new Float32Array(this.g.alphas), 
            colors: new Uint32Array(this.g.colors), 
            tracers: new Uint8Array(total), 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total)
        };
        const d = this.c.derived; const s = this._getEffectiveState(); const holdEnd = d.cycleDuration + d.holdFrames;
        const fps = s.pulseMovieAccurate ? 30 : 60;
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        const fallbackChars = Utils.CHARS;
        for(let i=0; i<total; i++) {
            // Identify Tracer State
            const type = this.g.types[i] & CELL_TYPE_MASK; 
            const age = this.g.ages[i];
            let isTracer = false;
            if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                const at = age - 1; 
                if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                    isTracer = true;
                } 
            }
            this.snap.tracers[i] = isTracer ? 1 : 0; 
            // Generate Fill Char/Font for gaps
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                this.snap.fillChars[i] = fallbackChars.charCodeAt(Math.floor(Math.random() * fallbackChars.length));
            }
        }
        let ox, oy;
        if (s.pulseMovieAccurate) {
             // Find Tracer closest to center
             const cx = Math.floor(this.g.cols / 2);
             const cy = Math.floor(this.g.rows / 2);
             let minDist = 99999999;
             let bestX = cx; 
             let bestY = cy;
             for(let i=0; i<total; i++) {
                 if (this.snap.tracers[i] === 1) {
                     const x = i % this.g.cols;
                     const y = Math.floor(i / this.g.cols);
                     const dx = (x - cx);
                     const dy = (y - cy);
                     const dist = dx*dx + dy*dy;
                     if (dist < minDist) {
                         minDist = dist;
                         bestX = x;
                         bestY = y;
                     }
                 }
             }
             ox = bestX;
             oy = bestY;
        } else if (s.pulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8);
            oy = Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.pulseWidth && pxDistY < s.pulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols/2);
            oy = Math.floor(this.g.rows/2);
        }
        this.origin = {x: ox, y: oy};
        this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelaySeconds * fps; 
        // Radius Init
        if (s.pulseMovieAccurate) {
            this.radius = 2 * d.cellWidth * s.stretchX; 
        } else {
            this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; 
        }
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * fps);
        // --- Dynamic Delay Chunks ---
        this.chunks = [];
        this.spawnedCount = 0;
        this.spawnCooldown = 0;
        return true; 
    }
    update() {
        const s = this._getEffectiveState();
        const fps = s.pulseMovieAccurate ? 30 : 60;
        if (s.pulseMovieAccurate) {
             this.frameAccumulator++;
             if (this.frameAccumulator < 2) return;
             this.frameAccumulator = 0;
        } else {
             this.frameAccumulator = 0;
        }
        if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * fps; }
        if(!this.active) { this.renderData = null; return; }
        const d = this.c.derived;
        if(this.state === 'WAITING') { 
            if(--this.timer <= 0) { this.state = 'EXPANDING'; }
        } else {
            const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
            this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * fps);
            this.radius += this.speed; 
            if(this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
            // --- Chunk Lifecycle & Spawning ---
            if (s.pulseMovieAccurate) {
                // 1. Update existing chunks
                for (let i = this.chunks.length - 1; i >= 0; i--) {
                    this.chunks[i].life--;
                    if (this.chunks[i].life <= 0) {
                        this.chunks.splice(i, 1);
                    }
                }
                // 2. Cooldown
                if (this.spawnCooldown > 0) this.spawnCooldown--;
                // 3. Spawn Logic
                const progress = this.radius / maxDim;
                if (progress > 0.15 && this.spawnedCount < 4 && this.spawnCooldown <= 0) {
                    // Spawn new chunk - Select Type
                    const type = Math.floor(Math.random() * 3);
                    const w = Utils.randomInt(Math.floor(this.g.cols * 0.5), this.g.cols);
                    let h, y;
                    if (type === 0) {
                        // Type A: Bottom Half
                        h = Math.floor(this.g.rows / 2);
                        y = Math.floor(this.g.rows / 2);
                    } else if (type === 1) {
                        // Type B: Mid Section (9-10 tall)
                        h = Utils.randomInt(9, 10);
                        // Center near wave edge, but favor middle
                        const rY = this.radius / 1.6;
                        const topEdgeY = (this.origin.y * d.cellHeight * s.stretchY - rY) / (d.cellHeight * s.stretchY);
                        const botEdgeY = (this.origin.y * d.cellHeight * s.stretchY + rY) / (d.cellHeight * s.stretchY);
                        let targetY = (Math.random() < 0.5) ? topEdgeY : botEdgeY;
                        y = Math.floor(targetY - h / 2);
                        // Constrain to "Middle-ish" (20% to 80%)
                        y = Math.max(Math.floor(this.g.rows * 0.2), Math.min(Math.floor(this.g.rows * 0.8) - h, y));
                    } else {
                        // Type C: Thin Strip (4 tall) near bottom
                        h = 4;
                        y = Utils.randomInt(this.g.rows - 15, this.g.rows - 5);
                    }
                    const x = Utils.randomInt(0, this.g.cols - w);
                    // Final Clamp
                    y = Math.max(0, Math.min(this.g.rows - h, y));
                    const delayPixels = 4 * d.cellWidth * s.stretchX; 
                    // Duration: Time to traverse delay + Time to traverse 1 extra char + buffer
                    const oneCharTime = (d.cellWidth * s.stretchX) / this.speed;
                    const duration = Math.ceil(delayPixels / this.speed) + Math.ceil(oneCharTime) + 2;
                    this.chunks.push({
                        x, y, w, h,
                        lag: delayPixels,
                        life: duration
                    });
                    this.spawnedCount++;
                    this.spawnCooldown = duration + 5; // Wait at least 5 frames after despawn
                }
            }
        }
        // --- Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); 
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        // Effective ratio for calculation
        let ratio = 1;
        if (s.pulseMovieAccurate) {
             ratio = 1.6; // Locked 16:10
        } else if (!s.pulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        const width = s.pulseWidth * 2; 
        const innerEdge = this.radius - width;
        let minX, maxX, minY, maxY;
        if (s.pulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = { ox, oy, radius: this.radius, innerEdge, width, ratio, minX, maxX, minY, maxY };
    }
    applyToGrid(grid) {
        if (!this.active || !this.snap || !this.renderData) return;
        const s = this._getEffectiveState(); 
        const d = this.c.derived;
        const rd = this.renderData;
        const total = grid.cols * grid.rows;
        // ===========================================
        // MOVIE ACCURATE RENDER PATH
        // ===========================================
        if (s.pulseMovieAccurate) {
             const aspect = 1.0; 
             const sideWidth = 7 * d.cellWidth * s.stretchX; 
             const vertWidth = 5 * d.cellHeight * s.stretchY; 
             const fadeSizeSide = 0.5 * d.cellWidth * s.stretchX;
             const fadeSizeVert = 0.5 * d.cellHeight * s.stretchY;
             const initHoleRad = 2 * d.cellWidth * s.stretchX; 
             const maxWaveWidth = sideWidth; 
             let innerB = Math.max(initHoleRad, this.radius - maxWaveWidth);
             let outerB = this.radius;
             const revealFadeLenSide = 2 * d.cellWidth * s.stretchX;
             const revealFadeLenVert = 2 * d.cellHeight * s.stretchY;
             const maxRad = Math.max(grid.cols * d.cellWidth * s.stretchX, grid.rows * d.cellHeight * s.stretchY);
             const delayDist = 4 * d.cellWidth * s.stretchX;
             const r30 = maxRad * 0.30;
             const r40 = maxRad * 0.40; 
             const rHalfRow = Math.floor(grid.rows / 2);
             const progress = this.radius / maxRad;
             // FADE TO DARK LOGIC
             // Timer counts DOWN. We want to fade OUT in the first 10 frames of the wait.
             // Max timer = s.pulseDelaySeconds * 60
             const maxTimer = s.pulseDelaySeconds * 60;
             const timeElapsed = maxTimer - this.timer;
             const fadeDur = 10; // Frames
             let fadeMult = s.pulseDimming;
             if (timeElapsed < fadeDur) {
                 const t = timeElapsed / fadeDur; 
                 // Lerp from 1.0 to s.pulseDimming
                 fadeMult = 1.0 + (s.pulseDimming - 1.0) * t;
             }
             for (let i = 0; i < total; i++) {
                 // Common Data Fetch
                 const snAlpha = this.snap.alphas[i];
                 let charCode = this.snap.chars[i];
                 let color = this.snap.colors[i];
                 let fontIdx = this.snap.fontIndices[i];
                 const isTracer = (this.snap.tracers[i] === 1);
                 // Fill gaps from snapshot
                 const isGap = (snAlpha <= 0.01);
                 if (isGap) {
                     charCode = this.snap.fillChars[i];
                     color = d.streamColorUint32;
                     fontIdx = this.snap.fillFonts[i];
                 }
                 if (this.state === 'WAITING') {
                     // 1. Darken Everything with Fade
                     if (isTracer) {
                         const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                         // Tracers REMAIN BRIGHT (Ignore fadeMult)
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                     } else {
                         grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * fadeMult, fontIdx, 0);
                     }
                     continue;
                 }
                 // EXPANDING
                 const x = i % grid.cols; 
                 const y = Math.floor(i / grid.cols);
                 const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                 const cy = Math.floor(y * d.cellHeight * s.stretchY);
                 // --- Apply Catching Lag ---
                 let curLag = 0;
                 // Check active chunks
                 if (this.chunks) {
                     const col = x; 
                     const row = y;
                     for (const chunk of this.chunks) {
                         if (col >= chunk.x && col < chunk.x + chunk.w &&
                             row >= chunk.y && row < chunk.y + chunk.h) {
                             curLag = chunk.lag;
                             break; // Apply first found (or max if we wanted overlap)
                         }
                     }
                 }
                 const localOuter = Math.max(0, outerB - curLag);
                 const localInner = Math.max(0, innerB - curLag);
                 const dx = Math.abs(cx - rd.ox);
                 const dy = Math.abs(cy - rd.oy);
                 const dyScaled = dy * aspect;
                 const dist = Math.max(dx, dyScaled);
                 const isSide = (dx > dyScaled);
                 const fadeSize = isSide ? fadeSizeSide : fadeSizeVert;
                 if (dist > localOuter) {
                     // --- OUTSIDE ---
                     // Check if this block is "Lagging" (Delayed Chunk)
                     if (curLag > 0 && dist < outerB) {
                         // LAGGED CHUNK: Faded Pulse Character on Dimmed Background
                         // User Req: "characters... empty due to delay be faded characters the color of the pulse wave"
                         // User Req: "green code... should be dark like the background"
                         const displayChar = String.fromCharCode(this.snap.fillChars[i]);
                         const displayFont = this.snap.fillFonts[i];
                         // Dim the underlying green code
                         let baseColor = grid.colors[i];
                         const r = baseColor & 0xFF;
                         const g = (baseColor >> 8) & 0xFF;
                         const b = (baseColor >> 16) & 0xFF;
                         baseColor = Utils.packAbgr(Math.floor(r * s.pulseDimming), Math.floor(g * s.pulseDimming), Math.floor(b * s.pulseDimming));
                         // Faded Pulse Overlay (Alpha 0.4 - Visible but Dim)
                         grid.setEffectOverlay(i, displayChar, baseColor, 0.4, displayFont, 0); // No glow for faded part
                     } else {
                         // NORMAL BACKGROUND
                         if (isTracer) {
                             // Tracers remain bright outside
                             const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                         } else {
                             grid.setHighPriorityEffect(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                         }
                     }
                 } 
                 else {
                     // --- INSIDE WAVE FRONT (Revealing Simulation) ---
                     if (dist > localInner) {
                         // --- WAVE BAND OVERLAY ---
                         // 0. Random Glitch "Dead" Characters (2% chance - sparse)
                         if ((i * 13) % 100 < 2) {
                             grid.clearEffectOverride(i); // Show simulation (with its gaps)
                         } else {
                             // Use random char and font
                             const displayChar = String.fromCharCode(this.snap.fillChars[i]);
                             const displayFont = this.snap.fillFonts[i];
                             // 1. Alpha Variance (15% chance to be 20% darker)
                             // Base: 1.0 (Full Bright)
                             // Variance: 0.8 (20% darker)
                             let alpha = 1.0;
                             if ((i * 37) % 100 < 15) {
                                 alpha = 0.8; 
                             }
                             // 2. Delay Dimming
                             // If this part of the wave is delayed (lagged), dim it.
                             if (curLag > 0) {
                                 alpha *= 0.6;
                             }
                             // Slight Glow -> Bold/Thicker (1.5)
                             const waveGlow = 1.5;
                             // Dimming Logic for Leading Edge (First 5 chars)
                             let baseColor = grid.colors[i];
                             // Check distance from leading edge
                             const edgeDist = localOuter - dist;
                             const threshold = 5 * d.cellWidth * s.stretchX;
                             if (edgeDist < threshold) {
                                 const r = baseColor & 0xFF;
                                 const g = (baseColor >> 8) & 0xFF;
                                 const b = (baseColor >> 16) & 0xFF;
                                 // Dim by 50%
                                 baseColor = Utils.packAbgr(Math.floor(r * 0.5), Math.floor(g * 0.5), Math.floor(b * 0.5));
                             }
                             // Use Overlay Mode (2) to see simulation underneath
                             grid.setEffectOverlay(i, displayChar, baseColor, alpha, displayFont, waveGlow);
                         }
                     } else {
                         // --- HOLE (Full Reveal) ---
                         grid.clearEffectOverride(i);
                     }
                 }
             }
             return; // End MA path
        }
        // ===========================================
        // STANDARD PATH (Original Logic)
        // ===========================================
        const tColorInt = d.tracerColorUint32;
        const tR = tColorInt & 0xFF;
        const tG = (tColorInt >> 8) & 0xFF;
        const tB = (tColorInt >> 16) & 0xFF;
        for (let i = 0; i < total; i++) {
            // Optimization: Skip if we are waiting (Override whole screen efficiently)
            let dist = 0;
            if (this.state === 'EXPANDING') {
                const x = i % grid.cols; 
                const y = Math.floor(i / grid.cols);
                const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                const cy = Math.floor(y * d.cellHeight * s.stretchY);
                if (s.pulseCircular) {
                    const dx = cx - rd.ox; const dy = cy - rd.oy;
                    dist = Math.sqrt(dx*dx + dy*dy);
                } else {
                    const dx = Math.abs(cx - rd.ox);
                    const dy = Math.abs(cy - rd.oy);
                    dist = Math.max(dx, dy * rd.ratio);
                }
                // 1. HOLE (Inner Edge): Instant Reveal
                if (dist < rd.innerEdge) {
                    grid.clearEffectOverride(i); 
                    continue;
                }
            } else {
                dist = 999999; // Waiting state: effectively infinite distance
            }
            // --- Common Data Fetch ---
            const snAlpha = this.snap.alphas[i];
            let charCode = this.snap.chars[i];
            let fontIdx = this.snap.fontIndices[i];
            let color = this.snap.colors[i];
            const isTracer = (this.snap.tracers[i] === 1);
            const isGap = (snAlpha <= 0.01);
            // Apply Gap Filling (Global)
            if (isGap && !s.pulsePreserveSpaces) {
                charCode = this.snap.fillChars[i];
                fontIdx = this.snap.fillFonts[i];
            }
            // 2. BACKGROUND (Dimmed)
            // Condition: Waiting OR Outside Radius
            if (this.state === 'WAITING' || dist > rd.radius) {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else if (isTracer && s.pulseIgnoreTracers) {
                    // Keep original tracer
                    const glow = (s.pulseUseTracerGlow) ? s.tracerGlow : 0;
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha, fontIdx, glow);
                } else {
                    // Dimmed Snapshot
                    if (snAlpha > 0.01 || !s.pulsePreserveSpaces) {
                        grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0);
                    } else {
                        grid.clearEffectOverride(i);
                    }
                }
            } 
            // 3. WAVE BAND (Bright)
            // Condition: We are here because dist >= innerEdge AND dist <= radius
            else {
                if (s.pulsePreserveSpaces && isGap) {
                    grid.setEffectOverride(i, String.fromCharCode(charCode), color, snAlpha * s.pulseDimming, fontIdx, 0)
                } else {
                    // Calculate relative position (0.0 at outer edge, 1.0 at inner edge)
                    // (radius - dist) is small at edge, large at inner
                    const rel = Math.max(0, Math.min(1, (rd.radius - dist) / (s.pulseWidth * 1.25)));
                    let finalColor = tColorInt;
                    if (s.pulseBlend) {
                        const bR = color & 0xFF;
                        const bG = (color >> 8) & 0xFF;
                        const bB = (color >> 16) & 0xFF;
                        const mR = Math.floor(tR + (bR - tR) * rel);
                        const mG = Math.floor(tG + (bG - tG) * rel);
                        const mB = Math.floor(tB + (bB - tB) * rel);
                        finalColor = Utils.packAbgr(mR, mG, mB);
                    }
                    const glowAmount = (s.pulseUseTracerGlow) ? Math.max(s.tracerGlow, 30 * (1.0 - rel)) : 0;
                    // Force alpha 1.0 for the wave
                    grid.setEffectOverride(i, String.fromCharCode(charCode), finalColor, 1.0 , fontIdx, glowAmount);
                }
            }
        }
    }
}
// --- QuantizedBaseEffect.js ---
/**
 * QuantizedBaseEffect.js - Version 8.5.1
 */
class QuantizedBaseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.configPrefix = "quantizedPulse"; 
        // Components
        this.sequenceManager = new QuantizedSequence();
        this.shadowController = new QuantizedShadow();
        this.renderer = new QuantizedRenderer();
        // Sequence State
        this.sequence = [[]];
        this.expansionPhase = 0;
        this.maskOps = [];
        // Grid State
        this.logicGrid = null;
        this.logicGridW = 0;
        this.logicGridH = 0;
        this.renderGrid = null; 
        this.layerGrids = [];   
        this.removalGrids = []; 
        // Debug/Editor State
        this.debugMode = false;
        this.manualStep = false;
        this.editorHighlight = false;
        this._boundDebugHandler = this._handleDebugInput.bind(this);
        // Render Cache
        this.maskCanvas = null;
        this.maskCtx = null;
        this.scratchCanvas = null;
        this.scratchCtx = null;
        this.gridCacheCanvas = null;
        this.gridCacheCtx = null;
        this._maskDirty = true;
        this.lastGridSeed = -1;
        this.layout = null;
        this._outsideMap = null;
        this._outsideMapWidth = 0;
        this._outsideMapHeight = 0;
        this._outsideMapDirty = true;
        this._gridCacheDirty = true;
        // Logic Grid Scaling
        this.logicScale = 1.0;
        // Shadow World Swap State
        this.hasSwapped = false;
        this.isSwapping = false;
        this.swapTimer = 0;
        // Line Tracking
        this.lineStates = new Map(); 
        this.suppressedFades = new Set(); 
        this.lastVisibilityChangeFrame = 0;
        this.lastMaskUpdateFrame = 0;
        this.warmupRemaining = 0;
        // Procedural Generation State
        this.blockMap = new Map();
        this.activeBlocks = [];
        this.unfoldSequences = [];
        this.visibleLayers = [true, true, true];
        this.layerOrder = [0, 1, 2];
        this.proceduralLayerIndex = 0;
        this.nextBlockId = 0;
        this.overlapState = { step: 0 };
        this.cycleState = null;
        this.isReconstructing = false;
        // Buffer Pool for high-frequency operations
        this._bufferPool = {
            combined: null,
            connectedMap: null,
            queue: null,
            syncGrid: null,
            stepOccupancy: null
        };
        this._gridsDirty = true;
    }
    _getBuffer(key, length, type = Uint8Array) {
        if (!this._bufferPool[key] || this._bufferPool[key].length !== length) {
            this._bufferPool[key] = new type(length);
        }
        return this._bufferPool[key];
    }
    _checkDirtiness() {
        if (this._maskDirty || this._previewActive) return; 
        const fadeIn = Math.max(1, this.getConfig('FadeInFrames') || 0);
        const fadeOut = Math.max(1, this.getConfig('FadeFrames') || 0);
        const maxDuration = Math.max(fadeIn, fadeOut) + 2; 
        if (this.animFrame - this.lastVisibilityChangeFrame < fadeOut + 2) {
            this._maskDirty = true;
            return;
        }
        if (this.maskOps) {
            for (let i = this.maskOps.length - 1; i >= 0; i--) {
                const op = this.maskOps[i];
                const age = this.animFrame - (op.startFrame || 0);
                if (age < maxDuration) {
                    this._maskDirty = true;
                    return;
                }
                if (age >= maxDuration) break; 
            }
        }
    }
    _handleDebugInput(e) {
        if (e.key === '.') {
            this.manualStep = true;
        } else if (e.key === 'Escape') {
            this.active = false;
            this.state = 'IDLE';
            this.alpha = 0.0;
            window.removeEventListener('keydown', this._boundDebugHandler);
        }
    }
    _log(...args) { if (this.c.state.logErrors) console.log(...args); }
    _warn(...args) { if (this.c.state.logErrors) console.warn(...args); }
    _error(...args) { if (this.c.state.logErrors) console.error(...args); }
    getConfig(keySuffix) {
        const key = this.configPrefix + keySuffix;
        return this.c.state[key];
    }
    getBlockSize() {
        let w = this.c.state[this.configPrefix + 'BlockWidthCells'];
        let h = this.c.state[this.configPrefix + 'BlockHeightCells'];
        if (w === undefined) w = this.c.state.quantizedBlockWidthCells;
        if (h === undefined) h = this.c.state.quantizedBlockHeightCells;
        w = w || 4;
        h = h || 4;
        return { w, h };
    }
    _initLogicGrid() {
        const bs = this.getBlockSize();
        const cellPitchX = Math.max(1, bs.w);
        const cellPitchY = Math.max(1, bs.h);
        let blocksX = Math.ceil((this.g.cols * this.logicScale) / cellPitchX);
        let blocksY = Math.ceil((this.g.rows * this.logicScale) / cellPitchY);
        // Ensure integer cell offsets by making (blocks * pitch - screenCells) even
        if ((blocksX * cellPitchX - this.g.cols) % 2 !== 0) blocksX++;
        if ((blocksY * cellPitchY - this.g.rows) % 2 !== 0) blocksY++;
        if (!this.logicGrid || this.logicGrid.length !== blocksX * blocksY) {
            this.logicGrid = new Uint8Array(blocksX * blocksY);
        } else {
            this.logicGrid.fill(0);
        }
        this.logicGridW = blocksX;
        this.logicGridH = blocksY;
        this._gridsDirty = true;
        if (!this.renderGrid || this.renderGrid.length !== blocksX * blocksY) {
            this.renderGrid = new Int32Array(blocksX * blocksY);
        }
        this.renderGrid.fill(-1);
        for (let i = 0; i < 3; i++) {
            if (!this.layerGrids[i] || this.layerGrids[i].length !== blocksX * blocksY) {
                this.layerGrids[i] = new Int32Array(blocksX * blocksY);
                this.layerGrids[i].fill(-1);
            } else {
                this.layerGrids[i].fill(-1);
            }
            if (!this.removalGrids[i] || this.removalGrids[i].length !== blocksX * blocksY) {
                this.removalGrids[i] = new Int32Array(blocksX * blocksY);
            } else {
                this.removalGrids[i].fill(-1);
            }
        }
    }
    _updateLayerOrder(updatedLayer) {
        if (updatedLayer === undefined || updatedLayer === 0) return;
        // Remove the updated layer from its current position (if it's not 0)
        const idx = this.layerOrder.indexOf(updatedLayer);
        if (idx !== -1) {
            this.layerOrder.splice(idx, 1);
            // Insert it at index 1 (right behind Layer 0)
            this.layerOrder.splice(1, 0, updatedLayer);
        }
    }
    trigger(force = false) {
        if (this.active && !force) return false;
        const enabled = this.getConfig('Enabled');
        if (!enabled && !force) return false;
        if (window.matrixPatterns && window.matrixPatterns[this.name]) {
            this.sequence = window.matrixPatterns[this.name];
            if (this.sequence.length > 1000) {
                this.sequence = this.sequence.slice(0, 1000);
            }
        }
        this.active = true;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.expansionPhase = 0;
        this.maskOps = [];
        this._lastProcessedOpIndex = 0;
        this.animFrame = 0;
        this._maskDirty = true;
        this._gridsDirty = true;
        // Reset Render Cache
        this.renderer._edgeCacheDirty = true;
        this.renderer._distMapDirty = true;
        this.renderer._cachedEdgeMaps = [];
        this._outsideMapDirty = true;
        this._gridCacheDirty = true;
        this.lastGridSeed = -1;
        this.lineStates = new Map();
        this.suppressedFades.clear();
        this.lastVisibilityChangeFrame = 0;
        this.lastMaskUpdateFrame = 0;
        this.hasSwapped = false;
        this.isSwapping = false;
        this.swapTimer = 0;
        this.blockMap.clear();
        this.activeBlocks = [];
        this.unfoldSequences = [];
        this.nextBlockId = 0;
        this.nudgeState = null;
        this.overlapState = { step: 0 };
        this.cycleState = null;
        this.proceduralInitiated = false;
        this._initLogicGrid();
        if (this.debugMode) {
            // Keydown handling for stepping is managed by the Editor when active
        }
        return true;
    }
    _processAnimationStep() {
        if (this.expansionPhase < this.sequence.length) {
            const step = this.sequence[this.expansionPhase];
            if (step) this._executeStepOps(step);
            this.expansionPhase++;
            this._maskDirty = true;
        }
    }
    hitTest(x, y, options = {}) {
        if (!this.layout) return null;
        const l = this.layout;
        const offX = options.editorOffX || 0;
        const offY = options.editorOffY || 0;
        const cellX = (x - offX - l.screenOriginX - l.pixelOffX) / l.screenStepX;
        const cellY = (y - offY - l.screenOriginY - l.pixelOffY) / l.screenStepY;
        const bx_screen = Math.floor(cellX);
        const by_screen = Math.floor(cellY);
        const rawBx = (bx_screen / l.cellPitchX) + l.offX - l.userBlockOffX;
        const rawBy = (by_screen / l.cellPitchY) + l.offY - l.userBlockOffY;
        const bx = Math.floor(rawBx + 0.001);
        const by = Math.floor(rawBy + 0.001);
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        if (bx >= -10 && bx <= blocksX + 10 && by >= -10 && by <= blocksY + 10) {
            return { x: bx - cx, y: by - cy, absX: bx, absY: by };
        }
        return null;
    }
    jumpToStep(targetStepsCompleted) {
        this.isReconstructing = true;
        this.maskOps = [];
        this.activeBlocks = []; 
        this.nextBlockId = 0;
        this.proceduralInitiated = false;
        // Fully reset procedural state machine
        this.unfoldSequences = Array.from({ length: 3 }, () => []);
        this.nudgeState = null;
        this.cycleState = null;
        this.centeredState = null;
        this._initLogicGrid();
        if (this.renderGrid) this.renderGrid.fill(-1);
        for (let i = 0; i < 3; i++) {
            if (this.layerGrids[i]) this.layerGrids[i].fill(-1);
        }
        this._lastProcessedOpIndex = 0;
        const framesPerStep = 60; // Standardize to 60 frames per step for consistent internal timing
        const jumpTime = targetStepsCompleted * framesPerStep;
        for (const [key, state] of this.lineStates) {
            if (state.visible) {
                state.visible = false;
                state.deathFrame = jumpTime;
                state.birthFrame = -1;
            } else if (state.deathFrame !== -1 && jumpTime > state.deathFrame + (this.getConfig('FadeFrames') || 60)) {
                this.lineStates.delete(key);
            }
        }
        for (let i = 0; i < targetStepsCompleted; i++) {
            this.expansionPhase = i; 
            const step = this.sequence[i];
            if (step) {
                const simFrame = i * framesPerStep;
                this._executeStepOps(step, simFrame); 
            }
        }
        // Re-seed initial blocks or reconstruct from maskOps
        this._initProceduralState();
        this.expansionPhase = targetStepsCompleted; 
        this.animFrame = targetStepsCompleted * framesPerStep;
        this._maskDirty = true;
        this.renderer._edgeCacheDirty = true;
        this.renderer._distMapDirty = true;
        this._outsideMapDirty = true;
        this.isReconstructing = false;
    }
    refreshStep() {
        this.jumpToStep(this.expansionPhase);
    }
    // Proxy for SequenceManager
    _executeStepOps(step, startFrameOverride) {
        this.sequenceManager.executeStepOps(this, step, startFrameOverride);
    }
    _lerpColor(c1, c2, t) { return this.renderer._lerpColor(c1, c2, t); }
    _getBiasedDirections() {
        const ratio = (this.g.cols / this.g.rows) || 1.0;
        const faces = ['N', 'S', 'E', 'W'];
        // Weights: 1.0 is neutral. 
        // If ratio > 1.0 (Horizontal), E/W are preferred.
        // If ratio < 1.0 (Vertical), N/S are preferred.
        const horizWeight = Math.max(1.0, ratio);
        const vertWeight = Math.max(1.0, 1.0 / ratio);
        const weightedPool = [
            { id: 'N', w: vertWeight },
            { id: 'S', w: vertWeight },
            { id: 'E', w: horizWeight },
            { id: 'W', w: horizWeight }
        ];
        // Weighted Shuffle
        const result = [];
        const pool = [...weightedPool];
        while (pool.length > 0) {
            let totalW = 0;
            for (const item of pool) totalW += item.w;
            let r = Math.random() * totalW;
            for (let i = 0; i < pool.length; i++) {
                r -= pool[i].w;
                if (r <= 0) {
                    result.push(pool[i].id);
                    pool.splice(i, 1);
                    break;
                }
            }
        }
        return result;
    }
    updateTransition(deactivate = true) {
        if (!this.isSwapping) return false;
        this._updateShadowSim();
        this.swapTimer--;
        if (this.swapTimer <= 0) {
            this.g.clearAllOverrides();
            if (this.g.cellLocks) this.g.cellLocks.fill(0);
            this.isSwapping = false;
            this.hasSwapped = true;
            this.shadowGrid = null;
            this.shadowSim = null;
            if (deactivate) {
                this.active = false;
                this.state = 'IDLE';
                window.removeEventListener('keydown', this._boundDebugHandler);
            }
            return true;
        }
        return false;
    }
    _swapStates() {
        if (this.hasSwapped || this.isSwapping) return;
        const result = this._commitShadowState();
        if (result === 'ASYNC') {
            this.isSwapping = true;
            this.swapTimer = 5; 
        } else if (result === 'SYNC') {
            this.g.clearAllOverrides();
            if (this.g.cellLocks) this.g.cellLocks.fill(0);
            this.hasSwapped = true;
        } else {
            this.g.clearAllOverrides();
            this.active = false;
        }
    }
    _ensureCanvases(w, h) {
        if (!this.maskCanvas) {
            this.maskCanvas = document.createElement('canvas');
            this.maskCtx = this.maskCanvas.getContext('2d');
            this._maskDirty = true;
        }
        if (!this.scratchCanvas) {
            this.scratchCanvas = document.createElement('canvas');
            this.scratchCtx = this.scratchCanvas.getContext('2d');
        }
        if (!this.gridCacheCanvas) {
            this.gridCacheCanvas = document.createElement('canvas');
            this.gridCacheCtx = this.gridCacheCanvas.getContext('2d');
        }
        if (!this.perimeterMaskCanvas) {
            this.perimeterMaskCanvas = document.createElement('canvas');
            this.perimeterMaskCtx = this.perimeterMaskCanvas.getContext('2d');
        }
        if (!this.lineMaskCanvas) {
            this.lineMaskCanvas = document.createElement('canvas');
            this.lineMaskCtx = this.lineMaskCanvas.getContext('2d');
        }
        if (this.maskCanvas.width !== w || this.maskCanvas.height !== h) {
            this.maskCanvas.width = w;
            this.maskCanvas.height = h;
            this._maskDirty = true;
        }
        if (this.scratchCanvas.width !== w || this.scratchCanvas.height !== h) {
            this.scratchCanvas.width = w;
            this.scratchCanvas.height = h;
        }
        if (this.gridCacheCanvas.width !== w || this.gridCacheCanvas.height !== h) {
            this.gridCacheCanvas.width = w;
            this.gridCacheCanvas.height = h;
            this.lastGridSeed = -1; 
        }
        if (this.perimeterMaskCanvas.width !== w || this.perimeterMaskCanvas.height !== h) {
            this.perimeterMaskCanvas.width = w;
            this.perimeterMaskCanvas.height = h;
        }
        if (this.lineMaskCanvas.width !== w || this.lineMaskCanvas.height !== h) {
            this.lineMaskCanvas.width = w;
            this.lineMaskCanvas.height = h;
        }
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        if (blocksX && blocksY) {
            const requiredSize = blocksX * blocksY;
            if (!this.renderGrid || this.renderGrid.length !== requiredSize) {
                 this.renderGrid = new Int32Array(requiredSize);
                 this.renderGrid.fill(-1);
            }
            for (let i = 0; i < 3; i++) {
                if (!this.layerGrids[i] || this.layerGrids[i].length !== requiredSize) {
                    this.layerGrids[i] = new Int32Array(requiredSize);
                    this.layerGrids[i].fill(-1);
                }
            }
        }
    }
    // Proxy for ShadowController
    _initShadowWorld() {
        this.shadowController.initShadowWorld(this);
    }
    _initShadowWorldBase(workerEnabled) {
        return this.shadowController.initShadowWorldBase(this, workerEnabled);
    }
    _commitShadowState() {
        return this.shadowController.commitShadowState(this);
    }
    _updateShadowSim() {
        return this.shadowController.updateShadowSim(this);
    }
    _updateGridCache(w, h, s, d) {
        const rotatorCycle = d.rotatorCycleFrames || 20;
        const timeSeed = Math.floor(this.animFrame / rotatorCycle);
        if (timeSeed === this.lastGridSeed && !this._gridCacheDirty) return; 
        this.lastGridSeed = timeSeed;
        this._gridCacheDirty = false;
        const ctx = this.gridCacheCtx;
        ctx.clearRect(0, 0, w, h);
        const glowStrength = this.getConfig('BorderIllumination') || 0;
        const t = Math.min(1.0, glowStrength / 10.0);
        const intensity = Math.min(1.0, glowStrength / 1.0); 
        const charColor = '#FFFFFF';
        const visualFontSize = s.fontSize + (s.tracerSizeIncrease || 0);
        const style = s.italicEnabled ? 'italic ' : '';
        const weight = s.fontWeight;
        const family = s.fontFamily;
        ctx.font = `${style}${weight} ${visualFontSize}px ${family}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = charColor;
        const grid = this.g;
        const shadowGrid = this.shadowGrid;
        const distMap = this.renderer._distMap;
        const distW = this.renderer._distMapWidth;
        const distH = this.renderer._distMapHeight;
        const l = this.layout;
        const screenStepX = d.cellWidth * s.stretchX;
        const screenStepY = d.cellHeight * s.stretchY;
        const screenOriginX = ((0 - (grid.cols * d.cellWidth * 0.5)) * s.stretchX) + (w * 0.5);
        const screenOriginY = ((0 - (grid.rows * d.cellHeight * 0.5)) * s.stretchY) + (h * 0.5);
        const cols = grid.cols;
        const rows = grid.rows;
        const chars = grid.chars;
        const drawChar = (x, y) => {
            let charCode = 32;
            let i = -1;
            let useShadow = false;
            // Only use shadow world for characters within the actual grid
            const isInsideGrid = (x >= 0 && x < cols && y >= 0 && y < rows);
            if (isInsideGrid && shadowGrid && distMap && l) {
                const bx = Math.floor((x / l.cellPitchX) + l.offX - l.userBlockOffX);
                const by = Math.floor((y / l.cellPitchY) + l.offY - l.userBlockOffY);
                if (bx >= 0 && bx < distW && by >= 0 && by < distH) {
                    const dIdx = by * distW + bx;
                    if (distMap[dIdx] <= 1) useShadow = true;
                }
            }
            if (isInsideGrid) {
                i = (y * cols) + x;
                if (useShadow && shadowGrid.chars) {
                    charCode = shadowGrid.chars[i];
                } else if (grid.overrideActive && grid.overrideActive[i] > 0) {
                    charCode = grid.overrideChars[i];
                } else {
                    charCode = chars[i];
                }
            } else {
                i = (y * 10000) + x; 
                charCode = 0; 
            }
            if (charCode <= 32) {
                const activeFonts = d.activeFonts;
                const fontData = activeFonts[0] || { chars: "01" };
                const charSet = fontData.chars;
                const seed = i * 12.9898 + timeSeed * 78.233;
                const hash = Math.abs(Math.sin(seed) * 43758.5453) % 1;
                const char = charSet[Math.floor(hash * charSet.length)];
                charCode = (char) ? char.charCodeAt(0) : 32;
            }
            const cx = screenOriginX + ((x + 0.5) * screenStepX);
            const cy = screenOriginY + ((y + 0.5) * screenStepY);
            if (s.stretchX !== 1 || s.stretchY !== 1) {
                ctx.setTransform(s.stretchX, 0, 0, s.stretchY, cx, cy);
                ctx.fillText(String.fromCharCode(charCode), 0, 0);
            } else {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillText(String.fromCharCode(charCode), cx, cy);
            }
        };
        const padding = 5;
        for (let y = -padding; y < rows + padding; y++) {
            for (let x = -padding; x < cols + padding; x++) {
                drawChar(x, y);
            }
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    _updateRenderGridLogic() {
        if (!this.logicGridW || !this.logicGridH) return;
        const totalBlocks = this.logicGridW * this.logicGridH;
        if (!this.renderGrid || this.renderGrid.length !== totalBlocks) {
            this.renderGrid = new Int32Array(totalBlocks);
            this.renderGrid.fill(-1);
            this._gridsDirty = true;
        }
        for (let i = 0; i < 3; i++) {
            if (!this.layerGrids[i] || this.layerGrids[i].length !== totalBlocks) {
                this.layerGrids[i] = new Int32Array(totalBlocks);
                this.layerGrids[i].fill(-1);
                this._gridsDirty = true;
            }
        }
        if (!this.maskOps) return;
        const cx = Math.floor(this.logicGridW / 2);
        const cy = Math.floor(this.logicGridH / 2);
        const startIndex = this._lastProcessedOpIndex || 0;
        let processed = 0;
        let i = startIndex;
        for (; i < this.maskOps.length; i++) {
            const op = this.maskOps[i];
            if (op.startFrame && this.animFrame < op.startFrame) break;
            processed++;
            const layerIdx = (op.layer !== undefined && op.layer >= 0 && op.layer <= 2) ? op.layer : 0;
            const targetGrid = this.layerGrids[layerIdx];
            if (layerIdx !== 0 && (op.type === 'add' || op.type === 'addSmart' || op.type === 'removeBlock')) {
                this._updateLayerOrder(layerIdx);
                this._gridsDirty = true;
            }
            if (op.type === 'add' || op.type === 'addSmart') {
                const start = { x: cx + op.x1, y: cy + op.y1 };
                const end = { x: cx + op.x2, y: cy + op.y2 };
                const minX = Math.max(0, Math.min(start.x, end.x));
                const maxX = Math.min(this.logicGridW - 1, Math.max(start.x, end.x));
                const minY = Math.max(0, Math.min(start.y, end.y));
                const maxY = Math.min(this.logicGridH - 1, Math.max(start.y, end.y));
                for (let by = minY; by <= maxY; by++) {
                    const rowOff = by * this.logicGridW;
                    for (let bx = minX; bx <= maxX; bx++) {
                        const idx = rowOff + bx;
                        targetGrid[idx] = op.startFrame || 0;
                        if (this.removalGrids[layerIdx]) this.removalGrids[layerIdx][idx] = -1;
                    }
                }
            } else if (op.type === 'removeBlock') {
                const start = { x: cx + op.x1, y: cy + op.y1 };
                const end = { x: cx + op.x2, y: cy + op.y2 };
                const minX = Math.max(0, Math.min(start.x, end.x));
                const maxX = Math.min(this.logicGridW - 1, Math.max(start.x, end.x));
                const minY = Math.max(0, Math.min(start.y, end.y));
                const maxY = Math.min(this.logicGridH - 1, Math.max(start.y, end.y));
                for (let by = minY; by <= maxY; by++) {
                    const rowOff = by * this.logicGridW;
                    for (let bx = minX; bx <= maxX; bx++) {
                        const idx = rowOff + bx;
                        const remFrame = op.startFrame || 0;
                        if (op.layer !== undefined) {
                            targetGrid[idx] = -1;
                            if (op.fade !== false && this.removalGrids[layerIdx]) this.removalGrids[layerIdx][idx] = remFrame;
                        } else {
                            for (let l = 0; l < 3; l++) {
                                this.layerGrids[l][idx] = -1;
                                if (op.fade !== false && this.removalGrids[l]) this.removalGrids[l][idx] = remFrame;
                            }
                        }
                    }
                }
            }
        }
        // Skip full re-composite if nothing changed
        if (processed === 0 && !this._gridsDirty) {
            this._lastProcessedOpIndex = i;
            return;
        }
        const visibleIndices = this.layerOrder.filter(l => l >= 0 && l <= 2);
        const layerGrids = this.layerGrids;
        for (let idx = 0; idx < totalBlocks; idx++) {
            let finalVal = -1;
            let anyActive = false;
            for (let j = 0; j < visibleIndices.length; j++) {
                const lIdx = visibleIndices[j];
                const grid = layerGrids[lIdx];
                if (grid && grid[idx] !== -1) {
                    if (finalVal === -1) finalVal = grid[idx];
                    anyActive = true;
                }
            }
            this.renderGrid[idx] = finalVal;
            if (this.logicGrid) this.logicGrid[idx] = anyActive ? 1 : 0;
        }
        this._lastProcessedOpIndex = i;
        this._gridsDirty = false;
        this._lastBlocksX = this.logicGridW;
        this._lastBlocksY = this.logicGridH;
        const bs = this.getBlockSize();
        this._lastPitchX = Math.max(1, bs.w);
        this._lastPitchY = Math.max(1, bs.h);
        if (processed > 0) {
            this.renderer._distMapDirty = true;
            this._outsideMapDirty = true;
            this._maskDirty = true;
            this._gridCacheDirty = true;
        }
    }
    _computeCenteredOffset(blocksX, blocksY, pitchX, pitchY) {
        const logicCellsX = blocksX * pitchX;
        const logicCellsY = blocksY * pitchY;
        const screenCellsX = this.g.cols;
        const screenCellsY = this.g.rows;
        const cellOffX = (logicCellsX - screenCellsX) / 2.0;
        const cellOffY = (logicCellsY - screenCellsY) / 2.0;
        const offX = cellOffX / pitchX;
        const offY = cellOffY / pitchY;
        return { offX, offY };
    }
    _computeTrueOutside(blocksX, blocksY) {
        return this.renderer.computeTrueOutside(this, blocksX, blocksY);
    }
    _rebuildEdgeCache(w, h) {
        this.renderer.rebuildEdgeCache(this, w, h);
    }
    // Proxy for Renderer
    _updateMask(w, h, s, d) {
        this.renderer.updateMask(this, w, h, s, d);
    }
    _renderEdges(ctx, ignoredCtx, now, blocksX, blocksY, offX, offY) {
        this.renderer.renderEdges(this, ctx, now, blocksX, blocksY, offX, offY);
    }
    _removeBlockCorner(bx, by, corner) {
        this.renderer._removeBlockCorner(this, this.maskCtx, bx, by, corner);
    }
    _addBlock(start, end, ext, check) {
        this.renderer._addBlockToCtx(this.maskCtx, this.layout, start, end);
    }
    render(ctx, d) {
        if (!this.active || (this.alpha <= 0.01 && !this.debugMode)) return;
        this._checkDirtiness();
        this._updateRenderGridLogic();
        const s = this.c.state;
        const glowStrength = this.getConfig('BorderIllumination') || 0;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        this._ensureCanvases(width, height); 
        if (this._maskDirty || this.maskCanvas.width !== width || this.maskCanvas.height !== height || this.debugMode) {
             this._updateMask(width, height, s, d);
             this._maskDirty = false;
        }
        const showLines = (this.c.state.layerEnableQuantizedLines !== false);
        const showSource = (this.c.state.layerEnableQuantizedGridCache === true);
        if ((glowStrength > 0 && showLines) || showSource) {
            const isSolid = this.c.state.quantizedSolidPerimeter || false;
            if (showSource) {
                this._updateGridCache(width, height, s, d);
                const srcOffX = (0) + (d.cellWidth * 0.5);
                const srcOffY = (0) + (d.cellHeight * 0.5);
                ctx.save();
                ctx.globalAlpha = 0.3; 
                ctx.globalCompositeOperation = 'source-over';
                ctx.translate(srcOffX, srcOffY);
                ctx.drawImage(this.gridCacheCanvas, 0, 0);
                ctx.restore();
            }
            if (showLines && glowStrength > 0) {
                const scratchCtx = this.scratchCtx;
                const srcOffX = (0) + (d.cellWidth * 0.5);
                const srcOffY = (0) + (d.cellHeight * 0.5);
                scratchCtx.globalCompositeOperation = 'source-over';
                scratchCtx.clearRect(0, 0, width, height);
                if (isSolid) {
                    scratchCtx.globalAlpha = this.alpha;
                    scratchCtx.drawImage(this.lineMaskCanvas, 0, 0);
                } else {
                    this._updateGridCache(width, height, s, d);
                    scratchCtx.globalAlpha = 1.0; 
                    scratchCtx.save();
                    scratchCtx.translate(srcOffX, srcOffY);
                    scratchCtx.drawImage(this.gridCacheCanvas, 0, 0);
                    scratchCtx.restore();
                    // Mask the characters with the colored fading lines
                    // Using source-in ensures characters take the line colors and alpha
                    scratchCtx.globalCompositeOperation = 'source-in';
                    scratchCtx.globalAlpha = this.alpha;
                    scratchCtx.drawImage(this.lineMaskCanvas, 0, 0);
                }
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; 
                const alphaMult = Math.min(1.0, glowStrength / 4.0); 
                ctx.globalAlpha = alphaMult;
                ctx.drawImage(this.scratchCanvas, 0, 0);
                ctx.restore();
            }
        }
    }
    renderDebug(ctx, derived) {
        if (!this.debugMode) return;
        const s = this.c.state;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        this._ensureCanvases(width, height);
        if (!this.layout || this.maskCanvas.width !== width || this._maskDirty) {
             this._updateMask(width, height, s, derived);
             this._maskDirty = false;
        }
        this._updateGridCache(width, height, s, derived);
        const scratchCtx = this.scratchCtx;
        scratchCtx.globalCompositeOperation = 'source-over';
        scratchCtx.clearRect(0, 0, width, height);
        scratchCtx.globalAlpha = 1.0; 
        const srcOffX = (0) + (derived.cellWidth * 0.5);
        const srcOffY = (0) + (derived.cellHeight * 0.5);
        scratchCtx.save();
        scratchCtx.translate(srcOffX, srcOffY);
        scratchCtx.drawImage(this.gridCacheCanvas, 0, 0);
        scratchCtx.restore();
        scratchCtx.globalCompositeOperation = 'destination-in';
        scratchCtx.drawImage(this.lineMaskCanvas, 0, 0);
        ctx.save();
        if (ctx.canvas.style.mixBlendMode !== 'plus-lighter') {
            ctx.canvas.style.mixBlendMode = 'plus-lighter';
        }
        ctx.globalCompositeOperation = 'lighter';
        const glowStrength = this.getConfig('BorderIllumination') || 4.0;
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = (glowStrength * 4.0);
        ctx.drawImage(this.scratchCanvas, 0, 0);
        ctx.restore();
    }
    renderEditorPreview(ctx, derived, previewOp) {
        const opHash = previewOp ? JSON.stringify(previewOp) : "";
        const stateHash = `${this.maskOps.length}_${this.expansionPhase}_${opHash}`;
        if (stateHash !== this._lastPreviewStateHash) {
            const savedLogicGrid = new Uint8Array(this.logicGrid);
            const savedMaskOpsLen = this.maskOps.length;
            if (previewOp) {
                this._executeStepOps([previewOp], this.animFrame);
            }
            const opsAdded = this.maskOps.length - savedMaskOpsLen;
            if (typeof this._updateRenderGridLogic === 'function') {
                this._updateRenderGridLogic();
            }
            this._maskDirty = true; 
            this._lastPreviewSavedLogic = savedLogicGrid;
            this._lastPreviewSavedOpsLen = savedMaskOpsLen;
            this._lastPreviewOpsAddedCount = opsAdded;
            this._lastPreviewStateHash = stateHash;
            this._previewActive = true;
        }
        const s = this.c.state;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        this._ensureCanvases(width, height);
        this._checkDirtiness();
        if (this._maskDirty) {
             this._updateMask(width, height, s, derived);
             this._maskDirty = false;
        }
        const isSolid = this.c.state.quantizedSolidPerimeter || false;
        if (this.c.state.layerEnableQuantizedGridCache === true) {
            this._updateGridCache(width, height, s, derived);
            const srcOffX = (0) + (derived.cellWidth * 0.5);
            const srcOffY = (0) + (derived.cellHeight * 0.5);
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.globalCompositeOperation = 'source-over';
            ctx.translate(srcOffX, srcOffY);
            ctx.drawImage(this.gridCacheCanvas, 0, 0);
            ctx.restore();
        }
        const scratchCtx = this.scratchCtx;
        const srcOffX = (0) + (derived.cellWidth * 0.5);
        const srcOffY = (0) + (derived.cellHeight * 0.5);
        scratchCtx.globalCompositeOperation = 'source-over';
        scratchCtx.clearRect(0, 0, width, height);
        if (isSolid) {
            scratchCtx.globalAlpha = this.alpha;
            scratchCtx.drawImage(this.lineMaskCanvas, 0, 0);
        } else {
            this._updateGridCache(width, height, s, derived);
            scratchCtx.globalAlpha = 1.0;
            scratchCtx.save();
            scratchCtx.translate(srcOffX, srcOffY);
            scratchCtx.drawImage(this.gridCacheCanvas, 0, 0);
            scratchCtx.restore();
            scratchCtx.globalCompositeOperation = 'source-in';
            scratchCtx.globalAlpha = this.alpha;
            scratchCtx.drawImage(this.lineMaskCanvas, 0, 0);
        }
        ctx.save();
        ctx.globalCompositeOperation = 'lighter'; 
        ctx.drawImage(this.scratchCanvas, 0, 0);
        ctx.restore();
        if (this._previewActive) {
            // Surgically remove exactly the number of ops we added for the preview
            if (this._lastPreviewOpsAddedCount > 0) {
                this.maskOps.splice(this._lastPreviewSavedOpsLen, this._lastPreviewOpsAddedCount);
            }
            this.logicGrid.set(this._lastPreviewSavedLogic);
            this.renderGrid.fill(-1);
            for (let i = 0; i < 3; i++) {
                 if (this.layerGrids[i]) this.layerGrids[i].fill(-1);
            }
            this._lastProcessedOpIndex = 0;
            if (typeof this._updateRenderGridLogic === 'function') {
                this._updateRenderGridLogic();
            }
            this._maskDirty = true;
            this._previewActive = false;
        }
    }
    renderEditorGrid(ctx) {
        if (!this.layout) return;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const l = this.layout;
        if (this.c.state.layerEnableEditorGrid === false) return;
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        const gridOffX = 0;
        const gridOffY = 0;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; 
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let bx = 0; bx <= blocksX; bx++) {
            let cellX = Math.round((bx - l.offX + l.userBlockOffX) * l.cellPitchX);
            cellX = Math.max(0, Math.min(this.g.cols, cellX));
            const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + gridOffX;
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
        }
        for (let by = 0; by <= blocksY; by++) {
            let cellY = Math.round((by - l.offY + l.userBlockOffY) * l.cellPitchY);
            cellY = Math.max(0, Math.min(this.g.rows, cellY));
            const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + gridOffY;
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
        }
        ctx.stroke();
        let centerCellX = Math.round((cx - l.offX + l.userBlockOffX) * l.cellPitchX);
        centerCellX = Math.max(0, Math.min(this.g.cols, centerCellX));
        let centerCellY = Math.round((cy - l.offY + l.userBlockOffY) * l.cellPitchY);
        centerCellY = Math.max(0, Math.min(this.g.rows, centerCellY));
        const centerX = l.screenOriginX + (centerCellX * l.screenStepX) + l.pixelOffX + gridOffX;
        const centerY = l.screenOriginY + (centerCellY * l.screenStepY) + l.pixelOffY + gridOffY;
        const bW = Math.round(l.cellPitchX) * l.screenStepX; 
        const bH = Math.round(l.cellPitchY) * l.screenStepY;
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.strokeRect(centerX, centerY, bW, bH);
        ctx.restore();
    }
    renderEditorOverlay(ctx) {
         if (!this.layout) return;
         const l = this.layout;
         if (this.c.state.layerEnableEditorOverlay === false) return;
         const blocksX = this.logicGridW;
         const blocksY = this.logicGridH;
         const cx = Math.floor(blocksX / 2);
         const cy = Math.floor(this.logicGridH / 2);
         const changesOffX = 0;
         const changesOffY = 0;
         ctx.save();
        const layerColors = ['rgba(0, 255, 0, 0.15)', 'rgba(0, 200, 255, 0.15)', 'rgba(255, 0, 200, 0.15)'];
        const layerLines = ['rgba(0, 255, 0, 0.8)', 'rgba(0, 200, 255, 0.8)', 'rgba(255, 0, 200, 0.8)'];
        // Draw Fills in reverse layer order (back-to-front), but only top 3 + alternating visible
        const visibleIndices = this.layerOrder.filter(l => l >= 0 && l <= 2);
        for (let i = visibleIndices.length - 1; i >= 0; i--) {
            const lIdx = visibleIndices[i];
            if (this.visibleLayers && this.visibleLayers[lIdx] === false) continue;
            const rGrid = this.layerGrids[lIdx];
            if (rGrid) {
                ctx.fillStyle = layerColors[lIdx];
                for (let idx = 0; idx < rGrid.length; idx++) {
                    if (rGrid[idx] !== -1) {
                        const bx = idx % blocksX;
                        const by = Math.floor(idx / blocksX);
                        let cellX = Math.round((bx - l.offX + l.userBlockOffX) * l.cellPitchX);
                        let cellY = Math.round((by - l.offY + l.userBlockOffY) * l.cellPitchY);
                        cellX = Math.max(0, Math.min(this.g.cols, cellX));
                        cellY = Math.max(0, Math.min(this.g.rows, cellY));
                        const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                        const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                        let nextCellX = Math.round((bx + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                        let nextCellY = Math.round((by + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                        nextCellX = Math.max(0, Math.min(this.g.cols, nextCellX));
                        nextCellY = Math.max(0, Math.min(this.g.rows, nextCellY));
                        const w = (nextCellX - cellX) * l.screenStepX;
                        const h = (nextCellY - cellY) * l.screenStepY;
                        ctx.fillRect(x, y, w, h); 
                    }
                }
            }
        }
        const getVal = (grid, bx, by) => {
            if (bx < 0 || bx >= blocksX || by < 0 || by >= blocksY) return -1;
            return grid[by * blocksX + bx];
        };
        // Draw Lines in reverse layer order (back-to-front), but only top 3 + alternating visible
        for (let i = visibleIndices.length - 1; i >= 0; i--) {
            const lIdx = visibleIndices[i];
            if (this.visibleLayers && this.visibleLayers[lIdx] === false) continue;
            const rGrid = this.layerGrids[lIdx];
            if (!rGrid) continue;
            const pSolid = new Path2D();
            for (let x = 0; x <= blocksX; x++) {
                for (let y = 0; y < blocksY; y++) {
                    const activeL = (getVal(rGrid, x - 1, y) !== -1);
                    const activeR = (getVal(rGrid, x, y) !== -1);
                    if (activeL !== activeR) {
                        // Perimeter of Layer lIdx. Is it obscured by any higher layer in the order?
                        let obscured = false;
                        for (let j = 0; j < i; j++) {
                            const higherLIdx = visibleIndices[j];
                            // Only obscure if the higher layer is also VISIBLE in the editor
                            if (this.visibleLayers && this.visibleLayers[higherLIdx] === false) continue;
                            if (getVal(this.layerGrids[higherLIdx], x - 1, y) !== -1 || getVal(this.layerGrids[higherLIdx], x, y) !== -1) {
                                obscured = true;
                                break;
                            }
                        }
                        if (!obscured) {
                            let cellX = Math.round((x - l.offX + l.userBlockOffX) * l.cellPitchX);
                            cellX = Math.max(0, Math.min(this.g.cols, cellX));
                            let cellY1 = Math.round((y - l.offY + l.userBlockOffY) * l.cellPitchY);
                            let cellY2 = Math.round((y + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                            cellY1 = Math.max(0, Math.min(this.g.rows, cellY1));
                            cellY2 = Math.max(0, Math.min(this.g.rows, cellY2));
                            const px = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                            const py1 = l.screenOriginY + (cellY1 * l.screenStepY) + l.pixelOffY + changesOffY;
                            const py2 = l.screenOriginY + (cellY2 * l.screenStepY) + l.pixelOffY + changesOffY;
                            pSolid.moveTo(px, py1);
                            pSolid.lineTo(px, py2);
                        }
                    }
                }
            }
            for (let y = 0; y <= blocksY; y++) {
                for (let x = 0; x < blocksX; x++) {
                    const activeT = (getVal(rGrid, x, y - 1) !== -1);
                    const activeB = (getVal(rGrid, x, y) !== -1);
                    if (activeT !== activeB) {
                        // Perimeter of Layer lIdx. Is it obscured by any higher layer in the order?
                        let obscured = false;
                        for (let j = 0; j < i; j++) {
                            const higherLIdx = visibleIndices[j];
                            // Only obscure if the higher layer is also VISIBLE in the editor
                            if (this.visibleLayers && this.visibleLayers[higherLIdx] === false) continue;
                            if (getVal(this.layerGrids[higherLIdx], x, y - 1) !== -1 || getVal(this.layerGrids[higherLIdx], x, y) !== -1) {
                                obscured = true;
                                break;
                            }
                        }
                        if (!obscured) {
                            let cellY = Math.round((y - l.offY + l.userBlockOffY) * l.cellPitchY);
                            cellY = Math.max(0, Math.min(this.g.rows, cellY));
                            let cellX1 = Math.round((x - l.offX + l.userBlockOffX) * l.cellPitchX);
                            let cellX2 = Math.round((x + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                            cellX1 = Math.max(0, Math.min(this.g.cols, cellX1));
                            cellX2 = Math.max(0, Math.min(this.g.cols, cellX2));
                            const py = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                            const px1 = l.screenOriginX + (cellX1 * l.screenStepX) + l.pixelOffX + changesOffX;
                            const px2 = l.screenOriginX + (cellX2 * l.screenStepX) + l.pixelOffX + changesOffX;
                            pSolid.moveTo(px1, py);
                            pSolid.lineTo(px2, py);
                        }
                    }
                }
            }
            ctx.strokeStyle = layerLines[lIdx];
            ctx.stroke(pSolid);
        }
        const ops = this.maskOps;
        if (ops && this.c.state.layerEnableEditorRemovals !== false) {
            for (const op of ops) {
                if (op.type === 'removeBlock') {
                    if (op.startPhase !== this.expansionPhase) continue;
                    const bx = cx + op.x1;
                    const by = cy + op.y1;
                    let cellX = Math.round((bx - l.offX + l.userBlockOffX) * l.cellPitchX);
                    let cellY = Math.round((by - l.offY + l.userBlockOffY) * l.cellPitchY);
                    cellX = Math.max(0, Math.min(this.g.cols, cellX));
                    cellY = Math.max(0, Math.min(this.g.rows, cellY));
                    const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                    const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                    let nextCellX = Math.round((bx + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                    let nextCellY = Math.round((by + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                    nextCellX = Math.max(0, Math.min(this.g.cols, nextCellX));
                    nextCellY = Math.max(0, Math.min(this.g.rows, nextCellY));
                    const w = (nextCellX - cellX) * l.screenStepX;
                    const h = (nextCellY - cellY) * l.screenStepY;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                }
            }
        }
        ctx.restore();
    }
    // =========================================================================
    // PROCEDURAL GENERATION (from BlockGenerator)
    // =========================================================================
    _initProceduralState() {
        if (this.proceduralInitiated) return;
        this.proceduralInitiated = true;
        console.log("[QuantizedBaseEffect] Initializing Procedural State");
        // Initialize activeBlocks from current maskOps (manual steps)
        if (this.maskOps) {
            for (const op of this.maskOps) {
                if (op.type === 'add' || op.type === 'addSmart') {
                    // Reconstruct block object
                    const id = this.nextBlockId++;
                    this.activeBlocks.push({
                        x: op.x1, y: op.y1, 
                        w: Math.abs(op.x2 - op.x1) + 1, 
                        h: Math.abs(op.y2 - op.y1) + 1,
                        startFrame: op.startFrame || this.animFrame,
                        layer: op.layer || 0,
                        id: id
                    });
                } else if (op.type === 'removeBlock') {
                    const bx1 = op.x1, by1 = op.y1;
                    const bx2 = (op.x2 !== undefined) ? op.x2 : bx1;
                    const by2 = (op.y2 !== undefined) ? op.y2 : by1;
                    const layer = op.layer; // can be undefined
                    this.activeBlocks = this.activeBlocks.filter(b => {
                        // If layer is specified, only remove from that layer
                        if (layer !== undefined && b.layer !== layer) return true;
                        // Check if block b is within or overlaps with removal rect (bx1, by1) to (bx2, by2)
                        // For structural blocks, we usually want to remove it if its anchor (top-left) matches,
                        // or if it's fully contained. Let's use anchor match for simplicity as most ops are 1x1 removals of larger blocks.
                        // Actually, let's check if the block's area overlaps with the removal area.
                        const b_x2 = b.x + b.w - 1;
                        const b_y2 = b.y + b.h - 1;
                        const overlap = !(b.x > bx2 || b_x2 < bx1 || b.y > by2 || b_y2 < by1);
                        return !overlap;
                    });
                }
            }
        }
        // Initialize growth states
        this.unfoldSequences = Array.from({ length: 3 }, () => []);
        this.nudgeState = {
            dirCounts: { N: 0, S: 0, E: 0, W: 0 },
            fieldExpansion: { N: 0, S: 0, E: 0, W: 0 },
            lanes: new Map() // Tracks {0: count, 1: count} per lane
        };
        this.overlapState = { step: 0 };
        this.cycleState = { step: 0, step1Block: null };
        this.centeredState = null;
        this.rearrangePool = Array.from({ length: 3 }, () => 0);
        // Ensure we have at least one anchor if starting fresh
        if (this.activeBlocks.length === 0) {
            // Principle #3: Adhere to LayerCount setting. 
            // Seed the center block on all active layers to ensure they have an initial anchor.
            const maxLayer = this.getConfig('LayerCount') || 0;
            for (let l = 0; l <= maxLayer; l++) {
                // Use skipConnectivity=true and bypassOccupancy=true for the initial seeds
                this._spawnBlock(0, 0, 1, 1, l, false, 0, true, true, false, false, true);
            }
        }
    }
    _processActiveStatefulBehaviors(targetLayer) {
        let updated = false;
        if (this.unfoldSequences && this.unfoldSequences[targetLayer]) {
            for (let i = this.unfoldSequences[targetLayer].length - 1; i >= 0; i--) {
                const seq = this.unfoldSequences[targetLayer][i];
                if (seq.active) {
                    if (this._attemptUnfoldGrowth(seq, targetLayer)) updated = true;
                } else {
                    this.unfoldSequences[targetLayer].splice(i, 1);
                }
            }
        }
        return updated;
    }
    _attemptGrowth() {
        if (this._isCanvasFullyCovered()) return;
        this._initProceduralState();
        const s = this.c.state;
        const getGenConfig = (key) => {
            const val = this.getConfig(key);
            if (val !== undefined) return val;
            return s['quantizedGenerateV2' + key];
        };
        const enUnfold = getGenConfig('EnableUnfold');
        const enNudge = getGenConfig('EnableNudge');
        const enCluster = getGenConfig('EnableCluster');
        const enShift = getGenConfig('EnableShift');
        const enCentered = getGenConfig('EnableCentered');
        
        // Default behaviors if nothing is explicitly configured for this effect
        // Most effects should at least Nudge and Cluster to ensure coverage.
        const useUnfold = (enUnfold === true);
        const useNudge = (enNudge === true || enNudge === undefined);
        const useCluster = (enCluster === true || enCluster === undefined);
        const useShift = (enShift === true);
        const useCentered = (enCentered === true);
        const quota = getGenConfig('SimultaneousSpawns') || 1;
        const maxLayer = getGenConfig('LayerCount') || 0; 
        // Determine target layer for THIS step (Sequential Rotation)
        const targetLayer = this.proceduralLayerIndex;
        const pool = [];
        if (useUnfold) pool.push(() => this._attemptUnfoldGrowth(null, targetLayer));
        if (useNudge) {
            pool.push(() => {
                const sw = getGenConfig('MinBlockWidth') || 1;
                const mw = getGenConfig('MaxBlockWidth') || 3;
                const sh = getGenConfig('MinBlockHeight') || 1;
                const mh = getGenConfig('MaxBlockHeight') || 3;
                const bw = Math.floor(Math.random() * (mw - sw + 1)) + sw;
                const bh = Math.floor(Math.random() * (mh - sh + 1)) + sh;
                return this._attemptNudgeGrowthWithParams(targetLayer, bw, bh);
            });
        }
        if (useCluster) pool.push(() => this._attemptClusterGrowth(null, targetLayer));
        if (useShift) {
            pool.push(() => this._attemptSpokeShiftGrowth(null, targetLayer));
            pool.push(() => this._attemptQuadrantShiftGrowth(null, targetLayer));
        }
        if (useCentered) pool.push(() => this._attemptCenteredGrowth(null, targetLayer));
        // Execute total quota of actions
        let actionsPerformed = 0;
        const maxAttempts = quota * 2; 
        let attempts = 0;
        while (actionsPerformed < quota && attempts < maxAttempts) {
            attempts++;
            let success = false;
            if (pool.length > 0) {
                const behavior = pool[Math.floor(Math.random() * pool.length)];
                if (behavior()) success = true;
            }
            if (success) actionsPerformed++;
        }
        // Rotate layer for NEXT step
        this.proceduralLayerIndex = (this.proceduralLayerIndex + 1) % (maxLayer + 1);
    }
    _isNudgePathFull(x, y, w, h, face, layer) {
        const grid = this.layerGrids[layer];
        if (!grid) return false;
        const bx = this.logicGridW, by = this.logicGridH;
        const cx = Math.floor(bx / 2), cy = Math.floor(by / 2);
        // Visible boundary limits (Canvas + 1 block)
        const bs = this.getBlockSize();
        const visW = Math.ceil(this.g.cols / bs.w);
        const visH = Math.ceil(this.g.rows / bs.h);
        const xLimit = Math.floor(visW / 2) + 1;
        const yLimit = Math.floor(visH / 2) + 1;
        const isLaneFull = (rx, ry, dx, dy) => {
            // Check if the chain is unbroken from current point to the VISIBLE boundary
            let tx = rx, ty = ry;
            while (true) {
                // If we hit the boundary of the visible area, this lane is "full"
                if (tx < -xLimit || tx > xLimit || ty < -yLimit || ty > yLimit) break;
                const gx = cx + tx, gy = cy + ty;
                if (gx < 0 || gx >= bx || gy < 0 || gy >= by) break;
                if (grid[gy * bx + gx] === -1) return false; // Gap found, not full
                tx += dx; ty += dy;
                if (Math.abs(tx) > bx || Math.abs(ty) > by) break; // Safety
            }
            return true;
        };
        // Check each row/column in the nudge span
        for (let ly = 0; ly < h; ly++) {
            for (let lx = 0; lx < w; lx++) {
                const tx = x + lx, ty = y + ly;
                let full = false;
                if (face === 'E') full = isLaneFull(tx, ty, 1, 0);
                else if (face === 'W') full = isLaneFull(tx, ty, -1, 0);
                else if (face === 'S') full = isLaneFull(tx, ty, 0, 1);
                else if (face === 'N') full = isLaneFull(tx, ty, 0, -1);
                if (full) return true;
            }
        }
        return false;
    }
    _attemptNudgeGrowthWithParams(targetLayer, bw, bh) {
        if (!this.logicGridW || !this.logicGridH) return false;
        const w = this.logicGridW;
        const h = this.logicGridH;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(h / 2);
        const grid = this.layerGrids[targetLayer];
        if (!grid) return false;
        // 1. Pick a Cardinal Face (Direction) - Biased by Aspect Ratio
        const faces = this._getBiasedDirections();
        for (const dir of faces) {
            // Offsets from axis: 0, 1, -1, 2, -2, 3, -3...
            const maxOffset = Math.max(cx, cy);
            for (let offset = 0; offset <= maxOffset; offset++) {
                // Try both sides of the axis for this offset
                const dxs = (offset === 0) ? [0] : [offset, -offset];
                for (const dAxis of dxs) {
                    let isContinuous = true;
                    let firstEmpty = null;
                    if (dir === 'N' || dir === 'S') {
                        // Check Vertical Spoke at x = cx + dAxis
                        const gx = cx + dAxis;
                        if (gx < 0 || gx >= w) continue;
                        const startY = (dir === 'N') ? cy - 1 : cy + 1;
                        const endY = (dir === 'N') ? 0 : h - 1;
                        const step = (dir === 'N') ? -1 : 1;
                        for (let gy = startY; (dir === 'N' ? gy >= endY : gy <= endY); gy += step) {
                            if (grid[gy * w + gx] === -1) {
                                isContinuous = false;
                                if (firstEmpty === null) firstEmpty = { x: dAxis, y: gy - cy };
                            }
                        }
                    } else {
                        // Check Horizontal Spoke at y = cy + dAxis
                        const gy = cy + dAxis;
                        if (gy < 0 || gy >= h) continue;
                        const startX = (dir === 'W') ? cx - 1 : cx + 1;
                        const endX = (dir === 'W') ? 0 : w - 1;
                        const step = (dir === 'W') ? -1 : 1;
                        for (let gx = startX; (dir === 'W' ? gx >= endX : gx <= endX); gx += step) {
                            if (grid[gy * w + gx] === -1) {
                                isContinuous = false;
                                if (firstEmpty === null) firstEmpty = { x: gx - cx, y: dAxis };
                            }
                        }
                    }
                    // If the spoke isn't full, fill the gap closest to center
                    if (!isContinuous && firstEmpty) {
                        let spawnX = firstEmpty.x;
                        let spawnY = firstEmpty.y;
                        // Align requested dimensions
                        if (dir === 'N') { spawnY = firstEmpty.y - bh + 1; spawnX = firstEmpty.x - Math.floor(bw / 2); }
                        else if (dir === 'S') { spawnY = firstEmpty.y; spawnX = firstEmpty.x - Math.floor(bw / 2); }
                        else if (dir === 'W') { spawnX = firstEmpty.x - bw + 1; spawnY = firstEmpty.y - Math.floor(bh / 2); }
                        else if (dir === 'E') { spawnX = firstEmpty.x; spawnY = firstEmpty.y - Math.floor(bh / 2); }
                        // Override Rule Stack to ensure continuity
                        if (this._spawnBlock(spawnX, spawnY, bw, bh, targetLayer, false, 0, true, true, false, false, true) !== -1) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    _attemptQuadrantShiftGrowth(ignored, targetLayer) {
        if (targetLayer === 0) return false; // Sub-layers only
        const s = this.c.state;
        const freq = s.quantizedGenerateV2ShiftFrequency || 5;
        if (Math.random() * 10 > freq) return false;
        const w = this.logicGridW;
        const h = this.logicGridH;
        if (!w || !h) return false;
        const grid = this.layerGrids[targetLayer];
        if (!grid) return false;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(h / 2);
        // 1. Pick a Quadrant
        const quads = ['NW', 'NE', 'SW', 'SE'];
        Utils.shuffle(quads);
        for (const q of quads) {
            let xStart, xEnd, yStart, yEnd;
            if (q === 'NW') { xStart = 0; xEnd = cx - 1; yStart = 0; yEnd = cy - 1; }
            else if (q === 'NE') { xStart = cx; xEnd = w - 1; yStart = 0; yEnd = cy - 1; }
            else if (q === 'SW') { xStart = 0; xEnd = cx - 1; yStart = cy; yEnd = h - 1; }
            else { xStart = cx; xEnd = w - 1; yStart = cy; yEnd = h - 1; }
            // 2. Thickness Check
            let maxThickness = 0;
            if (q === 'NW' || q === 'SW') { // West side
                for (let gy = yStart; gy <= yEnd; gy++) {
                    let thick = 0;
                    for (let gx = xStart; gx <= xEnd; gx++) if (grid[gy * w + gx] !== -1) thick++;
                    maxThickness = Math.max(maxThickness, thick);
                }
            } else { // East side
                for (let gy = yStart; gy <= yEnd; gy++) {
                    let thick = 0;
                    for (let gx = xEnd; gx >= xStart; gx--) if (grid[gy * w + gx] !== -1) thick++;
                    maxThickness = Math.max(maxThickness, thick);
                }
            }
            if (maxThickness >= (s.quantizedGenerateV2ShiftMaxThickness || 5)) continue;
            // 3. Find a Group (3x3, 3x2, etc.)
            const sizes = [{w:3, h:3}, {w:3, h:2}, {w:2, h:3}, {w:4, h:3}, {w:3, h:4}];
            Utils.shuffle(sizes);
            for (const sz of sizes) {
                const candidates = [];
                for (let gy = yStart; gy <= yEnd - sz.h + 1; gy++) {
                    for (let gx = xStart; gx <= xEnd - sz.w + 1; gx++) {
                        let count = 0;
                        for (let iy = 0; iy < sz.h; iy++) {
                            for (let ix = 0; ix < sz.w; ix++) {
                                if (grid[(gy + iy) * w + (gx + ix)] !== -1) count++;
                            }
                        }
                        // Accept cluster if at least 50% populated
                        if (count >= (sz.w * sz.h) * 0.5) candidates.push({gx, gy});
                    }
                }
                if (candidates.length > 0) {
                    const best = candidates[Math.floor(Math.random() * candidates.length)];
                    // 4. Shift Direction (Away from center axis)
                    let dx = 0, dy = 0;
                    if (q === 'NW') { dx = -1; dy = -1; }
                    else if (q === 'NE') { dx = 1; dy = -1; }
                    else if (q === 'SW') { dx = -1; dy = 1; }
                    else { dx = 1; dy = 1; }
                    const bias = this._getBiasedDirections();
                    if (bias[0] === 'N' || bias[0] === 'S') dx = 0;
                    else dy = 0;
                    // 5. "Never leave holes behind" check:
                    // Ensure the NEW position is still connected to the mass (not an island).
                    const nx = best.gx + dx, ny = best.gy + dy;
                    if (nx < 0 || nx + sz.w > w || ny < 0 || ny + sz.h > h) continue;
                    let connectedAtTarget = false;
                    for (let iy = -1; iy <= sz.h; iy++) {
                        for (let ix = -1; ix <= sz.w; ix++) {
                            if (ix >= 0 && ix < sz.w && iy >= 0 && iy < sz.h) continue; // Skip self
                            const tx = nx + ix, ty = ny + iy;
                            if (tx >= 0 && tx < w && ty >= 0 && ty < h) {
                                if (grid[ty * w + tx] !== -1) { connectedAtTarget = true; break; }
                            }
                        }
                        if (connectedAtTarget) break;
                    }
                    if (!connectedAtTarget) continue;
                    // 6. Execute True Shift (Remove Source, Add Target)
                    const lx = best.gx - cx, ly = best.gy - cy;
                    // Add REM operations for the source area
                    for (let iy = 0; iy < sz.h; iy++) {
                        for (let ix = 0; ix < sz.w; ix++) {
                            const tx = best.gx + ix, ty = best.gy + iy;
                            // Only REM if it was actually occupied
                            if (grid[ty * w + tx] === -1) continue; 
                            const inNew = (tx >= nx && tx < nx + sz.w && ty >= ny && ty < ny + sz.h);
                            if (!inNew) {
                                this._executeStepOps([{ op: 'rem', args: [tx - cx, ty - cy], layer: targetLayer }], this.animFrame);
                            }
                        }
                    }
                    // Spawn at new location
                    if (this._spawnBlock(lx + dx, ly + dy, sz.w, sz.h, targetLayer, true, 0, true, true, false, false, true) !== -1) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    _spawnBlock(x, y, w, h, layer = 0, isShifter = false, expireFrames = 0, skipConnectivity = false, allowInternal = false, suppressFades = false, isMirroredSpawn = false, bypassOccupancy = false) {
        const bs = this.getBlockSize();
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        if (!blocksX || !blocksY) return -1;
        // 0. Safety Limits
        if (this.maskOps.length > 50000 || this.activeBlocks.length > 50000) {
            this._warn("QuantizedBlockGenerator: maskOps/activeBlocks limit reached, stopping growth.");
            return -1;
        }
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        // 1. Grid Boundary Constraint: Logic Grid Bounds
        const wLimit = Math.floor(blocksX / 2);
        const hLimit = Math.floor(blocksY / 2);
        if (cx + x < 0 || cx + x + w > blocksX || cy + y < 0 || cy + y + h > blocksY) {
            // Allow nudge/mirror to push things slightly further if logic grid allows, 
            // but generally restrict to logic grid boundaries.
            if (!isShifter && !isMirroredSpawn) return -1;
        }
        const startX = cx + x;
        const startY = cy + y;
        const minX = Math.max(0, startX);
        const maxX = Math.min(blocksX - 1, startX + w - 1);
        const minY = Math.max(0, startY);
        const maxY = Math.min(blocksY - 1, startY + h - 1);
        if (minX > maxX || minY > maxY) return -1; // Out of logic grid entirely
        // 2. Enforce Strict Layer-Specific Connectivity (Grid-Based Optimization)
        if (!skipConnectivity) {
             let connected = false;
             let overlapArea = 0;
             const targetGrid = this.layerGrids[layer];
             if (targetGrid) {
                 // Check overlap and adjacency in one pass (O(area) instead of O(N_blocks))
                 // Expand search by 1 unit for adjacency
                 search: for (let gy = minY - 1; gy <= maxY + 1; gy++) {
                     if (gy < 0 || gy >= blocksY) continue;
                     const rowOff = gy * blocksX;
                     const isEdgeY = (gy < minY || gy > maxY);
                     for (let gx = minX - 1; gx <= maxX + 1; gx++) {
                         if (gx < 0 || gx >= blocksX) continue;
                         const isEdgeX = (gx < minX || gx > maxX);
                         if (targetGrid[rowOff + gx] !== -1) {
                             if (isEdgeX || isEdgeY) {
                                 connected = true;
                             } else {
                                 overlapArea++;
                                 connected = true; // Overlap also implies connectivity
                             }
                             // If we found connectivity and don't need accurate overlapArea yet, we could break
                             // But we need overlapArea for the internal stacking check
                         }
                     }
                 }
             }
             if (!connected) return -1; 
             // Prevent internal stacking if not allowed
             if (!isShifter && !allowInternal && overlapArea >= (w * h)) return -1; 
        }
        // 3. Optional: Sub-Layer Anchoring
        if (!this._isAnchored(x, y, w, h, layer)) return -1;
        // 4. Occupancy and Logic Grid Update (Merged Loops)
        if (this._stepOccupancy && !bypassOccupancy) {
            for (let gy = minY; gy <= maxY; gy++) {
                const rowOff = gy * blocksX;
                for (let gx = minX; gx <= maxX; gx++) {
                    if (this._stepOccupancy[rowOff + gx] === 1) return -1;
                }
            }
            // Mark occupancy
            for (let gy = minY; gy <= maxY; gy++) {
                const rowOff = gy * blocksX;
                for (let gx = minX; gx <= maxX; gx++) {
                    this._stepOccupancy[rowOff + gx] = 1;
                }
            }
        }
        if (this.logicGrid) {
            for (let gy = minY; gy <= maxY; gy++) {
                const rowOff = gy * blocksX;
                for (let gx = minX; gx <= maxX; gx++) {
                    this.logicGrid[rowOff + gx] = 1;
                }
            }
        }
        const id = this.nextBlockId++;
        const b = { x, y, w, h, startFrame: this.animFrame, startPhase: this.expansionPhase, layer, id, isShifter };
        if (expireFrames > 0) b.expireFrame = this.animFrame + expireFrames;
        this.activeBlocks.push(b);
        if (layer !== 0) this._updateLayerOrder(layer);
        const op = {
            type: 'addSmart', 
            x1: x, y1: y, x2: x + w - 1, y2: y + h - 1,
            startFrame: this.animFrame,
            expireFrame: (expireFrames > 0) ? this.animFrame + expireFrames : null,
            layer: layer,
            blockId: id,
            isShifter: isShifter,
            fade: !suppressFades
        };
        this.maskOps.push(op);
        this._gridsDirty = true;
        // Record to sequence for Editor/Step support
        if (this.manualStep && this.sequence && !this.isReconstructing) {
            if (!this.sequence[this.expansionPhase]) this.sequence[this.expansionPhase] = [];
            const seqOp = {
                op: (w === 1 && h === 1) ? 'addSmart' : 'addRect',
                args: (w === 1 && h === 1) ? [x, y] : [x, y, x + w - 1, y + h - 1],
                layer: layer
            };
            this.sequence[this.expansionPhase].push(seqOp);
        }
        this._writeToGrid(x, y, w, h, this.animFrame, layer);
        return id;
    }
    _writeToGrid(x, y, w, h, value, layer = 0) {
        if (!this.renderGrid) return;
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        const startX = cx + x;
        const startY = cy + y;
        const minX = Math.max(0, startX);
        const maxX = Math.min(blocksX - 1, startX + w - 1);
        const minY = Math.max(0, startY);
        const maxY = Math.min(blocksY - 1, startY + h - 1);
        for (let gy = minY; gy <= maxY; gy++) {
            for (let gx = minX; gx <= maxX; gx++) {
                const idx = gy * blocksX + gx;
                // Update specific layer
                if (this.layerGrids[layer]) {
                    this.layerGrids[layer][idx] = value;
                }
                // Composite to renderGrid using current layerOrder priority
                let finalValue = -1;
                const visibleIndices = this.layerOrder.filter(l => l >= 0 && l <= 2);
                for (let j = 0; j < visibleIndices.length; j++) {
                    const lIdx = visibleIndices[j];
                    if (this.layerGrids[lIdx] && this.layerGrids[lIdx][idx] !== -1) {
                        finalValue = this.layerGrids[lIdx][idx];
                        break;
                    }
                }
                this.renderGrid[idx] = finalValue;
            }
        }
    }
    /*
    _attemptCyclicGrowth() {
        const phase = this.cycleState.step % 3;
        const spawnSmart = (layer, mustOverlap, mustProtrude) => {
            const anchors = this.activeBlocks.filter(b => b.layer === 0);
            if (anchors.length === 0) return null;
            const attempts = 40;
            const validShapes = [
                {w:1, h:2}, {w:2, h:1}, {w:1, h:3}, {w:3, h:1},
                {w:2, h:2}, {w:1, h:4}, {w:4, h:1}, {w:1, h:5},
                {w:5, h:1}, {w:2, h:3}, {w:3, h:2}, {w:1, h:6}, {w:6, h:1}
            ];
            for (let i = 0; i < attempts; i++) {
                const anchor = anchors[Math.floor(Math.random() * anchors.length)];
                const shape = validShapes[Math.floor(Math.random() * validShapes.length)];
                const w = shape.w, h = shape.h;
                const ox = Math.floor(Math.random() * (anchor.w + w + 1)) - w;
                const oy = Math.floor(Math.random() * (anchor.h + h + 1)) - h;
                const tx = anchor.x + ox, ty = anchor.y + oy;
                let intersectArea = 0, isTouching = false;
                for (const b of this.activeBlocks) {
                    if (b.layer !== 0) continue; 
                    const ix = Math.max(tx, b.x), iy = Math.max(ty, b.y);
                    const iw = Math.min(tx + w, b.x + b.w) - ix, ih = Math.min(ty + h, b.y + b.h) - iy;
                    if (iw > 0 && ih > 0) intersectArea += (iw * ih);
                    else {
                        const touchX = (tx === b.x + b.w) || (tx + w === b.x);
                        const overlapY = (ty < b.y + b.h) && (ty + h > b.y);
                        const touchY = (ty === b.y + b.h) || (ty + h === b.y);
                        const overlapX = (tx < b.x + b.w) && (tx + w > b.x);
                        if ((touchX && overlapY) || (touchY && overlapX)) isTouching = true;
                    }
                }
                const totalArea = w * h;
                const protrudeArea = totalArea - intersectArea;
                const isConnected = (intersectArea > 0 || isTouching);
                const isProtruding = (protrudeArea > 0);
                if ((!mustOverlap || isConnected) && (!mustProtrude || isProtruding)) {
                    this._spawnBlock(tx, ty, w, h, layer);
                    return { x: tx, y: ty, w, h };
                }
            }
            return null;
        };
        if (phase === 0) { 
            const b = spawnSmart(0, true, true);
            if (b) this.cycleState.step1Block = b;
        } else if (phase === 1) { 
            spawnSmart(1, true, true);
        } else if (phase === 2) { 
            spawnSmart(0, true, true);
            if (this.cycleState.step1Block) {
                const b = this.cycleState.step1Block;
                for (let iy = 0; iy < b.h; iy++) {
                    for (let ix = 0; ix < b.w; ix++) {
                        const lx = b.x + ix, ly = b.y + iy;
                        const faces = ['N', 'S', 'W', 'E'];
                        for (const face of faces) {
                            if (this.manualStep && this.sequence) {
                                if (!this.sequence[this.expansionPhase]) this.sequence[this.expansionPhase] = [];
                            }
                        }
                    }
                }
            }
        }
        this.cycleState.step++;
    }
    */
    _nudge(x, y, w, h, face, layer = 0) {
        const bs = this.getBlockSize();
        const now = this.animFrame;
        const bx = this.logicGridW, by = this.logicGridH;
        const cx = Math.floor(bx / 2), cy = Math.floor(by / 2);
        let axis = 'X', dir = 1;
        if (face) {
            const f = face.toUpperCase();
            if (f === 'N') { axis = 'Y'; dir = -1; }
            else if (f === 'S') { axis = 'Y'; dir = 1; }
            else if (f === 'E') { axis = 'X'; dir = 1; }
            else if (f === 'W') { axis = 'X'; dir = -1; }
        }
        const shiftAmt = (axis === 'X' ? w : h);
        // 1. Identify and Shift blocks
        const shiftedBlocks = [];
        for (const b of this.activeBlocks) {
            if (b.layer !== layer) continue;
            let shouldMove = false;
            if (axis === 'X') {
                const laneMatch = (b.y >= y && b.y < y + h);
                const posMatch = (dir > 0) ? (b.x >= x) : (b.x + b.w - 1 <= x + w - 1);
                if (laneMatch && posMatch) shouldMove = true;
            } else {
                const laneMatch = (b.x >= x && b.x < x + w);
                const posMatch = (dir > 0) ? (b.y >= y) : (b.y + b.h - 1 <= y + h - 1);
                if (laneMatch && posMatch) shouldMove = true;
            }
            if (shouldMove) {
                shiftedBlocks.push({ b, oldX: b.x, oldY: b.y, oldW: b.w, oldH: b.h, start: b.startFrame });
                if (axis === 'X') b.x += (dir * shiftAmt);
                else b.y += (dir * shiftAmt);
            }
        }
        // 2. Synchronize shifts with maskOps (Addition-Only for continuous structure)
        for (const m of shiftedBlocks) {
            // Keep the old position filled in maskOps (don't add a removeBlock op)
            // Record addition at new position
            this.maskOps.push({ 
                type: 'addSmart', 
                x1: m.b.x, y1: m.b.y, x2: m.b.x + m.b.w - 1, y2: m.b.y + m.b.h - 1, 
                startFrame: m.start, startPhase: this.expansionPhase, 
                layer: layer 
            });
            // IMPORTANT: Add a NEW block to activeBlocks at the OLD position 
            // This ensures the simulation matches the physics grid (no holes in collision logic)
            this._spawnBlock(m.oldX, m.oldY, m.oldW, m.oldH, layer, false, 0, true, true, false, false, true);
        }
        // 3. Add the SOURCE REPLACEMENT block at the original origin (x, y)
        if (this._spawnBlock(x, y, w, h, layer, false, 0, true, true, false, false, true) !== -1) {
            // Record to sequence for Editor/Step support (ONLY if not currently reconstructing)
            if (this.manualStep && this.sequence && !this.isReconstructing) {
                if (!this.sequence[this.expansionPhase]) this.sequence[this.expansionPhase] = [];
                this.sequence[this.expansionPhase].push({ 
                    op: 'nudge', 
                    args: [x, y, w, h, face], 
                    layer: layer 
                });
            }
            this._log(`Nudge: Solid Shifted ${shiftedBlocks.length} blocks, continuous mass preserved.`);
            return true;
        }
        return false;
    }
    _nudgeBlock(block, dx, dy) {
        if (!block) return false;
        let face = 'N';
        if (dx === 1) face = 'E';
        else if (dx === -1) face = 'W';
        else if (dy === 1) face = 'S';
        else if (dy === -1) face = 'N';
        // _nudge already contains anchoring and occupancy checks
        return this._nudge(block.x, block.y, block.w, block.h, face, block.layer);
    }
    _attemptSpokeShiftGrowth(ignored, targetLayer = 0) {
        const anchors = this.activeBlocks.filter(b => b.layer === targetLayer);
        if (anchors.length === 0) return false;
        const anchor = anchors[Math.floor(Math.random() * anchors.length)];
        const dirs = this._getBiasedDirections(), dir = dirs[0];
        const amount = Math.floor(Math.random() * 2) + 1;
        let startCoords = (dir === 'N' || dir === 'S') ? { x: anchor.x, y: 0 } : { x: 0, y: anchor.y };
        return this._blockShift(dir, amount, startCoords, targetLayer);
    }
    _blockShift(direction, amount, startCoords, targetLayer = 0) {
        if (!this.renderGrid) return false;
        const w = this.logicGridW, h = this.logicGridH, cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        let dx = 0, dy = 0, scanX = false;
        if (direction === 'N') { dy = -1; scanX = false; }
        else if (direction === 'S') { dy = 1; scanX = false; }
        else if (direction === 'E') { dx = 1; scanX = true; }
        else if (direction === 'W') { dx = -1; scanX = true; }
        const rowY = startCoords.y, colX = startCoords.x;
        let currentRelX = scanX ? 0 : colX, currentRelY = scanX ? rowY : 0;
        let furthestDist = -1; const potentialGaps = [];
        const maxDist = Math.max(w, h);
        for (let d = 0; d < maxDist; d++) {
            const tx = currentRelX + (scanX ? d * dx : 0), ty = currentRelY + (scanX ? 0 : d * dy);
            const gx = cx + tx, gy = cy + ty;
            if (gx < 0 || gx >= w || gy < 0 || gy >= h) break;
            const idx = gy * w + gx;
            if (this.layerGrids[targetLayer] && this.layerGrids[targetLayer][idx] !== -1) furthestDist = d;
            else potentialGaps.push({x: tx, y: ty, d: d});
        }
        let success = false;
        for (const gap of potentialGaps) {
            if (gap.d < furthestDist) {
                if (this._spawnBlock(gap.x, gap.y, 1, 1, targetLayer, false, 0, false, true) !== -1) success = true; 
            }
        }
        let startExt = furthestDist + 1;
        for (let i = 0; i < amount; i++) {
            const d = startExt + i, tx = currentRelX + (scanX ? d * dx : 0), ty = currentRelY + (scanX ? 0 : d * dy);
            const gx = cx + tx, gy = cy + ty;
            if (gx >= 0 && gx < w && gy >= 0 && gy < h) {
                if (this._spawnBlock(tx, ty, 1, 1, targetLayer) !== -1) success = true;
            }
        }
        return success;
    }
    _attemptClusterGrowth(ignored, targetLayer = 0) {
        const anchors = this.activeBlocks.filter(b => b.layer === targetLayer);
        if (anchors.length === 0) return false;
        const anchor = anchors[Math.floor(Math.random() * anchors.length)];
        const dirs = this._getBiasedDirections();
        const dir = dirs[0];
        const axis = (dir === 'N' || dir === 'S') ? 'V' : 'H';
        let startCoords;
        if (axis === 'V') { startCoords = { x: anchor.x, y: 0 }; }
        else { startCoords = { x: 0, y: anchor.y }; }
        return this._blockShift(dir, Math.floor(Math.random() * 2) + 2, startCoords, targetLayer);
    }
    flattenLayers(targetLayers, selectionRect, stepIndex) {
        if (!this.sequence) return 0;
        const layers = targetLayers || [1, 2];
        const layerSet = new Set(layers);
        let count = 0;
        const processStep = (step) => {
            if (!step || !Array.isArray(step)) return;
            for (const opObj of step) {
                let op, args;
                if (Array.isArray(opObj)) {
                    continue; 
                } else {
                    op = opObj;
                    args = op.args;
                }
                if (op.layer && layerSet.has(op.layer)) {
                    if (selectionRect) {
                        const cx = Math.floor(this.logicGridW / 2);
                        const cy = Math.floor(this.logicGridH / 2);
                        let opX1, opY1, opX2, opY2;
                        if (op.op === 'add' || op.op === 'removeBlock' || op.op === 'addSmart') {
                            opX1 = cx + args[0]; opY1 = cy + args[1];
                            opX2 = opX1; opY2 = opY1;
                        } else if (op.op === 'addRect') {
                            opX1 = cx + args[0]; opY1 = cy + args[1];
                            opX2 = cx + args[2]; opY2 = cy + args[3];
                        } else {
                            continue; 
                        }
                        const minX = Math.min(opX1, opX2);
                        const maxX = Math.max(opX1, opX2);
                        const minY = Math.min(opY1, opY2);
                        const maxY = Math.max(opY1, opY2);
                        const sMinX = selectionRect.x;
                        const sMaxX = selectionRect.x + selectionRect.w;
                        const sMinY = selectionRect.y;
                        const sMaxY = selectionRect.y + selectionRect.h;
                        if (maxX < sMinX || minX > sMaxX || maxY < sMinY || minY > sMaxY) {
                            continue; 
                        }
                    }
                    op.layer = 0;
                    count++;
                }
            }
        };
        if (stepIndex !== undefined && stepIndex >= 0) {
            if (stepIndex < this.sequence.length) {
                processStep(this.sequence[stepIndex]);
            }
        } else {
            for (const step of this.sequence) {
                processStep(step);
            }
        }
        return count;
    }
    mergeBlocksAtStep(blocks, stepIndex) {
        if (!this.sequence || stepIndex < 0 || stepIndex >= this.sequence.length) return 0;
        if (!blocks || blocks.length === 0) return 0;
        const step = this.sequence[stepIndex];
        const cx = Math.floor(this.logicGridW / 2);
        const cy = Math.floor(this.logicGridH / 2);
        const w = this.logicGridW;
        let count = 0;
        for (const pt of blocks) {
            const x = pt.x;
            const y = pt.y;
            if (x < 0 || x >= this.logicGridW || y < 0 || y >= this.logicGridH) continue;
            const idx = y * w + x;
            for (let l = 1; l <= 2; l++) {
                const grid = this.layerGrids[l];
                if (grid && grid[idx] !== -1) {
                    const rx = x - cx;
                    const ry = y - cy;
                    step.push({ op: 'removeBlock', args: [rx, ry], layer: l });
                    step.push({ op: 'add', args: [rx, ry], layer: 0 });
                    count++;
                }
            }
        }
        return count;
    }
    mergeSelectionAtStep(selectionRect, stepIndex) {
        if (!this.sequence || stepIndex < 0 || stepIndex >= this.sequence.length) return 0;
        if (!selectionRect) return 0;
        const step = this.sequence[stepIndex];
        const cx = Math.floor(this.logicGridW / 2);
        const cy = Math.floor(this.logicGridH / 2);
        const r = selectionRect;
        const w = this.logicGridW;
        let count = 0;
        for (let y = r.y; y <= r.y + r.h; y++) {
            for (let x = r.x; x <= r.x + r.w; x++) {
                if (x < 0 || x >= this.logicGridW || y < 0 || y >= this.logicGridH) continue;
                const idx = y * w + x;
                for (let l = 1; l <= 2; l++) {
                    const grid = this.layerGrids[l];
                    if (grid && grid[idx] !== -1) {
                        const rx = x - cx;
                        const ry = y - cy;
                        step.push({ op: 'removeBlock', args: [rx, ry], layer: l });
                        step.push({ op: 'add', args: [rx, ry], layer: 0 });
                        count++;
                    }
                }
            }
        }
        return count;
    }
    _isProceduralFinished() {
        if (!this.renderGrid) return true;
        // 1. Check axis points (fast)
        const w = this.logicGridW;
        const h = this.logicGridH;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(h / 2);
        const check = (x, y) => {
            if (x < 0 || x >= w || y < 0 || y >= h) return true;
            return this.renderGrid[y * w + x] !== -1;
        };
        const hitN = check(cx, 0);
        const hitS = check(cx, h - 1);
        const hitW = check(0, cy);
        const hitE = check(w - 1, cy);
        // 2. If axes reached, perform full visible coverage check
        if (hitN && hitS && hitW && hitE) {
            return this._isCanvasFullyCovered();
        }
        return false;
    }
    _getBiasedCoordinate(minL, maxL, size, pStatus, axis) {
        const centerReached = (axis === 'X') ? (pStatus.E && pStatus.W) : (pStatus.N && pStatus.S);
        if (!centerReached && Math.random() < 0.8) {
            const range = 2;
            const low = Math.max(minL, -range);
            const high = Math.min(maxL - size, range);
            return Math.floor(Math.random() * (high - low + 1)) + low;
        }
        return Math.floor(Math.random() * (maxL - size - minL + 1)) + minL;
    }
    _getPerimeterStatus(offX, offY, visibleW, visibleH) {
        const w = this.logicGridW, h = this.logicGridH;
        const startX = Math.max(0, Math.floor(offX));
        const endX = Math.min(w, startX + visibleW);
        const startY = Math.max(0, Math.floor(offY));
        const endY = Math.min(h, startY + visibleH);
        const status = { N: true, S: true, E: true, W: true };
        const check = (layer) => {
            const grid = this.layerGrids[layer];
            if (!grid) return;
            for (let x = startX; x < endX; x++) if (grid[startY * w + x] === -1) status.N = false;
            const lastY = endY - 1;
            for (let x = startX; x < endX; x++) if (grid[lastY * w + x] === -1) status.S = false;
            for (let y = startY; y < endY; y++) if (grid[y * w + startX] === -1) status.W = false;
            const lastX = endX - 1;
            for (let y = startY; y < endY; y++) if (grid[y * w + lastX] === -1) status.E = false;
        };
        for (let i = 0; i < 3; i++) check(i);
        return status;
    }
    _validateNudgeSafety(x, y, w, h, face, targetLayer, pullOther) {
        if (!this.activeBlocks || this.activeBlocks.length === 0) return true;
        const uf = face.toUpperCase();
        const axis = (uf === 'N' || uf === 'S') ? 'Y' : 'X';
        const dSign = (uf === 'N' || uf === 'W') ? -1 : 1;
        const shiftAmt = (axis === 'X' ? w : h);
        // Virtual view of activeBlocks with projected moves
        const virtualBlocks = {
            length: this.activeBlocks.length + (pullOther ? 2 : 1),
            getItem: (i) => {
                if (i < this.activeBlocks.length) {
                    const b = this.activeBlocks[i];
                    // Check if it's moved
                    let l = b.layer;
                    if (l === targetLayer || (pullOther && l === 1 - targetLayer)) {
                        let move = false;
                        if (axis === 'X') { if (b.y >= y && b.y < y + h && ((dSign > 0 && b.x >= x) || (dSign < 0 && b.x <= x + w - 1))) move = true; }
                        else { if (b.x >= x && b.x < x + w && ((dSign > 0 && b.y >= y) || (dSign < 0 && b.y <= y + h - 1))) move = true; }
                        if (move) {
                            const nb = { ...b };
                            if (axis === 'X') nb.x += (dSign * shiftAmt); else nb.y += (dSign * shiftAmt);
                            return nb;
                        }
                    }
                    return b;
                } else {
                    const idx = i - this.activeBlocks.length;
                    if (idx === 0) return { x, y, w, h, layer: targetLayer };
                    return { x, y, w, h, layer: 1 - targetLayer };
                }
            }
        };
        return this._checkEnvelopeDriftVirtual(virtualBlocks);
    }
    _checkEnvelopeDriftVirtual(virtualBlocks) {
        if (this.getConfig('EnableSubLayerAnchoring') !== true) return true;
        const lgW = this.logicGridW, lgH = this.logicGridH;
        if (!lgW || !lgH) return true;
        const cx = Math.floor(lgW / 2), cy = Math.floor(lgH / 2);
        if (!this._driftBuffers) {
            this._driftBuffers = Array.from({ length: 3 }, () => ({
                colMin: new Int32Array(2000), colMax: new Int32Array(2000),
                rowMin: new Int32Array(2000), rowMax: new Int32Array(2000)
            }));
        }
        const db = this._driftBuffers;
        for (let l = 0; l < 3; l++) {
            db[l].colMin.fill(10000); db[l].colMax.fill(-10000);
            db[l].rowMin.fill(10000); db[l].rowMax.fill(-10000);
        }
        const updateBounds = (b) => {
            const bounds = db[b.layer]; if (!bounds) return;
            const bx1 = cx + b.x, by1 = cy + b.y, bx2 = bx1 + b.w - 1, by2 = by1 + b.h - 1;
            for (let x = Math.max(0, bx1); x <= Math.min(lgW - 1, bx2); x++) { 
                if (bounds.colMin[x] > by1) bounds.colMin[x] = by1; if (bounds.colMax[x] < by2) bounds.colMax[x] = by2; 
            }
            for (let y = Math.max(0, by1); y <= Math.min(lgH - 1, by2); y++) { 
                if (bounds.rowMin[y] > bx1) bounds.rowMin[y] = bx1; if (bounds.rowMax[y] < bx2) bounds.rowMax[y] = bx2; 
            }
        };
        for (let i = 0; i < virtualBlocks.length; i++) updateBounds(virtualBlocks.getItem(i));
        const l0 = db[0], driftLimit = this.getConfig('SubLayerAnchorDistance') || 3;
        for (let l = 1; l < 3; l++) {
            const lb = db[l]; let hasData = false;
            for (let x = 0; x < lgW; x++) { if (lb.colMin[x] !== 10000) { hasData = true; break; } }
            if (!hasData) continue;
            for (let x = 0; x < lgW; x++) {
                if (l0.colMin[x] !== 10000 && lb.colMin[x] !== 10000) {
                    if (Math.abs(l0.colMin[x] - lb.colMin[x]) > driftLimit || Math.abs(l0.colMax[x] - lb.colMax[x]) > driftLimit) return false;
                }
            }
            for (let y = 0; y < lgH; y++) {
                if (l0.rowMin[y] !== 10000 && lb.rowMin[y] !== 10000) {
                    if (Math.abs(l0.rowMin[y] - lb.rowMin[y]) > driftLimit || Math.abs(l0.rowMax[y] - lb.rowMax[y]) > driftLimit) return false;
                }
            }
        }
        return true;
    }
    _checkEnvelopeDrift(blocks, candidate = null) {
        // Only enforce drift limits if SubLayerAnchoring is enabled.
        if (this.getConfig('EnableSubLayerAnchoring') !== true) return true;
        const lgW = this.logicGridW, lgH = this.logicGridH;
        if (!lgW || !lgH) return true;
        const cx = Math.floor(lgW / 2), cy = Math.floor(lgH / 2);
        // Use pooled buffers for bounds tracking
        if (!this._driftBuffers) {
            this._driftBuffers = Array.from({ length: 3 }, () => ({
                colMin: new Int32Array(2000), // Max likely dimension
                colMax: new Int32Array(2000),
                rowMin: new Int32Array(2000),
                rowMax: new Int32Array(2000)
            }));
        }
        const db = this._driftBuffers;
        for (let l = 0; l < 3; l++) {
            db[l].colMin.fill(10000);
            db[l].colMax.fill(-10000);
            db[l].rowMin.fill(10000);
            db[l].rowMax.fill(-10000);
        }
        const updateBounds = (b) => {
            const bounds = db[b.layer];
            if (!bounds) return;
            const bx1 = cx + b.x, by1 = cy + b.y, bx2 = bx1 + b.w - 1, by2 = by1 + b.h - 1;
            for (let x = Math.max(0, bx1); x <= Math.min(lgW - 1, bx2); x++) { 
                if (bounds.colMin[x] > by1) bounds.colMin[x] = by1; 
                if (bounds.colMax[x] < by2) bounds.colMax[x] = b.y2; 
            }
            for (let y = Math.max(0, by1); y <= Math.min(lgH - 1, by2); y++) { 
                if (bounds.rowMin[y] > bx1) bounds.rowMin[y] = bx1; 
                if (bounds.rowMax[y] < bx2) bounds.rowMax[y] = bx2; 
            }
        };
        for (let i = 0; i < blocks.length; i++) updateBounds(blocks[i]);
        if (candidate) updateBounds(candidate);
        const l0 = db[0];
        const driftLimit = this.getConfig('SubLayerAnchorDistance') || 3;
        for (let l = 1; l < 3; l++) {
            const lb = db[l];
            let hasData = false;
            for (let x = 0; x < lgW; x++) { if (lb.colMin[x] !== 10000) { hasData = true; break; } }
            if (!hasData) continue;
            for (let x = 0; x < lgW; x++) {
                if (l0.colMin[x] !== 10000 && lb.colMin[x] !== 10000) {
                    if (Math.abs(l0.colMin[x] - lb.colMin[x]) > driftLimit || Math.abs(l0.colMax[x] - lb.colMax[x]) > driftLimit) return false;
                }
            }
            for (let y = 0; y < lgH; y++) {
                if (l0.rowMin[y] !== 10000 && lb.rowMin[y] !== 10000) {
                    if (Math.abs(l0.rowMin[y] - lb.rowMin[y]) > driftLimit || Math.abs(l0.rowMax[y] - lb.rowMax[y]) > driftLimit) return false;
                }
            }
        }
        return true;
    }
    _mergeLayer1(maxCycle = -1) {
        const now = this.animFrame;
        const blocksToMerge = this.activeBlocks.filter(b => 
            b.layer === 1 && (maxCycle === -1 || b.spawnCycle === undefined || b.spawnCycle <= maxCycle)
        );
        if (blocksToMerge.length === 0) return;
        for (const b of blocksToMerge) {
            this.maskOps.push({ type: 'removeBlock', x1: b.x, y1: b.y, x2: b.x + b.w - 1, y2: b.y + b.h - 1, startFrame: now, layer: 1, fade: false });
            this.maskOps.push({ type: 'add', x1: b.x, y1: b.y, x2: b.x + b.w - 1, y2: b.y + b.h - 1, startFrame: now, layer: 0, blockId: b.id });
            b.layer = 0;
            this._writeToGrid(b.x, b.y, b.w, b.h, now, 0); 
            this._writeToGrid(b.x, b.y, b.w, b.h, -1, 1);  
        }
        this._lastProcessedOpIndex = 0;
        this._maskDirty = true;
    }
    _getScaledConfig(key, defaultValue) {
        const val = this.getConfig(key);
        const finalVal = (val !== undefined) ? val : defaultValue;
        if (this.getConfig('EnableScaledGrowth') === true) {
            // Calculate current mass percentage
            let filled = 0;
            const lg = this.logicGrid;
            if (lg) {
                for (let i = 0; i < lg.length; i++) if (lg[i] === 1) filled++;
                const massPercent = filled / lg.length;
                const isMin = key === 'MinBlockWidth' || key === 'MinBlockHeight';
                const isMax = key === 'MaxBlockWidth' || key === 'MaxBlockHeight';
                if (isMin || isMax) {
                    // Initial Phase (Mass < 5%): Max 2, Min 1
                    if (massPercent < 0.05) {
                        return isMax ? Math.min(finalVal, 2) : Math.min(finalVal, 1);
                    } 
                    // Growth Phase (5% - 25%): Interpolate
                    else if (massPercent < 0.25) {
                        const t = (massPercent - 0.05) / 0.20;
                        if (isMax) return Math.min(finalVal, Math.round(2 + (finalVal - 2) * t));
                        return Math.min(finalVal, Math.round(1 + (finalVal - 1) * t));
                    }
                }
            }
        }
        return finalVal;
    }
    _checkNoOverlap(x, y, w, h, layer = 0) {
        if (!this.logicGridW || !this.logicGridH || !this.logicGrid) return false;
        const cx = Math.floor(this.logicGridW / 2), cy = Math.floor(this.logicGridH / 2);
        const gx1 = cx + x, gy1 = cy + y;
        const gx2 = gx1 + w - 1, gy2 = gy1 + h - 1;
        // Bounds check
        if (gx1 < 0 || gx2 >= this.logicGridW || gy1 < 0 || gy2 >= this.logicGridH) return false;
        // Grid-based overlap check (All Layers via logicGrid)
        for (let gy = gy1; gy <= gy2; gy++) {
            const rowOff = gy * this.logicGridW;
            for (let gx = gx1; gx <= gx2; gx++) {
                if (this.logicGrid[rowOff + gx] === 1) return false;
            }
        }
        // Sub-Layer Anchoring Logic
        if (!this._isAnchored(x, y, w, h, layer)) return false;
        return true;
    }
    _isAnchored(x, y, w, h, layer) {
        if (layer > 0 && this.getConfig('EnableSubLayerAnchoring')) {
            const anchorDist = this.getConfig('SubLayerAnchorDistance') || 2;
            const lgW = this.logicGridW, lgH = this.logicGridH;
            const cx = Math.floor(lgW / 2), cy = Math.floor(lgH / 2);
            const l0 = this.layerGrids[0];
            if (l0) {
                // Check every block space in the proposed new block
                for (let ly = 0; ly < h; ly++) {
                    for (let lx = 0; lx < w; lx++) {
                        const gx = cx + x + lx, gy = cy + y + ly;
                        if (gx < 0 || gx >= lgW || gy < 0 || gy >= lgH) continue;
                        // For THIS cell, is there a Layer 0 block within anchorDist?
                        let anchored = false;
                        const r = anchorDist;
                        for (let dy = -r; dy <= r; dy++) {
                            for (let dx = -r; dx <= r; dx++) {
                                const nx = gx + dx, ny = gy + dy;
                                if (nx >= 0 && nx < lgW && ny >= 0 && ny < lgH) {
                                    if (l0[ny * lgW + nx] !== -1) {
                                        anchored = true;
                                        break;
                                    }
                                }
                            }
                            if (anchored) break;
                        }
                        if (!anchored) return false; // This part of the block is too far from Layer 0
                    }
                }
            }
        }
        return true;
    }
    _checkNoHole(tx, ty, tw, th) {
        const w = this.logicGridW, h = this.logicGridH, cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const candidates = [];
        for (let x = tx - 1; x <= tx + tw; x++) { candidates.push([x, ty - 1], [x, ty + th]); }
        for (let y = ty; y < ty + th; y++) { candidates.push([tx - 1, y], [tx + tw, y]); }
        for (const [nx, ny] of candidates) {
            const gx = nx + cx, gy = ny + cy;
            if (gx < 0 || gx >= w || gy < 0 || gy >= h) continue;
            if (this.logicGrid[gy * w + gx] !== 0) continue;
            if (nx >= tx && nx < tx + tw && ny >= ty && ny < ty + th) continue;
            if (!this._canReachBoundary(nx, ny, tx, ty, tw, th)) return false;
        }
        return true;
    }
    _canReachBoundary(startX, startY, px, py, pw, ph) {
        const w = this.logicGridW, h = this.logicGridH, cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const stack = [[startX, startY]], visited = new Set([`${startX},${startY}`]);
        while (stack.length > 0) {
            const [x, y] = stack.pop();
            if (x + cx <= 0 || x + cx >= w - 1 || y + cy <= 0 || y + cy >= h - 1) return true;
            const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
            for (const [nx, ny] of neighbors) {
                const gx = nx + cx, gy = ny + cy;
                if (gx < 0 || gx >= w || gy < 0 || gy >= h) continue;
                const key = `${nx},${ny}`;
                if (visited.has(key) || (nx >= px && nx < px + pw && ny >= py && ny < py + ph) || this.logicGrid[gy * w + gx] !== 0) continue;
                visited.add(key); stack.push([nx, ny]);
                if (visited.size > 2000) return true; 
            }
        }
        return false;
    }
    _attemptUnfoldGrowth(sequence = null, targetLayerInput = 0) {
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const targetLayer = targetLayerInput;
        if (sequence) {
            if (sequence.step === 0) { sequence.step = 1; } 
            else if (sequence.step === 1) {
                const { x, y, bw, bh, dir } = sequence;
                let tx = x, ty = y;
                if (dir === 'N') ty -= bh; else if (dir === 'S') ty += bh;
                else if (dir === 'E') tx += bw; else if (dir === 'W') tx -= bw;
                // Use skipConnectivity=false to ensure it attaches to its own layer
                this._spawnBlock(tx, ty, bw, bh, targetLayer, false, 0, false, true);
                sequence.active = false;
                return true;
            }
            return false;
        }
        // Local throttle per layer instead of global block
        if (this.unfoldSequences[targetLayer].length >= 3) return false;
        const l0 = this.layerGrids[targetLayer];
        if (!l0) return false;
        const anchors = this.activeBlocks.filter(b => b.layer === targetLayer);
        if (anchors.length === 0) return false;
        Utils.shuffle(anchors);
        for (const anchor of anchors) {
            const faces = this._getBiasedDirections();
            for (const unfoldDir of faces) {
                const sw = this._getScaledConfig('MinBlockWidth', 1);
                const mw = this._getScaledConfig('MaxBlockWidth', 5);
                const sh = this._getScaledConfig('MinBlockHeight', 1);
                const mh = this._getScaledConfig('MaxBlockHeight', 5);
                const bw_target = Math.floor(Math.random() * (mw - sw + 1)) + sw;
                const bh_target = Math.floor(Math.random() * (mh - sh + 1)) + sh;
                let bw = 1, bh = 1, startX_rel = anchor.x, startY_rel = anchor.y;
                if (unfoldDir === 'N' || unfoldDir === 'S') { 
                    bh = bh_target; 
                    bw = Math.min(anchor.w, bw_target); 
                    startX_rel = anchor.x + Math.floor((anchor.w - bw) / 2);
                    if (unfoldDir === 'N') startY_rel = anchor.y; else startY_rel = anchor.y + anchor.h - bh; 
                } 
                else { 
                    bw = bw_target; 
                    bh = Math.min(anchor.h, bh_target); 
                    startY_rel = anchor.y + Math.floor((anchor.h - bh) / 2);
                    if (unfoldDir === 'W') startX_rel = anchor.x; else startX_rel = anchor.x + anchor.w - bw; 
                }
                let t2x = startX_rel, t2y = startY_rel;
                if (unfoldDir === 'N') t2y -= bh; else if (unfoldDir === 'S') t2y += bh;
                else if (unfoldDir === 'E') t2x += bw; else if (unfoldDir === 'W') t2x -= bw;
                if (this._checkNoOverlap(t2x, t2y, bw, bh, targetLayer) && this._checkNoHole(t2x, t2y, bw, bh)) {
                    this.unfoldSequences[targetLayer].push({ active: true, step: 0, x: startX_rel, y: startY_rel, bw, bh, dir: unfoldDir, layer: targetLayer });
                    // Snapshot source area: Use skipConnectivity=true and bypassOccupancy=true since we are capturing existing mass
                    this._spawnBlock(startX_rel, startY_rel, bw, bh, targetLayer, false, 0, true, true, true, false, true);
                    return true;
                }
            }
        }
        return false;
    }
    _attemptRearrangeGrowth(targetLayerInput) {
        if (!this.rearrangePool) return false;
        const targetLayer = targetLayerInput !== undefined ? targetLayerInput : 0;
        // Use Frequency setting to throttle attempts
        const freq = this.getConfig('RearrangeFrequency') !== undefined ? this.getConfig('RearrangeFrequency') : 0.5;
        if (Math.random() > freq) return false;
        // Phase 1: Redistribution (Place blocks from pool into holes near center)
        if (this.rearrangePool[targetLayer] > 0) {
            const range = 25; 
            const holes = [];
            // Optimized Hole Selection: Sample random spots within range
            const maxHoleAttempts = 100;
            for (let i = 0; i < maxHoleAttempts; i++) {
                const dx = Math.floor(Math.random() * (range * 2 + 1)) - range;
                const dy = Math.floor(Math.random() * (range * 2 + 1)) - range;
                // A "hole" is an empty logic grid cell that is anchored to existing mass of this layer
                if (this._checkNoOverlap(dx, dy, 1, 1, targetLayer) && this._isAnchored(dx, dy, 1, 1, targetLayer)) {
                    holes.push({x: dx, y: dy, distSq: dx*dx + dy*dy});
                }
                if (holes.length >= 10) break;
            }
            if (holes.length > 0) {
                // Priority: Filling holes closest to the center
                holes.sort((a, b) => a.distSq - b.distSq);
                const hole = holes[0];
                const sizes = [{w:1,h:1}, {w:2,h:1}, {w:1,h:2}, {w:2,h:2}];
                Utils.shuffle(sizes);
                for (const sz of sizes) {
                    if (this._spawnBlock(hole.x, hole.y, sz.w, sz.h, targetLayer, false, 0, false, true, false, false, true) !== -1) {
                        this.rearrangePool[targetLayer]--;
                        this._log(`[Rearrange] Redistributed to (${hole.x}, ${hole.y}) on L${targetLayer}. Pool: ${this.rearrangePool[targetLayer]}`);
                        return true; 
                    }
                }
            }
        }
        // Phase 2: Selection (Remove extrusions to fund the pool)
        // Criteria: Only remove blocks born in previous steps that are far from center
        if (this.rearrangePool[targetLayer] < 4) {
            // Pick a random set of candidates and take the furthest one (Sampling approach)
            const lBlocks = this.activeBlocks.filter(b => b.layer === targetLayer && b.startPhase < this.expansionPhase);
            if (lBlocks.length > 0) {
                let furthestBlock = null;
                let maxDistSq = -1;
                const sampleSize = Math.min(lBlocks.length, 30);
                for (let i = 0; i < sampleSize; i++) {
                    const b = lBlocks[Math.floor(Math.random() * lBlocks.length)];
                    const distSq = b.x*b.x + b.y*b.y;
                    if (distSq > maxDistSq) {
                        maxDistSq = distSq;
                        furthestBlock = b;
                    }
                }
                if (furthestBlock && maxDistSq > 36) { // dist > 6
                    const b = furthestBlock;
                    const idx = this.activeBlocks.indexOf(b);
                    if (idx !== -1) {
                        this.activeBlocks.splice(idx, 1);
                        this.rearrangePool[targetLayer]++;
                        this.maskOps.push({ 
                            type: 'removeBlock', 
                            x1: b.x, y1: b.y, x2: b.x + b.w - 1, y2: b.y + b.h - 1, 
                            startFrame: this.animFrame, layer: b.layer, fade: false 
                        });
                        if (this.manualStep && this.sequence && !this.isReconstructing) {
                            if (!this.sequence[this.expansionPhase]) this.sequence[this.expansionPhase] = [];
                            this.sequence[this.expansionPhase].push({
                                op: 'removeBlock',
                                args: [b.x, b.y, b.x + b.w - 1, b.y + b.h - 1],
                                layer: b.layer,
                                fade: false
                            });
                        }
                        this._writeToGrid(b.x, b.y, b.w, b.h, -1, b.layer);
                        this._gridsDirty = true;
                        this._log(`[Rearrange] Removed extrusion at (${b.x}, ${b.y}) on L${targetLayer}. Pool: ${this.rearrangePool[targetLayer]}`);
                        this._maskDirty = true;
                        return true;
                    }
                }
            }
        }
        return false;
    }
    _attemptCenteredGrowth(ignored, targetLayer = 0) {
        if (!this.centeredState || !this.centeredState[targetLayer]) {
            if (!this.centeredState) this.centeredState = [];
            this.centeredState[targetLayer] = { currentMaxRadius: 0, lastUpdate: -100 };
        }
        const state = this.centeredState[targetLayer];
        // Pace control
        if (this.animFrame - state.lastUpdate < 3) return false;
        state.lastUpdate = this.animFrame;
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const grid = this.layerGrids[targetLayer];
        if (!grid) return false;
        const sizes = [
            {w:1, h:1}, {w:1, h:2}, {w:2, h:1}, {w:2, h:2}
        ];
        // Search from r=0 outwards to find the first available innermost gap.
        // This ensures the core remains solid even if nudge shifts blocks away.
        // We limit search radius to currentMaxRadius + buffer for performance.
        const maxR = Math.min(Math.max(w, h), state.currentMaxRadius + 5);
        for (let r = 0; r <= maxR; r++) {
            const points = [];
            if (r === 0) {
                points.push({x: 0, y: 0});
            } else {
                // Sample the ring
                const samples = Math.min(16, r * 4); 
                for (let i = 0; i < samples; i++) {
                    const side = Math.floor(Math.random() * 4);
                    const pos = Math.floor(Math.random() * (r * 2 + 1)) - r;
                    if (side === 0) points.push({x: -r, y: pos});
                    else if (side === 1) points.push({x: r, y: pos});
                    else if (side === 2) points.push({x: pos, y: -r});
                    else points.push({x: pos, y: r});
                }
            }
            for (const pt of points) {
                const gx = cx + pt.x, gy = cy + pt.y;
                if (gx < 0 || gx >= w || gy < 0 || gy >= h) continue;
                // If this spot is empty on the target layer, try to fill it
                if (grid[gy * w + gx] === -1) {
                    const sz = sizes[Math.floor(Math.random() * sizes.length)];
                    const ox = pt.x - Math.floor(sz.w / 2);
                    const oy = pt.y - Math.floor(sz.h / 2);
                    // Must be anchored to existing mass OR be the center seed
                    const isCenter = (pt.x === 0 && pt.y === 0);
                    if (isCenter || this._isAnchored(ox, oy, sz.w, sz.h, targetLayer)) {
                        if (this._spawnBlock(ox, oy, sz.w, sz.h, targetLayer, false, 0, true, true) !== -1) {
                            // Update max radius if we spawned at the frontier
                            if (r >= state.currentMaxRadius) {
                                state.currentMaxRadius = r + 1;
                            }
                            return true; 
                        }
                    }
                }
            }
        }
        return false;
    }
    _performCenterBiasedGrowth(maxLen, layer, isVertical) {
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const grid = this.layerGrids[layer];
        if (!grid) return false;
        const candidates = [];
        const searchRange = 10; 
        for (let gy = cy - searchRange; gy <= cy + searchRange; gy++) {
            for (let gx = cx - searchRange; gx <= cx + searchRange; gx++) {
                if (gx < 0 || gx >= w || gy < 0 || gy >= h) continue;
                if (grid[gy * w + gx] !== -1) continue;
                const lx = gx - cx, ly = gy - cy;
                // Strict Cardinal Axis focus: only spawn ON the center lines
                const onNS = Math.abs(lx) <= 0;
                const onEW = Math.abs(ly) <= 0;
                if (isVertical && !onNS) continue;
                if (!isVertical && !onEW) continue;
                const hasNeighbor = 
                    (gy > 0 && grid[(gy-1)*w+gx] !== -1) || (gy < h-1 && grid[(gy+1)*w+gx] !== -1) ||
                    (gx > 0 && grid[gy*w+gx-1] !== -1) || (gx < w-1 && grid[gy*w+gx+1] !== -1);
                if (hasNeighbor || (lx === 0 && ly === 0)) {
                    candidates.push({ gx, gy, dist: Math.abs(lx) + Math.abs(ly) });
                }
            }
        }
        if (candidates.length === 0) return false;
        candidates.sort((a, b) => a.dist - b.dist);
        const best = candidates.slice(0, 3);
        const winner = best[Math.floor(Math.random() * best.length)];
        // Force thin strips (max width 2 for vertical, max height 2 for horizontal)
        let bw = 1, bh = 1;
        if (isVertical) {
            bh = Math.min(maxLen, 2 + Math.floor(Math.random() * 3));
            bw = (Math.random() < 0.15) ? 2 : 1; 
        } else {
            bw = Math.min(maxLen, 2 + Math.floor(Math.random() * 3));
            bh = (Math.random() < 0.15) ? 2 : 1;
        }
        const bx = winner.gx - cx, by = winner.gy - cy;
        let fx = bx, fy = by;
        if (bw > 1) fx -= Math.floor(bw / 2);
        if (bh > 1) fy -= Math.floor(bh / 2);
        if (this._checkNoOverlap(fx, fy, bw, bh, layer)) {
            // Use suppressLines=true to prevent accumulation of persistent internal lines
            this._spawnBlock(fx, fy, bw, bh, layer, false, 0, true, true, false);
            return true;
        }
        return false;
    }
    _checkCardinalCompletion() {
        const w = this.logicGridW, h = this.logicGridH;
        const grid = this.layerGrids[0];
        if (!grid) return { ns: false, ew: false };
        let n = false, s = false, e = false, w_ = false;
        // North/South check (Top/Bottom rows of logic grid)
        for (let x = 0; x < w; x++) {
            if (grid[x] !== -1) n = true;
            if (grid[(h - 1) * w + x] !== -1) s = true;
        }
        // East/West check (Left/Right columns)
        for (let y = 0; y < h; y++) {
            if (grid[y * w] !== -1) w_ = true;
            if (grid[y * w + (w - 1)] !== -1) e = true;
        }
        return { ns: n && s, ew: e && w_ };
    }
    _performAxisNudging(completion) {
        const targetLayer = this.proceduralLayerIndex || 0;
        const candidates = this.activeBlocks.filter(b => b.layer === targetLayer && b.isPerimeter);
        if (candidates.length === 0) return false;
        Utils.shuffle(candidates);
        for (const b of candidates) {
            let dx = 0, dy = 0;
            // 10% Special case: expansion nudge towards nearest canvas edge
            if (Math.random() < 0.1) {
                const distN = b.y + (this.logicGridH / 2);
                const distS = (this.logicGridH / 2) - b.y;
                const distW = b.x + (this.logicGridW / 2);
                const distE = (this.logicGridW / 2) - b.x;
                const minDist = Math.min(distN, distS, distW, distE);
                if (minDist === distN) dy = -1;
                else if (minDist === distS) dy = 1;
                else if (minDist === distW) dx = -1;
                else if (minDist === distE) dx = 1;
            } else {
                // Nudge along axis of completion
                if (completion.ns) {
                    // N/S reached -> Nudge E/W to fill width
                    dx = b.x >= 0 ? 1 : -1;
                } else if (completion.ew) {
                    // E/W reached -> Nudge N/S to fill height
                    dy = b.y >= 0 ? 1 : -1;
                } else {
                    // Expanding away from center
                    dx = b.x === 0 ? 0 : (b.x > 0 ? 1 : -1);
                    dy = b.y === 0 ? 0 : (b.y > 0 ? 1 : -1);
                }
            }
            if ((dx !== 0 || dy !== 0) && this._nudgeBlock(b, dx, dy)) {
                b.age = 0;
                return true;
            }
        }
        return false;
    }
    _checkIsPerimeter(b) {
        const w = this.logicGridW, cx = Math.floor(w / 2), cy = Math.floor(this.logicGridH / 2);
        const grid = this.layerGrids[b.layer];
        if (!grid) return false;
        let openSides = 0;
        const checks = [
            {x: b.x - 1, y: b.y, w: 1, h: b.h}, // West
            {x: b.x + b.w, y: b.y, w: 1, h: b.h}, // East
            {x: b.x, y: b.y - 1, w: b.w, h: 1}, // North
            {x: b.x, y: b.y + b.h, w: b.w, h: 1}  // South
        ];
        for (const c of checks) {
            let occupied = false;
            for (let ly = 0; ly < c.h; ly++) {
                for (let lx = 0; lx < c.w; lx++) {
                    const gx = cx + c.x + lx, gy = cy + c.y + ly;
                    if (gx >= 0 && gx < w && gy >= 0 && gy < this.logicGridH && grid[gy * w + gx] !== -1) {
                        occupied = true;
                        break;
                    }
                }
                if (occupied) break;
            }
            if (!occupied) openSides++;
        }
        return openSides >= 1;
    }
    _performBlockMaintenance(block, maxLen) {
        const action = Math.random();
        if (action < 0.3) {
            // Transformation: Flip 5x1 to 1x5 or similar
            this.maskOps.push({ type: 'removeBlock', x1: block.x, y1: block.y, x2: block.x + block.w - 1, y2: block.y + block.h - 1, startFrame: this.animFrame, layer: block.layer, fade: false });
            this._writeToGrid(block.x, block.y, block.w, block.h, -1, block.layer);
            const nw = block.h, nh = block.w; 
            if (this._checkNoOverlap(block.x, block.y, nw, nh, block.layer)) {
                this._spawnBlock(block.x, block.y, nw, nh, block.layer, false, 0, true, true, true);
                const idx = this.activeBlocks.indexOf(block);
                if (idx !== -1) this.activeBlocks.splice(idx, 1);
                return true;
            }
        } else {
            // Nudge outwards
            const dx = block.x === 0 ? 0 : (block.x > 0 ? 1 : -1);
            const dy = block.y === 0 ? 0 : (block.y > 0 ? 1 : -1);
            if (this._nudgeBlock(block, dx, dy)) {
                block.age = 0;
                return true;
            }
        }
        return false;
    }
    _performBlockExpansion(maxLen, prioritizeLength = true) {
        if (this.activeBlocks.length === 0) return false;
        // Expansion logic now favors creating strips (e.g. 1x5)
        const candidates = this.activeBlocks.filter(b => b.isPerimeter && (b.w < maxLen || b.h < maxLen));
        if (prioritizeLength) {
            // Prefer expanding blocks that are already thin strips
            candidates.sort((a, b) => {
                const aRatio = Math.max(a.w, a.h);
                const bRatio = Math.max(b.w, b.h);
                return bRatio - aRatio;
            });
        }
        if (candidates.length === 0) return false;
        for (const b of candidates) {
            const dirs = ['N', 'S', 'E', 'W'];
            Utils.shuffle(dirs);
            for (const dir of dirs) {
                let nw = b.w, nh = b.h, nx = b.x, ny = b.y;
                // Strict strip growth: only expand in the dimension that is already dominant
                // or if it's a 1x1 block.
                const isVertical = b.h > b.w;
                const isHorizontal = b.w > b.h;
                if (isVertical && (dir === 'E' || dir === 'W')) continue;
                if (isHorizontal && (dir === 'N' || dir === 'S')) continue;
                if ((dir === 'N' || dir === 'S') && b.h >= maxLen) continue;
                if ((dir === 'E' || dir === 'W') && b.w >= maxLen) continue;
                if (dir === 'N') { ny--; nh++; }
                else if (dir === 'S') { nh++; }
                else if (dir === 'W') { nx--; nw++; }
                else if (dir === 'E') { nw++; }
                let extX = b.x, extY = b.y, extW = 1, extH = 1;
                if (dir === 'N') { extX = b.x; extY = b.y - 1; extW = b.w; extH = 1; }
                else if (dir === 'S') { extX = b.x; extY = b.y + b.h; extW = b.w; extH = 1; }
                else if (dir === 'W') { extX = b.x - 1; extY = b.y; extW = 1; extH = b.h; }
                else if (dir === 'E') { extX = b.x + b.w; extY = b.y; extW = 1; extH = b.h; }
                if (this._checkNoOverlap(extX, extY, extW, extH, b.layer) && this._checkNoHole(extX, extY, extW, extH)) {
                    // Use suppressLines=true for clean unfold expansion
                    this._spawnBlock(extX, extY, extW, extH, b.layer, false, 0, true, true, true);
                    b.x = nx; b.y = ny; b.w = nw; b.h = nh; b.age = 0;
                    this._writeToGrid(nx, ny, nw, nh, 1, b.layer);
                    return true;
                }
            }
        }
        return false;
    }
    _performCardinalGrowth(maxLen, mode = 'ANY') {
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const targetLayer = this.proceduralLayerIndex || 0;
        const grid = this.layerGrids[targetLayer];
        if (!grid) return false;
        const frontier = [];
        for (let gy = 1; gy < h - 1; gy++) {
            for (let gx = 1; gx < w - 1; gx++) {
                if (grid[gy * w + gx] !== -1) continue;
                const hasNeighbor = grid[(gy - 1) * w + gx] !== -1 || grid[(gy + 1) * w + gx] !== -1 || grid[gy * w + gx - 1] !== -1 || grid[gy * w + gx + 1] !== -1;
                if (hasNeighbor) {
                    const lx = gx - cx, ly = gy - cy;
                    const dist = Math.sqrt(lx * lx + ly * ly);
                    const isNS = Math.abs(lx) <= 1;
                    const isEW = Math.abs(ly) <= 1;
                    let score = 100 - dist;
                    if (mode === 'VERTICAL' && isNS) score += 200;
                    else if (mode === 'HORIZONTAL' && isEW) score += 200;
                    // Prioritize frontier cells that are already at the "tips" of the arms
                    if (isNS && Math.abs(ly) > 5) score += 50;
                    if (isEW && Math.abs(lx) > 5) score += 50;
                    let neighbors = 0;
                    if (grid[(gy-1)*w+gx] !== -1) neighbors++;
                    if (grid[(gy+1)*w+gx] !== -1) neighbors++;
                    if (grid[gy*w+gx-1] !== -1) neighbors++;
                    if (grid[gy*w+gx+1] !== -1) neighbors++;
                    if (neighbors >= 3) score -= 400; // Penalize filling inward, keep it branching
                    frontier.push({ gx, gy, score });
                }
            }
        }
        if (frontier.length === 0) {
            if (grid[cy * w + cx] === -1) {
                this._spawnBlock(0, 0, 1, 1, targetLayer, false, 0, true, true, false);
                return true;
            }
            return false;
        }
        frontier.sort((a, b) => b.score - a.score);
        const winners = frontier.slice(0, 3);
        const winner = winners[Math.floor(Math.random() * winners.length)];
        // Favor 1xN strips for cardinal growth
        let bw = 1, bh = 1;
        if (mode === 'VERTICAL') { 
            bh = Math.min(maxLen, 2 + Math.floor(Math.random() * 4)); 
            bw = 1;
        } else if (mode === 'HORIZONTAL') { 
            bw = Math.min(maxLen, 2 + Math.floor(Math.random() * 4)); 
            bh = 1;
        }
        let bx = winner.gx - cx, by = winner.gy - cy;
        if (bw > 1) bx -= Math.floor(bw / 2);
        if (bh > 1) by -= Math.floor(bh / 2);
        if (this._checkNoOverlap(bx, by, bw, bh, targetLayer)) {
            const enShoving = this.getConfig('EnableLayerShoving') === true;
            if (targetLayer === 0 && enShoving) this._shoveOtherLayers(bx, by, bw, bh);
            // Use suppressLines=true for clean expansion
            this._spawnBlock(bx, by, bw, bh, targetLayer, false, 0, true, true, false);
            return true;
        }
        return false;
    }
    _shoveOtherLayers(x, y, w, h) {
        // Simple shoving: if a block in Layer 1 overlaps, nudge it
        const l1 = this.layerGrids[1];
        if (!l1) return;
        const lgW = this.logicGridW;
        const cx = Math.floor(lgW / 2), cy = Math.floor(this.logicGridH / 2);
        for (let ly = 0; ly < h; ly++) {
            for (let lx = 0; lx < w; lx++) {
                const gx = cx + x + lx, gy = cy + y + ly;
                if (l1[gy * lgW + gx] !== -1) {
                    // Conflict found. Find the block in Layer 1 and nudge it.
                    const block = this.activeBlocks.find(b => b.layer === 1 && 
                        gx >= cx + b.x && gx < cx + b.x + b.w && 
                        gy >= cy + b.y && gy < cy + b.y + b.h);
                    if (block) {
                        // Nudge outwards from center
                        const dx = block.x > 0 ? 1 : -1;
                        const dy = block.y > 0 ? 1 : -1;
                        // Pick the axis with more momentum
                        if (Math.abs(block.x) > Math.abs(block.y)) {
                            this._nudgeBlock(block, dx, 0);
                        } else {
                            this._nudgeBlock(block, 0, dy);
                        }
                    }
                }
            }
        }
    }
    _performAutoActions() {
        const getGenConfig = (key) => {
            const val = this.getConfig(key);
            if (val !== undefined) return val;
            return this.c.state['quantizedGenerateV2' + key];
        };
        if (getGenConfig('EnableAutoFillHoles') === true) {
            for (let i = 0; i < 3; i++) this._fillHoles(i);
        }
        if (getGenConfig('EnableAutoConnectIslands') === true) {
            this._connectIslands();
        }
    }
    _fillHoles(layer) {
        if (!this._gridsDirty && this.activeBlocks.length > 0) return;
        if (!this.logicGridW || !this.logicGridH) return;
        const w = this.logicGridW, h = this.logicGridH;
        const grid = this.layerGrids[layer];
        if (!grid) return;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const bs = this.getBlockSize();
        // 1. Define Visible Boundary (with a 2-block safety buffer)
        const visW = Math.ceil(this.g.cols / bs.w);
        const visH = Math.ceil(this.g.rows / bs.h);
        const xLim = Math.floor(visW / 2) + 2;
        const yLim = Math.floor(visH / 2) + 2;
        const minGX = Math.max(0, cx - xLim), maxGX = Math.min(w - 1, cx + xLim);
        const minGY = Math.max(0, cy - yLim), maxGY = Math.min(h - 1, cy + yLim);
        // 2. BFS from the Visibility Perimeter to find "Outside"
        const outsideMap = this._getBuffer('connectedMap', w * h, Uint8Array);
        outsideMap.fill(0);
        const queue = this._getBuffer('queue', w * h, Int32Array);
        let head = 0, tail = 0;
        const add = (gx, gy) => {
            const idx = gy * w + gx;
            if (outsideMap[idx] === 0 && grid[idx] === -1) { 
                outsideMap[idx] = 1; 
                queue[tail++] = idx; 
            }
        };
        // Seed BFS from any empty cell on or outside the visible boundary
        for (let gy = 0; gy < h; gy++) {
            for (let gx = 0; gx < w; gx++) {
                const isOutsideVis = (gx <= minGX || gx >= maxGX || gy <= minGY || gy >= maxGY);
                if (isOutsideVis) add(gx, gy);
            }
        }
        while (head < tail) {
            const idx = queue[head++];
            const cgx = idx % w, cgy = (idx / w) | 0;
            if (cgy > 0) add(cgx, cgy - 1); if (cgy < h - 1) add(cgx, cgy + 1);
            if (cgx > 0) add(cgx - 1, cgy); if (cgx < w - 1) add(cgx + 1, cgy);
        }
        // 3. Fill holes inside the visible area
        let filledCount = 0;
        for (let gy = minGY + 1; gy < maxGY; gy++) {
            for (let gx = minGX + 1; gx < maxGX; gx++) {
                const i = gy * w + gx;
                if (grid[i] === -1) {
                    // Case A: Enclosed Hole (Cannot reach visible boundary)
                    const isEnclosed = (outsideMap[i] === 0);
                    // Case B: Aggressive Infill (3 or 4 cardinal neighbors are full)
                    // This catches inlets and dead-ends that are connected to the outside.
                    let neighborCount = 0;
                    if (grid[i - 1] !== -1) neighborCount++;
                    if (grid[i + 1] !== -1) neighborCount++;
                    if (grid[i - w] !== -1) neighborCount++;
                    if (grid[i + w] !== -1) neighborCount++;
                    const isSmallGap = (neighborCount >= 3);
                    if (isEnclosed || isSmallGap) {
                        this._spawnBlock(gx - cx, gy - cy, 1, 1, layer, false, 0, true, true);
                        this._gridsDirty = true;
                        filledCount++;
                    }
                }
            }
        }
        if (filledCount > 0) this._log(`[AutoFill] Layer ${layer}: Filled ${filledCount} holes/gaps.`);
    }
    _connectIslands() {
        if (!this._gridsDirty && this.activeBlocks.length > 0) return;
        if (!this.logicGridW || !this.logicGridH) return;
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const combined = this._getBuffer('combined', w * h, Int8Array);
        combined.fill(-1);
        for (let i = 0; i < this.activeBlocks.length; i++) {
            const b = this.activeBlocks[i];
            const x1 = cx + b.x, y1 = cy + b.y, x2 = x1 + b.w - 1, y2 = y1 + b.h - 1;
            for (let gy = Math.max(0, y1); gy <= Math.min(h - 1, y2); gy++) {
                const rowOff = gy * w;
                for (let gx = Math.max(0, x1); gx <= Math.min(w - 1, x2); gx++) { 
                    combined[rowOff + gx] = 1; 
                }
            }
        }
        const connectedMap = this._getBuffer('connectedMap', w * h, Uint8Array);
        connectedMap.fill(0);
        const queue = this._getBuffer('queue', w * h, Int32Array);
        let head = 0, tail = 0;
        const startIdx = cy * w + cx;
        if (combined[startIdx] === 1) { 
            connectedMap[startIdx] = 1; 
            queue[tail++] = startIdx; 
        } else {
            // Find any mainland cell if center isn't covered
            for(let i=0; i<w*h; i++) {
                if(combined[i] === 1) {
                    connectedMap[i] = 1;
                    queue[tail++] = i;
                    break;
                }
            }
        }
        while (head < tail) {
            const idx = queue[head++];
            const gx = idx % w, gy = (idx / w) | 0;
            const neighbors = [idx - w, idx + w, idx - 1, idx + 1];
            for (let i = 0; i < 4; i++) {
                const nIdx = neighbors[i];
                if (nIdx >= 0 && nIdx < w * h && connectedMap[nIdx] === 0 && combined[nIdx] === 1) {
                    if (i === 2 && gx === 0) continue;
                    if (i === 3 && gx === w - 1) continue;
                    connectedMap[nIdx] = 1; 
                    queue[tail++] = nIdx;
                }
            }
        }
        const islands = this.activeBlocks.filter(b => {
            const x1 = cx + b.x, y1 = cy + b.y, x2 = x1 + b.w - 1, y2 = y1 + b.h - 1;
            for (let gy = Math.max(0, y1); gy <= Math.min(h - 1, y2); gy++) {
                const rowOff = gy * w;
                for (let gx = Math.max(0, x1); gx <= Math.min(w - 1, x2); gx++) { 
                    if (connectedMap[rowOff + gx] === 1) return false; 
                }
            }
            return true;
        });
        if (islands.length === 0) return;
        // Optimized Connection: Find nearest mainland point via BFS per island
        for (const island of islands) {
            let bestIslandPt = { x: cx + island.x, y: cy + island.y };
            let bestTargetPt = null;
            // Per-island BFS to find nearest connectedMap === 1
            const iQueue = new Int32Array(w * h); // Local small queue if possible, but reused buffer is better
            const iVisited = new Uint8Array(w * h);
            let iHead = 0, iTail = 0;
            const iStartIdx = bestIslandPt.y * w + bestIslandPt.x;
            iQueue[iTail++] = iStartIdx;
            iVisited[iStartIdx] = 1;
            while(iHead < iTail) {
                const idx = iQueue[iHead++];
                if (connectedMap[idx] === 1) {
                    bestTargetPt = { x: idx % w, y: (idx / w) | 0 };
                    break;
                }
                const gx = idx % w, gy = (idx / w) | 0;
                const neighbors = [idx - w, idx + w, idx - 1, idx + 1];
                for (let i = 0; i < 4; i++) {
                    const nIdx = neighbors[i];
                    if (nIdx >= 0 && nIdx < w * h && iVisited[nIdx] === 0) {
                        if (i === 2 && gx === 0) continue;
                        if (i === 3 && gx === w - 1) continue;
                        iVisited[nIdx] = 1;
                        iQueue[iTail++] = nIdx;
                    }
                }
                if (iTail > 2000) break; // Safety break
            }
            if (bestTargetPt) {
                let curX = bestIslandPt.x, curY = bestIslandPt.y;
                while (curX !== bestTargetPt.x || curY !== bestTargetPt.y) {
                    if (curX < bestTargetPt.x) curX++; else if (curX > bestTargetPt.x) curX--;
                    else if (curY < bestTargetPt.y) curY++; else if (curY > bestTargetPt.y) curY--;
                    if (combined[curY * w + curX] === -1) {
                        this._spawnBlock(curX - cx, curY - cy, 1, 1, island.layer, false, 0, true, true);
                        combined[curY * w + curX] = 1;
                    }
                }
            }
        }
    }
    _validateAdditionSafety(bx, by, layer, bypass = false) {
        if (bypass) return true;
        // Optimized: Use a virtual view to avoid cloning activeBlocks
        const virtualBlocks = {
            length: this.activeBlocks.length + 1,
            getItem: (i) => {
                if (i < this.activeBlocks.length) return this.activeBlocks[i];
                return { x: bx, y: by, w: 1, h: 1, layer };
            }
        };
        return this._checkEnvelopeDriftVirtual(virtualBlocks);
    }
    _isCanvasFullyCovered() {
        const w = this.logicGridW, h = this.logicGridH;
        if (!w || !h || !this.renderGrid) return false;
        const bs = this.getBlockSize();
        const { offX, offY } = this._computeCenteredOffset(w, h, bs.w, bs.h);
        const visibleW = Math.ceil(this.g.cols / bs.w);
        const visibleH = Math.ceil(this.g.rows / bs.h);
        const startX = Math.max(0, Math.floor(offX));
        const endX = Math.min(w, startX + visibleW);
        const startY = Math.max(0, Math.floor(offY));
        const endY = Math.min(h, startY + visibleH);
        for (let gy = startY; gy < endY; gy++) {
            const rowOff = gy * w;
            for (let gx = startX; gx < endX; gx++) {
                if (this.renderGrid[rowOff + gx] === -1) return false;
            }
        }
        return true;
    }
    stop() {
        this.active = false;
        this.state = 'IDLE';
        this.alpha = 0.0;
        this.expansionPhase = 0;
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        window.removeEventListener('keydown', this._boundDebugHandler);
        if (this.g) this.g.clearAllOverrides();
        this.shadowGrid = null;
        this.shadowSim = null;
    }
}
// --- QuantizedAddEffect.js ---
class QuantizedAddEffect extends QuantizedBaseEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "QuantizedAdd";
        this.active = false;
        this.configPrefix = "quantizedAdd";
        this.timer = 0;
        this.state = 'IDLE'; // IDLE, FADE_IN, SUSTAIN, FADE_OUT
        this.alpha = 0.0;
        // Grid properties
        this.offsetX = 0;
        this.offsetY = 0;
        // Animation Sequence Data
        this.sequence = [[]]; 
        this.expansionPhase = 0;
        this.maskOps = [];
        this.editorHighlight = false;
        // Flicker Fix: Swap Transition State
        this.isSwapping = false;
        this.swapTimer = 0;
    }
    trigger(force = false) {
        // 1. Strict Active Check
        if (this.active) return false;
        // 2. Mutually Exclusive Lock
        if (window.matrix && window.matrix.effectRegistry) {
            const siblings = ["QuantizedPulse", "QuantizedRetract", "QuantizedClimb", "QuantizedZoom"];
            for (const name of siblings) {
                const eff = window.matrix.effectRegistry.get(name);
                if (eff && eff.active) {
                    return false;
                }
            }
        }
        if (!super.trigger(force)) return false;
        this.state = 'FADE_IN';
        this.timer = 0;
        this.alpha = 0.0;
        this.offsetX = 0.5; 
        this.offsetY = 0.5;
                this.expansionPhase = 0;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.manualStep = false;
        this._initShadowWorld();
        this.hasSwapped = false;
        this.isSwapping = false;
        // Ensure renderGrid is initialized
        if (this.renderGrid) {
            this.renderGrid.fill(-1);
        }
        return true;
    }
    update() {
        const s = this.c.state;
        const fps = 60;
        if (!this.active) return;
        // 0. Update Shadow Simulation & Warmup
        if (!this.hasSwapped && !this.isSwapping) {
            if (super._updateShadowSim()) return;
        } else if (this.isSwapping) {
            super.updateTransition(true);
        }
        this.animFrame++;
        // 1. Animation Cycle (Grid Expansion) - Logic Update
        const baseDuration = Math.max(1, this.c.derived.cycleDuration);
        const userSpeed = (s.quantizedAddSpeed !== undefined) ? s.quantizedAddSpeed : 5;
        // Map 1 (Slowest) -> 10 (Fastest) to internal delayMult 10 -> 1
        const delayMult = 11 - userSpeed;
        const effectiveInterval = baseDuration * (delayMult / 4.0);
        this.cycleTimer++;
        if (this.cycleTimer >= effectiveInterval) {
            if (!this.debugMode || this.manualStep) {
                this.cycleTimer = 0;
                this.cyclesCompleted++;
                if (this.expansionPhase < this.sequence.length) {
                    this._processAnimationStep();
                } else if (this.getConfig('AutoGenerateRemaining')) {
                    this._attemptGrowth();
                }
                this.manualStep = false;
            }
        }
        this._updateRenderGridLogic();
        // 3. Lifecycle State Machine
        const fadeInFrames = Math.max(1, s.quantizedAddFadeInFrames);
        const fadeOutFrames = Math.max(1, s.quantizedAddFadeFrames);
        const durationFrames = s.quantizedAddDurationSeconds * fps;
        const setAlpha = (val) => { this.alpha = Math.max(0, Math.min(1, val)); };
        if (this.state === 'FADE_IN') {
            this.timer++;
            setAlpha(this.timer / fadeInFrames);
            if (this.timer >= fadeInFrames) {
                this.state = 'SUSTAIN';
                this.timer = 0;
                this.alpha = 1.0;
            }
        } else if (this.state === 'SUSTAIN') {
            this.timer++;
            const isFinished = (this.timer >= durationFrames);
            const procFinished = this.getConfig('AutoGenerateRemaining') && this._isProceduralFinished();
            if (!this.debugMode && (isFinished || procFinished)) {
                this.state = 'FADE_OUT';
                this.timer = 0;
                if (!this.hasSwapped && !this.isSwapping) {
                    this._swapStates();
                }
            }
        } else if (this.state === 'FADE_OUT') {
            // If swapping, we handle termination in swap logic.
            // If just fading out (e.g. cancelled), handle standard fade.
            if (!this.isSwapping) {
                this.timer++;
                setAlpha(1.0 - (this.timer / fadeOutFrames));
                if (this.timer >= fadeOutFrames) {
                    this.active = false;
                    this.state = 'IDLE';
                    this.alpha = 0.0;
                    window.removeEventListener('keydown', this._boundDebugHandler);
                    this.g.clearAllOverrides();
                    this.shadowGrid = null;
                    this.shadowSim = null;
                }
            }
        }
        // 4. Animation Transition Management (Dirtiness)
        this._checkDirtiness();
    }
    applyToGrid(grid) {
    }
}
// --- QuantizedBlockGeneration.js ---
class QuantizedBlockGeneration extends QuantizedBaseEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "QuantizedBlockGenerator"; 
        this.configPrefix = "quantizedGenerateV2";
        this.active = false;
        this.timer = 0;
        this.genTimer = 0;
        this.logicScale = 3.0; // Allow expansion 200% past screen edges to prevent border stalls
        // --- 1. Growth Behaviors (Proposers) ---
        // These behaviors simply calculate coordinates and call _spawnBlock.
        // The new Controller Logic in _spawnBlock ensures they all adhere to the Rule Stack.
        this.GROWTH_BEHAVIORS = [
            { id: 'Unfold', method: '_attemptUnfoldGrowth' },
            { id: 'Nudge', method: '_executeNudgeGrowth' },
            { id: 'Cluster', method: '_attemptClusterGrowth' },
            { id: 'Shift', method: '_attemptQuadrantShiftGrowth' },
            { id: 'Centered', method: '_attemptCenteredGrowth' },
            { id: 'Thicken', method: '_attemptThickenGrowth' }
        ];
        // --- 2. Global Maintenance Behaviors ---
        this.GLOBAL_BEHAVIORS = [
            { id: 'Rearrange', method: '_attemptRearrangeGrowth', perLayer: true },
            { id: 'AutoFillHoles', method: '_fillHoles', perLayer: true },
            { id: 'AutoConnectIslands', method: '_connectIslands' }
        ];
        // --- 3. Rule Stack (Validation) ---
        // Centralized configuration of all constraints.
        this.RULES = {
            // A. Bounds Check
            bounds: (c) => {
                const w = this.logicGridW;
                const h = this.logicGridH;
                const cx = Math.floor(w / 2);
                const cy = Math.floor(h / 2);
                if (cx + c.x < 0 || cx + c.x + c.w > w || 
                    cy + c.y < 0 || cy + c.y + c.h > h) return false;
                return true;
            },
            // B. Step Occupancy (Prevent stacking in one frame)
            occupancy: (c) => {
                if (c.bypassOccupancy || !this._stepOccupancy) return true;
                const w = this.logicGridW;
                const cx = Math.floor(w / 2);
                const cy = Math.floor(this.logicGridH / 2);
                const x1 = Math.max(0, cx + c.x);
                const y1 = Math.max(0, cy + c.y);
                const x2 = Math.min(w - 1, x1 + c.w - 1);
                const y2 = Math.min(this.logicGridH - 1, y1 + c.h - 1);
                for (let gy = y1; gy <= y2; gy++) {
                    const rowOff = gy * w;
                    for (let gx = x1; gx <= x2; gx++) {
                        if (this._stepOccupancy[rowOff + gx] === 1) return false;
                    }
                }
                return true;
            },
            // C. Connectivity (Adherence to layer)
            connectivity: (c) => {
                if (c.skipConnectivity) return true;
                const grid = this.layerGrids[c.layer];
                if (!grid) return false;
                const w = this.logicGridW;
                const h = this.logicGridH;
                const cx = Math.floor(w / 2);
                const cy = Math.floor(h / 2);
                const x1 = Math.max(0, cx + c.x);
                const y1 = Math.max(0, cy + c.y);
                const x2 = Math.min(w - 1, x1 + c.w - 1);
                const y2 = Math.min(h - 1, y1 + c.h - 1);
                let connected = false;
                let overlapCount = 0;
                const area = c.w * c.h;
                // 1. Check Overlap (Internal)
                for (let gy = y1; gy <= y2; gy++) {
                    const rowOff = gy * w;
                    for (let gx = x1; gx <= x2; gx++) {
                        const idx = rowOff + gx;
                        if (grid[idx] !== -1) {
                            overlapCount++;
                            connected = true;
                            c._foundAnchorIdx = idx; // Set anchor for direction check
                        }
                    }
                }
                // Prevent full internal stacking unless allowed
                if (!c.isShifter && !c.allowInternal && overlapCount >= area) return false;
                if (connected) return true;
                // 2. Check Adjacency (Perimeter)
                // Top
                if (y1 > 0) {
                    const rowOff = (y1 - 1) * w;
                    for (let gx = x1; gx <= x2; gx++) { 
                        const aIdx = rowOff + gx;
                        if (grid[aIdx] !== -1) {
                            c._foundAnchorIdx = aIdx;
                            return true; 
                        }
                    }
                }
                // Bottom
                if (y2 < h - 1) {
                    const rowOff = (y2 + 1) * w;
                    for (let gx = x1; gx <= x2; gx++) { 
                        const aIdx = rowOff + gx;
                        if (grid[aIdx] !== -1) {
                            c._foundAnchorIdx = aIdx;
                            return true; 
                        }
                    }
                }
                // Left
                if (x1 > 0) {
                    for (let gy = y1; gy <= y2; gy++) { 
                        const aIdx = gy * w + x1 - 1;
                        if (grid[aIdx] !== -1) {
                            c._foundAnchorIdx = aIdx;
                            return true; 
                        }
                    }
                }
                // Right
                if (x2 < w - 1) {
                    for (let gy = y1; gy <= y2; gy++) { 
                        const aIdx = gy * w + x2 + 1;
                        if (grid[aIdx] !== -1) {
                            c._foundAnchorIdx = aIdx;
                            return true; 
                        }
                    }
                }
                return false;
            },
            // D. Outward Growth Check
            direction: (c) => {
                if (c.isShifter || c.isMirroredSpawn || c.skipConnectivity) return true;
                // The block must be connecting to an existing anchor further in.
                const cx = Math.floor(this.logicGridW / 2);
                const cy = Math.floor(this.logicGridH / 2);
                const nx = c.x + c.w / 2;
                const ny = c.y + c.h / 2;
                const newDistSq = nx * nx + ny * ny;
                // Use the anchor found during connectivity check
                if (c._foundAnchorIdx !== undefined) {
                    const ax_abs = c._foundAnchorIdx % this.logicGridW;
                    const ay_abs = Math.floor(c._foundAnchorIdx / this.logicGridW);
                    const ax = ax_abs - cx + 0.5;
                    const ay = ay_abs - cy + 0.5;
                    const anchorDistSq = ax * ax + ay * ay;
                    // Allow very slight tolerance for floating point parity, 
                    // but generally must be further out.
                    if (newDistSq < anchorDistSq - 0.01) return false;
                }
                return true;
            },
            // E. Anchoring (Optional sub-layer constraint)
            anchoring: (c) => {
                 if (c.skipAnchoring || c.layer === 0) return true;
                 return this._isAnchored(c.x, c.y, c.w, c.h, c.layer);
            },
            // E. Drift Check (Optional sub-layer constraint)
            drift: (c) => {
                if (c.bypassDriftCheck) return true;
                return this._validateAdditionSafety(c.x, c.y, c.layer);
            },
            // F. Spatial Distribution (Prevent clustering in one step)
            spatial: (c) => {
                if (c.isMirroredSpawn || c.isShifter || c.bypassSpatial) return true;
                if (!this._currentStepActions || this._currentStepActions.length === 0) return true;
                const cx = c.x + c.w / 2;
                const cy = c.y + c.h / 2;
                // Manhattan distance: 5% of max dimension, min 1 block
                const minDistance = Math.max(1, Math.floor(Math.max(this.logicGridW, this.logicGridH) * 0.05));
                for (const action of this._currentStepActions) {
                    const ax = action.x + action.w / 2;
                    const ay = action.y + action.h / 2;
                    const dist = Math.abs(cx - ax) + Math.abs(cy - ay);
                    if (dist < minDistance) return false;
                }
                return true;
            }
        };
    }
    _initShadowWorld() {
        this._initShadowWorldBase(false);
        const sm = this.shadowSim.streamManager;
        const s = this.c.state;
        const cols = this.shadowGrid.cols;
        const rows = this.shadowGrid.rows;
        const targetStreamCount = Math.floor(cols * 0.5); 
        const totalSpawns = (s.streamSpawnCount || 0) + (s.eraserSpawnCount || 0);
        const eraserChance = totalSpawns > 0 ? (s.eraserSpawnCount / totalSpawns) : 0;
        const columns = Array.from({length: cols}, (_, i) => i);
        Utils.shuffle(columns);
        let spawned = 0;
        let colIdx = 0;
        const maxAttempts = targetStreamCount * 3; 
        let attempts = 0;
        while (spawned < targetStreamCount && attempts < maxAttempts) {
            attempts++;
            const col = columns[colIdx % columns.length];
            colIdx++;
            const isEraser = Math.random() < eraserChance;
            const stream = sm._initializeStream(col, isEraser, s);
            const totalSteps = stream.visibleLen;
            const fallSteps = rows;
            const currentAge = Math.floor(Math.random() * totalSteps);
            if (currentAge < fallSteps) {
                stream.y = currentAge;
                stream.age = currentAge;
            } else {
                stream.y = rows + 1; 
                stream.age = currentAge;
                if (!stream.isEraser) {
                    const eraserAge = currentAge - fallSteps;
                    if (eraserAge > 0) {
                        const eraser = sm._initializeStream(col, true, s);
                        eraser.y = Math.min(eraserAge, rows + 5);
                        eraser.age = eraserAge;
                        eraser.tickInterval = stream.tickInterval; 
                        sm.addActiveStream(eraser);
                    }
                }
            }
            stream.visibleLen += Math.floor(Math.random() * 300);
            if (stream.age < stream.visibleLen) {
                sm.addActiveStream(stream);
                spawned++;
            }
        }
        const warmupFrames = 60; 
        this.warmupRemaining = warmupFrames;
        this.shadowSimFrame = 0;
    }
    trigger(force = false) {
        if (this.active && !force) return false;
        if (!super.trigger(force)) return false;
        this._log("QuantizedBlockGenerator: Triggered");
        this.timer = 0;
        this.genTimer = 0;
        this.animFrame = 0;
        this.expansionPhase = 0;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.alpha = 1.0;
        this.state = 'GENERATING';
        this.usedCardinalIndices = [];
        this.nudgeAxisBalance = 0; 
        this._initShadowWorld(); 
        const bs = this.getBlockSize();
        this._lastBlocksX = this.logicGridW;
        this._lastBlocksY = this.logicGridH;
        this._lastPitchX = Math.max(1, bs.w);
        this._lastPitchY = Math.max(1, bs.h);
        this._initProceduralState(true);
        this._updateRenderGridLogic();
        return true;
    }
    update() {
        if (!this.active) return;
        if (!this.hasSwapped && !this.isSwapping) {
            if (super._updateShadowSim()) return;
        } else if (this.isSwapping) {
            super.updateTransition(false);
        }
        const s = this.c.state;
        const fps = 60;
        this.animFrame++;
        this.timer++;
        const fadeOutFrames = this.getConfig('FadeFrames') || 0;
        if (this.maskOps.length > 0 && this.animFrame % 60 === 0) {
             const oldLen = this.maskOps.length;
             this.maskOps = this.maskOps.filter(op => {
                 if (op.expireFrame && this.animFrame >= op.expireFrame + fadeOutFrames) return false;
                 return true;
             });
             if (this.maskOps.length !== oldLen) {
                 this._lastProcessedOpIndex = 0; 
                 this._gridsDirty = true;
             }
        }
        const durationFrames = (s.quantizedGenerateV2DurationSeconds || 5) * fps;
        if (this.state === 'GENERATING') {
            const baseDuration = Math.max(1, this.c.derived.cycleDuration);
            const userSpeed = (s.quantizedGenerateV2Speed !== undefined) ? s.quantizedGenerateV2Speed : 5;
            const delayMult = 11 - userSpeed;
            const enNudge = (this.getConfig('EnableNudge') === true);
            const intervalMult = enNudge ? 0.15 : 0.25; 
            const interval = Math.max(1, baseDuration * (delayMult * intervalMult));
            if (!this.debugMode || this.manualStep) {
                this.genTimer++;
                if (this.genTimer >= interval || this.manualStep) {
                    this.genTimer = 0;
                    try {
                        this._attemptGrowth();
                    } catch (e) {
                        console.error("QuantizedBlockGenerator: Error in _attemptGrowth:", e);
                    }
                    this.expansionPhase++;
                }
                this.manualStep = false;
            }
            this._updateRenderGridLogic();
            // Cache coverage check
            if (this._gridsDirty || this._isCovered === undefined) {
                this._isCovered = this._isCanvasFullyCovered();
            }
            const isCovered = this._isCovered;
            const timedOut = this.timer >= durationFrames;
            if (!this.debugMode && (timedOut || isCovered)) {
                this._log(`QuantizedBlockGenerator: Ending generation. Reason: ${isCovered ? 'FULL COVERAGE' : 'TIMEOUT (' + (this.timer/fps).toFixed(1) + 's)'}`);
                this.state = 'FADE_OUT';
                this.timer = 0;
                if (!this.hasSwapped && !this.isSwapping) {
                    this._swapStates();
                }
            }
        } else if (this.state === 'FADE_OUT') {
            const fadeFrames = s.quantizedGenerateV2FadeFrames || 60;
            this.alpha = Math.max(0, 1.0 - (this.timer / fadeFrames));
            if (this.timer >= fadeFrames) {
                this._log("QuantizedBlockGenerator: Effect complete.");
                this.active = false;
                this.state = 'IDLE';
                this.g.clearAllOverrides();
            }
        }
        this._checkDirtiness();
    }
    _attemptGrowth() {
        this._initProceduralState(true); 
        this._syncSubLayers(); // Synchronize existing state first
        this._currentStepActions = []; // Reset step actions for spatial distribution check
        const s = this.c.state;
        const getGenConfig = (key) => {
            const val = this.getConfig(key);
            if (val !== undefined) return val;
            return s['quantizedGenerateV2' + key];
        };
        // 1. Sync Logic Grid (for connectivity checks)
        this._updateInternalLogicGrid();
        const w = this.logicGridW, h = this.logicGridH;
        // 2. Initialize Step Occupancy
        const stepOccupancy = this._getBuffer('stepOccupancy', this.logicGrid.length, Uint8Array);
        stepOccupancy.fill(0);
        this._stepOccupancy = stepOccupancy;
        // 3. Preparation
        let quota = getGenConfig('SimultaneousSpawns') || 1;
        if (getGenConfig('EnableEventScaling')) {
            const minQuota = getGenConfig('EventScalingMin') || 1;
            let filled = 0;
            for (let i = 0; i < this.logicGrid.length; i++) if (this.logicGrid[i] === 1) filled++;
            const massPercent = filled / this.logicGrid.length;
            const t = Math.min(1.0, massPercent / 0.5); 
            quota = Math.round(minQuota + (quota - minQuota) * t);
        }
        const maxLayer = getGenConfig('LayerCount') || 1;
        // Collect behaviors
        const behaviors = [];
        this.GROWTH_BEHAVIORS.forEach(b => {
            if (getGenConfig('Enable' + b.id)) {
                behaviors.push(b);
            }
        });
        let successInStep = false;
        // 4. Synchronized Layer Growth Loop
        for (let q = 0; q < quota; q++) {
            for (const behavior of behaviors) {
                for (let targetLayer = 0; targetLayer <= maxLayer; targetLayer++) {
                    let successForLayer = false;
                    if (behavior.id === 'Unfold') {
                        // 1. Try to continue existing sequences
                        if (this._processActiveStatefulBehaviors(targetLayer)) {
                            successForLayer = true;
                        }
                        // 2. If no active sequence was updated, try to start a new one
                        if (!successForLayer) {
                            if (this._attemptUnfoldGrowth(null, targetLayer)) {
                                successForLayer = true;
                            }
                        }
                    } else {
                        if (typeof this[behavior.method] === 'function') {
                            if (this[behavior.method](null, targetLayer)) successForLayer = true;
                        }
                    }
                    if (successForLayer) successInStep = true;
                }
            }
        }
        // 5. Global Maintenance (Pruning, etc.)
        for (const behavior of this.GLOBAL_BEHAVIORS) {
            const isEnabled = getGenConfig('Enable' + behavior.id) === true;
            if (isEnabled) {
                if (behavior.perLayer) {
                    for (let l = 0; l <= maxLayer; l++) this[behavior.method](l);
                } else {
                    this[behavior.method]();
                }
            }
        }
        // Update Layer Rotation for any behaviors that still use sequential rotation
        this.proceduralLayerIndex = (this.proceduralLayerIndex + 1) % (maxLayer + 1);
        if (!successInStep && !this._isCanvasFullyCovered()) {
            this._warn("QuantizedBlockGenerator: Growth stalled - no safe move found in this step.");
        }
        // Final Logic Grid Sync (for rendering)
        this._updateInternalLogicGrid();
    }
    _updateInternalLogicGrid() {
        if (!this.logicGridW || !this.logicGridH) return;
        if (!this._gridsDirty && this.logicGrid.some(v => v === 1)) return; // Skip if already synced
        const w = this.logicGridW, h = this.logicGridH;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        this.logicGrid.fill(0);
        for (let i = 0; i < this.activeBlocks.length; i++) {
            const b = this.activeBlocks[i];
            const x1 = Math.max(0, cx + b.x), x2 = Math.min(w - 1, cx + b.x + b.w - 1);
            const y1 = Math.max(0, cy + b.y), y2 = Math.min(h - 1, cy + b.y + b.h - 1);
            for (let gy = y1; gy <= y2; gy++) {
                const rowOff = gy * w;
                for (let gx = x1; gx <= x2; gx++) {
                    this.logicGrid[rowOff + gx] = 1;
                }
            }
        }
    }
    _executeNudgeGrowth(ignored, targetLayer) {
        const sw = this._getScaledConfig('MinBlockWidth', 1);
        const mw = this._getScaledConfig('MaxBlockWidth', 3);
        const sh = this._getScaledConfig('MinBlockHeight', 1);
        const mh = this._getScaledConfig('MaxBlockHeight', 3);
        const bw = Math.floor(Math.random() * (mw - sw + 1)) + sw;
        const bh = Math.floor(Math.random() * (mh - sh + 1)) + sh;
        return this._attemptNudgeGrowthWithParams(targetLayer, bw, bh);
    }
    _attemptThickenGrowth(ignored, targetLayer) {
        const s = this.c.state;
        const count = s.quantizedGenerateV2ThickenQuadrantCount;
        if (count === 0) return false;
        // Since this is in the quota loop, we only want to trigger the quadrant logic ONCE per step per layer
        // to match the slider's definition of "per step" while allowing it to apply to all layers.
        if (!this._thickenStepFrames) this._thickenStepFrames = {};
        if (this._thickenStepFrames[targetLayer] === this.animFrame) return false;
        this._thickenStepFrames[targetLayer] = this.animFrame;
        const w = this.logicGridW;
        const h = this.logicGridH;
        if (!w || !h) return false;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(h / 2);
        const grid = this.layerGrids[targetLayer];
        if (!grid) return false;
        const ratio = (this.g.cols / this.g.rows) || 1.0;
        const horizWeight = Math.max(1.0, ratio);
        const vertWeight = Math.max(1.0, 1.0 / ratio);
        const weightedQuadrants = [
            { id: 'NW', w: vertWeight * horizWeight },
            { id: 'NE', w: vertWeight * horizWeight },
            { id: 'SW', w: vertWeight * horizWeight },
            { id: 'SE', w: vertWeight * horizWeight }
        ];
        // Aspect Ratio Bias: If horizontal, prefer E/W quadrants. If vertical, prefer N/S.
        // Actually, quadrants are combinations. NW is N+W. 
        // If ratio > 1 (Horizontal), W and E are good. All quadrants have W or E.
        // Let's refine: prefer quadrants that align with the longest side's ends.
        const result = [];
        const pool = [...weightedQuadrants];
        while (pool.length > 0) {
            let totalW = 0;
            for (const item of pool) totalW += item.w;
            let r = Math.random() * totalW;
            for (let i = 0; i < pool.length; i++) {
                r -= pool[i].w;
                if (r <= 0) {
                    result.push(pool[i].id);
                    pool.splice(i, 1);
                    break;
                }
            }
        }
        const chosen = result.slice(0, count);
        let success = false;
        for (const q of chosen) {
            let xStart, xEnd, yStart, yEnd;
            if (q === 'NW') { xStart = 0; xEnd = cx - 1; yStart = 0; yEnd = cy - 1; }
            else if (q === 'NE') { xStart = cx; xEnd = w - 1; yStart = 0; yEnd = cy - 1; }
            else if (q === 'SW') { xStart = 0; xEnd = cx - 1; yStart = cy; yEnd = h - 1; }
            else { xStart = cx; xEnd = w - 1; yStart = cy; yEnd = h - 1; }
            // Find frontier within this quadrant
            const frontier = [];
            for (let gy = yStart; gy <= yEnd; gy++) {
                const rowOff = gy * w;
                for (let gx = xStart; gx <= xEnd; gx++) {
                    const idx = rowOff + gx;
                    if (grid[idx] === -1) {
                        // Check if any neighbor is active on THIS layer
                        const neighbors = [
                            {x: gx, y: gy - 1}, {x: gx, y: gy + 1},
                            {x: gx - 1, y: gy}, {x: gx + 1, y: gy}
                        ];
                        for (const n of neighbors) {
                            if (n.x >= 0 && n.x < w && n.y >= 0 && n.y < h) {
                                if (grid[n.y * w + n.x] !== -1) {
                                    frontier.push({x: gx, y: gy});
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (frontier.length > 0) {
                // To avoid massive performance hits or visual spikes, 
                // we fill a random portion of the frontier (up to 20 blocks).
                Utils.shuffle(frontier);
                const toFill = frontier.slice(0, 20);
                for (const pt of toFill) {
                    // Use skipConnectivity=false to enforce the 'direction' (outward) rule
                    if (this._spawnBlock(pt.x - cx, pt.y - cy, 1, 1, targetLayer, false, 0, false, true) !== -1) {
                        success = true;
                    }
                }
            }
        }
        return success;
    }
    // --- CONTROLLER LOGIC ---
    _spawnBlock(x, y, w, h, layer = 0, isShifter = false, expireFrames = 0, skipConnectivity = false, allowInternal = false, suppressFades = false, isMirroredSpawn = false, bypassOccupancy = false) {
        const candidate = {
            x, y, w, h, layer,
            isShifter, expireFrames, skipConnectivity, allowInternal,
            suppressFades, isMirroredSpawn, bypassOccupancy,
            skipAnchoring: skipConnectivity,
            bypassSpatial: skipConnectivity,
            bypassDriftCheck: skipConnectivity
        };
        return this._proposeCandidate(candidate);
    }
    _proposeCandidate(c) {
        // 1. Offscreen Redirection
        if (!this.RULES.bounds(c)) {
            if (!this._redirectOffscreen(c)) return -1; // Abort if no on-screen fallback found
        }
        // 2. Validate
        if (!this._validateCandidate(c)) return -1;
        // 3. Commit
        const id = this._commitCandidate(c);
        if (id === -1) return -1;
        // 4. Side Effects (Axis Balancing)
        if (!c.isShifter && !c.isMirroredSpawn && this.getConfig('EnableAxisBalancing')) {
            this._handleAxisBalancing(c);
        }
        return id;
    }
    _redirectOffscreen(c) {
        if (c.skipConnectivity) return false;
        const bs = this.getBlockSize();
        const xLimit = Math.floor((this.g.cols / bs.w) / 2);
        const yLimit = Math.floor((this.g.rows / bs.h) / 2);
        // Find all exposed blocks on THIS layer that are strictly on-screen
        const anchors = this.activeBlocks.filter(b => {
            if (b.layer !== c.layer) return false;
            // Check if block is at least partially on-screen
            return !(b.x < -xLimit || b.x > xLimit || b.y < -yLimit || b.y > yLimit);
        });
        if (anchors.length === 0) return false;
        // Prefer anchors closest to the "offscreen" target to maintain some intent
        const tx = c.x, ty = c.y;
        anchors.sort((a, b) => {
            const distA = Math.abs(a.x - tx) + Math.abs(a.y - ty);
            const distB = Math.abs(b.x - tx) + Math.abs(b.y - ty);
            return distA - distB;
        });
        // Try to attach the requested shape to the perimeter of the nearest on-screen anchors
        const dirs = this._getBiasedDirections();
        for (let i = 0; i < Math.min(10, anchors.length); i++) {
            const a = anchors[i];
            for (const dir of dirs) {
                let nx = a.x, ny = a.y;
                if (dir === 'N') ny = a.y - c.h;
                else if (dir === 'S') ny = a.y + a.h;
                else if (dir === 'E') nx = a.x + a.w;
                else if (dir === 'W') nx = a.x - c.w;
                // Validate new position is on-screen
                if (nx >= -xLimit && nx + c.w - 1 <= xLimit && ny >= -yLimit && ny + c.h - 1 <= yLimit) {
                    // Update candidate coordinates
                    c.x = nx;
                    c.y = ny;
                    return true;
                }
            }
        }
        return false;
    }
    _validateCandidate(c) {
        if (!this.RULES.bounds(c)) return false;
        if (!this.RULES.occupancy(c)) return false;
        if (!this.RULES.anchoring(c)) return false;
        if (!this.RULES.drift(c)) return false;
        // Shifter blocks bypass growth constraints
        if (c.isShifter) return true;
        if (!this.RULES.connectivity(c)) return false;
        if (!this.RULES.direction(c)) return false;
        if (!this.RULES.spatial(c)) return false;
        return true;
    }
    _commitCandidate(c) {
        // Bypass checks in super that we already performed
        const id = super._spawnBlock(
            c.x, c.y, c.w, c.h, c.layer,
            c.isShifter, c.expireFrames,
            true, // Skip super's connectivity/overlap check
            c.allowInternal, c.suppressFades, c.isMirroredSpawn, c.bypassOccupancy
        );
        if (id !== -1) {
            if (!this._currentStepActions) this._currentStepActions = [];
            this._currentStepActions.push(c);
        }
        return id;
    }
    _handleAxisBalancing(c) {
        const mirrorType = Math.floor(Math.random() * 3); // 0: X, 1: Y, 2: Both
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        // Target Quadrant Logic
        let flipX = (mirrorType === 0 || mirrorType === 2);
        let flipY = (mirrorType === 1 || mirrorType === 2);
        let targetX = flipX ? -c.x - c.w : c.x;
        let targetY = flipY ? -c.y - c.h : c.y;
        const candidate = { ...c, x: targetX, y: targetY, isMirroredSpawn: true };
        // 1. Try direct mirror first
        if (this._validateCandidate(candidate)) {
            this._commitCandidate(candidate);
            return;
        }
        // 2. Search for nearest connected spot in target quadrant
        const searchRange = 5;
        const attempts = [];
        for (let dy = -searchRange; dy <= searchRange; dy++) {
            for (let dx = -searchRange; dx <= searchRange; dx++) {
                if (dx === 0 && dy === 0) continue;
                attempts.push({ 
                    x: targetX + dx, 
                    y: targetY + dy, 
                    dist: Math.abs(dx) + Math.abs(dy) 
                });
            }
        }
        attempts.sort((a, b) => a.dist - b.dist);
        for (const att of attempts) {
            const searchCandidate = { ...candidate, x: att.x, y: att.y };
            if (this._validateCandidate(searchCandidate)) {
                this._commitCandidate(searchCandidate);
                return;
            }
        }
        // 3. Last resort: Any connected spot on the target layer
        // This ensures the balancing quota is fulfilled without breaking rules
        const anchors = this.activeBlocks.filter(b => b.layer === c.layer);
        if (anchors.length > 0) {
            Utils.shuffle(anchors);
            for (let i = 0; i < Math.min(10, anchors.length); i++) {
                const a = anchors[i];
                const dirs = [{dx:1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:1}, {dx:0, dy:-1}];
                Utils.shuffle(dirs);
                for (const d of dirs) {
                    let tx = (d.dx === 1) ? a.x + a.w : (d.dx === -1 ? a.x - c.w : a.x);
                    let ty = (d.dy === 1) ? a.y + a.h : (d.dy === -1 ? a.y - c.h : a.y);
                    const finalAttempt = { ...candidate, x: tx, y: ty };
                    if (this._validateCandidate(finalAttempt)) {
                        this._commitCandidate(finalAttempt);
                        return;
                    }
                }
            }
        }
    }
    _executeStepOps(step, startFrameOverride) {
        this._syncSubLayers(); // Synchronize at the start
        super._executeStepOps(step, startFrameOverride);
    }
    _syncSubLayers() {
        const s = this.c.state;
        if (!s.quantizedGenerateV2EnableSyncSubLayers) return;
        // Ensure we only sync once per step (frame-based throttle)
        if (this._syncFrame === this.animFrame) return;
        this._syncFrame = this.animFrame;
        const maxLayer = s.quantizedGenerateV2LayerCount || 1;
        if (maxLayer < 1) return;
        const w = this.logicGridW;
        const h = this.logicGridH;
        const l0Grid = this.layerGrids[0];
        if (!l0Grid) return;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(h / 2);
        // 1. Identify all active cells in Layer 0 to sync.
        const syncGrid = this._getBuffer('syncGrid', w * h, Uint8Array);
        syncGrid.fill(0);
        for (let i = 0; i < l0Grid.length; i++) {
            if (l0Grid[i] !== -1) syncGrid[i] = 1;
        }
        // 2. Extract rectangles from syncGrid (Greedy Fill)
        const rects = [];
        for (let gy = 0; gy < h; gy++) {
            const rowOffBase = gy * w;
            for (let gx = 0; gx < w; gx++) {
                if (syncGrid[rowOffBase + gx] === 1) {
                    let rw = 0;
                    while (gx + rw < w && syncGrid[rowOffBase + gx + rw] === 1) rw++;
                    let rh = 1;
                    while (gy + rh < h) {
                        let lineFull = true;
                        const targetRowOff = (gy + rh) * w;
                        for (let ix = 0; ix < rw; ix++) {
                            if (syncGrid[targetRowOff + gx + ix] !== 1) { lineFull = false; break; }
                        }
                        if (!lineFull) break;
                        rh++;
                    }
                    rects.push({ x: gx - cx, y: gy - cy, w: rw, h: rh });
                    // Mark as processed
                    for (let iy = 0; iy < rh; iy++) {
                        const markRowOff = (gy + iy) * w;
                        for (let ix = 0; ix < rw; ix++) syncGrid[markRowOff + gx + ix] = 0;
                    }
                }
            }
        }
        // 3. Commit these rectangles to sub-layers if they aren't already covered
        for (const r of rects) {
            const rx = cx + r.x, ry = cy + r.y;
            for (let l = 1; l <= maxLayer; l++) {
                const targetGrid = this.layerGrids[l];
                let fullyCovered = true;
                for (let iy = 0; iy < r.h; iy++) {
                    const rowOff = (ry + iy) * w;
                    for (let ix = 0; ix < r.w; ix++) {
                        if (targetGrid[rowOff + rx + ix] === -1) { 
                            fullyCovered = false; 
                            break; 
                        }
                    }
                    if (!fullyCovered) break;
                }
                if (!fullyCovered) {
                    this._spawnBlock(r.x, r.y, r.w, r.h, l, false, 0, true, true, true, true, true);
                }
            }
        }
    }
    stop() {
        super.stop();
    }
}
// --- QuantizedClimbEffect.js ---
class QuantizedClimbEffect extends QuantizedBaseEffect {
    constructor(grid, config) {
        super(grid, config);
        this.name = "QuantizedClimb";
        this.active = false;
        this.configPrefix = "quantizedClimb";
        // Simulation State
        this.timer = 0;
        this.state = 'IDLE'; // IDLE, FADE_IN, SUSTAIN, FADE_OUT
        this.alpha = 0.0;
        // Sequence State
        this.sequence = [[]]; 
        this.expansionPhase = 0;
        this.maskOps = [];
        // Flicker Fix
        this.isSwapping = false;
        this.swapTimer = 0;
    }
    trigger(force = false) {
        // 1. Strict Active Check
        if (this.active) return false;
        // 2. Mutually Exclusive Lock
        if (window.matrix && window.matrix.effectRegistry) {
            const siblings = ["QuantizedPulse", "QuantizedAdd", "QuantizedRetract", "QuantizedZoom"];
            for (const name of siblings) {
                const eff = window.matrix.effectRegistry.get(name);
                if (eff && eff.active) {
                    return false;
                }
            }
        }
        if (!super.trigger(force)) return false;
        this.state = 'FADE_IN';
        this.timer = 0;
        this.alpha = 0.0;
        this.hasSwapped = false;
        this.isSwapping = false;
        this.expansionPhase = 0;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.manualStep = false;
        this._initShadowWorld();
        if (this.renderGrid) this.renderGrid.fill(-1);
        return true;
    }
    update() {
        if (!this.active) return;
        // 0. Update Shadow Simulation & Warmup
        if (!this.hasSwapped && !this.isSwapping) {
            if (super._updateShadowSim()) return;
        } else if (this.isSwapping) {
            super.updateTransition(true);
        }
        const s = this.c.state;
        const fps = 60;
        this.animFrame++;
        // 1. Animation Cycle
        const baseDuration = Math.max(1, this.c.derived.cycleDuration);
        const userSpeed = (s.quantizedClimbSpeed !== undefined) ? s.quantizedClimbSpeed : 5;
        // Map 1 (Slowest) -> 10 (Fastest) to internal delayMult 10 -> 1
        const delayMult = 11 - userSpeed;
        const effectiveInterval = baseDuration * (delayMult / 4.0);
            this.cycleTimer++;
            if (this.cycleTimer >= effectiveInterval) {
                if (!this.debugMode || this.manualStep) {
                    this.cycleTimer = 0;
                    this.cyclesCompleted++;
                    if (this.expansionPhase < this.sequence.length) {
                        this._processAnimationStep();
                    } else if (this.getConfig('AutoGenerateRemaining')) {
                        this._attemptGrowth();
                    }
                    this.manualStep = false;
                }
            }
        this._updateRenderGridLogic();
        // 2. Lifecycle
        const fadeInFrames = Math.max(1, (s.quantizedClimbFadeInFrames !== undefined) ? s.quantizedClimbFadeInFrames : 60);
        const fadeOutFrames = Math.max(1, (s.quantizedClimbFadeFrames !== undefined) ? s.quantizedClimbFadeFrames : 60);
        const durationFrames = (s.quantizedClimbDurationSeconds || 2) * fps;
        if (this.state === 'FADE_IN') {
            this.timer++;
            this.alpha = Math.min(1.0, this.timer / fadeInFrames);
            if (this.timer >= fadeInFrames) {
                this.state = 'SUSTAIN';
                this.timer = 0;
                this.alpha = 1.0;
            }
        } else if (this.state === 'SUSTAIN') {
            this.timer++;
            const isFinished = (this.timer >= durationFrames);
            const procFinished = this.getConfig('AutoGenerateRemaining') && this._isProceduralFinished();
            if (!this.debugMode && (isFinished || procFinished)) {
                this.state = 'FADE_OUT';
                this.timer = 0;
                if (!this.hasSwapped && !this.isSwapping) {
                    this._swapStates();
                }
            }
        } else if (this.state === 'FADE_OUT') {
            if (!this.isSwapping) {
                this.timer++;
                this.alpha = Math.max(0.0, 1.0 - (this.timer / fadeOutFrames));
                if (this.timer >= fadeOutFrames) {
                    this.active = false;
                    this.state = 'IDLE';
                    window.removeEventListener('keydown', this._boundDebugHandler);
                    this.g.clearAllOverrides();
                    this.shadowGrid = null;
                    this.shadowSim = null;
                }
            }
        }
        // 4. Animation Transition Management (Dirtiness)
        this._checkDirtiness();
    }
}
// --- QuantizedPatterns.js ---
window.matrixPatterns = {
    "QuantizedPulse": [
        [
            1,
            0,
            0
        ],
        [
            8,
            0,
            0,
            1
        ],
        [
            8,
            1,
            0,
            1
        ],
        [],
        [
            8,
            0,
            -1,
            1,
            8,
            0,
            1,
            1,
            1,
            1,
            0
        ],
        [],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            2
        ],
        [],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            2
        ],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            0,
            1,
            1,
            1,
            1,
            4
        ],
        [
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1
        ],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            4
        ],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            0,
            -2,
            1,
            1,
            1,
            8,
            12,
            0,
            -1,
            1,
            1,
            0,
            8,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            1,
            1,
            1,
            0,
            2,
            11,
            -1,
            1,
            1
        ],
        [
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            5,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            8
        ],
        [
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            -4,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            1,
            1,
            1,
            1,
            4,
            12,
            0,
            2,
            1,
            1,
            1,
            4,
            12,
            0,
            3,
            1,
            1,
            1,
            4,
            11,
            -1,
            1,
            1,
            12,
            0,
            2,
            1,
            1,
            1,
            8,
            12,
            0,
            2,
            1,
            1,
            1,
            8,
            12,
            0,
            3,
            1,
            1,
            1,
            8,
            12,
            0,
            4,
            1,
            1,
            1,
            8,
            12,
            0,
            -2,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1
        ],
        [
            12,
            0,
            4,
            1,
            1,
            1,
            8,
            12,
            1,
            1,
            1,
            1,
            1,
            2,
            11,
            1,
            6,
            1,
            11,
            2,
            3,
            1,
            11,
            2,
            1,
            1,
            12,
            1,
            2,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -2,
            1,
            1,
            1,
            8,
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            0,
            -4,
            1,
            1,
            1,
            8,
            12,
            0,
            -2,
            1,
            1,
            0,
            1,
            12,
            1,
            -2,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            2,
            12,
            1,
            0,
            1,
            1,
            0,
            2,
            11,
            -4,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            11,
            -2,
            2,
            1,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            0,
            -1,
            1,
            1,
            0,
            8,
            11,
            -5,
            0,
            1
        ],
        [
            12,
            0,
            1,
            1,
            1,
            1,
            8,
            12,
            0,
            1,
            1,
            1,
            0,
            8,
            11,
            3,
            2,
            1,
            12,
            0,
            1,
            1,
            1,
            1,
            4,
            12,
            0,
            3,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -2,
            1,
            1,
            0,
            8,
            12,
            0,
            -3,
            1,
            1,
            1,
            8,
            12,
            -4,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1
        ],
        [
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            1,
            0,
            1,
            1,
            0,
            2,
            12,
            2,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            2,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            2,
            1,
            1,
            1,
            8,
            12,
            -2,
            4,
            1,
            1,
            1,
            2,
            12,
            -1,
            4,
            1,
            1,
            1,
            2,
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            -4,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -4,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            0,
            -2,
            1,
            1,
            0,
            8,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            11,
            1,
            5,
            1,
            12,
            7,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -7,
            1,
            1,
            1,
            8
        ],
        [
            12,
            0,
            -2,
            1,
            1,
            1,
            8,
            11,
            -5,
            -1,
            1,
            12,
            0,
            1,
            1,
            1,
            1,
            8,
            11,
            -5,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            -2,
            4,
            1,
            1,
            1,
            2,
            12,
            -1,
            4,
            1,
            1,
            1,
            2,
            11,
            -2,
            5,
            1,
            11,
            -1,
            5,
            1,
            11,
            1,
            6,
            1,
            12,
            0,
            3,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            0,
            -1,
            1,
            1,
            0,
            8,
            12,
            0,
            -2,
            1,
            1,
            0,
            8,
            12,
            0,
            -4,
            1,
            1,
            0,
            8,
            12,
            0,
            -4,
            1,
            1,
            0,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            3,
            1,
            1,
            1,
            8,
            12,
            -1,
            6,
            1,
            1,
            1,
            2,
            11,
            -1,
            7,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            -2,
            6,
            1,
            1,
            1,
            2,
            12,
            -1,
            6,
            1,
            1,
            1,
            2,
            11,
            -2,
            6,
            1,
            11,
            -1,
            6,
            1,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            3,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            2,
            1,
            1,
            0,
            8,
            12,
            0,
            3,
            1,
            1,
            0,
            8,
            12,
            0,
            2,
            1,
            1,
            0,
            8,
            11,
            8,
            -1,
            1
        ],
        [
            12,
            -1,
            7,
            1,
            1,
            1,
            2,
            12,
            0,
            6,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            8,
            -4,
            2,
            1,
            8,
            0,
            -3,
            1,
            12,
            0,
            -3,
            1,
            1,
            1,
            8,
            12,
            0,
            1,
            1,
            1,
            0,
            8,
            12,
            0,
            4,
            1,
            1,
            0,
            8,
            12,
            0,
            4,
            1,
            1,
            0,
            8,
            12,
            0,
            -1,
            1,
            1,
            0,
            8,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            2,
            1,
            1,
            0,
            4,
            12,
            0,
            -3,
            1,
            1,
            1,
            4,
            12,
            0,
            1,
            1,
            1,
            1,
            4,
            12,
            0,
            2,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            -1,
            -7,
            1,
            1,
            1,
            1
        ],
        [
            12,
            0,
            1,
            1,
            1,
            1,
            2,
            12,
            0,
            1,
            1,
            1,
            1,
            2,
            12,
            0,
            1,
            1,
            1,
            1,
            8,
            12,
            0,
            2,
            1,
            1,
            1,
            8,
            11,
            -5,
            2,
            1,
            8,
            -4,
            2,
            1,
            12,
            -1,
            7,
            1,
            1,
            1,
            2,
            11,
            -2,
            7,
            1,
            12,
            -2,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            8,
            -1,
            7,
            1,
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            3,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -4,
            1,
            1,
            1,
            8,
            12,
            0,
            -3,
            1,
            1,
            0,
            8,
            12,
            0,
            -3,
            1,
            1,
            0,
            8,
            11,
            4,
            -3,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            3,
            0,
            1,
            1,
            0,
            1,
            12,
            4,
            0,
            1,
            1,
            1,
            1,
            12,
            5,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -2,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            -8,
            1,
            1,
            1,
            1,
            12,
            -1,
            -7,
            1,
            1,
            1,
            1,
            12,
            -2,
            -4,
            1,
            1,
            1,
            1,
            12,
            0,
            3,
            1,
            1,
            0,
            8,
            7,
            -2,
            -3
        ],
        [
            12,
            3,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            1,
            1,
            1,
            1,
            4,
            12,
            0,
            0,
            1,
            1,
            1,
            4,
            12,
            0,
            -2,
            1,
            1,
            1,
            4,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            -2,
            1,
            1,
            1,
            1,
            12,
            -4,
            2,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            0,
            -2,
            1,
            1,
            1,
            8,
            12,
            -2,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            11,
            -2,
            5,
            1,
            12,
            0,
            -2,
            1,
            1,
            0,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            0,
            8,
            1,
            1,
            1,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            -3,
            1,
            1,
            0,
            8,
            12,
            0,
            -1,
            1,
            1,
            0,
            4,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            3,
            0,
            1,
            1,
            0,
            2,
            12,
            3,
            0,
            1,
            1,
            1,
            2,
            12,
            2,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1
        ],
        [
            12,
            -3,
            0,
            1,
            1,
            1,
            2,
            12,
            -2,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            4,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -3,
            1,
            1,
            1,
            8,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            -1,
            0,
            1,
            1,
            0,
            2,
            12,
            -1,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            6,
            1,
            1,
            0,
            4,
            11,
            1,
            5,
            1,
            12,
            0,
            6,
            1,
            1,
            1,
            4,
            12,
            -1,
            0,
            1,
            1,
            0,
            1
        ],
        [
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            0,
            2,
            1,
            1,
            1,
            8,
            12,
            -4,
            2,
            1,
            1,
            1,
            2,
            12,
            -3,
            2,
            1,
            1,
            1,
            2,
            11,
            -2,
            7,
            1,
            8,
            -1,
            8,
            1,
            8,
            1,
            13,
            1,
            12,
            0,
            5,
            1,
            1,
            1,
            4,
            12,
            0,
            3,
            1,
            1,
            1,
            4,
            12,
            0,
            -2,
            1,
            1,
            1,
            4,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -1,
            1,
            1,
            0,
            8,
            12,
            0,
            2,
            1,
            1,
            0,
            8,
            12,
            0,
            2,
            1,
            1,
            0,
            8,
            12,
            0,
            1,
            1,
            1,
            0,
            8,
            11,
            -2,
            9,
            1,
            12,
            0,
            -1,
            1,
            1,
            0,
            4,
            12,
            0,
            -2,
            1,
            1,
            0,
            4,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            -1,
            0,
            1,
            1,
            0,
            1,
            12,
            -1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            2
        ],
        [
            12,
            -4,
            3,
            1,
            1,
            1,
            2,
            12,
            0,
            1,
            1,
            1,
            1,
            8,
            12,
            -2,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            8,
            1,
            11,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -4,
            1,
            1,
            1,
            8,
            12,
            0,
            -5,
            1,
            1,
            1,
            8,
            12,
            0,
            -3,
            1,
            1,
            1,
            4,
            12,
            3,
            0,
            1,
            1,
            1,
            1,
            12,
            3,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            -1,
            1,
            1,
            0,
            4,
            12,
            0,
            -2,
            1,
            1,
            0,
            4,
            12,
            0,
            3,
            1,
            1,
            0,
            8,
            12,
            3,
            0,
            1,
            1,
            0,
            2,
            12,
            0,
            -4,
            1,
            1,
            0,
            8,
            12,
            0,
            0,
            1,
            1,
            1,
            8,
            12,
            -3,
            0,
            1,
            1,
            0,
            2,
            12,
            4,
            0,
            1,
            1,
            0,
            2,
            12,
            -1,
            0,
            1,
            1,
            0,
            2,
            12,
            -1,
            0,
            1,
            1,
            0,
            2
        ],
        [
            12,
            0,
            1,
            1,
            1,
            1,
            8,
            12,
            -3,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            6,
            1,
            1,
            1,
            4,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            -2,
            0,
            1,
            1,
            1,
            1,
            12,
            -2,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            0,
            -1,
            1,
            1,
            0,
            4,
            12,
            0,
            -3,
            1,
            1,
            0,
            8,
            12,
            -2,
            0,
            1,
            1,
            0,
            1,
            12,
            -1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            5,
            1,
            1,
            0,
            4,
            12,
            0,
            1,
            1,
            1,
            0,
            8,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            -1,
            0,
            1,
            1,
            0,
            2,
            12,
            -1,
            0,
            1,
            1,
            0,
            2
        ],
        [
            12,
            0,
            -3,
            1,
            1,
            1,
            8,
            12,
            -3,
            0,
            1,
            1,
            1,
            1,
            12,
            -2,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            -1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            1,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            -1,
            0,
            1,
            1,
            1,
            2,
            12,
            0,
            -1,
            1,
            1,
            1,
            4,
            12,
            0,
            3,
            1,
            1,
            1,
            8,
            12,
            0,
            -1,
            1,
            1,
            1,
            8,
            12,
            4,
            0,
            1,
            1,
            1,
            2,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            2,
            0,
            1,
            1,
            1,
            1,
            12,
            4,
            0,
            1,
            1,
            1,
            1,
            12,
            4,
            0,
            1,
            1,
            1,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            8,
            12,
            0,
            -2,
            1,
            1,
            0,
            8,
            12,
            -1,
            0,
            1,
            1,
            0,
            1,
            12,
            -1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            1,
            0,
            1,
            1,
            0,
            1,
            12,
            0,
            0,
            1,
            1,
            0,
            4,
            12,
            0,
            -1,
            1,
            1,
            0,
            4,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            3,
            0,
            1,
            1,
            0,
            1,
            12,
            3,
            0,
            1,
            1,
            0,
            1,
            12,
            2,
            0,
            1,
            1,
            0,
            1,
            12,
            4,
            0,
            1,
            1,
            0,
            2,
            12,
            3,
            0,
            1,
            1,
            0,
            2,
            12,
            -4,
            0,
            1,
            1,
            0,
            2,
            12,
            -2,
            0,
            1,
            1,
            0,
            2
        ],
        []
    ],
    "QuantizedAdd": [
        [
            1,
            -17,
            20,
            1,
            -17,
            21,
            1,
            -17,
            22
        ],
        [
            3,
            2,
            -1,
            4,
            -4
        ],
        [
            3,
            2,
            -5,
            4,
            -8
        ],
        [
            3,
            5,
            -5,
            7,
            -5,
            3,
            1,
            -5,
            -2,
            -5,
            3,
            -1,
            -6,
            -1,
            -7,
            3,
            -1,
            -4,
            -1,
            -3,
            3,
            6,
            -6,
            6,
            -7,
            3,
            3,
            0,
            3,
            7,
            3,
            4,
            3,
            4,
            3,
            3,
            3,
            -9,
            3,
            -14,
            7,
            -1,
            -7,
            7,
            -1,
            -6,
            7,
            0,
            -4,
            7,
            -1,
            -4,
            7,
            -1,
            -3,
            7,
            3,
            -14,
            7,
            3,
            -13,
            7,
            3,
            -12,
            7,
            3,
            -11,
            7,
            3,
            -10,
            7,
            3,
            -9,
            7,
            6,
            -7,
            7,
            6,
            -6,
            7,
            3,
            0,
            7,
            3,
            1,
            7,
            3,
            2,
            7,
            4,
            3,
            7,
            3,
            3,
            7,
            3,
            5,
            7,
            3,
            4,
            7,
            3,
            6,
            7,
            3,
            7
        ],
        [
            3,
            4,
            4,
            4,
            4,
            3,
            0,
            -7,
            0,
            -6,
            3,
            0,
            -4,
            0,
            -3,
            3,
            3,
            -16,
            3,
            -16,
            3,
            3,
            -15,
            3,
            -9,
            3,
            3,
            0,
            3,
            5,
            3,
            3,
            6,
            3,
            9,
            3,
            6,
            -5,
            6,
            -7
        ],
        [
            3,
            1,
            -7,
            1,
            -3
        ],
        [
            3,
            -2,
            -6,
            -2,
            -4,
            3,
            -1,
            -8,
            0,
            -8,
            3,
            1,
            -4,
            -1,
            -1,
            3,
            3,
            11,
            3,
            11,
            3,
            7,
            -6,
            4,
            -4,
            3,
            6,
            -7,
            5,
            -8,
            3,
            0,
            -7,
            -1,
            -6
        ],
        [
            3,
            7,
            -8,
            7,
            -8,
            3,
            7,
            -3,
            4,
            -3,
            3,
            8,
            -5,
            12,
            -5,
            3,
            -3,
            -5,
            -5,
            -5,
            3,
            -7,
            -5,
            -7,
            -5,
            3,
            -4,
            -4,
            -4,
            -4,
            3,
            -2,
            -3,
            -2,
            -3,
            3,
            6,
            -9,
            6,
            -12,
            1,
            3,
            10,
            1,
            3,
            12
        ],
        [
            3,
            0,
            -9,
            -1,
            -9,
            3,
            -1,
            -12,
            -1,
            -12,
            3,
            -2,
            -8,
            -3,
            -8,
            3,
            3,
            8,
            3,
            10,
            1,
            4,
            5,
            1,
            5,
            3,
            1,
            4,
            11,
            1,
            3,
            13,
            1,
            -4,
            -3,
            1,
            -6,
            -5,
            1,
            -1,
            0,
            1,
            0,
            0,
            3,
            5,
            -9,
            5,
            -9,
            3,
            7,
            -8,
            9,
            -8
        ],
        [
            3,
            -1,
            1,
            0,
            5,
            3,
            5,
            -2,
            4,
            -1,
            3,
            4,
            0,
            4,
            3,
            7,
            1,
            -1,
            7,
            1,
            -2,
            3,
            5,
            1,
            6,
            5,
            3,
            7,
            2,
            7,
            2,
            3,
            4,
            10,
            4,
            12,
            3,
            5,
            11,
            5,
            11,
            3,
            3,
            15,
            3,
            15,
            3,
            3,
            14,
            3,
            14,
            3,
            4,
            6,
            4,
            7,
            3,
            10,
            -4,
            12,
            -3,
            3,
            4,
            -9,
            4,
            -9,
            3,
            5,
            -9,
            5,
            -11,
            3,
            6,
            -13,
            6,
            -14,
            3,
            1,
            -6,
            1,
            -7,
            3,
            -1,
            -10,
            -1,
            -13,
            3,
            0,
            -10,
            0,
            -13,
            3,
            3,
            -17,
            3,
            -17,
            3,
            3,
            -17,
            3,
            -17,
            3,
            3,
            -17,
            3,
            -17,
            1,
            3,
            -17,
            1,
            3,
            -15,
            3,
            -1,
            -16,
            -1,
            -16,
            3,
            2,
            -8,
            2,
            -16,
            3,
            -3,
            -8,
            -3,
            -8,
            7,
            -3,
            -8,
            3,
            -2,
            -7,
            -2,
            -9,
            7,
            12,
            -4,
            7,
            12,
            -3,
            3,
            13,
            -5,
            13,
            -7,
            3,
            12,
            -6,
            9,
            -6
        ],
        [
            3,
            -1,
            6,
            0,
            8,
            7,
            13,
            -7,
            3,
            14,
            -6,
            12,
            -3,
            3,
            15,
            -5,
            17,
            -5,
            1,
            4,
            15,
            1,
            7,
            3,
            1,
            8,
            2,
            1,
            8,
            3,
            1,
            -4,
            -2,
            1,
            -4,
            -1,
            3,
            -3,
            -7,
            -6,
            -3,
            3,
            -8,
            -5,
            -9,
            -5,
            3,
            -9,
            -5,
            -8,
            -3,
            3,
            -1,
            -12,
            -6,
            -11,
            3,
            -2,
            -10,
            -3,
            -9,
            7,
            -2,
            -8,
            3,
            -1,
            -13,
            0,
            -16,
            3,
            5,
            -11,
            6,
            -17,
            7,
            9,
            -8,
            7,
            8,
            -8,
            3,
            7,
            -9,
            10,
            -11,
            3,
            11,
            -10,
            12,
            -12,
            1,
            7,
            -7,
            1,
            8,
            -6,
            7,
            7,
            -8,
            3,
            9,
            -11,
            9,
            -17
        ],
        [
            3,
            -5,
            -2,
            -4,
            2,
            3,
            -4,
            3,
            -4,
            6,
            3,
            -8,
            -2,
            -8,
            1,
            3,
            -10,
            -5,
            -12,
            -5,
            3,
            -11,
            -4,
            -11,
            -4,
            3,
            -13,
            -5,
            -13,
            -5,
            3,
            -12,
            -4,
            -12,
            -4,
            7,
            -3,
            -9,
            7,
            -2,
            -9,
            1,
            -3,
            -8,
            1,
            -2,
            -8,
            1,
            -2,
            -9,
            3,
            -4,
            -10,
            -6,
            -10,
            3,
            -2,
            -13,
            -4,
            -13,
            3,
            -7,
            -12,
            -8,
            -12,
            3,
            1,
            -7,
            1,
            -11,
            3,
            4,
            -10,
            4,
            -17,
            3,
            11,
            -12,
            12,
            -16,
            3,
            13,
            -10,
            15,
            -12,
            3,
            16,
            -11,
            16,
            -11,
            3,
            14,
            -12,
            14,
            -13,
            3,
            7,
            2,
            8,
            5,
            3,
            9,
            2,
            11,
            2,
            3,
            3,
            -1,
            2,
            7,
            3,
            4,
            12,
            6,
            10,
            3,
            7,
            10,
            7,
            10,
            3,
            4,
            9,
            5,
            9,
            3,
            5,
            15,
            4,
            14,
            3,
            4,
            13,
            4,
            13,
            3,
            -1,
            9,
            0,
            11,
            3,
            0,
            12,
            0,
            14,
            3,
            18,
            -5,
            20,
            -5
        ],
        [
            3,
            8,
            -11,
            10,
            -17,
            3,
            14,
            -13,
            15,
            -14,
            3,
            16,
            -12,
            16,
            -11,
            7,
            15,
            -10,
            7,
            14,
            -10,
            7,
            13,
            -10,
            7,
            12,
            -10,
            1,
            16,
            -13,
            1,
            13,
            -13,
            1,
            17,
            -12,
            1,
            17,
            -11,
            1,
            11,
            -9,
            3,
            7,
            -9,
            8,
            -6,
            3,
            8,
            -7,
            14,
            -7,
            3,
            14,
            -6,
            20,
            -6,
            3,
            14,
            -4,
            20,
            -4,
            3,
            20,
            -5,
            23,
            -5,
            3,
            5,
            -4,
            9,
            -1,
            3,
            10,
            -2,
            10,
            -1,
            3,
            2,
            -2,
            0,
            -1,
            3,
            -1,
            -2,
            -3,
            -1,
            3,
            9,
            3,
            13,
            4,
            3,
            9,
            5,
            12,
            6,
            3,
            4,
            7,
            8,
            6,
            3,
            5,
            0,
            6,
            0,
            3,
            6,
            1,
            8,
            1,
            3,
            2,
            8,
            2,
            10,
            3,
            4,
            8,
            5,
            9,
            3,
            5,
            9,
            6,
            13,
            3,
            7,
            10,
            8,
            12,
            3,
            9,
            11,
            9,
            11,
            3,
            6,
            15,
            7,
            15,
            3,
            0,
            15,
            0,
            15,
            3,
            -1,
            11,
            -1,
            13,
            3,
            -3,
            0,
            -5,
            4,
            3,
            -4,
            7,
            -4,
            9,
            3,
            -4,
            14,
            -4,
            15,
            3,
            -6,
            -3,
            -6,
            3,
            3,
            -11,
            -3,
            -12,
            -2,
            3,
            -9,
            -5,
            -7,
            -6,
            3,
            -3,
            -8,
            -3,
            -9,
            3,
            -3,
            -8,
            -6,
            -8,
            3,
            -6,
            -4,
            -7,
            1,
            3,
            -6,
            3,
            -6,
            4,
            3,
            -8,
            -6,
            -7,
            -7,
            7,
            -6,
            -10,
            7,
            -5,
            -10,
            7,
            -4,
            -10,
            3,
            -4,
            -9,
            -6,
            -9,
            7,
            -5,
            -11,
            7,
            -4,
            -11,
            7,
            -6,
            -11,
            3,
            -5,
            -13,
            -17,
            -12,
            7,
            -6,
            -9,
            7,
            -5,
            -9,
            7,
            -4,
            -9,
            7,
            -6,
            -8,
            7,
            -5,
            -8,
            7,
            -4,
            -8,
            3,
            -3,
            -10,
            -5,
            -11,
            3,
            -6,
            -11,
            -9,
            -11,
            3,
            1,
            -11,
            1,
            -14,
            3,
            -1,
            -14,
            -5,
            -14
        ],
        [
            3,
            -8,
            -3,
            -15,
            -7,
            3,
            -16,
            -4,
            -17,
            -7,
            3,
            -18,
            -7,
            -18,
            -7,
            3,
            -7,
            2,
            -8,
            4,
            3,
            -5,
            5,
            -3,
            8,
            3,
            -4,
            10,
            -4,
            13,
            3,
            -4,
            -8,
            -4,
            -8,
            3,
            -6,
            -11,
            -12,
            -14,
            7,
            -17,
            -13,
            7,
            -17,
            -12,
            7,
            -16,
            -13,
            7,
            -16,
            -12,
            7,
            -15,
            -13,
            7,
            -15,
            -12,
            7,
            -14,
            -13,
            7,
            -14,
            -12,
            7,
            -13,
            -13,
            7,
            -13,
            -12,
            3,
            -5,
            -10,
            -9,
            -10,
            3,
            -6,
            -14,
            -2,
            -17,
            3,
            1,
            -14,
            1,
            -17,
            3,
            -12,
            -1,
            -11,
            1,
            3,
            6,
            13,
            8,
            13,
            3,
            9,
            12,
            13,
            11,
            3,
            10,
            11,
            9,
            10,
            3,
            5,
            7,
            6,
            8,
            7,
            8,
            7,
            3,
            13,
            6,
            18,
            3,
            3,
            7,
            0,
            8,
            0,
            3,
            9,
            1,
            11,
            1,
            3,
            11,
            -2,
            14,
            -2,
            3,
            15,
            -6,
            23,
            -7,
            3,
            23,
            -5,
            27,
            -5,
            3,
            8,
            15,
            10,
            15,
            3,
            7,
            -11,
            7,
            -16,
            3,
            17,
            -11,
            19,
            -14,
            3,
            17,
            -14,
            17,
            -16,
            3,
            14,
            -14,
            15,
            -16,
            3,
            13,
            -14,
            13,
            -14,
            3,
            16,
            -13,
            16,
            -14
        ],
        [
            3,
            8,
            7,
            11,
            8,
            3,
            7,
            8,
            10,
            10,
            3,
            6,
            14,
            14,
            15,
            3,
            9,
            13,
            10,
            13,
            3,
            15,
            -2,
            22,
            -4,
            3,
            23,
            -4,
            28,
            -5,
            3,
            23,
            -5,
            28,
            -7,
            3,
            28,
            -6,
            31,
            -6,
            3,
            9,
            -10,
            14,
            0,
            3,
            15,
            -7,
            22,
            -8,
            3,
            15,
            -10,
            22,
            -11,
            3,
            23,
            -8,
            24,
            -8,
            3,
            13,
            -14,
            21,
            -16,
            3,
            11,
            9,
            15,
            12,
            3,
            12,
            3,
            18,
            2,
            7,
            12,
            0,
            7,
            13,
            0,
            7,
            14,
            0,
            3,
            15,
            -1,
            20,
            -1,
            3,
            12,
            7,
            16,
            7,
            7,
            18,
            2,
            7,
            17,
            2,
            3,
            18,
            4,
            21,
            5,
            3,
            2,
            -1,
            -3,
            6,
            3,
            -5,
            9,
            -3,
            13,
            3,
            -8,
            -3,
            -11,
            1,
            3,
            -11,
            2,
            -12,
            8,
            3,
            -6,
            5,
            -7,
            10,
            3,
            -17,
            -3,
            -15,
            -1,
            3,
            -16,
            0,
            -16,
            5,
            3,
            -18,
            -2,
            -21,
            -7,
            3,
            -22,
            -6,
            -25,
            -6,
            3,
            -25,
            -6,
            -26,
            -6,
            3,
            -25,
            -5,
            -25,
            -3,
            3,
            -25,
            -3,
            -25,
            -2,
            3,
            -5,
            -8,
            -9,
            -8,
            3,
            -4,
            -9,
            -6,
            -9,
            3,
            -13,
            -12,
            -17,
            -15,
            3,
            -18,
            -14,
            -21,
            -13,
            3,
            -13,
            -14,
            -6,
            -16
        ],
        [
            3,
            -18,
            -2,
            -15,
            4,
            3,
            -17,
            5,
            -16,
            8,
            3,
            -14,
            -2,
            -14,
            2,
            3,
            -12,
            9,
            -11,
            14,
            3,
            -12,
            15,
            -12,
            15,
            3,
            15,
            -9,
            19,
            -9,
            3,
            20,
            -12,
            23,
            -13,
            3,
            22,
            -14,
            25,
            -16,
            3,
            24,
            -8,
            33,
            -4,
            3,
            23,
            -2,
            29,
            -3,
            3,
            12,
            1,
            15,
            0,
            3,
            16,
            2,
            19,
            7,
            3,
            20,
            3,
            23,
            6,
            3,
            24,
            4,
            25,
            5,
            3,
            16,
            10,
            21,
            12,
            3,
            22,
            11,
            23,
            12,
            3,
            11,
            13,
            17,
            15,
            3,
            18,
            15,
            22,
            15,
            3,
            2,
            11,
            2,
            15,
            3,
            1,
            7,
            1,
            11,
            3,
            -2,
            7,
            -2,
            11,
            3,
            -1,
            13,
            -1,
            15,
            3,
            -3,
            13,
            -3,
            15,
            3,
            -5,
            13,
            -5,
            15,
            3,
            -6,
            10,
            -6,
            14,
            3,
            -10,
            2,
            -8,
            4,
            3,
            -8,
            4,
            -8,
            7,
            3,
            -7,
            11,
            -7,
            11,
            3,
            -17,
            9,
            -17,
            15,
            3,
            -7,
            -10,
            -10,
            -8,
            3,
            -10,
            -12,
            -14,
            -10,
            3,
            -10,
            -8,
            -13,
            -8,
            3,
            -21,
            -14,
            -25,
            -13,
            3,
            -17,
            -15,
            -20,
            -12,
            3,
            -19,
            -15,
            -13,
            -17,
            7,
            -14,
            -10,
            3,
            -20,
            -2,
            -21,
            2,
            3,
            -22,
            -5,
            -24,
            -2,
            3,
            -21,
            -7,
            -24,
            -6,
            3,
            -26,
            -6,
            -27,
            -4,
            3,
            -24,
            -7,
            -25,
            -7,
            3,
            -25,
            -1,
            -25,
            5,
            3,
            -24,
            -1,
            -22,
            -1,
            3,
            -20,
            -1,
            -19,
            -1,
            3,
            -14,
            -3,
            -13,
            -2,
            7,
            15,
            0,
            7,
            14,
            0,
            7,
            13,
            0,
            7,
            12,
            0
        ],
        [
            3,
            -16,
            8,
            -16,
            15,
            3,
            -21,
            3,
            -20,
            7,
            3,
            -24,
            0,
            -24,
            5,
            3,
            -25,
            6,
            -25,
            11,
            3,
            20,
            -9,
            25,
            -11,
            3,
            24,
            -12,
            28,
            -14,
            3,
            26,
            -14,
            30,
            -16,
            3,
            26,
            -3,
            32,
            -1,
            3,
            12,
            0,
            18,
            1,
            3,
            19,
            2,
            23,
            7,
            3,
            24,
            3,
            27,
            6,
            3,
            28,
            4,
            29,
            5,
            3,
            18,
            15,
            22,
            13,
            3,
            22,
            12,
            27,
            10,
            3,
            28,
            11,
            29,
            12,
            3,
            23,
            15,
            26,
            15,
            3,
            -3,
            11,
            2,
            15,
            3,
            -10,
            5,
            -8,
            7,
            3,
            -9,
            8,
            -7,
            11,
            3,
            -7,
            12,
            -7,
            14,
            3,
            -6,
            14,
            -6,
            15,
            3,
            -11,
            14,
            -11,
            15,
            3,
            -15,
            5,
            -15,
            9,
            3,
            -14,
            3,
            -14,
            7,
            3,
            -18,
            5,
            -18,
            9,
            3,
            -19,
            0,
            -19,
            3,
            3,
            -20,
            -12,
            -24,
            -15,
            3,
            -25,
            -14,
            -28,
            -13,
            3,
            -20,
            -16,
            -23,
            -16,
            3,
            -11,
            -8,
            -14,
            -11,
            3,
            -27,
            -6,
            -31,
            -4,
            3,
            -26,
            -7,
            -29,
            -7,
            3,
            -29,
            -3,
            -29,
            1,
            3,
            -23,
            -7,
            -15,
            -8,
            3,
            -15,
            -11,
            -23,
            -11,
            3,
            -15,
            -10,
            -18,
            -8
        ],
        [
            3,
            -32,
            -6,
            -35,
            -4,
            3,
            -25,
            -3,
            -27,
            1,
            3,
            -30,
            -3,
            -31,
            1,
            3,
            -29,
            2,
            -29,
            5,
            3,
            -30,
            -7,
            -31,
            -7,
            3,
            -24,
            -8,
            -28,
            -8,
            3,
            -18,
            -10,
            -22,
            -9,
            3,
            -24,
            -11,
            -25,
            -11,
            3,
            -25,
            -12,
            -28,
            -12,
            3,
            -29,
            -13,
            -31,
            -14,
            3,
            -25,
            -15,
            -28,
            -15,
            3,
            -24,
            -16,
            -27,
            -16,
            3,
            -25,
            11,
            -25,
            15,
            3,
            -24,
            6,
            -24,
            11,
            3,
            -21,
            8,
            -20,
            11,
            3,
            -19,
            4,
            -19,
            6,
            3,
            -18,
            9,
            -18,
            11,
            3,
            -23,
            0,
            -23,
            6,
            3,
            -15,
            10,
            -15,
            15,
            3,
            -14,
            8,
            -14,
            11,
            3,
            -10,
            8,
            -10,
            11,
            3,
            -9,
            12,
            -8,
            14,
            3,
            -7,
            15,
            -7,
            15,
            3,
            -8,
            15,
            -8,
            15,
            3,
            -13,
            -1,
            -13,
            -1,
            3,
            31,
            -14,
            32,
            -16,
            3,
            29,
            -12,
            30,
            -13,
            3,
            26,
            -11,
            28,
            -10,
            3,
            19,
            0,
            20,
            1,
            3,
            21,
            -1,
            23,
            -1,
            7,
            29,
            -1,
            7,
            30,
            -1,
            1,
            24,
            -1,
            1,
            25,
            -1,
            7,
            28,
            -1,
            7,
            27,
            -1,
            3,
            23,
            2,
            26,
            2,
            3,
            27,
            3,
            29,
            6,
            3,
            30,
            4,
            31,
            5,
            3,
            16,
            9,
            20,
            9,
            3,
            12,
            8,
            15,
            8,
            3,
            30,
            11,
            33,
            12,
            3,
            28,
            10,
            31,
            10,
            3,
            23,
            13,
            26,
            14,
            3,
            27,
            15,
            30,
            15,
            3,
            32,
            -1,
            33,
            -3
        ],
        [
            3,
            31,
            -12,
            33,
            -16,
            3,
            29,
            -11,
            31,
            -10,
            3,
            26,
            -9,
            29,
            -9,
            3,
            27,
            -1,
            31,
            -1,
            3,
            21,
            0,
            27,
            0,
            3,
            27,
            3,
            29,
            3,
            3,
            21,
            1,
            22,
            1,
            3,
            30,
            3,
            31,
            6,
            3,
            32,
            4,
            33,
            5,
            3,
            24,
            7,
            26,
            7,
            3,
            21,
            9,
            22,
            9,
            3,
            16,
            8,
            19,
            8,
            3,
            32,
            10,
            33,
            10,
            3,
            27,
            14,
            30,
            13,
            3,
            31,
            15,
            33,
            14,
            3,
            -10,
            11,
            -9,
            15,
            3,
            -13,
            0,
            -13,
            3,
            3,
            -14,
            11,
            -14,
            15,
            3,
            -19,
            7,
            -19,
            10,
            3,
            -18,
            12,
            -18,
            14,
            3,
            -20,
            12,
            -20,
            14,
            3,
            -21,
            11,
            -21,
            14,
            3,
            -24,
            11,
            -24,
            14,
            3,
            -22,
            0,
            -22,
            3,
            3,
            -23,
            6,
            -23,
            10,
            3,
            -30,
            2,
            -30,
            5,
            3,
            -29,
            6,
            -29,
            9,
            3,
            -28,
            -3,
            -28,
            0,
            3,
            -27,
            2,
            -26,
            5,
            3,
            -32,
            -3,
            -34,
            -2,
            3,
            -31,
            -14,
            -34,
            -13,
            3,
            -28,
            -15,
            -32,
            -15,
            3,
            -28,
            -16,
            -30,
            -17,
            3,
            -28,
            -12,
            -32,
            -12,
            3,
            -25,
            -11,
            -30,
            -11,
            3,
            -23,
            -10,
            -25,
            -9,
            3,
            -28,
            -8,
            -29,
            -8,
            3,
            -31,
            -7,
            -32,
            -7,
            3,
            -31,
            1,
            -31,
            2
        ],
        [
            3,
            -32,
            -15,
            -35,
            -15,
            3,
            -31,
            -16,
            -32,
            -16,
            3,
            -33,
            -12,
            -35,
            -12,
            3,
            -30,
            -11,
            -32,
            -11,
            3,
            -26,
            -10,
            -29,
            -9,
            3,
            -30,
            -8,
            -32,
            -8,
            3,
            -33,
            -7,
            -35,
            -7,
            3,
            -31,
            -1,
            -34,
            1,
            3,
            -28,
            1,
            -28,
            3,
            3,
            -27,
            5,
            -26,
            10,
            3,
            -31,
            2,
            -31,
            5,
            3,
            -30,
            5,
            -30,
            9,
            3,
            -29,
            9,
            -29,
            13,
            3,
            -31,
            9,
            -33,
            9,
            3,
            -26,
            10,
            -26,
            14,
            3,
            -23,
            10,
            -24,
            15,
            3,
            -22,
            4,
            -22,
            7,
            3,
            -19,
            10,
            -19,
            14,
            3,
            -18,
            14,
            -18,
            15,
            3,
            -20,
            15,
            -21,
            15,
            3,
            -13,
            4,
            -13,
            7,
            3,
            30,
            13,
            33,
            12,
            3,
            22,
            9,
            26,
            9,
            3,
            19,
            9,
            23,
            8,
            3,
            27,
            7,
            29,
            7,
            3,
            31,
            6,
            33,
            5,
            3,
            31,
            4,
            33,
            3,
            3,
            26,
            3,
            29,
            2,
            3,
            22,
            1,
            25,
            1,
            3,
            27,
            0,
            31,
            -1,
            3,
            29,
            -9,
            32,
            -11
        ],
        [
            3,
            32,
            -11,
            33,
            -8,
            3,
            26,
            1,
            29,
            1,
            3,
            31,
            0,
            33,
            0,
            3,
            30,
            2,
            32,
            2,
            3,
            30,
            7,
            33,
            7,
            3,
            26,
            9,
            30,
            9,
            3,
            24,
            8,
            27,
            8,
            3,
            -13,
            7,
            -13,
            11,
            3,
            -18,
            14,
            -19,
            15,
            3,
            -22,
            7,
            -22,
            11,
            3,
            -26,
            14,
            -26,
            15,
            3,
            -27,
            11,
            -27,
            13,
            3,
            -28,
            3,
            -28,
            7,
            3,
            -29,
            13,
            -29,
            15,
            3,
            -30,
            10,
            -34,
            9,
            3,
            -31,
            1,
            -35,
            3,
            3,
            -31,
            5,
            -31,
            8,
            3,
            -32,
            3,
            -32,
            4,
            3,
            -32,
            5,
            -32,
            5,
            3,
            -30,
            10,
            -30,
            15,
            3,
            -32,
            -8,
            -35,
            -8,
            3,
            -32,
            -11,
            -35,
            -11,
            3,
            -30,
            -11,
            -32,
            -8,
            3,
            -32,
            -15,
            -36,
            -17
        ],
        [
            3,
            -31,
            -11,
            -38,
            -6,
            3,
            -32,
            3,
            -36,
            6,
            3,
            -31,
            6,
            -32,
            9,
            3,
            -29,
            7,
            -27,
            11,
            3,
            -27,
            13,
            -27,
            15,
            3,
            -23,
            11,
            -22,
            14,
            3,
            -14,
            11,
            -12,
            14,
            3,
            -30,
            10,
            -32,
            14,
            3,
            -32,
            13,
            -34,
            13,
            3,
            30,
            0,
            33,
            2,
            3,
            30,
            9,
            33,
            9,
            3,
            27,
            7,
            30,
            8
        ],
        [
            3,
            -32,
            6,
            -35,
            9,
            3,
            -32,
            10,
            -35,
            12,
            3,
            -32,
            14,
            -35,
            14,
            3,
            -30,
            14,
            -32,
            15,
            3,
            -29,
            11,
            -28,
            14,
            3,
            -23,
            14,
            -21,
            16,
            3,
            -13,
            14,
            -12,
            16,
            3,
            30,
            9,
            33,
            7
        ],
        [
            3,
            -32,
            14,
            -38,
            17,
            3,
            -26,
            14,
            -30,
            16
        ]
    ],
    "QuantizedClimb": [
        [],
        [
            3,
            0,
            11,
            0,
            11
        ],
        [
            3,
            0,
            10,
            0,
            8,
            3,
            -4,
            11,
            -3,
            10
        ],
        [
            7,
            -4,
            10,
            7,
            -4,
            11,
            3,
            -2,
            10,
            -1,
            11,
            3,
            3,
            10,
            3,
            11,
            4,
            -1,
            10,
            4
        ],
        [
            3,
            -1,
            9,
            -2,
            8,
            3,
            0,
            7,
            0,
            7,
            3,
            3,
            11,
            2,
            11,
            3,
            3,
            10,
            3,
            9,
            4,
            -1,
            9,
            4,
            4,
            -1,
            8,
            4,
            4,
            -2,
            9,
            2,
            4,
            -1,
            9,
            2
        ],
        [
            3,
            5,
            11,
            5,
            8,
            3,
            3,
            8,
            3,
            7,
            3,
            2,
            11,
            2,
            9,
            3,
            1,
            10,
            1,
            11,
            3,
            0,
            7,
            0,
            5,
            4,
            3,
            8,
            2
        ],
        [
            7,
            0,
            5,
            3,
            -1,
            6,
            -1,
            7,
            3,
            -3,
            10,
            -3,
            9,
            3,
            -4,
            10,
            -4,
            11,
            3,
            1,
            9,
            1,
            8,
            3,
            3,
            7,
            3,
            6,
            3,
            4,
            10,
            4,
            11,
            3,
            6,
            10,
            6,
            11,
            4,
            -3,
            9,
            2,
            4,
            -1,
            7,
            4,
            4,
            -1,
            6,
            4,
            4,
            -1,
            7,
            2,
            4,
            1,
            9,
            2,
            4,
            1,
            9,
            4,
            4,
            0,
            9,
            4,
            4,
            0,
            8,
            4,
            4,
            -3,
            9,
            4,
            4,
            3,
            7,
            1,
            5,
            -1,
            10,
            4
        ],
        [
            3,
            5,
            8,
            5,
            4,
            3,
            6,
            10,
            6,
            7,
            3,
            7,
            9,
            7,
            11,
            3,
            3,
            5,
            3,
            5,
            3,
            4,
            10,
            4,
            8,
            3,
            4,
            8,
            4,
            7,
            3,
            -4,
            10,
            -8,
            11,
            3,
            -4,
            9,
            -4,
            9,
            3,
            -2,
            7,
            -2,
            7,
            4,
            3,
            7,
            4,
            4,
            3,
            8,
            4,
            4,
            3,
            9,
            4,
            4,
            4,
            9,
            2,
            4,
            4,
            9,
            4,
            4,
            4,
            8,
            4,
            4,
            4,
            7,
            4,
            4,
            5,
            7,
            4,
            4,
            5,
            7,
            2,
            4,
            -2,
            7,
            2,
            4,
            -4,
            9,
            2,
            4,
            7,
            9,
            2,
            4,
            6,
            8,
            8,
            4,
            6,
            9,
            8,
            4,
            6,
            9,
            2
        ],
        [
            3,
            8,
            10,
            10,
            11,
            3,
            6,
            7,
            6,
            4,
            3,
            -1,
            5,
            -1,
            3,
            3,
            2,
            9,
            2,
            6,
            3,
            2,
            6,
            2,
            5,
            3,
            -2,
            8,
            -4,
            8,
            3,
            -4,
            9,
            -6,
            9,
            4,
            2,
            8,
            2,
            5,
            1,
            9,
            2,
            4,
            7,
            10,
            4,
            4,
            -6,
            9,
            2,
            4,
            -5,
            9,
            2,
            4,
            -4,
            9,
            8,
            4,
            -2,
            8,
            8,
            5,
            0,
            8,
            8,
            5,
            0,
            9,
            8,
            5,
            -1,
            8,
            4,
            5,
            -1,
            9,
            4,
            5,
            -2,
            9,
            2,
            5,
            -1,
            9,
            2,
            5,
            0,
            8,
            4,
            5,
            0,
            9,
            4,
            5,
            1,
            9,
            4,
            4,
            1,
            8,
            4,
            5,
            4,
            9,
            8,
            5,
            5,
            9,
            8,
            5,
            5,
            8,
            8,
            5,
            5,
            9,
            2,
            5,
            4,
            9,
            2,
            5,
            3,
            9,
            4,
            5,
            4,
            9,
            4,
            5,
            4,
            8,
            4,
            5,
            3,
            6,
            2,
            5,
            3,
            7,
            1,
            4,
            5,
            6,
            4,
            4,
            5,
            5,
            4,
            4,
            5,
            4,
            4,
            4,
            5,
            6,
            2,
            4,
            6,
            6,
            2,
            5,
            5,
            7,
            2,
            5,
            4,
            7,
            4,
            5,
            5,
            6,
            4,
            5,
            5,
            5,
            4,
            5,
            5,
            4,
            4
        ],
        [
            3,
            6,
            4,
            6,
            1,
            3,
            5,
            4,
            5,
            2,
            3,
            9,
            10,
            9,
            8,
            3,
            10,
            10,
            10,
            8,
            3,
            10,
            11,
            13,
            11,
            3,
            -9,
            11,
            -13,
            11,
            3,
            -9,
            10,
            -9,
            7,
            3,
            -6,
            9,
            -9,
            9,
            3,
            -6,
            9,
            -6,
            7,
            3,
            -5,
            9,
            -5,
            7,
            3,
            -4,
            8,
            -4,
            5,
            3,
            -3,
            7,
            -3,
            5,
            5,
            8,
            10,
            4,
            5,
            7,
            10,
            4,
            5,
            -6,
            9,
            2,
            5,
            -5,
            9,
            2,
            5,
            -4,
            9,
            2,
            5,
            -3,
            9,
            2,
            5,
            -5,
            9,
            4,
            5,
            -3,
            9,
            4,
            5,
            -3,
            8,
            4,
            5,
            -4,
            9,
            8,
            5,
            -2,
            8,
            8,
            4,
            -6,
            8,
            2,
            4,
            -5,
            8,
            2,
            4,
            -5,
            8,
            4,
            4,
            -5,
            7,
            4,
            4,
            -7,
            9,
            4,
            4,
            -7,
            9,
            2,
            4,
            -8,
            9,
            2,
            4,
            -9,
            9,
            2,
            4,
            -3,
            7,
            4,
            4,
            -3,
            7,
            2,
            4,
            -4,
            7,
            2,
            5,
            6,
            9,
            2,
            5,
            7,
            9,
            2,
            5,
            5,
            9,
            4,
            5,
            5,
            8,
            4,
            5,
            6,
            8,
            8,
            5,
            6,
            9,
            8,
            5,
            5,
            6,
            2,
            5,
            6,
            6,
            2,
            5,
            6,
            7,
            8,
            5,
            5,
            7,
            4,
            4,
            5,
            3,
            2,
            4,
            6,
            4,
            1,
            5,
            5,
            5,
            4,
            5,
            5,
            6,
            4,
            4,
            9,
            9,
            2,
            4,
            10,
            9,
            2
        ],
        [
            3,
            -2,
            7,
            -2,
            5,
            3,
            1,
            7,
            1,
            6,
            7,
            -1,
            3,
            7,
            -1,
            4,
            3,
            -5,
            6,
            -7,
            6,
            3,
            -7,
            7,
            -7,
            8,
            3,
            -11,
            11,
            -11,
            8,
            3,
            -12,
            10,
            -12,
            8,
            3,
            -13,
            11,
            -14,
            11,
            3,
            4,
            7,
            4,
            5,
            3,
            7,
            9,
            7,
            7,
            3,
            8,
            10,
            8,
            7,
            3,
            10,
            10,
            13,
            10,
            3,
            13,
            11,
            15,
            11,
            4,
            4,
            6,
            2,
            4,
            1,
            7,
            2,
            4,
            -7,
            8,
            2,
            4,
            4,
            6,
            4,
            4,
            4,
            5,
            4,
            4,
            1,
            7,
            4,
            4,
            1,
            6,
            4,
            4,
            0,
            7,
            4,
            4,
            0,
            6,
            4,
            4,
            -3,
            6,
            4,
            4,
            -3,
            5,
            4,
            4,
            -5,
            6,
            4,
            4,
            -7,
            8,
            4,
            4,
            -7,
            7,
            4,
            5,
            -9,
            9,
            2,
            5,
            -8,
            9,
            2,
            5,
            -7,
            9,
            2,
            5,
            -7,
            9,
            4,
            4,
            -6,
            6,
            2,
            4,
            -5,
            6,
            2,
            5,
            -2,
            7,
            2,
            5,
            -1,
            7,
            2,
            5,
            -1,
            7,
            4,
            5,
            -1,
            6,
            4,
            4,
            -2,
            5,
            4,
            4,
            -2,
            6,
            4,
            4,
            -2,
            6,
            2,
            5,
            2,
            8,
            2,
            5,
            3,
            8,
            2,
            5,
            1,
            8,
            4,
            5,
            3,
            8,
            4,
            5,
            3,
            7,
            4,
            4,
            3,
            6,
            4,
            4,
            3,
            5,
            4,
            4,
            8,
            8,
            4,
            4,
            8,
            9,
            4,
            4,
            6,
            7,
            4,
            4,
            6,
            8,
            4
        ],
        [
            3,
            5,
            3,
            2,
            3,
            3,
            5,
            4,
            2,
            4,
            7,
            6,
            1,
            3,
            -10,
            10,
            -10,
            7,
            3,
            -8,
            9,
            -8,
            7,
            3,
            -9,
            7,
            -9,
            5,
            3,
            -14,
            11,
            -18,
            11,
            3,
            -12,
            10,
            -16,
            10,
            3,
            -14,
            9,
            -13,
            9,
            3,
            -12,
            8,
            -12,
            5,
            3,
            -6,
            5,
            -6,
            4,
            3,
            -5,
            6,
            -5,
            4,
            3,
            -2,
            4,
            -2,
            2,
            3,
            7,
            7,
            7,
            4,
            3,
            16,
            11,
            18,
            11,
            3,
            14,
            10,
            16,
            10,
            3,
            11,
            8,
            13,
            9,
            3,
            9,
            8,
            10,
            7,
            3,
            8,
            6,
            8,
            6,
            3,
            0,
            6,
            0,
            -1,
            3,
            2,
            2,
            2,
            0,
            3,
            -1,
            5,
            -1,
            2,
            4,
            6,
            4,
            4,
            4,
            6,
            5,
            4,
            4,
            6,
            7,
            4,
            5,
            7,
            7,
            8,
            5,
            6,
            7,
            4,
            4,
            7,
            5,
            2,
            5,
            9,
            9,
            2,
            5,
            10,
            9,
            2,
            5,
            8,
            9,
            4,
            4,
            8,
            7,
            4,
            4,
            9,
            8,
            2,
            4,
            10,
            8,
            2,
            4,
            10,
            8,
            4,
            5,
            -6,
            8,
            2,
            5,
            4,
            6,
            2,
            5,
            3,
            6,
            4,
            5,
            3,
            5,
            4,
            5,
            4,
            5,
            4,
            5,
            4,
            6,
            4,
            4,
            2,
            5,
            2,
            4,
            3,
            5,
            2,
            4,
            4,
            5,
            2,
            5,
            1,
            7,
            2,
            5,
            0,
            6,
            4,
            5,
            0,
            7,
            4,
            5,
            1,
            6,
            4,
            5,
            1,
            7,
            4,
            5,
            2,
            5,
            2,
            5,
            3,
            5,
            2,
            5,
            4,
            5,
            2,
            4,
            2,
            4,
            2,
            4,
            3,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            3,
            4,
            4,
            -7,
            6,
            2,
            5,
            -7,
            8,
            2,
            5,
            -7,
            7,
            4,
            5,
            -7,
            8,
            4,
            4,
            -5,
            5,
            4,
            4,
            -13,
            9,
            4,
            4,
            -13,
            10,
            4,
            4,
            -11,
            8,
            4,
            4,
            -11,
            9,
            4,
            4,
            -11,
            10,
            4,
            4,
            -9,
            7,
            4,
            4,
            -9,
            8,
            4,
            4,
            -9,
            6,
            2,
            4,
            -8,
            8,
            2,
            5,
            -4,
            7,
            2,
            5,
            -3,
            7,
            2,
            5,
            -5,
            7,
            4,
            5,
            -3,
            7,
            4,
            5,
            -2,
            6,
            4,
            5,
            -2,
            5,
            4,
            5,
            -3,
            5,
            4,
            5,
            -3,
            6,
            4,
            5,
            -1,
            6,
            2,
            5,
            -2,
            6,
            2,
            4,
            -2,
            4,
            2,
            4,
            -1,
            4,
            2,
            4,
            -1,
            4,
            4,
            4,
            -1,
            3,
            4,
            4,
            -1,
            2,
            4
        ],
        [
            3,
            3,
            3,
            3,
            -1,
            3,
            2,
            2,
            2,
            -1,
            7,
            5,
            2,
            7,
            6,
            2,
            3,
            4,
            2,
            4,
            2,
            3,
            7,
            3,
            7,
            3,
            3,
            9,
            6,
            10,
            5,
            3,
            0,
            6,
            1,
            3,
            3,
            -2,
            2,
            -2,
            0,
            3,
            13,
            8,
            13,
            5,
            3,
            14,
            10,
            14,
            8,
            3,
            18,
            11,
            20,
            11,
            3,
            -7,
            6,
            -7,
            2,
            3,
            -8,
            7,
            -8,
            5,
            3,
            -11,
            8,
            -11,
            5,
            3,
            -18,
            11,
            -21,
            11,
            3,
            -16,
            10,
            -19,
            10,
            3,
            -16,
            10,
            -16,
            7,
            3,
            -15,
            9,
            -15,
            9,
            3,
            -13,
            8,
            -13,
            8,
            3,
            17,
            11,
            17,
            9,
            7,
            0,
            -1,
            7,
            0,
            0,
            7,
            0,
            1,
            4,
            -9,
            7,
            4,
            4,
            -9,
            8,
            4,
            5,
            -9,
            7,
            4,
            5,
            -9,
            8,
            4,
            5,
            -11,
            8,
            4,
            5,
            -11,
            9,
            4,
            5,
            -13,
            9,
            4,
            5,
            -13,
            10,
            4,
            4,
            -13,
            8,
            2,
            4,
            -11,
            7,
            2,
            5,
            -8,
            8,
            2,
            4,
            -7,
            5,
            2,
            4,
            -7,
            4,
            4,
            5,
            -5,
            5,
            4,
            5,
            -5,
            6,
            4,
            5,
            -5,
            6,
            2,
            5,
            -6,
            6,
            2,
            5,
            -7,
            6,
            2,
            4,
            -8,
            6,
            2,
            4,
            -8,
            6,
            4,
            4,
            -7,
            5,
            4,
            4,
            -8,
            5,
            4,
            4,
            -2,
            2,
            4,
            4,
            -2,
            2,
            2,
            5,
            -2,
            4,
            2,
            5,
            -1,
            4,
            2,
            5,
            -1,
            4,
            4,
            5,
            -1,
            3,
            4,
            5,
            -1,
            2,
            4,
            4,
            1,
            4,
            4,
            4,
            1,
            3,
            4,
            4,
            0,
            3,
            4,
            4,
            0,
            4,
            4,
            4,
            0,
            5,
            4,
            4,
            8,
            6,
            4,
            5,
            9,
            8,
            2,
            5,
            10,
            8,
            2,
            5,
            10,
            8,
            4,
            5,
            7,
            8,
            4,
            5,
            8,
            8,
            4,
            5,
            8,
            7,
            4,
            4,
            9,
            6,
            2,
            4,
            10,
            6,
            2,
            4,
            13,
            7,
            2,
            4,
            14,
            9,
            2,
            4,
            13,
            8,
            4,
            4,
            13,
            9,
            4,
            4,
            16,
            10,
            4,
            4,
            1,
            5,
            4,
            4,
            1,
            5,
            2,
            4,
            4,
            2,
            2,
            4,
            3,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            2,
            1,
            4,
            4,
            2,
            0,
            4,
            4,
            2,
            -1,
            4,
            4,
            6,
            3,
            4,
            5,
            5,
            3,
            2,
            5,
            6,
            3,
            2,
            5,
            6,
            4,
            1,
            4,
            -11,
            7,
            4,
            4,
            -13,
            8,
            4,
            4,
            -12,
            7,
            2,
            4,
            -15,
            9,
            2,
            4,
            -16,
            9,
            2,
            4,
            -15,
            9,
            4
        ],
        [
            3,
            21,
            11,
            24,
            11,
            3,
            25,
            11,
            25,
            11,
            3,
            -22,
            11,
            -26,
            11,
            3,
            -16,
            6,
            -16,
            4,
            3,
            -12,
            5,
            -12,
            3,
            3,
            -13,
            7,
            -13,
            5,
            3,
            -10,
            7,
            -10,
            5,
            3,
            -19,
            10,
            -21,
            10,
            3,
            -16,
            9,
            -18,
            9,
            3,
            -9,
            5,
            -9,
            3,
            3,
            -8,
            5,
            -8,
            3,
            3,
            -7,
            2,
            -7,
            1,
            3,
            -6,
            4,
            -5,
            3,
            7,
            -2,
            0,
            7,
            -2,
            1,
            7,
            -2,
            2,
            3,
            -3,
            5,
            -3,
            3,
            7,
            -1,
            5,
            7,
            -1,
            6,
            7,
            13,
            5,
            7,
            13,
            6,
            3,
            8,
            5,
            8,
            3,
            3,
            4,
            2,
            6,
            2,
            3,
            3,
            -1,
            4,
            -1,
            3,
            3,
            0,
            4,
            0,
            3,
            10,
            7,
            12,
            7,
            3,
            14,
            8,
            14,
            7,
            3,
            14,
            9,
            16,
            9,
            3,
            -2,
            4,
            0,
            6,
            3,
            1,
            2,
            1,
            -4,
            3,
            -2,
            3,
            -2,
            -1,
            3,
            -3,
            3,
            -3,
            1,
            5,
            -16,
            9,
            2,
            5,
            -15,
            9,
            2,
            5,
            -13,
            8,
            2,
            5,
            -12,
            7,
            2,
            5,
            -11,
            7,
            2,
            5,
            -9,
            6,
            2,
            5,
            -8,
            6,
            2,
            5,
            -7,
            5,
            2,
            5,
            3,
            4,
            2,
            5,
            4,
            4,
            2,
            5,
            7,
            5,
            2,
            5,
            9,
            6,
            2,
            5,
            10,
            6,
            2,
            5,
            14,
            9,
            2,
            5,
            -15,
            9,
            4,
            5,
            -13,
            8,
            4,
            5,
            -11,
            7,
            4,
            5,
            -8,
            6,
            4,
            5,
            -8,
            5,
            4,
            5,
            -7,
            4,
            4,
            5,
            -7,
            5,
            4,
            5,
            0,
            3,
            4,
            5,
            0,
            4,
            4,
            5,
            0,
            5,
            4,
            5,
            1,
            4,
            4,
            5,
            1,
            3,
            4,
            5,
            4,
            3,
            4,
            5,
            4,
            4,
            4,
            5,
            6,
            5,
            4,
            5,
            6,
            4,
            4,
            5,
            6,
            3,
            4,
            5,
            8,
            6,
            4,
            5,
            13,
            8,
            4,
            5,
            13,
            9,
            4,
            5,
            -2,
            2,
            2,
            5,
            13,
            7,
            2,
            4,
            -17,
            9,
            4,
            4,
            -13,
            7,
            4,
            4,
            -13,
            6,
            4,
            4,
            -13,
            5,
            4,
            4,
            -10,
            6,
            4,
            4,
            -10,
            5,
            4,
            4,
            -8,
            4,
            4,
            4,
            -8,
            3,
            4,
            4,
            -7,
            3,
            4,
            4,
            -2,
            3,
            4,
            4,
            -2,
            4,
            4,
            4,
            1,
            -1,
            4,
            4,
            1,
            0,
            4,
            4,
            1,
            1,
            4,
            4,
            1,
            2,
            4,
            4,
            7,
            5,
            4,
            4,
            7,
            4,
            4,
            4,
            7,
            3,
            4,
            4,
            8,
            5,
            4,
            4,
            14,
            9,
            4,
            4,
            16,
            9,
            4,
            4,
            16,
            10,
            4,
            4,
            14,
            8,
            2,
            4,
            13,
            8,
            2,
            4,
            12,
            8,
            2,
            4,
            11,
            8,
            2,
            4,
            10,
            7,
            4,
            5,
            9,
            8,
            4,
            5,
            10,
            8,
            4,
            4,
            10,
            8,
            4,
            4,
            14,
            7,
            2,
            4,
            5,
            2,
            2,
            4,
            6,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            3,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            0,
            2,
            4,
            4,
            1,
            2,
            2,
            4,
            -3,
            4,
            2,
            5,
            -2,
            3,
            2,
            5,
            -2,
            4,
            2,
            4,
            -2,
            4,
            2,
            4,
            -9,
            4,
            2,
            4,
            -8,
            4,
            2,
            4,
            -10,
            6,
            2,
            4,
            -11,
            6,
            2,
            4,
            -12,
            6,
            2,
            4,
            -13,
            7,
            2,
            4,
            -17,
            9,
            2,
            4,
            -18,
            9,
            2
        ],
        [
            3,
            0,
            3,
            0,
            0,
            3,
            1,
            3,
            1,
            1,
            3,
            2,
            -1,
            2,
            -2,
            3,
            3,
            -1,
            3,
            -2,
            3,
            4,
            0,
            4,
            1,
            7,
            6,
            2,
            7,
            5,
            2,
            3,
            7,
            3,
            8,
            1,
            3,
            10,
            5,
            10,
            3,
            3,
            10,
            6,
            12,
            6,
            3,
            14,
            8,
            16,
            8,
            3,
            22,
            11,
            22,
            8,
            3,
            23,
            11,
            23,
            8,
            3,
            17,
            9,
            19,
            9,
            3,
            18,
            10,
            19,
            10,
            3,
            14,
            6,
            14,
            6,
            3,
            -2,
            3,
            -2,
            0,
            3,
            -4,
            4,
            -4,
            3,
            3,
            -5,
            3,
            -7,
            2,
            3,
            -7,
            1,
            -9,
            1,
            3,
            -7,
            2,
            -8,
            2,
            3,
            -11,
            5,
            -11,
            3,
            3,
            -12,
            2,
            -12,
            2,
            3,
            -13,
            8,
            -16,
            6,
            3,
            -16,
            8,
            -18,
            8,
            3,
            -18,
            9,
            -21,
            9,
            3,
            -21,
            10,
            -26,
            10,
            3,
            -16,
            4,
            -16,
            3,
            7,
            -7,
            1,
            7,
            1,
            -4,
            7,
            1,
            -3,
            3,
            -1,
            2,
            -1,
            -2,
            3,
            -3,
            1,
            -3,
            -1,
            5,
            -18,
            9,
            2,
            5,
            -17,
            9,
            2,
            5,
            -13,
            7,
            2,
            5,
            -12,
            6,
            2,
            5,
            -11,
            6,
            2,
            5,
            -10,
            6,
            2,
            5,
            -3,
            4,
            2,
            5,
            1,
            2,
            2,
            5,
            3,
            2,
            2,
            5,
            4,
            2,
            2,
            5,
            13,
            8,
            2,
            5,
            14,
            8,
            2,
            5,
            14,
            7,
            2,
            5,
            -8,
            4,
            2,
            5,
            -9,
            4,
            2,
            5,
            -17,
            9,
            4,
            5,
            -10,
            6,
            4,
            5,
            -10,
            5,
            4,
            5,
            -8,
            4,
            4,
            5,
            -2,
            4,
            4,
            5,
            -2,
            3,
            4,
            5,
            -2,
            2,
            4,
            5,
            0,
            2,
            4,
            5,
            1,
            2,
            4,
            5,
            1,
            1,
            4,
            5,
            1,
            0,
            4,
            5,
            1,
            -1,
            4,
            5,
            2,
            -1,
            4,
            5,
            2,
            0,
            4,
            5,
            2,
            1,
            4,
            5,
            2,
            2,
            4,
            5,
            7,
            3,
            4,
            5,
            7,
            4,
            4,
            5,
            7,
            5,
            4,
            5,
            8,
            5,
            4,
            5,
            11,
            7,
            4,
            5,
            10,
            7,
            4,
            5,
            14,
            9,
            4,
            5,
            16,
            10,
            4,
            5,
            16,
            9,
            4,
            5,
            -2,
            4,
            2,
            5,
            10,
            8,
            2,
            5,
            10,
            8,
            4,
            5,
            12,
            8,
            2,
            5,
            11,
            8,
            2,
            4,
            -18,
            8,
            2,
            4,
            -17,
            8,
            2,
            4,
            -15,
            8,
            2,
            4,
            -14,
            8,
            2,
            4,
            -11,
            4,
            2,
            4,
            -8,
            2,
            2,
            4,
            -6,
            2,
            2,
            4,
            -5,
            2,
            2,
            4,
            -3,
            0,
            2,
            4,
            -2,
            0,
            2,
            4,
            -1,
            0,
            2,
            4,
            0,
            0,
            2,
            4,
            1,
            0,
            2,
            4,
            4,
            1,
            2,
            4,
            7,
            2,
            2,
            4,
            8,
            2,
            2,
            4,
            10,
            4,
            2,
            4,
            11,
            6,
            2,
            4,
            12,
            6,
            2,
            4,
            14,
            6,
            2,
            4,
            15,
            8,
            2,
            4,
            16,
            8,
            2,
            4,
            -16,
            8,
            4,
            4,
            -16,
            7,
            4,
            4,
            -16,
            6,
            4,
            4,
            -17,
            8,
            4,
            4,
            -14,
            8,
            4,
            4,
            -14,
            7,
            4,
            4,
            -14,
            6,
            4,
            4,
            -13,
            5,
            4,
            4,
            -13,
            6,
            8,
            5,
            -12,
            6,
            8,
            5,
            -12,
            7,
            8,
            5,
            -13,
            7,
            4,
            4,
            -13,
            6,
            4,
            5,
            -13,
            6,
            4,
            4,
            -13,
            5,
            2,
            4,
            -16,
            5,
            2,
            4,
            -12,
            4,
            4,
            4,
            -12,
            3,
            4,
            4,
            -8,
            3,
            4,
            4,
            -7,
            3,
            4,
            4,
            -7,
            3,
            2
        ],
        [
            3,
            -1,
            7,
            -1,
            3,
            3,
            -2,
            0,
            -2,
            -2,
            3,
            1,
            1,
            1,
            -2,
            7,
            2,
            -2,
            7,
            3,
            -2,
            3,
            5,
            3,
            6,
            1,
            3,
            0,
            -1,
            0,
            -1,
            3,
            -3,
            3,
            -3,
            0,
            3,
            -5,
            2,
            -6,
            0,
            3,
            -9,
            3,
            -8,
            0,
            3,
            -11,
            3,
            -11,
            1,
            3,
            -12,
            2,
            -13,
            4,
            3,
            -16,
            6,
            -15,
            3,
            3,
            -17,
            8,
            -18,
            5,
            3,
            -20,
            8,
            -20,
            6,
            3,
            -21,
            9,
            -21,
            6,
            3,
            -21,
            9,
            -23,
            8,
            3,
            -25,
            10,
            -25,
            7,
            3,
            -7,
            1,
            -7,
            1,
            3,
            -7,
            0,
            -7,
            0,
            3,
            -8,
            -1,
            -6,
            -1,
            3,
            0,
            -1,
            0,
            -6,
            3,
            1,
            -2,
            1,
            -3,
            3,
            -1,
            -2,
            -1,
            -3
        ],
        [
            3,
            -14,
            5,
            -14,
            3,
            3,
            -18,
            4,
            -17,
            4,
            3,
            -13,
            2,
            -13,
            1,
            3,
            -11,
            0,
            -11,
            0,
            3,
            -10,
            5,
            -10,
            4,
            3,
            -16,
            2,
            -16,
            2,
            3,
            -24,
            10,
            -24,
            6,
            3,
            -23,
            8,
            -23,
            6,
            3,
            -21,
            6,
            -21,
            5,
            3,
            -20,
            8,
            -18,
            8,
            3,
            -7,
            -1,
            -7,
            -3,
            3,
            -4,
            3,
            -4,
            1,
            3,
            -3,
            0,
            -3,
            -2,
            3,
            9,
            5,
            9,
            3,
            3,
            10,
            3,
            10,
            1,
            3,
            7,
            1,
            7,
            -2,
            3,
            23,
            11,
            25,
            9,
            3,
            23,
            8,
            23,
            6,
            3,
            21,
            11,
            21,
            8,
            3,
            19,
            9,
            19,
            7,
            3,
            13,
            7,
            13,
            4,
            3,
            12,
            5,
            12,
            4,
            3,
            6,
            0,
            6,
            -2,
            3,
            -25,
            6,
            -25,
            3,
            7,
            0,
            -6,
            7,
            0,
            -5,
            3,
            2,
            -2,
            2,
            -2,
            3,
            3,
            -2,
            3,
            -2
        ],
        [
            3,
            20,
            11,
            20,
            8,
            7,
            19,
            7,
            7,
            23,
            6,
            3,
            24,
            9,
            25,
            7,
            3,
            21,
            8,
            21,
            6,
            3,
            22,
            7,
            22,
            7,
            3,
            18,
            9,
            18,
            6,
            3,
            17,
            9,
            17,
            7,
            3,
            15,
            8,
            15,
            6,
            3,
            13,
            4,
            13,
            2,
            3,
            7,
            -2,
            7,
            -4,
            3,
            1,
            -2,
            1,
            -5,
            3,
            -7,
            -4,
            -7,
            -6,
            3,
            -3,
            0,
            -5,
            -1,
            3,
            -8,
            -1,
            -9,
            -1,
            3,
            -10,
            4,
            -10,
            3,
            3,
            -18,
            8,
            -19,
            6,
            3,
            -21,
            5,
            -21,
            3,
            3,
            -20,
            5,
            -20,
            5,
            3,
            -16,
            3,
            -18,
            3,
            3,
            -18,
            3,
            -18,
            2,
            3,
            -16,
            2,
            -16,
            1,
            3,
            -24,
            6,
            -24,
            4,
            3,
            -25,
            3,
            -25,
            2,
            3,
            2,
            -2,
            2,
            -2,
            3,
            -1,
            2,
            -1,
            1,
            3,
            -3,
            -2,
            -3,
            -3,
            3,
            5,
            1,
            5,
            -1,
            3,
            3,
            -1,
            3,
            -3,
            3,
            4,
            -1,
            4,
            -3,
            3,
            0,
            -1,
            0,
            -2,
            3,
            8,
            1,
            8,
            -1,
            3,
            10,
            1,
            10,
            -1,
            3,
            11,
            5,
            11,
            3,
            3,
            12,
            4,
            12,
            3,
            3,
            14,
            6,
            14,
            4,
            3,
            15,
            6,
            15,
            5,
            3,
            16,
            8,
            16,
            6,
            3,
            16,
            6,
            16,
            5,
            3,
            -15,
            2,
            -15,
            0,
            3,
            -13,
            1,
            -13,
            0,
            3,
            -14,
            3,
            -14,
            1,
            3,
            -16,
            1,
            -16,
            0,
            3,
            -21,
            3,
            -21,
            0,
            3,
            22,
            7,
            22,
            3,
            3,
            -1,
            -3,
            -1,
            -6,
            3,
            -2,
            -2,
            -2,
            -5,
            3,
            0,
            -4,
            0,
            -5,
            3,
            0,
            -6,
            0,
            -6,
            3,
            0,
            -7,
            0,
            -7
        ],
        [
            7,
            -7,
            -6,
            7,
            -7,
            -5,
            7,
            -7,
            -4,
            7,
            1,
            -5,
            7,
            1,
            -4,
            7,
            7,
            -4,
            3,
            -3,
            -3,
            -3,
            -5,
            3,
            2,
            -3,
            2,
            -3,
            3,
            3,
            -3,
            4,
            -4,
            3,
            -1,
            1,
            -1,
            -1,
            3,
            -6,
            -1,
            -6,
            -3,
            3,
            -7,
            -2,
            -9,
            -2,
            3,
            -4,
            -2,
            -4,
            -3,
            3,
            -2,
            -2,
            -2,
            -3,
            3,
            8,
            -1,
            8,
            -3,
            3,
            9,
            3,
            9,
            0,
            3,
            13,
            1,
            13,
            -1,
            3,
            13,
            -1,
            14,
            -1,
            3,
            16,
            5,
            16,
            2,
            3,
            17,
            6,
            17,
            4,
            3,
            18,
            6,
            18,
            4,
            3,
            20,
            7,
            20,
            4,
            3,
            21,
            6,
            21,
            4,
            3,
            24,
            7,
            24,
            4,
            3,
            25,
            7,
            25,
            4,
            3,
            21,
            4,
            21,
            3,
            3,
            -10,
            3,
            -10,
            0,
            3,
            -11,
            0,
            -11,
            -2,
            3,
            -12,
            1,
            -12,
            0,
            3,
            -13,
            0,
            -13,
            0,
            3,
            -20,
            5,
            -20,
            3,
            3,
            -21,
            3,
            -21,
            1,
            3,
            -22,
            8,
            -22,
            3,
            3,
            -24,
            3,
            -24,
            2,
            3,
            -25,
            1,
            -25,
            0,
            3,
            21,
            6,
            23,
            6,
            3,
            20,
            7,
            19,
            7,
            3,
            -17,
            3,
            -17,
            0,
            3,
            22,
            5,
            22,
            3,
            7,
            -2,
            -5,
            7,
            -2,
            -4
        ],
        [
            3,
            14,
            -1,
            14,
            4,
            3,
            15,
            5,
            15,
            3,
            7,
            16,
            2,
            3,
            19,
            6,
            19,
            3,
            3,
            21,
            6,
            23,
            4,
            3,
            24,
            4,
            24,
            1,
            3,
            25,
            4,
            25,
            1,
            7,
            21,
            3,
            3,
            12,
            1,
            12,
            2,
            3,
            10,
            -1,
            10,
            -3,
            3,
            9,
            0,
            9,
            -1,
            3,
            7,
            -3,
            7,
            -7,
            3,
            4,
            -4,
            4,
            -7,
            3,
            3,
            -4,
            3,
            -7,
            3,
            0,
            -2,
            0,
            -5,
            3,
            -2,
            -4,
            -2,
            -5,
            3,
            -3,
            -6,
            -3,
            -6,
            3,
            -4,
            -4,
            -4,
            -5,
            3,
            -5,
            -1,
            -5,
            -3,
            3,
            -19,
            6,
            -19,
            3,
            3,
            -25,
            -1,
            -25,
            -2,
            3,
            -23,
            5,
            -23,
            3,
            3,
            -24,
            2,
            -24,
            0,
            3,
            -18,
            2,
            -18,
            -1,
            7,
            -21,
            0,
            7,
            -21,
            1,
            3,
            -20,
            2,
            -19,
            2,
            3,
            -18,
            2,
            -16,
            2,
            3,
            -15,
            0,
            -15,
            -3,
            3,
            -14,
            1,
            -14,
            -2,
            3,
            -9,
            -2,
            -11,
            -1,
            3,
            -11,
            -3,
            -11,
            -5,
            3,
            -9,
            -2,
            -8,
            -3,
            3,
            -7,
            -3,
            -7,
            -5,
            3,
            -17,
            -1,
            -17,
            -1,
            3,
            24,
            1,
            22,
            1,
            3,
            24,
            3,
            23,
            3,
            3,
            23,
            3,
            23,
            2,
            7,
            22,
            1,
            3,
            -1,
            -7,
            -1,
            -7,
            3,
            -1,
            -8,
            -1,
            -8,
            3,
            -1,
            -9,
            -1,
            -9,
            3,
            0,
            -8,
            0,
            -9,
            3,
            -1,
            -6,
            -3,
            -6,
            3,
            -2,
            -7,
            -2,
            -8,
            3,
            1,
            -3,
            1,
            -6
        ],
        [
            3,
            -21,
            2,
            -21,
            0,
            3,
            -19,
            2,
            -19,
            -1,
            3,
            -17,
            0,
            -16,
            -1,
            3,
            -16,
            -1,
            -16,
            -3,
            3,
            -14,
            -2,
            -14,
            -5,
            3,
            -14,
            -2,
            -11,
            -1,
            3,
            -10,
            -2,
            -10,
            -5,
            3,
            -7,
            -6,
            -7,
            -7,
            3,
            -5,
            -3,
            -5,
            -5,
            3,
            -4,
            -5,
            -4,
            -8,
            7,
            -25,
            -2,
            3,
            -1,
            -1,
            -1,
            -4,
            3,
            1,
            -3,
            1,
            -5,
            3,
            6,
            -2,
            6,
            -5,
            7,
            3,
            -7,
            7,
            4,
            -7,
            3,
            5,
            -2,
            5,
            -3,
            3,
            9,
            -1,
            9,
            -3,
            3,
            8,
            -3,
            8,
            -5,
            3,
            12,
            1,
            12,
            -3,
            3,
            11,
            3,
            11,
            1,
            3,
            14,
            -1,
            14,
            -3,
            3,
            16,
            3,
            16,
            0,
            3,
            15,
            3,
            15,
            0,
            3,
            19,
            3,
            19,
            0,
            3,
            23,
            4,
            23,
            0,
            3,
            21,
            3,
            21,
            2,
            3,
            22,
            4,
            22,
            2,
            3,
            25,
            1,
            25,
            -3,
            7,
            0,
            -9,
            3,
            1,
            -4,
            2,
            -4
        ],
        [
            3,
            -25,
            -2,
            -25,
            -3,
            3,
            -23,
            3,
            -23,
            0,
            3,
            -20,
            2,
            -20,
            0,
            3,
            24,
            1,
            24,
            -3,
            3,
            22,
            2,
            22,
            -1,
            3,
            21,
            2,
            21,
            -1,
            3,
            21,
            2,
            20,
            3,
            3,
            14,
            -1,
            16,
            -2,
            3,
            19,
            0,
            19,
            -2,
            3,
            7,
            -7,
            7,
            -10,
            3,
            6,
            -5,
            6,
            -7,
            3,
            4,
            -6,
            4,
            -8,
            3,
            3,
            -5,
            1,
            -4,
            3,
            -11,
            -5,
            -11,
            -10,
            3,
            -7,
            -8,
            -7,
            -10,
            3,
            -1,
            -5,
            -2,
            -6,
            3,
            -3,
            -7,
            -3,
            -8,
            3,
            -13,
            -3,
            -12,
            -4,
            3,
            -13,
            -4,
            -13,
            -5,
            3,
            -17,
            -1,
            -19,
            -3,
            3,
            -21,
            0,
            -21,
            -1,
            3,
            10,
            -2,
            11,
            0,
            3,
            12,
            -3,
            12,
            -5,
            3,
            14,
            -3,
            14,
            -4,
            3,
            16,
            3,
            19,
            3,
            3,
            -3,
            -8,
            -3,
            -10,
            3,
            -3,
            -8,
            0,
            -10,
            3,
            -1,
            -11,
            -2,
            -11
        ],
        [
            3,
            16,
            0,
            18,
            3,
            7,
            19,
            -2,
            7,
            16,
            -2,
            7,
            15,
            -2,
            7,
            12,
            -5,
            3,
            13,
            -1,
            13,
            -4,
            3,
            11,
            -3,
            11,
            -3,
            3,
            5,
            -3,
            5,
            -6,
            7,
            4,
            -8,
            7,
            -7,
            -10,
            7,
            -7,
            -9,
            3,
            -6,
            -3,
            -6,
            -5,
            7,
            -11,
            -10,
            7,
            -11,
            -9,
            3,
            -10,
            -3,
            -8,
            -5,
            3,
            -3,
            -6,
            -2,
            -7,
            3,
            -5,
            -5,
            -5,
            -7,
            3,
            -1,
            -6,
            0,
            -6,
            3,
            3,
            -6,
            2,
            -6,
            3,
            6,
            -8,
            6,
            -10,
            3,
            8,
            -5,
            8,
            -6,
            3,
            9,
            -3,
            9,
            -4,
            3,
            19,
            2,
            20,
            0,
            3,
            23,
            0,
            23,
            -3,
            3,
            25,
            -3,
            25,
            -5,
            3,
            -13,
            -5,
            -13,
            -7,
            3,
            -14,
            -5,
            -14,
            -7,
            3,
            -15,
            -3,
            -18,
            -4,
            3,
            -22,
            3,
            -22,
            0,
            3,
            -24,
            0,
            -24,
            -3,
            3,
            -25,
            -3,
            -25,
            -6,
            7,
            7,
            -10,
            7,
            7,
            -9,
            7,
            7,
            -8,
            7,
            7,
            -7,
            3,
            22,
            -1,
            22,
            -5,
            3,
            21,
            -1,
            21,
            -3,
            3,
            1,
            -7,
            1,
            -8,
            3,
            -1,
            -11,
            -1,
            -13
        ],
        [
            7,
            -25,
            -6,
            7,
            -25,
            -5,
            3,
            -23,
            0,
            -23,
            -3,
            3,
            -19,
            -1,
            -20,
            -1,
            3,
            -19,
            -2,
            -21,
            -2,
            3,
            -18,
            -4,
            -19,
            -4,
            3,
            -14,
            -5,
            -17,
            -5,
            3,
            -14,
            -7,
            -14,
            -8,
            3,
            -12,
            -4,
            -12,
            -7,
            3,
            -11,
            -8,
            -11,
            -10,
            3,
            -7,
            -9,
            -7,
            -10,
            3,
            -10,
            -5,
            -10,
            -7,
            3,
            -6,
            -5,
            -6,
            -7,
            3,
            -5,
            -7,
            -5,
            -9,
            3,
            -4,
            -8,
            -3,
            -9,
            3,
            -2,
            -6,
            -1,
            -8,
            3,
            2,
            -6,
            0,
            -6,
            3,
            2,
            -6,
            2,
            -8,
            3,
            3,
            -6,
            3,
            -8,
            3,
            5,
            -6,
            5,
            -9,
            3,
            4,
            -8,
            4,
            -8,
            3,
            7,
            -6,
            7,
            -9,
            3,
            12,
            -4,
            9,
            -4,
            3,
            16,
            -1,
            16,
            -3,
            3,
            17,
            0,
            17,
            -3,
            3,
            22,
            -5,
            22,
            -8,
            3,
            22,
            -4,
            24,
            -4,
            3,
            20,
            0,
            20,
            -3,
            3,
            14,
            -4,
            14,
            -5,
            7,
            -1,
            -12
        ],
        [
            7,
            6,
            -10,
            7,
            -11,
            -10,
            7,
            -11,
            -9,
            7,
            22,
            -8,
            7,
            22,
            -7,
            3,
            -22,
            0,
            -22,
            -2,
            3,
            -12,
            -8,
            -14,
            -8,
            3,
            -9,
            -5,
            -8,
            -7,
            3,
            -6,
            -7,
            -6,
            -9,
            3,
            2,
            -7,
            -1,
            -7,
            3,
            -19,
            -3,
            -21,
            -3,
            3,
            -24,
            -3,
            -24,
            -4,
            3,
            -25,
            -4,
            -25,
            -6,
            3,
            -17,
            -5,
            -17,
            -7,
            3,
            -16,
            -5,
            -16,
            -6,
            3,
            -19,
            -4,
            -19,
            -6,
            3,
            -1,
            -8,
            -1,
            -9,
            3,
            2,
            -8,
            2,
            -9,
            3,
            -3,
            -9,
            -3,
            -10,
            3,
            -3,
            -10,
            -5,
            -10,
            3,
            5,
            -9,
            5,
            -10,
            3,
            5,
            -8,
            4,
            -9,
            3,
            8,
            -6,
            8,
            -9,
            3,
            9,
            -4,
            9,
            -7,
            3,
            10,
            -4,
            10,
            -7,
            3,
            12,
            -5,
            12,
            -6,
            3,
            13,
            -4,
            13,
            -6,
            3,
            14,
            -5,
            14,
            -7,
            3,
            17,
            -3,
            17,
            -6,
            3,
            18,
            -1,
            18,
            -3,
            3,
            20,
            -3,
            20,
            -4,
            3,
            21,
            -4,
            21,
            -5,
            3,
            23,
            -4,
            23,
            -6,
            3,
            25,
            -5,
            25,
            -8,
            3,
            24,
            -5,
            24,
            -5,
            3,
            -3,
            -10,
            -3,
            -13,
            3,
            -4,
            -10,
            -4,
            -13
        ],
        [
            3,
            -25,
            -6,
            -25,
            -10,
            3,
            -22,
            -3,
            -22,
            -3,
            3,
            -11,
            -8,
            -11,
            -10,
            3,
            22,
            -6,
            22,
            -8,
            3,
            20,
            -3,
            14,
            -2,
            3,
            17,
            -6,
            17,
            -8,
            3,
            25,
            -8,
            25,
            -11,
            3,
            6,
            -9,
            6,
            -10,
            3,
            6,
            -10,
            6,
            -11,
            3,
            5,
            -10,
            5,
            -11,
            3,
            1,
            -7,
            1,
            -10,
            3,
            2,
            -8,
            3,
            -9,
            3,
            2,
            -9,
            2,
            -10,
            3,
            -1,
            -9,
            -3,
            -9,
            3,
            -2,
            -9,
            -2,
            -10,
            3,
            -5,
            -10,
            -7,
            -11,
            3,
            -7,
            -10,
            -8,
            -10,
            3,
            -21,
            -3,
            -21,
            -6,
            3,
            -20,
            -3,
            -20,
            -6,
            3,
            -14,
            -6,
            -16,
            -6,
            3,
            -24,
            -4,
            -24,
            -5,
            3,
            8,
            -9,
            9,
            -9,
            3,
            13,
            -7,
            13,
            -7,
            3,
            -2,
            -11,
            -2,
            -12
        ],
        [
            3,
            25,
            -11,
            24,
            -11,
            3,
            -8,
            -7,
            -8,
            -9,
            3,
            0,
            -8,
            0,
            -9,
            3,
            9,
            -7,
            9,
            -9,
            3,
            8,
            -9,
            7,
            -10,
            3,
            5,
            -11,
            5,
            -12,
            7,
            -25,
            -10,
            7,
            -25,
            -9,
            7,
            -11,
            -10,
            7,
            17,
            -8,
            7,
            17,
            -7,
            3,
            11,
            -5,
            11,
            -5,
            3,
            11,
            -6,
            11,
            -6,
            3,
            12,
            -7,
            12,
            -7,
            3,
            13,
            -8,
            13,
            -8,
            3,
            14,
            -8,
            14,
            -8,
            3,
            15,
            -5,
            16,
            -4,
            3,
            20,
            -4,
            18,
            -5,
            3,
            22,
            -8,
            22,
            -9,
            3,
            23,
            -6,
            23,
            -8,
            3,
            24,
            -5,
            24,
            -7,
            3,
            21,
            -5,
            21,
            -7,
            3,
            21,
            -7,
            21,
            -8,
            3,
            -5,
            -11,
            -5,
            -13,
            3,
            -11,
            -9,
            -13,
            -9,
            3,
            -14,
            -7,
            -16,
            -7,
            3,
            -18,
            -4,
            -18,
            -5,
            3,
            -21,
            -4,
            -23,
            -4,
            3,
            -1,
            -10,
            -1,
            -10,
            3,
            -2,
            -10,
            -3,
            -11,
            3,
            1,
            -10,
            1,
            -11,
            3,
            2,
            -10,
            2,
            -11,
            3,
            4,
            -9,
            4,
            -12,
            3,
            18,
            -5,
            18,
            -8
        ],
        [
            3,
            -25,
            -8,
            -25,
            -11,
            3,
            -24,
            -5,
            -24,
            -7,
            3,
            -23,
            -4,
            -23,
            -7,
            3,
            -20,
            -6,
            -20,
            -8,
            3,
            -19,
            -6,
            -19,
            -8,
            3,
            -18,
            -5,
            -18,
            -7,
            3,
            -17,
            -7,
            -17,
            -8,
            3,
            -16,
            -7,
            -16,
            -8,
            3,
            -14,
            -8,
            -14,
            -11,
            3,
            -10,
            -8,
            -10,
            -10,
            3,
            -9,
            -7,
            -9,
            -9,
            3,
            -11,
            -9,
            -11,
            -10,
            3,
            -8,
            -10,
            -8,
            -12,
            3,
            -4,
            -10,
            -4,
            -12,
            3,
            0,
            -10,
            0,
            -11,
            3,
            2,
            -11,
            2,
            -12,
            3,
            3,
            -10,
            3,
            -10,
            3,
            8,
            -10,
            8,
            -12,
            3,
            11,
            -7,
            11,
            -10,
            3,
            13,
            -8,
            14,
            -10,
            3,
            14,
            -10,
            15,
            -10,
            3,
            17,
            -6,
            17,
            -9,
            3,
            17,
            -6,
            20,
            -6,
            3,
            20,
            -7,
            20,
            -8,
            3,
            24,
            -7,
            24,
            -10,
            3,
            25,
            -11,
            25,
            -12,
            7,
            22,
            -9,
            3,
            15,
            -5,
            15,
            -9,
            3,
            18,
            -6,
            18,
            -8,
            3,
            12,
            -7,
            12,
            -9,
            3,
            9,
            -10,
            9,
            -11,
            3,
            7,
            -10,
            7,
            -13,
            3,
            6,
            -11,
            6,
            -13,
            3,
            0,
            -11,
            0,
            -12,
            3,
            -3,
            -11,
            -3,
            -13,
            3,
            -2,
            -12,
            -2,
            -12,
            3,
            -5,
            -12,
            -8,
            -12,
            3,
            -13,
            -9,
            -13,
            -12
        ],
        [
            3,
            22,
            -8,
            22,
            -12,
            3,
            25,
            -12,
            24,
            -13,
            3,
            22,
            -9,
            24,
            -9,
            3,
            21,
            -8,
            21,
            -11,
            3,
            20,
            -8,
            20,
            -11,
            3,
            20,
            -7,
            17,
            -7,
            7,
            -25,
            -11,
            7,
            -25,
            -10,
            7,
            -13,
            -12,
            7,
            -13,
            -11,
            7,
            -2,
            -12,
            7,
            -2,
            -11,
            7,
            6,
            -12,
            3,
            -1,
            -11,
            -1,
            -11,
            3,
            18,
            -9,
            18,
            -10,
            3,
            17,
            -10,
            17,
            -10,
            3,
            16,
            -5,
            16,
            -8,
            3,
            15,
            -10,
            15,
            -11,
            3,
            13,
            -11,
            13,
            -12,
            3,
            10,
            -7,
            10,
            -9,
            3,
            11,
            -10,
            11,
            -11,
            3,
            9,
            -11,
            9,
            -12,
            3,
            1,
            -11,
            1,
            -12,
            3,
            -9,
            -9,
            -9,
            -13,
            3,
            -12,
            -10,
            -12,
            -10,
            3,
            -15,
            -8,
            -15,
            -10,
            3,
            -24,
            -7,
            -24,
            -9,
            3,
            -23,
            -7,
            -23,
            -9,
            3,
            -22,
            -4,
            -22,
            -6,
            3,
            -20,
            -8,
            -20,
            -10
        ],
        [
            3,
            -20,
            -10,
            -20,
            -13,
            3,
            -19,
            -8,
            -19,
            -11,
            3,
            -22,
            -6,
            -22,
            -9,
            3,
            -21,
            -6,
            -21,
            -9,
            3,
            -23,
            -9,
            -23,
            -11,
            3,
            -25,
            -9,
            -25,
            -11,
            3,
            -15,
            -9,
            -16,
            -9,
            3,
            -15,
            -10,
            -16,
            -10,
            3,
            -14,
            -11,
            -15,
            -11,
            3,
            -10,
            -10,
            -10,
            -12,
            3,
            -11,
            -10,
            -11,
            -11,
            3,
            -2,
            -10,
            -1,
            -12,
            3,
            3,
            -10,
            3,
            -12,
            3,
            6,
            -11,
            6,
            -13,
            3,
            23,
            -9,
            23,
            -12,
            3,
            20,
            -11,
            20,
            -12,
            3,
            19,
            -7,
            19,
            -9,
            3,
            16,
            -8,
            16,
            -10,
            3,
            15,
            -11,
            15,
            -12,
            3,
            14,
            -10,
            14,
            -11,
            3,
            12,
            -9,
            12,
            -10,
            3,
            10,
            -9,
            10,
            -10,
            3,
            11,
            -11,
            11,
            -12,
            3,
            17,
            -10,
            17,
            -12
        ],
        [
            3,
            19,
            -9,
            19,
            -12,
            3,
            21,
            -12,
            21,
            -12,
            3,
            16,
            -11,
            16,
            -13,
            3,
            14,
            -12,
            14,
            -12,
            3,
            10,
            -10,
            10,
            -12,
            3,
            12,
            -10,
            12,
            -11,
            3,
            -12,
            -10,
            -12,
            -12,
            3,
            -13,
            -10,
            -13,
            -12,
            3,
            -16,
            -10,
            -16,
            -13,
            3,
            -17,
            -8,
            -17,
            -10,
            3,
            -18,
            -7,
            -18,
            -9,
            3,
            -22,
            -10,
            -22,
            -11,
            3,
            -25,
            -11,
            -25,
            -12,
            3,
            -24,
            -9,
            -24,
            -10,
            3,
            -23,
            -11,
            -23,
            -12,
            3,
            -24,
            -10,
            -24,
            -12,
            3,
            -22,
            -11,
            -22,
            -12,
            3,
            -21,
            -10,
            -21,
            -11,
            3,
            -19,
            -12,
            -19,
            -13,
            3,
            -17,
            -10,
            -17,
            -12,
            3,
            -17,
            -11,
            -18,
            -10,
            3,
            -15,
            -11,
            -15,
            -12,
            7,
            17,
            -12,
            7,
            17,
            -11,
            3,
            18,
            -10,
            18,
            -12
        ],
        [
            3,
            -21,
            -11,
            -20,
            -12,
            3,
            -18,
            -11,
            -17,
            -12,
            3,
            -14,
            -12,
            -14,
            -12,
            3,
            -11,
            -11,
            -10,
            -12,
            3,
            16,
            -10,
            16,
            -10,
            3,
            18,
            -10,
            18,
            -12,
            3,
            12,
            -11,
            12,
            -12,
            3,
            17,
            -10,
            17,
            -12
        ]
    ],
    "QuantizedRetract": [
        [],
        [],
        [],
        [],
        [],
        [],
        [
            3,
            -26,
            -13,
            25,
            -13,
            3,
            -26,
            -8,
            -23,
            -8,
            3,
            -6,
            -9,
            -6,
            -13,
            3,
            -13,
            11,
            -13,
            9,
            3,
            25,
            6,
            21,
            6
        ],
        [
            3,
            -22,
            -8,
            -21,
            -8,
            3,
            -24,
            -7,
            -25,
            -7,
            3,
            -25,
            -9,
            -25,
            -9,
            3,
            -6,
            -8,
            -6,
            -6,
            3,
            -13,
            9,
            -13,
            7,
            3,
            -12,
            9,
            -12,
            11,
            3,
            21,
            6,
            20,
            6,
            3,
            25,
            5,
            23,
            5,
            3,
            25,
            7,
            24,
            7,
            3,
            11,
            -13,
            11,
            -11,
            3,
            25,
            -3,
            22,
            -3,
            3,
            -25,
            4,
            -23,
            4,
            3,
            -24,
            -9,
            -24,
            -9
        ],
        [
            3,
            -21,
            -8,
            -18,
            -8,
            3,
            -23,
            -7,
            -22,
            -7,
            3,
            -24,
            -9,
            -24,
            -9,
            3,
            -25,
            -9,
            -25,
            -12,
            3,
            -23,
            4,
            -21,
            4,
            3,
            -25,
            3,
            -23,
            3,
            3,
            -25,
            5,
            -24,
            5,
            3,
            -6,
            -5,
            -6,
            -6,
            3,
            -5,
            -12,
            -5,
            -10,
            3,
            -7,
            -12,
            -7,
            -11,
            3,
            10,
            -12,
            10,
            -8,
            3,
            11,
            -11,
            11,
            -10,
            3,
            22,
            -3,
            19,
            -3,
            3,
            25,
            -4,
            22,
            -4,
            3,
            20,
            6,
            16,
            6,
            3,
            23,
            5,
            20,
            5,
            3,
            25,
            4,
            23,
            4,
            3,
            24,
            7,
            21,
            7,
            3,
            -13,
            7,
            -13,
            4,
            3,
            -12,
            9,
            -12,
            8,
            3,
            -11,
            11,
            -11,
            11,
            3,
            -7,
            11,
            -7,
            9,
            3,
            16,
            -12,
            16,
            -12,
            3,
            21,
            -2,
            21,
            -2,
            3,
            -22,
            -12,
            -22,
            -12,
            3,
            -21,
            -12,
            -21,
            -12,
            3,
            -25,
            -3,
            -25,
            -3,
            3,
            -25,
            11,
            -25,
            11,
            7,
            -18,
            -8,
            7,
            -19,
            -8
        ],
        [
            3,
            -2,
            11,
            -2,
            9,
            3,
            -7,
            3,
            -7,
            2,
            3,
            -13,
            4,
            -13,
            4,
            3,
            -12,
            5,
            -10,
            5,
            3,
            -13,
            4,
            -13,
            3,
            3,
            -21,
            4,
            -19,
            4,
            3,
            -24,
            5,
            -22,
            5,
            3,
            -23,
            3,
            -21,
            3,
            3,
            -25,
            -7,
            -25,
            -3,
            3,
            -25,
            -3,
            -23,
            -3,
            3,
            -22,
            -7,
            -21,
            -7,
            3,
            -18,
            -8,
            -17,
            -8,
            3,
            -25,
            -12,
            -21,
            -12,
            3,
            -24,
            -11,
            -24,
            -9,
            3,
            -23,
            -9,
            -23,
            -9,
            3,
            -7,
            -12,
            -10,
            -11,
            3,
            -9,
            -11,
            -9,
            -8,
            3,
            -5,
            -10,
            -5,
            -9,
            3,
            -6,
            -5,
            -6,
            -4,
            3,
            -7,
            9,
            -7,
            7,
            3,
            -12,
            8,
            -11,
            11,
            3,
            -11,
            10,
            -10,
            11,
            3,
            -14,
            11,
            -14,
            8,
            3,
            16,
            6,
            12,
            6,
            3,
            20,
            5,
            17,
            5,
            3,
            22,
            7,
            19,
            7,
            3,
            25,
            7,
            23,
            8,
            3,
            23,
            11,
            20,
            10,
            3,
            19,
            -3,
            16,
            -3,
            3,
            22,
            -4,
            19,
            -4,
            3,
            20,
            -3,
            20,
            0,
            3,
            22,
            -4,
            24,
            -5,
            3,
            25,
            -5,
            25,
            -5,
            3,
            10,
            -8,
            10,
            -6,
            3,
            6,
            -13,
            6,
            -10,
            3,
            9,
            -12,
            9,
            -11,
            3,
            11,
            -10,
            11,
            -9,
            3,
            15,
            -13,
            15,
            -9,
            3,
            14,
            -12,
            14,
            -11,
            3,
            -2,
            -12,
            -2,
            -12,
            3,
            20,
            -12,
            20,
            -12,
            3,
            -15,
            -12,
            -15,
            -12,
            7,
            20,
            0,
            7,
            -15,
            -12,
            7,
            -10,
            5,
            7,
            -17,
            -8,
            7,
            23,
            10,
            7,
            22,
            10,
            7,
            21,
            10,
            7,
            23,
            11,
            3,
            19,
            -2,
            19,
            -2,
            3,
            22,
            -2,
            25,
            -2,
            3,
            20,
            -2,
            20,
            -1,
            7,
            -7,
            2,
            7,
            20,
            -1,
            3,
            -24,
            11,
            -24,
            11,
            3,
            -24,
            10,
            -24,
            10,
            7,
            -18,
            -8,
            7,
            -19,
            -8,
            3,
            -16,
            -12,
            -16,
            -12,
            3,
            -16,
            -11,
            -16,
            -11,
            7,
            20,
            10,
            7,
            -7,
            3,
            7,
            -6,
            -4
        ],
        [
            7,
            -10,
            5,
            3,
            -12,
            5,
            -12,
            7,
            3,
            -9,
            11,
            -8,
            10,
            3,
            -15,
            11,
            -17,
            9,
            3,
            -26,
            9,
            -24,
            9,
            3,
            -25,
            6,
            -23,
            6,
            3,
            -21,
            5,
            -20,
            5,
            3,
            -18,
            4,
            -17,
            4,
            3,
            -20,
            3,
            -18,
            3,
            3,
            -25,
            3,
            -24,
            0,
            3,
            -24,
            0,
            -23,
            0,
            3,
            -25,
            -2,
            -24,
            -2,
            3,
            -23,
            -3,
            -20,
            -3,
            3,
            -24,
            -3,
            -24,
            -7,
            3,
            -24,
            -6,
            -22,
            -6,
            3,
            -21,
            -7,
            -19,
            -7,
            3,
            -17,
            -8,
            -15,
            -8,
            3,
            -14,
            -13,
            -14,
            -10,
            3,
            -11,
            -12,
            -11,
            -10,
            3,
            -9,
            -9,
            -9,
            -5,
            3,
            -10,
            -11,
            -10,
            -10,
            3,
            -23,
            -11,
            -19,
            -11,
            3,
            -21,
            -12,
            -19,
            -12,
            3,
            -24,
            -10,
            -21,
            -10,
            3,
            -23,
            -9,
            -21,
            -9,
            3,
            -21,
            -9,
            -20,
            -9,
            3,
            -6,
            -11,
            -8,
            -10,
            3,
            -7,
            -10,
            -7,
            -8,
            3,
            -5,
            -9,
            -5,
            -6,
            3,
            -6,
            -4,
            -6,
            -2,
            3,
            -4,
            -12,
            -1,
            -11,
            3,
            -2,
            -11,
            -2,
            -10,
            3,
            2,
            -12,
            2,
            -12,
            3,
            6,
            -10,
            6,
            -8,
            3,
            5,
            -12,
            5,
            -11,
            3,
            7,
            -12,
            8,
            -12,
            3,
            9,
            -11,
            9,
            -9,
            3,
            11,
            -9,
            11,
            -7,
            3,
            10,
            -6,
            10,
            -4,
            3,
            -13,
            3,
            -13,
            3,
            3,
            -13,
            3,
            -12,
            3,
            3,
            -20,
            11,
            -21,
            10,
            3,
            -2,
            9,
            -2,
            7,
            3,
            -1,
            11,
            -1,
            9,
            3,
            12,
            6,
            10,
            6,
            3,
            17,
            5,
            14,
            5,
            3,
            19,
            7,
            16,
            7,
            3,
            23,
            8,
            20,
            8,
            3,
            24,
            11,
            25,
            9,
            3,
            23,
            4,
            19,
            4,
            3,
            23,
            4,
            24,
            2,
            3,
            24,
            4,
            25,
            2,
            3,
            23,
            -3,
            25,
            -2,
            3,
            20,
            0,
            18,
            0,
            3,
            20,
            -3,
            19,
            -2,
            3,
            21,
            -3,
            21,
            -2,
            3,
            22,
            -3,
            22,
            -2,
            3,
            20,
            -4,
            23,
            -6,
            3,
            24,
            -5,
            24,
            -7,
            3,
            24,
            -6,
            25,
            -7,
            3,
            14,
            -11,
            14,
            -9,
            3,
            15,
            -9,
            15,
            -7,
            3,
            14,
            -12,
            12,
            -12,
            3,
            20,
            -12,
            20,
            -9,
            3,
            21,
            -12,
            21,
            -11,
            3,
            -7,
            6,
            -7,
            6,
            3,
            -7,
            3,
            -7,
            4,
            3,
            -7,
            2,
            -9,
            2,
            7,
            -9,
            2,
            7,
            -8,
            2,
            7,
            -15,
            -8,
            7,
            -16,
            -8,
            7,
            -9,
            -5,
            3,
            -24,
            2,
            -22,
            2,
            3,
            -23,
            1,
            -23,
            1,
            7,
            -23,
            0,
            7,
            -24,
            0,
            7,
            -25,
            0,
            7,
            -11,
            5,
            3,
            -15,
            -12,
            -15,
            -12,
            3,
            20,
            11,
            17,
            11,
            7,
            -7,
            2,
            7,
            -6,
            -2,
            7,
            -6,
            -3,
            7,
            -5,
            -6,
            7,
            18,
            0,
            7,
            19,
            0,
            7,
            20,
            0,
            7,
            -19,
            -11,
            3,
            -25,
            10,
            -25,
            11,
            3,
            -23,
            11,
            -23,
            11,
            3,
            -17,
            -12,
            -17,
            -12,
            1,
            -17,
            -7,
            7,
            -20,
            -11,
            7,
            -21,
            -11,
            7,
            -21,
            -10,
            7,
            -17,
            -8,
            7,
            -17,
            -7,
            7,
            -19,
            -12,
            3,
            18,
            -12,
            18,
            -12,
            7,
            17,
            11,
            7,
            24,
            11,
            7,
            25,
            11,
            7,
            24,
            10,
            7,
            25,
            10,
            3,
            23,
            11,
            25,
            11,
            7,
            20,
            -9,
            7,
            -7,
            3,
            7,
            -7,
            4,
            7,
            -6,
            -4
        ],
        [
            3,
            -7,
            4,
            -7,
            6,
            3,
            -11,
            10,
            -9,
            8,
            3,
            -8,
            9,
            -8,
            6,
            3,
            -11,
            8,
            -11,
            5,
            3,
            -11,
            5,
            -10,
            5,
            3,
            -12,
            5,
            -12,
            3,
            3,
            -12,
            3,
            -12,
            2,
            3,
            -7,
            2,
            -5,
            2,
            3,
            -7,
            3,
            -8,
            3,
            3,
            -7,
            3,
            -6,
            3,
            3,
            -14,
            8,
            -14,
            5,
            3,
            -15,
            9,
            -15,
            6,
            3,
            -18,
            11,
            -19,
            10,
            3,
            -19,
            10,
            -19,
            8,
            3,
            -17,
            9,
            -17,
            7,
            3,
            -17,
            8,
            -15,
            8,
            3,
            -21,
            10,
            -26,
            11,
            3,
            -25,
            9,
            -24,
            7,
            3,
            -23,
            6,
            -21,
            6,
            3,
            -20,
            5,
            -18,
            5,
            3,
            -17,
            4,
            -16,
            4,
            3,
            -17,
            3,
            -17,
            3,
            3,
            -24,
            2,
            -21,
            2,
            3,
            -22,
            0,
            -21,
            0,
            3,
            -23,
            0,
            -23,
            1,
            3,
            -25,
            0,
            -24,
            -2,
            3,
            -24,
            -2,
            -22,
            -2,
            3,
            -24,
            -4,
            -22,
            -4,
            3,
            -21,
            -3,
            -19,
            -3,
            3,
            -19,
            -3,
            -18,
            -3,
            3,
            -22,
            -6,
            -20,
            -6,
            3,
            -23,
            -6,
            -23,
            -4,
            3,
            -19,
            -7,
            -16,
            -7,
            3,
            -20,
            -11,
            -19,
            -9,
            3,
            -19,
            -12,
            -17,
            -11,
            3,
            -19,
            -10,
            -18,
            -10,
            3,
            -15,
            -12,
            -17,
            -12,
            3,
            -14,
            -12,
            -11,
            -12,
            3,
            -12,
            -12,
            -12,
            -10,
            3,
            -9,
            -5,
            -9,
            -4,
            3,
            -10,
            -10,
            -10,
            -7,
            3,
            -8,
            -10,
            -8,
            -10,
            3,
            -2,
            -10,
            -2,
            -8,
            3,
            -4,
            -11,
            -4,
            -9,
            3,
            -3,
            -11,
            -3,
            -10,
            3,
            -1,
            -11,
            -1,
            -10,
            3,
            -1,
            -12,
            2,
            -12,
            3,
            2,
            -12,
            2,
            -9,
            3,
            5,
            -12,
            2,
            -12,
            3,
            4,
            -12,
            4,
            -11,
            3,
            4,
            -11,
            4,
            -10,
            3,
            5,
            -11,
            5,
            -9,
            3,
            6,
            -9,
            6,
            -6,
            3,
            7,
            -12,
            7,
            -9,
            3,
            9,
            -9,
            9,
            -7,
            3,
            10,
            -4,
            10,
            -2,
            3,
            11,
            -7,
            11,
            -5,
            3,
            13,
            -12,
            13,
            -9,
            3,
            14,
            -9,
            14,
            -8,
            3,
            15,
            -7,
            15,
            -5,
            3,
            16,
            -12,
            18,
            -10,
            3,
            20,
            -12,
            19,
            -12,
            3,
            20,
            -9,
            20,
            -8,
            3,
            20,
            -8,
            19,
            -8,
            3,
            21,
            -11,
            21,
            -9,
            3,
            21,
            -12,
            25,
            -12,
            3,
            25,
            -8,
            23,
            -8,
            3,
            23,
            -7,
            22,
            -7,
            3,
            16,
            -3,
            15,
            -3,
            3,
            19,
            -4,
            17,
            -4,
            3,
            20,
            -5,
            18,
            -6,
            3,
            19,
            -2,
            17,
            -2,
            3,
            18,
            0,
            16,
            0,
            3,
            25,
            -1,
            21,
            -1,
            3,
            18,
            5,
            17,
            3,
            3,
            23,
            2,
            20,
            2,
            3,
            23,
            2,
            24,
            1,
            3,
            25,
            1,
            25,
            1,
            3,
            24,
            8,
            21,
            9,
            3,
            20,
            10,
            18,
            11,
            3,
            20,
            8,
            18,
            8,
            3,
            16,
            7,
            14,
            7,
            3,
            14,
            5,
            13,
            5,
            3,
            -6,
            11,
            -6,
            8,
            3,
            -1,
            9,
            -1,
            7,
            3,
            -2,
            7,
            -2,
            6,
            3,
            -3,
            11,
            -3,
            10,
            3,
            -4,
            11,
            -4,
            11,
            3,
            10,
            6,
            9,
            6,
            3,
            4,
            11,
            4,
            11,
            3,
            5,
            11,
            5,
            11,
            3,
            4,
            10,
            4,
            10,
            7,
            -6,
            -2,
            7,
            -6,
            -3,
            7,
            15,
            -5,
            7,
            15,
            -6,
            7,
            15,
            -7,
            7,
            -24,
            -1,
            7,
            -25,
            -1,
            7,
            -10,
            5,
            7,
            -17,
            7,
            7,
            -24,
            7,
            7,
            -25,
            7,
            7,
            -24,
            8,
            7,
            -25,
            8,
            7,
            -23,
            10,
            7,
            -22,
            10,
            7,
            -19,
            9,
            7,
            -19,
            8,
            7,
            -16,
            4,
            7,
            -9,
            8,
            7,
            -13,
            -12,
            7,
            -12,
            -10,
            7,
            -15,
            -12,
            7,
            -16,
            -12,
            7,
            -17,
            -12,
            7,
            -18,
            -10,
            7,
            -8,
            3,
            7,
            -5,
            2,
            3,
            -18,
            -12,
            -17,
            -12,
            3,
            -14,
            -10,
            -14,
            -9,
            3,
            -15,
            -12,
            -15,
            -11,
            3,
            14,
            -7,
            14,
            -7,
            7,
            22,
            3,
            7,
            20,
            2,
            7,
            18,
            3,
            7,
            17,
            3,
            3,
            23,
            11,
            20,
            10,
            7,
            10,
            -2,
            7,
            -6,
            3,
            7,
            -6,
            2,
            7,
            -7,
            2,
            7,
            -1,
            7,
            7,
            -1,
            8,
            7,
            19,
            -8,
            7,
            20,
            -8,
            7,
            18,
            0,
            7,
            17,
            0,
            7,
            16,
            0,
            7,
            16,
            -10,
            7,
            16,
            -11,
            7,
            17,
            -10,
            7,
            19,
            -12,
            7,
            -18,
            -8,
            7,
            -18,
            -12,
            7,
            -18,
            -11,
            7,
            -16,
            -7,
            1,
            -17,
            -8,
            3,
            -21,
            -12,
            -21,
            -10,
            7,
            -19,
            -11,
            7,
            -19,
            -10,
            7,
            -19,
            -9,
            7,
            -17,
            -8,
            7,
            -19,
            -12,
            7,
            -17,
            -7,
            3,
            -16,
            -12,
            -16,
            -12,
            3,
            -13,
            -12,
            -13,
            -12,
            3,
            -19,
            -12,
            -19,
            -12,
            3,
            -18,
            -12,
            -18,
            -12,
            7,
            21,
            -9,
            7,
            17,
            -11,
            7,
            17,
            -12,
            7,
            21,
            -10,
            7,
            2,
            -9,
            7,
            21,
            -1,
            7,
            22,
            -1,
            7,
            23,
            -1,
            7,
            23,
            1,
            3,
            22,
            3,
            22,
            3,
            3,
            21,
            3,
            21,
            3,
            3,
            23,
            9,
            25,
            10,
            7,
            0,
            -12,
            7,
            3,
            -12,
            7,
            20,
            -9
        ],
        [
            3,
            -17,
            -11,
            -15,
            -11,
            3,
            -19,
            -9,
            -16,
            -9,
            3,
            -17,
            -10,
            -15,
            -10,
            3,
            -13,
            -12,
            -13,
            -10,
            3,
            -15,
            -8,
            -14,
            -8,
            3,
            -20,
            -6,
            -17,
            -6,
            3,
            -22,
            -4,
            -19,
            -4,
            3,
            -22,
            -5,
            -22,
            -5,
            3,
            -18,
            -3,
            -16,
            -3,
            3,
            -22,
            -2,
            -20,
            -2,
            3,
            -22,
            1,
            -19,
            1,
            3,
            -20,
            2,
            -18,
            2,
            3,
            -24,
            7,
            -21,
            7,
            3,
            -24,
            8,
            -23,
            8,
            3,
            -24,
            9,
            -22,
            9,
            3,
            -21,
            10,
            -21,
            9,
            3,
            -20,
            10,
            -20,
            9,
            3,
            -18,
            10,
            -18,
            8,
            3,
            -16,
            8,
            -16,
            6,
            3,
            -21,
            6,
            -19,
            6,
            3,
            -17,
            3,
            -16,
            3,
            3,
            -10,
            8,
            -10,
            5,
            3,
            -11,
            4,
            -11,
            2,
            3,
            -12,
            2,
            -12,
            2,
            3,
            -13,
            3,
            -13,
            1,
            3,
            -12,
            2,
            -12,
            1,
            3,
            -8,
            2,
            -8,
            0,
            3,
            -7,
            2,
            -7,
            1,
            3,
            -6,
            3,
            -6,
            8,
            3,
            -5,
            8,
            -5,
            11,
            3,
            -8,
            6,
            -8,
            3,
            3,
            -1,
            7,
            -1,
            5,
            3,
            -2,
            6,
            -2,
            4,
            3,
            4,
            10,
            4,
            7,
            3,
            5,
            11,
            5,
            9,
            3,
            4,
            11,
            3,
            11,
            3,
            3,
            11,
            2,
            11,
            3,
            -8,
            -10,
            -8,
            -8,
            3,
            -12,
            -10,
            -11,
            -8,
            3,
            -11,
            -8,
            -11,
            -7,
            3,
            -10,
            -7,
            -10,
            -6,
            3,
            -9,
            -4,
            -9,
            -3,
            3,
            -5,
            -6,
            -5,
            -4,
            3,
            -7,
            -8,
            -7,
            -7,
            3,
            -4,
            -9,
            -4,
            -7,
            3,
            -3,
            -10,
            -3,
            -9,
            3,
            -1,
            -10,
            -1,
            -8,
            3,
            0,
            -12,
            1,
            -10,
            3,
            2,
            -9,
            2,
            -7,
            3,
            1,
            -9,
            1,
            -9,
            3,
            4,
            -9,
            4,
            -7,
            3,
            5,
            -9,
            5,
            -7,
            3,
            8,
            -11,
            8,
            -9,
            3,
            9,
            -7,
            9,
            -5,
            3,
            6,
            -6,
            6,
            -5,
            3,
            9,
            6,
            7,
            6,
            3,
            18,
            11,
            13,
            11,
            3,
            21,
            9,
            18,
            9,
            3,
            17,
            8,
            15,
            8,
            3,
            13,
            7,
            12,
            7,
            3,
            13,
            5,
            11,
            5,
            3,
            25,
            0,
            21,
            0,
            3,
            23,
            3,
            20,
            3,
            3,
            23,
            1,
            22,
            1,
            3,
            20,
            -1,
            18,
            -1,
            3,
            17,
            -2,
            15,
            -2,
            3,
            25,
            -8,
            22,
            -11,
            3,
            20,
            -12,
            19,
            -9,
            3,
            12,
            -12,
            12,
            -9,
            3,
            13,
            -9,
            13,
            -7,
            3,
            14,
            -8,
            14,
            -7,
            3,
            15,
            -5,
            14,
            -5,
            3,
            11,
            -5,
            11,
            -3,
            3,
            7,
            -9,
            7,
            -8,
            3,
            16,
            0,
            15,
            0,
            7,
            18,
            -1,
            7,
            0,
            -10,
            7,
            0,
            -11,
            7,
            -1,
            4,
            7,
            -1,
            5,
            7,
            -2,
            4,
            7,
            21,
            -8,
            7,
            20,
            -8,
            7,
            19,
            -8,
            7,
            16,
            -4,
            7,
            -18,
            5,
            7,
            -6,
            5,
            7,
            -6,
            6,
            7,
            -8,
            0,
            3,
            -9,
            8,
            -9,
            8,
            3,
            -24,
            9,
            -22,
            10,
            3,
            -24,
            7,
            -26,
            7,
            3,
            -8,
            5,
            -8,
            5,
            3,
            -8,
            4,
            -8,
            4,
            7,
            -7,
            1,
            3,
            -19,
            -11,
            -17,
            -9,
            3,
            -16,
            -10,
            -15,
            -8,
            3,
            -16,
            -11,
            -17,
            -12,
            7,
            -15,
            -8,
            7,
            -15,
            -9,
            7,
            -15,
            -10,
            7,
            -18,
            -6,
            7,
            -18,
            -7,
            7,
            -17,
            -6,
            7,
            -17,
            -7,
            3,
            14,
            -7,
            14,
            -6,
            7,
            15,
            -5,
            7,
            15,
            -3,
            7,
            16,
            -3,
            7,
            18,
            -6,
            7,
            19,
            -6,
            7,
            -13,
            1,
            7,
            -20,
            9,
            7,
            -6,
            3,
            7,
            -6,
            4,
            7,
            -8,
            1,
            7,
            -8,
            2,
            7,
            -8,
            3,
            7,
            -7,
            2,
            7,
            -10,
            5,
            7,
            -8,
            4,
            7,
            -9,
            8,
            7,
            -1,
            7,
            7,
            -1,
            6,
            7,
            2,
            11,
            7,
            -2,
            5,
            7,
            20,
            -9,
            7,
            21,
            -9,
            7,
            22,
            -9,
            7,
            22,
            -8,
            7,
            19,
            -9,
            7,
            19,
            -11,
            7,
            21,
            -10,
            7,
            22,
            -10,
            7,
            23,
            -8,
            7,
            23,
            -9,
            7,
            16,
            0,
            7,
            15,
            0,
            7,
            21,
            0,
            7,
            22,
            0,
            7,
            21,
            2,
            7,
            -19,
            -11,
            7,
            -18,
            -11,
            7,
            -19,
            -10,
            7,
            -18,
            -10,
            7,
            -19,
            -9,
            7,
            -18,
            -9,
            3,
            -18,
            -11,
            -18,
            -11,
            3,
            -19,
            -11,
            -19,
            -11,
            7,
            19,
            -12,
            7,
            23,
            -10,
            7,
            24,
            -9,
            7,
            24,
            -8,
            7,
            25,
            -8,
            7,
            25,
            -9,
            3,
            17,
            -12,
            17,
            -12,
            3,
            19,
            -12,
            19,
            -12,
            3,
            19,
            -11,
            19,
            -11,
            3,
            19,
            -10,
            19,
            -10,
            7,
            2,
            -7,
            7,
            2,
            -8,
            7,
            23,
            0,
            7,
            24,
            0,
            7,
            25,
            0,
            3,
            23,
            -1,
            23,
            -1,
            3,
            22,
            -1,
            22,
            -1,
            7,
            19,
            -1,
            7,
            20,
            -1,
            3,
            19,
            3,
            19,
            3,
            3,
            21,
            2,
            20,
            2,
            3,
            19,
            2,
            19,
            2,
            3,
            16,
            -3,
            15,
            -3,
            3,
            18,
            10,
            15,
            10,
            7,
            0,
            -12,
            7,
            1,
            -9,
            7,
            19,
            -10,
            7,
            14,
            -5,
            7,
            14,
            -6,
            7,
            -9,
            -3
        ],
        [
            3,
            -22,
            -5,
            -20,
            -5,
            3,
            -15,
            -9,
            -13,
            -9,
            3,
            -3,
            -9,
            -3,
            -8,
            3,
            -1,
            -8,
            -1,
            -6,
            3,
            -2,
            -8,
            -2,
            -6,
            3,
            -4,
            -7,
            -4,
            -6,
            3,
            1,
            -9,
            1,
            -6,
            3,
            2,
            -7,
            2,
            -6,
            3,
            4,
            -7,
            4,
            -4,
            3,
            5,
            -7,
            5,
            -6,
            3,
            7,
            -8,
            7,
            -6,
            3,
            8,
            -9,
            8,
            -5,
            3,
            9,
            -5,
            9,
            -3,
            3,
            12,
            -9,
            12,
            -6,
            3,
            14,
            -6,
            12,
            -6,
            3,
            21,
            -9,
            20,
            -7,
            3,
            18,
            -10,
            18,
            -8,
            3,
            16,
            -10,
            16,
            -8,
            3,
            17,
            -10,
            17,
            -9,
            3,
            18,
            -5,
            17,
            -5,
            3,
            18,
            -6,
            17,
            -6,
            3,
            19,
            -2,
            15,
            -1,
            3,
            20,
            2,
            17,
            3,
            3,
            21,
            0,
            21,
            2,
            3,
            17,
            3,
            14,
            3,
            3,
            17,
            4,
            14,
            4,
            3,
            18,
            10,
            14,
            10,
            3,
            -1,
            5,
            -1,
            3,
            3,
            -2,
            4,
            -2,
            2,
            3,
            2,
            11,
            -1,
            11,
            3,
            0,
            11,
            0,
            6,
            3,
            -3,
            10,
            -3,
            7,
            3,
            -4,
            11,
            -4,
            9,
            3,
            -5,
            8,
            -5,
            6,
            3,
            7,
            6,
            7,
            4,
            3,
            18,
            9,
            16,
            9,
            3,
            15,
            8,
            12,
            8,
            3,
            12,
            7,
            9,
            7,
            3,
            11,
            5,
            10,
            5,
            3,
            15,
            0,
            14,
            0,
            3,
            13,
            11,
            11,
            11,
            3,
            11,
            11,
            9,
            11,
            3,
            14,
            10,
            13,
            10,
            3,
            3,
            11,
            3,
            9,
            3,
            4,
            7,
            4,
            6,
            7,
            1,
            11,
            3,
            -19,
            -4,
            -17,
            -4,
            3,
            -16,
            -3,
            -15,
            -3,
            3,
            -21,
            0,
            -18,
            0,
            3,
            -19,
            1,
            -17,
            1,
            3,
            -18,
            2,
            -16,
            2,
            3,
            -16,
            1,
            -16,
            1,
            3,
            -20,
            -2,
            -19,
            -2,
            3,
            -23,
            -2,
            -24,
            -1,
            3,
            -23,
            8,
            -20,
            8,
            3,
            -20,
            7,
            -19,
            7,
            3,
            -19,
            6,
            -17,
            6,
            3,
            -18,
            6,
            -18,
            7,
            3,
            -14,
            5,
            -14,
            4,
            3,
            -7,
            1,
            -5,
            1,
            3,
            -8,
            8,
            -10,
            5,
            3,
            -11,
            5,
            -10,
            4,
            3,
            -12,
            -8,
            -12,
            -7,
            3,
            -11,
            -7,
            -11,
            -6,
            3,
            -10,
            -6,
            -10,
            -5,
            3,
            -10,
            -5,
            -10,
            -4,
            3,
            -8,
            -8,
            -8,
            -5,
            3,
            -5,
            -4,
            -5,
            -3,
            3,
            -5,
            -3,
            -5,
            -2,
            3,
            -6,
            3,
            -5,
            3,
            3,
            5,
            11,
            7,
            11,
            3,
            5,
            9,
            5,
            8,
            3,
            11,
            -3,
            11,
            -1,
            3,
            6,
            -5,
            6,
            -4,
            3,
            6,
            -4,
            6,
            -3,
            7,
            -1,
            3,
            7,
            -1,
            4,
            7,
            -2,
            2,
            3,
            -24,
            7,
            -26,
            9,
            7,
            -17,
            6,
            7,
            -19,
            5,
            7,
            -19,
            6,
            7,
            -19,
            7,
            1,
            -15,
            -10,
            3,
            -25,
            -2,
            -25,
            0,
            3,
            17,
            -8,
            17,
            -8,
            3,
            19,
            -8,
            19,
            -8,
            3,
            -6,
            7,
            -6,
            6,
            7,
            -6,
            4,
            3,
            -5,
            5,
            -5,
            5,
            7,
            7,
            4,
            3,
            19,
            -6,
            18,
            -7,
            3,
            -7,
            2,
            -6,
            2,
            7,
            7,
            5,
            7,
            5,
            -6,
            7,
            -20,
            9,
            7,
            -20,
            8,
            7,
            -16,
            6,
            7,
            -17,
            4,
            7,
            -16,
            1,
            7,
            -14,
            4,
            7,
            -5,
            5,
            7,
            -5,
            3,
            7,
            -18,
            6,
            7,
            -18,
            7,
            7,
            -20,
            7,
            7,
            -2,
            3,
            7,
            11,
            -1,
            7,
            -5,
            1,
            7,
            -6,
            1,
            7,
            -6,
            2,
            7,
            -1,
            5,
            7,
            0,
            6,
            7,
            0,
            7,
            7,
            0,
            8,
            7,
            2,
            11,
            7,
            -5,
            -3,
            7,
            -5,
            -2,
            7,
            -9,
            -3,
            7,
            -8,
            -5,
            7,
            -2,
            4,
            7,
            0,
            9,
            7,
            0,
            10,
            7,
            22,
            0,
            3,
            -19,
            -10,
            -19,
            -10,
            3,
            -19,
            -9,
            -19,
            -9,
            3,
            -19,
            -8,
            -19,
            -8,
            7,
            -14,
            -8,
            7,
            18,
            -7,
            7,
            19,
            -7,
            7,
            20,
            -7,
            7,
            21,
            -7,
            7,
            22,
            -7,
            7,
            18,
            -9,
            7,
            18,
            -8,
            7,
            19,
            -8,
            7,
            16,
            -10,
            7,
            16,
            -9,
            7,
            16,
            -8,
            7,
            21,
            -9,
            7,
            21,
            -8,
            7,
            20,
            -8,
            7,
            20,
            -9,
            3,
            25,
            -9,
            23,
            -10,
            3,
            22,
            -10,
            21,
            -10,
            7,
            17,
            -10,
            7,
            17,
            -9,
            7,
            17,
            -8,
            7,
            16,
            -12,
            3,
            16,
            -12,
            17,
            -11,
            7,
            8,
            -5,
            7,
            8,
            -6,
            7,
            8,
            -7,
            7,
            8,
            -8,
            7,
            7,
            -6,
            7,
            7,
            -7,
            7,
            2,
            -6,
            7,
            2,
            -7,
            7,
            1,
            -6,
            7,
            14,
            0,
            7,
            15,
            0,
            3,
            22,
            -2,
            19,
            -1,
            7,
            21,
            0,
            7,
            18,
            -1,
            7,
            19,
            -1,
            7,
            20,
            -1,
            7,
            -3,
            7,
            7,
            -1,
            -6,
            3,
            7,
            -7,
            7,
            -5,
            7,
            0,
            11,
            7,
            14,
            -6
        ],
        [
            3,
            -19,
            -6,
            -17,
            -5,
            3,
            -17,
            -6,
            -16,
            -6,
            3,
            -15,
            -8,
            -15,
            -7,
            3,
            -13,
            -9,
            -14,
            -7,
            3,
            -11,
            -7,
            -11,
            -6,
            3,
            -11,
            -6,
            -12,
            -6,
            3,
            -8,
            -5,
            -8,
            -3,
            3,
            -7,
            -7,
            -7,
            -5,
            3,
            -4,
            -6,
            -4,
            -3,
            3,
            -5,
            -1,
            -5,
            -1,
            3,
            -8,
            1,
            -7,
            0,
            3,
            -5,
            3,
            -5,
            5,
            3,
            -4,
            9,
            -4,
            7,
            3,
            -3,
            7,
            -3,
            4,
            3,
            -11,
            -6,
            -11,
            -5,
            3,
            -17,
            -4,
            -15,
            -4,
            3,
            -15,
            -3,
            -14,
            -3,
            3,
            -18,
            -2,
            -16,
            -2,
            3,
            -23,
            -1,
            -22,
            -1,
            3,
            -18,
            0,
            -16,
            0,
            3,
            -17,
            5,
            -15,
            5,
            3,
            -14,
            4,
            -14,
            2,
            3,
            -9,
            5,
            -10,
            2,
            3,
            -12,
            2,
            -11,
            1,
            3,
            -13,
            1,
            -13,
            0,
            3,
            -9,
            2,
            -9,
            1,
            3,
            -2,
            -6,
            -2,
            -4,
            3,
            0,
            -10,
            0,
            -9,
            3,
            -3,
            -8,
            -3,
            -7,
            3,
            2,
            -6,
            2,
            -4,
            3,
            1,
            -6,
            1,
            -5,
            3,
            -1,
            3,
            -1,
            2,
            3,
            -2,
            2,
            -2,
            1,
            3,
            0,
            6,
            0,
            5,
            3,
            2,
            11,
            2,
            9,
            3,
            3,
            9,
            3,
            7,
            7,
            1,
            -5,
            3,
            4,
            6,
            4,
            4,
            3,
            9,
            11,
            7,
            11,
            3,
            16,
            9,
            12,
            9,
            3,
            13,
            10,
            9,
            10,
            3,
            12,
            8,
            10,
            8,
            3,
            8,
            7,
            7,
            7,
            3,
            6,
            11,
            6,
            9,
            3,
            5,
            7,
            5,
            6,
            3,
            8,
            6,
            9,
            4,
            3,
            10,
            5,
            14,
            4,
            3,
            14,
            3,
            12,
            3,
            3,
            21,
            1,
            19,
            1,
            3,
            17,
            2,
            15,
            2,
            3,
            15,
            -1,
            14,
            -3,
            3,
            20,
            -7,
            17,
            -7,
            3,
            18,
            -9,
            16,
            -7,
            3,
            14,
            -5,
            11,
            -5,
            3,
            4,
            -6,
            7,
            -5,
            3,
            7,
            -5,
            7,
            -3,
            3,
            10,
            -2,
            9,
            -2,
            3,
            11,
            -1,
            10,
            -1,
            3,
            10,
            -1,
            9,
            -1,
            3,
            11,
            -1,
            11,
            0,
            7,
            -1,
            3,
            7,
            -1,
            2,
            3,
            -19,
            9,
            -17,
            6,
            7,
            -17,
            4,
            7,
            -18,
            4,
            3,
            -1,
            -12,
            0,
            -10,
            3,
            -19,
            -8,
            -16,
            -7,
            3,
            -6,
            7,
            -6,
            5,
            3,
            -6,
            1,
            -5,
            3,
            3,
            -7,
            3,
            -5,
            4,
            7,
            -5,
            1,
            7,
            -5,
            2,
            7,
            -5,
            3,
            7,
            -6,
            3,
            7,
            -7,
            0,
            7,
            -9,
            1,
            3,
            15,
            -7,
            15,
            -7,
            3,
            16,
            -3,
            17,
            -3,
            3,
            -22,
            -1,
            -20,
            -1,
            3,
            -20,
            5,
            -17,
            5,
            3,
            -16,
            -2,
            -14,
            -2,
            3,
            -17,
            -5,
            -16,
            -5,
            3,
            -16,
            -6,
            -14,
            -6,
            3,
            -13,
            -7,
            -13,
            -6,
            3,
            -10,
            -4,
            -10,
            -3,
            3,
            -21,
            7,
            -20,
            10,
            3,
            -16,
            0,
            -16,
            2,
            3,
            -17,
            5,
            -15,
            7,
            7,
            -16,
            -5,
            7,
            -18,
            -5,
            7,
            -17,
            -5,
            7,
            -18,
            -6,
            7,
            -17,
            -6,
            7,
            15,
            2,
            7,
            11,
            4,
            7,
            12,
            4,
            7,
            10,
            4,
            7,
            -6,
            4,
            7,
            -5,
            4,
            7,
            -19,
            4,
            7,
            -18,
            5,
            7,
            -19,
            5,
            7,
            -17,
            5,
            7,
            -17,
            6,
            7,
            -18,
            6,
            7,
            -19,
            6,
            7,
            -20,
            6,
            7,
            -13,
            0,
            7,
            -8,
            0,
            7,
            -5,
            -1,
            7,
            -2,
            1,
            7,
            -2,
            2,
            7,
            12,
            3,
            7,
            11,
            0,
            7,
            11,
            -1,
            7,
            10,
            -1,
            7,
            -8,
            4,
            7,
            -9,
            2,
            7,
            -8,
            1,
            7,
            -6,
            1,
            7,
            -3,
            4,
            7,
            -3,
            5,
            7,
            0,
            5,
            7,
            0,
            6,
            7,
            0,
            9,
            3,
            -18,
            -10,
            -18,
            -9,
            7,
            -15,
            -6,
            7,
            -15,
            -7,
            7,
            -15,
            -8,
            7,
            -17,
            -7,
            7,
            -17,
            -8,
            7,
            0,
            -9,
            7,
            -13,
            -5,
            7,
            -13,
            -6,
            7,
            -13,
            -7,
            7,
            -13,
            -8,
            7,
            -14,
            -6,
            7,
            -14,
            -7,
            7,
            -14,
            -8,
            3,
            16,
            -11,
            17,
            -9,
            7,
            17,
            -6,
            7,
            18,
            -6,
            7,
            19,
            -7,
            7,
            20,
            -7,
            7,
            18,
            -7,
            7,
            17,
            -7,
            7,
            16,
            -7,
            7,
            15,
            -7,
            7,
            18,
            -8,
            7,
            17,
            -8,
            7,
            16,
            -8,
            7,
            18,
            -9,
            3,
            23,
            -9,
            18,
            -9,
            3,
            25,
            -9,
            23,
            -8,
            7,
            14,
            -3,
            7,
            14,
            -2,
            7,
            14,
            -1,
            7,
            7,
            -7,
            3,
            7,
            -7,
            7,
            -7,
            3,
            2,
            -8,
            2,
            -7,
            7,
            2,
            -4,
            7,
            2,
            -5,
            7,
            2,
            -6,
            7,
            2,
            -7,
            7,
            2,
            -8,
            7,
            -2,
            -4,
            7,
            -2,
            -5,
            7,
            -4,
            -3,
            7,
            -8,
            -3,
            7,
            -7,
            -5,
            7,
            -7,
            -6,
            7,
            19,
            -9,
            3,
            3,
            -12,
            3,
            -10,
            7,
            0,
            -10,
            7,
            0,
            -11,
            7,
            0,
            -12,
            3,
            21,
            -1,
            18,
            -1,
            3,
            8,
            -8,
            8,
            -6,
            7,
            9,
            -1,
            3,
            25,
            0,
            23,
            0,
            7,
            14,
            -5,
            7,
            15,
            -3,
            3,
            20,
            -9,
            23,
            -6,
            7,
            20,
            -8,
            7,
            21,
            -8,
            7,
            22,
            -8,
            7,
            23,
            -8
        ],
        [
            3,
            19,
            -10,
            19,
            -9,
            3,
            23,
            -7,
            20,
            -7,
            3,
            22,
            -8,
            20,
            -8,
            3,
            19,
            -6,
            17,
            -6,
            3,
            3,
            -10,
            3,
            -6,
            3,
            6,
            -5,
            5,
            -4,
            3,
            8,
            -6,
            8,
            -3,
            3,
            -17,
            -9,
            -17,
            -7,
            3,
            -16,
            -7,
            -18,
            -6,
            3,
            -15,
            -8,
            -15,
            -6,
            3,
            -14,
            -8,
            -14,
            -7,
            7,
            -14,
            -7,
            3,
            -12,
            -6,
            -12,
            -5,
            3,
            -20,
            6,
            -17,
            6,
            3,
            -20,
            5,
            -19,
            5,
            3,
            -6,
            5,
            -6,
            3,
            3,
            -4,
            6,
            -4,
            6,
            3,
            -1,
            9,
            -1,
            7,
            3,
            2,
            9,
            2,
            8,
            3,
            3,
            6,
            3,
            6,
            3,
            12,
            9,
            9,
            9,
            3,
            9,
            10,
            7,
            10,
            3,
            10,
            8,
            9,
            8,
            3,
            8,
            5,
            7,
            5,
            3,
            13,
            4,
            10,
            4,
            3,
            16,
            2,
            14,
            2,
            3,
            19,
            1,
            17,
            1,
            3,
            23,
            0,
            21,
            0,
            3,
            19,
            -9,
            17,
            -6,
            7,
            17,
            -8,
            7,
            18,
            -8,
            7,
            19,
            -8,
            7,
            15,
            -8,
            3,
            23,
            -8,
            23,
            -8
        ],
        [
            3,
            20,
            -8,
            15,
            -8,
            3,
            20,
            -7,
            18,
            -7,
            3,
            16,
            -3,
            16,
            -6,
            3,
            15,
            -3,
            14,
            -1,
            3,
            17,
            1,
            14,
            1,
            3,
            14,
            2,
            13,
            2,
            3,
            13,
            3,
            10,
            3,
            3,
            9,
            8,
            6,
            9,
            3,
            8,
            4,
            7,
            4,
            3,
            12,
            -5,
            12,
            -3,
            3,
            20,
            0,
            19,
            0,
            3,
            1,
            11,
            1,
            9,
            3,
            2,
            8,
            2,
            7,
            3,
            3,
            6,
            3,
            6,
            3,
            4,
            4,
            3,
            4,
            3,
            -3,
            6,
            -5,
            5,
            3,
            -5,
            4,
            -5,
            3,
            3,
            -9,
            5,
            -8,
            3,
            3,
            -19,
            5,
            -16,
            5,
            3,
            -19,
            4,
            -18,
            4,
            3,
            -19,
            -1,
            -20,
            -1,
            3,
            -19,
            -5,
            -16,
            -5,
            3,
            -13,
            -9,
            -13,
            -6,
            3,
            -14,
            -8,
            -14,
            -7,
            3,
            -7,
            -7,
            -7,
            -6,
            3,
            -3,
            -7,
            -3,
            -4,
            3,
            -10,
            -3,
            -8,
            -3,
            3,
            -11,
            -5,
            -11,
            -4,
            3,
            -12,
            -5,
            -12,
            -4,
            3,
            2,
            -8,
            2,
            -8,
            3,
            3,
            -6,
            3,
            -5,
            3,
            3,
            -5,
            3,
            -4,
            3,
            6,
            -3,
            5,
            -3,
            3,
            9,
            -2,
            7,
            -2,
            3,
            14,
            -6,
            14,
            -6,
            3,
            17,
            -8,
            15,
            -6
        ],
        [
            3,
            3,
            5,
            3,
            5,
            3,
            6,
            8,
            6,
            6,
            3,
            17,
            -7,
            15,
            -7,
            3,
            14,
            -6,
            14,
            -5,
            3,
            12,
            -3,
            12,
            -2,
            3,
            2,
            -8,
            2,
            -6,
            3,
            -1,
            -7,
            -1,
            -4,
            3,
            -2,
            -6,
            -2,
            -5,
            3,
            -7,
            -6,
            -7,
            -3,
            3,
            -7,
            -3,
            -6,
            -3,
            3,
            -14,
            -7,
            -14,
            -5,
            3,
            -16,
            -5,
            -13,
            -5,
            3,
            -14,
            -5,
            -14,
            -4,
            3,
            -11,
            -4,
            -11,
            -3,
            3,
            -12,
            -4,
            -12,
            -3,
            3,
            -17,
            4,
            -14,
            4,
            3,
            -15,
            4,
            -15,
            2,
            3,
            -11,
            1,
            -10,
            1,
            3,
            -6,
            2,
            -6,
            1,
            3,
            -5,
            4,
            -3,
            4,
            3,
            -1,
            7,
            -1,
            6,
            3,
            5,
            6,
            5,
            4,
            3,
            10,
            3,
            8,
            3,
            3,
            13,
            2,
            11,
            2,
            3,
            19,
            0,
            17,
            0,
            3,
            3,
            -4,
            3,
            -3,
            3,
            4,
            -4,
            4,
            -3,
            3,
            7,
            -2,
            6,
            -2,
            3,
            5,
            -2,
            5,
            -2,
            7,
            14,
            -4,
            7,
            15,
            -7,
            3,
            15,
            -8,
            14,
            -4,
            3,
            -6,
            -4,
            -6,
            -4,
            7,
            -1,
            -4,
            7,
            -1,
            -5
        ],
        [
            3,
            15,
            -6,
            15,
            -4,
            3,
            15,
            -4,
            12,
            -4,
            3,
            17,
            0,
            15,
            0,
            3,
            1,
            9,
            1,
            7,
            3,
            -1,
            6,
            -1,
            4,
            3,
            -5,
            3,
            -4,
            3,
            3,
            -6,
            2,
            -5,
            2,
            3,
            -10,
            2,
            -7,
            2,
            3,
            -18,
            -1,
            -16,
            -1,
            3,
            -16,
            1,
            -14,
            1,
            3,
            -13,
            -5,
            -13,
            -3,
            3,
            -9,
            -3,
            -8,
            -2,
            3,
            -6,
            -3,
            -4,
            -3,
            3,
            -2,
            -5,
            -2,
            -4,
            3,
            -1,
            -4,
            -1,
            -3,
            3,
            2,
            -6,
            2,
            -4,
            3,
            5,
            -2,
            4,
            -2,
            3,
            11,
            2,
            9,
            2,
            3,
            8,
            3,
            7,
            3,
            3,
            6,
            6,
            6,
            4,
            3,
            14,
            1,
            11,
            1,
            7,
            -1,
            -3,
            3,
            -1,
            -5,
            -1,
            -5,
            7,
            -1,
            -4,
            7,
            -1,
            -5
        ],
        [
            3,
            13,
            -3,
            13,
            -2,
            3,
            15,
            0,
            12,
            0,
            3,
            11,
            1,
            9,
            1,
            3,
            1,
            -6,
            1,
            -4,
            3,
            2,
            -4,
            2,
            -3,
            3,
            3,
            -3,
            3,
            -2,
            3,
            9,
            2,
            7,
            2,
            3,
            6,
            3,
            4,
            3,
            3,
            2,
            6,
            2,
            6,
            3,
            3,
            5,
            2,
            5,
            3,
            -2,
            6,
            -2,
            4,
            3,
            -4,
            3,
            -3,
            3,
            3,
            -5,
            2,
            -4,
            2,
            3,
            -6,
            1,
            -4,
            1,
            3,
            -10,
            1,
            -7,
            1,
            3,
            -4,
            -3,
            -2,
            -3,
            3,
            -16,
            0,
            -11,
            0,
            3,
            -13,
            -2,
            -11,
            -2,
            3,
            -8,
            -2,
            -6,
            -2,
            7,
            -1,
            -3
        ],
        [
            3,
            -11,
            -2,
            -10,
            -2,
            3,
            -11,
            0,
            -8,
            0,
            3,
            -15,
            -1,
            -13,
            -1,
            3,
            -5,
            -2,
            -5,
            -2,
            3,
            -3,
            2,
            -3,
            2,
            3,
            -2,
            4,
            -2,
            2,
            3,
            2,
            5,
            2,
            3,
            3,
            3,
            4,
            3,
            3,
            3,
            7,
            2,
            5,
            2,
            3,
            9,
            1,
            7,
            1,
            3,
            12,
            0,
            8,
            0,
            3,
            14,
            -1,
            11,
            -1,
            3,
            0,
            -12,
            0,
            -11,
            7,
            -1,
            -3,
            7,
            -1,
            -4,
            7,
            -1,
            -5,
            7,
            1,
            -4,
            7,
            1,
            -5,
            3,
            -1,
            -5,
            -1,
            -5,
            3,
            1,
            -5,
            1,
            -5
        ],
        [
            3,
            1,
            7,
            1,
            3,
            3,
            -12,
            -1,
            -11,
            -1,
            3,
            -8,
            0,
            -6,
            0,
            3,
            -5,
            -2,
            -4,
            -2,
            3,
            1,
            -4,
            1,
            -3,
            3,
            3,
            -2,
            2,
            -2,
            3,
            10,
            -1,
            9,
            -1,
            3,
            8,
            0,
            5,
            0,
            3,
            6,
            1,
            5,
            1,
            3,
            5,
            1,
            5,
            1,
            3,
            2,
            3,
            3,
            2
        ],
        [
            3,
            -11,
            -1,
            -8,
            -1,
            3,
            -4,
            -2,
            -2,
            -2,
            3,
            -5,
            0,
            -4,
            0,
            3,
            -4,
            1,
            -2,
            1,
            3,
            -1,
            3,
            -1,
            3,
            3,
            0,
            -11,
            0,
            -9,
            3,
            2,
            -2,
            1,
            -2,
            3,
            9,
            -1,
            7,
            -1,
            3,
            5,
            2,
            3,
            1,
            3,
            1,
            3,
            1,
            2
        ],
        [
            3,
            -8,
            -1,
            -6,
            -1,
            3,
            0,
            -9,
            0,
            -6,
            3,
            -1,
            3,
            -1,
            1,
            3,
            -4,
            0,
            -3,
            0,
            3,
            -2,
            -2,
            -1,
            -2,
            3,
            5,
            0,
            3,
            0,
            3,
            1,
            2,
            1,
            1,
            3,
            2,
            2,
            2,
            1,
            7,
            1,
            1,
            7,
            -1,
            2,
            3,
            -1,
            -5,
            -1,
            -3,
            3,
            -1,
            1,
            -1,
            1,
            7,
            -1,
            1
        ],
        [
            3,
            7,
            -1,
            4,
            -1,
            3,
            0,
            -6,
            0,
            -6,
            3,
            1,
            8,
            -1,
            11,
            3,
            0,
            -3,
            0,
            -1,
            3,
            -3,
            -1,
            -1,
            -1,
            1,
            -2,
            -1,
            1,
            -1,
            -1,
            1,
            0,
            -1,
            1,
            0,
            -2,
            1,
            0,
            -3,
            7,
            0,
            -3,
            7,
            0,
            -2,
            7,
            0,
            -1,
            7,
            -1,
            -1,
            7,
            -2,
            -1,
            7,
            -3,
            -1,
            4,
            0,
            -4,
            4,
            4,
            1,
            -5,
            8,
            4,
            1,
            -4,
            8,
            4,
            1,
            -3,
            8,
            4,
            1,
            -2,
            8,
            4,
            -1,
            -5,
            4,
            4,
            -1,
            -4,
            4,
            4,
            -1,
            -3,
            4,
            4,
            -1,
            -2,
            4,
            4,
            -1,
            -2,
            2,
            4,
            -2,
            -2,
            2,
            4,
            -3,
            -2,
            2,
            4,
            -4,
            -2,
            2,
            4,
            -5,
            -2,
            2,
            4,
            -5,
            0,
            1,
            4,
            -4,
            0,
            1,
            4,
            -3,
            0,
            1,
            4,
            -2,
            1,
            1,
            4,
            -1,
            3,
            1,
            4,
            1,
            2,
            1,
            4,
            2,
            1,
            1,
            4,
            3,
            0,
            1,
            4,
            1,
            -2,
            2,
            4,
            2,
            -2,
            2,
            4,
            3,
            -2,
            2,
            4,
            0,
            -6,
            2,
            4,
            0,
            8,
            1,
            4,
            -6,
            -1,
            4,
            4,
            -3,
            0,
            4,
            4,
            -2,
            1,
            4,
            4,
            -2,
            2,
            4,
            4,
            -1,
            3,
            4,
            4,
            -1,
            4,
            4,
            4,
            -1,
            5,
            4,
            4,
            -1,
            6,
            4,
            4,
            -1,
            7,
            4,
            4,
            4,
            -1,
            8,
            4,
            3,
            0,
            8,
            4,
            2,
            1,
            8,
            4,
            1,
            2,
            8,
            4,
            1,
            3,
            8,
            4,
            1,
            4,
            8,
            4,
            1,
            5,
            8,
            4,
            1,
            6,
            8,
            4,
            1,
            7,
            8
        ],
        [
            3,
            -5,
            -1,
            -3,
            -1,
            3,
            0,
            8,
            0,
            5,
            3,
            3,
            -2,
            2,
            1,
            7,
            -1,
            1,
            5,
            -5,
            -2,
            2,
            5,
            -4,
            -2,
            2,
            5,
            -3,
            -2,
            2,
            5,
            -5,
            0,
            1,
            5,
            -4,
            0,
            1,
            5,
            -3,
            0,
            1,
            5,
            0,
            8,
            1,
            5,
            2,
            1,
            1,
            5,
            3,
            0,
            1,
            5,
            2,
            -2,
            2,
            5,
            3,
            -2,
            2,
            5,
            4,
            -1,
            8,
            5,
            3,
            0,
            8,
            5,
            1,
            5,
            8,
            5,
            1,
            6,
            8,
            5,
            1,
            7,
            8,
            5,
            -6,
            -1,
            4,
            5,
            -1,
            5,
            4,
            5,
            -1,
            6,
            4,
            5,
            -1,
            7,
            4,
            4,
            -3,
            -1,
            4,
            4,
            0,
            5,
            1,
            4,
            2,
            -1,
            8,
            4,
            2,
            0,
            8
        ],
        [
            3,
            0,
            -6,
            0,
            -2,
            3,
            0,
            5,
            0,
            3,
            7,
            0,
            -3,
            7,
            0,
            -2,
            5,
            -1,
            -5,
            4,
            5,
            -1,
            -4,
            4,
            5,
            -1,
            3,
            4,
            5,
            -1,
            4,
            4,
            5,
            1,
            3,
            8,
            5,
            1,
            4,
            8,
            5,
            1,
            -4,
            8,
            5,
            1,
            -5,
            8,
            5,
            0,
            -6,
            2,
            5,
            0,
            5,
            1,
            5,
            0,
            -4,
            4,
            4,
            0,
            -4,
            2,
            4,
            0,
            3,
            1
        ],
        [
            3,
            -3,
            -2,
            -1,
            0,
            3,
            -1,
            1,
            1,
            2,
            7,
            -1,
            -1,
            7,
            -2,
            -1,
            4,
            0,
            -3,
            4,
            5,
            -3,
            0,
            4,
            5,
            -2,
            1,
            4,
            5,
            -2,
            2,
            4,
            5,
            2,
            1,
            8,
            5,
            1,
            2,
            8,
            5,
            -2,
            1,
            1,
            5,
            1,
            2,
            1,
            5,
            0,
            3,
            1,
            5,
            -1,
            3,
            1,
            4,
            -2,
            0,
            1,
            4,
            -1,
            0,
            1,
            4,
            0,
            1,
            1,
            4,
            1,
            1,
            1,
            4,
            -1,
            0,
            4
        ],
        [
            3,
            -1,
            -2,
            1,
            -1,
            7,
            -1,
            -1,
            7,
            0,
            -1,
            7,
            0,
            -2,
            1,
            0,
            -3,
            5,
            2,
            -1,
            8,
            5,
            1,
            -2,
            2,
            5,
            -1,
            -3,
            8,
            5,
            0,
            -3,
            8,
            5,
            0,
            -3,
            4,
            5,
            0,
            -3,
            1,
            5,
            0,
            -4,
            2,
            5,
            -1,
            -3,
            4,
            5,
            2,
            -3,
            8,
            5,
            1,
            -3,
            8,
            4,
            1,
            -1,
            8,
            4,
            1,
            -1,
            2
        ],
        [
            3,
            2,
            -1,
            1,
            1,
            1,
            -2,
            -1,
            1,
            0,
            -2,
            5,
            1,
            -1,
            2,
            5,
            -2,
            0,
            1,
            5,
            2,
            1,
            1,
            5,
            1,
            1,
            1,
            5,
            2,
            0,
            8,
            5,
            -3,
            -1,
            4,
            5,
            -1,
            -2,
            4,
            4,
            1,
            0,
            8,
            5,
            -2,
            -1,
            8,
            5,
            0,
            -2,
            8,
            5,
            0,
            -2,
            4,
            5,
            0,
            -3,
            2,
            5,
            0,
            -2,
            1,
            5,
            2,
            -2,
            8,
            5,
            1,
            -2,
            8,
            5,
            -2,
            -1,
            2,
            5,
            -2,
            -2,
            2,
            5,
            -2,
            -1,
            1
        ],
        [
            3,
            -1,
            -1,
            1,
            1,
            7,
            -1,
            -1,
            7,
            0,
            -1,
            1,
            -1,
            -1,
            5,
            -2,
            -1,
            4,
            5,
            -1,
            0,
            4,
            5,
            1,
            0,
            8,
            5,
            0,
            1,
            1,
            5,
            -1,
            0,
            1,
            5,
            -1,
            -1,
            1,
            5,
            -1,
            -1,
            2,
            5,
            -1,
            -2,
            2,
            5,
            -1,
            -1,
            8
        ]
    ],
    "QuantizedZoom": [
        [
            1,
            0,
            11,
            4,
            0,
            11,
            1,
            4,
            0,
            11,
            2,
            4,
            0,
            11,
            4,
            4,
            0,
            11,
            8
        ],
        [
            5,
            -1,
            0,
            1,
            5,
            -1,
            0,
            2,
            5,
            -1,
            0,
            4,
            5,
            -1,
            0,
            8,
            1,
            -1,
            0,
            4,
            -1,
            0,
            1,
            4,
            -1,
            0,
            2,
            4,
            -1,
            0,
            4,
            4,
            -1,
            0,
            8
        ],
        [
            5,
            1,
            0,
            1,
            5,
            1,
            0,
            2,
            5,
            1,
            0,
            4,
            5,
            1,
            0,
            8,
            1,
            1,
            0,
            4,
            1,
            0,
            1,
            4,
            1,
            0,
            2,
            4,
            1,
            0,
            4,
            4,
            1,
            0,
            8
        ],
        [
            5,
            0,
            -1,
            1,
            5,
            0,
            -1,
            2,
            5,
            0,
            -1,
            4,
            5,
            0,
            -1,
            8,
            1,
            0,
            -1,
            4,
            0,
            -1,
            1,
            4,
            0,
            -1,
            2,
            4,
            0,
            -1,
            4,
            4,
            0,
            -1,
            8
        ],
        [
            5,
            -2,
            0,
            1,
            5,
            -2,
            0,
            2,
            5,
            -2,
            0,
            4,
            5,
            -2,
            0,
            8,
            1,
            -2,
            0,
            4,
            -2,
            0,
            1,
            4,
            -2,
            0,
            2,
            4,
            -2,
            0,
            4,
            4,
            -2,
            0,
            8
        ],
        [
            5,
            0,
            -2,
            1,
            5,
            0,
            -2,
            2,
            5,
            0,
            -2,
            4,
            5,
            0,
            -2,
            8,
            1,
            0,
            -2,
            4,
            0,
            -2,
            1,
            4,
            0,
            -2,
            2,
            4,
            0,
            -2,
            4,
            4,
            0,
            -2,
            8
        ],
        [
            5,
            2,
            0,
            1,
            5,
            2,
            0,
            2,
            5,
            2,
            0,
            4,
            5,
            2,
            0,
            8,
            1,
            2,
            0,
            4,
            2,
            0,
            1,
            4,
            2,
            0,
            2,
            4,
            2,
            0,
            4,
            4,
            2,
            0,
            8
        ],
        [
            5,
            -3,
            0,
            1,
            5,
            -3,
            0,
            2,
            5,
            -3,
            0,
            4,
            5,
            -3,
            0,
            8,
            1,
            -3,
            0,
            4,
            -3,
            0,
            1,
            4,
            -3,
            0,
            2,
            4,
            -3,
            0,
            4,
            4,
            -3,
            0,
            8
        ],
        [
            5,
            -4,
            0,
            1,
            5,
            -4,
            0,
            2,
            5,
            -4,
            0,
            4,
            5,
            -4,
            0,
            8,
            1,
            -4,
            0,
            4,
            -4,
            0,
            1,
            4,
            -4,
            0,
            2,
            4,
            -4,
            0,
            4,
            4,
            -4,
            0,
            8
        ],
        [
            5,
            3,
            0,
            1,
            5,
            3,
            0,
            2,
            5,
            3,
            0,
            4,
            5,
            3,
            0,
            8,
            1,
            3,
            0,
            4,
            3,
            0,
            1,
            4,
            3,
            0,
            2,
            4,
            3,
            0,
            4,
            4,
            3,
            0,
            8
        ],
        [
            5,
            4,
            0,
            1,
            5,
            4,
            0,
            2,
            5,
            4,
            0,
            4,
            5,
            4,
            0,
            8,
            1,
            4,
            0,
            4,
            4,
            0,
            1,
            4,
            4,
            0,
            2,
            4,
            4,
            0,
            4,
            4,
            4,
            0,
            8
        ],
        [
            5,
            0,
            1,
            1,
            5,
            0,
            1,
            2,
            5,
            0,
            1,
            4,
            5,
            0,
            1,
            8,
            1,
            0,
            1,
            4,
            0,
            1,
            1,
            4,
            0,
            1,
            2,
            4,
            0,
            1,
            4,
            4,
            0,
            1,
            8
        ],
        [
            5,
            5,
            0,
            1,
            5,
            5,
            0,
            2,
            5,
            5,
            0,
            4,
            5,
            5,
            0,
            8,
            1,
            5,
            0,
            4,
            5,
            0,
            1,
            4,
            5,
            0,
            2,
            4,
            5,
            0,
            4,
            4,
            5,
            0,
            8
        ],
        [
            5,
            6,
            0,
            1,
            5,
            6,
            0,
            2,
            5,
            6,
            0,
            4,
            5,
            6,
            0,
            8,
            1,
            6,
            0,
            4,
            6,
            0,
            1,
            4,
            6,
            0,
            2,
            4,
            6,
            0,
            4,
            4,
            6,
            0,
            8
        ],
        [
            5,
            -5,
            0,
            1,
            5,
            -5,
            0,
            2,
            5,
            -5,
            0,
            4,
            5,
            -5,
            0,
            8,
            1,
            -5,
            0,
            4,
            -5,
            0,
            1,
            4,
            -5,
            0,
            2,
            4,
            -5,
            0,
            4,
            4,
            -5,
            0,
            8
        ],
        [
            5,
            -6,
            0,
            1,
            5,
            -6,
            0,
            2,
            5,
            -6,
            0,
            4,
            5,
            -6,
            0,
            8,
            1,
            -6,
            0,
            4,
            -6,
            0,
            1,
            4,
            -6,
            0,
            2,
            4,
            -6,
            0,
            4,
            4,
            -6,
            0,
            8
        ],
        [
            5,
            0,
            2,
            1,
            5,
            0,
            2,
            2,
            5,
            0,
            2,
            4,
            5,
            0,
            2,
            8,
            1,
            0,
            2,
            4,
            0,
            2,
            1,
            4,
            0,
            2,
            2,
            4,
            0,
            2,
            4,
            4,
            0,
            2,
            8
        ],
        [
            5,
            0,
            3,
            1,
            5,
            0,
            3,
            2,
            5,
            0,
            3,
            4,
            5,
            0,
            3,
            8,
            1,
            0,
            3,
            4,
            0,
            3,
            1,
            4,
            0,
            3,
            2,
            4,
            0,
            3,
            4,
            4,
            0,
            3,
            8
        ],
        [
            5,
            -7,
            0,
            1,
            5,
            -7,
            0,
            2,
            5,
            -7,
            0,
            4,
            5,
            -7,
            0,
            8,
            1,
            -7,
            0,
            4,
            -7,
            0,
            1,
            4,
            -7,
            0,
            2,
            4,
            -7,
            0,
            4,
            4,
            -7,
            0,
            8
        ],
        [
            5,
            7,
            0,
            1,
            5,
            7,
            0,
            2,
            5,
            7,
            0,
            4,
            5,
            7,
            0,
            8,
            1,
            7,
            0,
            4,
            7,
            0,
            1,
            4,
            7,
            0,
            2,
            4,
            7,
            0,
            4,
            4,
            7,
            0,
            8
        ],
        [
            5,
            8,
            0,
            1,
            5,
            8,
            0,
            2,
            5,
            8,
            0,
            4,
            5,
            8,
            0,
            8,
            1,
            8,
            0,
            4,
            8,
            0,
            1,
            4,
            8,
            0,
            2,
            4,
            8,
            0,
            4,
            4,
            8,
            0,
            8
        ],
        [
            5,
            -8,
            0,
            1,
            5,
            -8,
            0,
            2,
            5,
            -8,
            0,
            4,
            5,
            -8,
            0,
            8,
            1,
            -8,
            0,
            4,
            -8,
            0,
            1,
            4,
            -8,
            0,
            2,
            4,
            -8,
            0,
            4,
            4,
            -8,
            0,
            8
        ],
        [
            5,
            0,
            -3,
            1,
            5,
            0,
            -3,
            2,
            5,
            0,
            -3,
            4,
            5,
            0,
            -3,
            8,
            1,
            0,
            -3,
            4,
            0,
            -3,
            1,
            4,
            0,
            -3,
            2,
            4,
            0,
            -3,
            4,
            4,
            0,
            -3,
            8
        ],
        [
            5,
            0,
            -4,
            1,
            5,
            0,
            -4,
            2,
            5,
            0,
            -4,
            4,
            5,
            0,
            -4,
            8,
            1,
            0,
            -4,
            4,
            0,
            -4,
            1,
            4,
            0,
            -4,
            2,
            4,
            0,
            -4,
            4,
            4,
            0,
            -4,
            8
        ],
        [
            5,
            0,
            -5,
            1,
            5,
            0,
            -5,
            2,
            5,
            0,
            -5,
            4,
            5,
            0,
            -5,
            8,
            1,
            0,
            -5,
            4,
            0,
            -5,
            1,
            4,
            0,
            -5,
            2,
            4,
            0,
            -5,
            4,
            4,
            0,
            -5,
            8
        ],
        [
            5,
            -9,
            0,
            1,
            5,
            -9,
            0,
            2,
            5,
            -9,
            0,
            4,
            5,
            -9,
            0,
            8,
            1,
            -9,
            0,
            4,
            -9,
            0,
            1,
            4,
            -9,
            0,
            2,
            4,
            -9,
            0,
            4,
            4,
            -9,
            0,
            8
        ],
        [
            5,
            -10,
            0,
            1,
            5,
            -10,
            0,
            2,
            5,
            -10,
            0,
            4,
            5,
            -10,
            0,
            8,
            1,
            -10,
            0,
            4,
            -10,
            0,
            1,
            4,
            -10,
            0,
            2,
            4,
            -10,
            0,
            4,
            4,
            -10,
            0,
            8
        ],
        [
            5,
            9,
            0,
            1,
            5,
            9,
            0,
            2,
            5,
            9,
            0,
            4,
            5,
            9,
            0,
            8,
            1,
            9,
            0,
            4,
            9,
            0,
            1,
            4,
            9,
            0,
            2,
            4,
            9,
            0,
            4,
            4,
            9,
            0,
            8
        ],
        [
            5,
            10,
            0,
            1,
            5,
            10,
            0,
            2,
            5,
            10,
            0,
            4,
            5,
            10,
            0,
            8,
            1,
            10,
            0,
            4,
            10,
            0,
            1,
            4,
            10,
            0,
            2,
            4,
            10,
            0,
            4,
            4,
            10,
            0,
            8
        ],
        [
            5,
            0,
            4,
            1,
            5,
            0,
            4,
            2,
            5,
            0,
            4,
            4,
            5,
            0,
            4,
            8,
            1,
            0,
            4,
            4,
            0,
            4,
            1,
            4,
            0,
            4,
            2,
            4,
            0,
            4,
            4,
            4,
            0,
            4,
            8
        ],
        [
            5,
            -11,
            0,
            1,
            5,
            -11,
            0,
            2,
            5,
            -11,
            0,
            4,
            5,
            -11,
            0,
            8,
            1,
            -11,
            0,
            4,
            -11,
            0,
            1,
            4,
            -11,
            0,
            2,
            4,
            -11,
            0,
            4,
            4,
            -11,
            0,
            8
        ],
        [
            5,
            0,
            -6,
            1,
            5,
            0,
            -6,
            2,
            5,
            0,
            -6,
            4,
            5,
            0,
            -6,
            8,
            1,
            0,
            -6,
            4,
            0,
            -6,
            1,
            4,
            0,
            -6,
            2,
            4,
            0,
            -6,
            4,
            4,
            0,
            -6,
            8
        ],
        [
            5,
            0,
            5,
            1,
            5,
            0,
            5,
            2,
            5,
            0,
            5,
            4,
            5,
            0,
            5,
            8,
            1,
            0,
            5,
            4,
            0,
            5,
            1,
            4,
            0,
            5,
            2,
            4,
            0,
            5,
            4,
            4,
            0,
            5,
            8
        ],
        [
            5,
            11,
            0,
            1,
            5,
            11,
            0,
            2,
            5,
            11,
            0,
            4,
            5,
            11,
            0,
            8,
            1,
            11,
            0,
            4,
            11,
            0,
            1,
            4,
            11,
            0,
            2,
            4,
            11,
            0,
            4,
            4,
            11,
            0,
            8
        ],
        [
            5,
            0,
            -7,
            1,
            5,
            0,
            -7,
            2,
            5,
            0,
            -7,
            4,
            5,
            0,
            -7,
            8,
            1,
            0,
            -7,
            4,
            0,
            -7,
            1,
            4,
            0,
            -7,
            2,
            4,
            0,
            -7,
            4,
            4,
            0,
            -7,
            8
        ],
        [
            5,
            0,
            6,
            1,
            5,
            0,
            6,
            2,
            5,
            0,
            6,
            4,
            5,
            0,
            6,
            8,
            1,
            0,
            6,
            4,
            0,
            6,
            1,
            4,
            0,
            6,
            2,
            4,
            0,
            6,
            4,
            4,
            0,
            6,
            8
        ],
        [
            5,
            -12,
            0,
            1,
            5,
            -12,
            0,
            2,
            5,
            -12,
            0,
            4,
            5,
            -12,
            0,
            8,
            1,
            -12,
            0,
            4,
            -12,
            0,
            1,
            4,
            -12,
            0,
            2,
            4,
            -12,
            0,
            4,
            4,
            -12,
            0,
            8
        ],
        [
            5,
            0,
            -8,
            1,
            5,
            0,
            -8,
            2,
            5,
            0,
            -8,
            4,
            5,
            0,
            -8,
            8,
            1,
            0,
            -8,
            4,
            0,
            -8,
            1,
            4,
            0,
            -8,
            2,
            4,
            0,
            -8,
            4,
            4,
            0,
            -8,
            8
        ],
        [
            5,
            0,
            7,
            1,
            5,
            0,
            7,
            2,
            5,
            0,
            7,
            4,
            5,
            0,
            7,
            8,
            1,
            0,
            7,
            4,
            0,
            7,
            1,
            4,
            0,
            7,
            2,
            4,
            0,
            7,
            4,
            4,
            0,
            7,
            8
        ],
        [
            5,
            12,
            0,
            1,
            5,
            12,
            0,
            2,
            5,
            12,
            0,
            4,
            5,
            12,
            0,
            8,
            1,
            12,
            0,
            4,
            12,
            0,
            1,
            4,
            12,
            0,
            2,
            4,
            12,
            0,
            4,
            4,
            12,
            0,
            8
        ],
        [
            5,
            13,
            0,
            1,
            5,
            13,
            0,
            2,
            5,
            13,
            0,
            4,
            5,
            13,
            0,
            8,
            1,
            13,
            0,
            4,
            13,
            0,
            1,
            4,
            13,
            0,
            2,
            4,
            13,
            0,
            4,
            4,
            13,
            0,
            8
        ],
        [
            5,
            14,
            0,
            1,
            5,
            14,
            0,
            2,
            5,
            14,
            0,
            4,
            5,
            14,
            0,
            8,
            1,
            14,
            0,
            4,
            14,
            0,
            1,
            4,
            14,
            0,
            2,
            4,
            14,
            0,
            4,
            4,
            14,
            0,
            8
        ],
        [
            5,
            0,
            8,
            1,
            5,
            0,
            8,
            2,
            5,
            0,
            8,
            4,
            5,
            0,
            8,
            8,
            1,
            0,
            8,
            4,
            0,
            8,
            1,
            4,
            0,
            8,
            2,
            4,
            0,
            8,
            4,
            4,
            0,
            8,
            8
        ],
        [
            5,
            -13,
            0,
            1,
            5,
            -13,
            0,
            2,
            5,
            -13,
            0,
            4,
            5,
            -13,
            0,
            8,
            1,
            -13,
            0,
            4,
            -13,
            0,
            1,
            4,
            -13,
            0,
            2,
            4,
            -13,
            0,
            4,
            4,
            -13,
            0,
            8
        ],
        [
            5,
            -14,
            0,
            1,
            5,
            -14,
            0,
            2,
            5,
            -14,
            0,
            4,
            5,
            -14,
            0,
            8,
            1,
            -14,
            0,
            4,
            -14,
            0,
            1,
            4,
            -14,
            0,
            2,
            4,
            -14,
            0,
            4,
            4,
            -14,
            0,
            8
        ],
        [
            5,
            15,
            0,
            1,
            5,
            15,
            0,
            2,
            5,
            15,
            0,
            4,
            5,
            15,
            0,
            8,
            1,
            15,
            0,
            4,
            15,
            0,
            1,
            4,
            15,
            0,
            2,
            4,
            15,
            0,
            4,
            4,
            15,
            0,
            8
        ],
        [
            5,
            16,
            0,
            1,
            5,
            16,
            0,
            2,
            5,
            16,
            0,
            4,
            5,
            16,
            0,
            8,
            1,
            16,
            0,
            4,
            16,
            0,
            1,
            4,
            16,
            0,
            2,
            4,
            16,
            0,
            4,
            4,
            16,
            0,
            8
        ],
        [
            5,
            0,
            -9,
            1,
            5,
            0,
            -9,
            2,
            5,
            0,
            -9,
            4,
            5,
            0,
            -9,
            8,
            1,
            0,
            -9,
            4,
            0,
            -9,
            1,
            4,
            0,
            -9,
            2,
            4,
            0,
            -9,
            4,
            4,
            0,
            -9,
            8
        ],
        [
            5,
            17,
            0,
            1,
            5,
            17,
            0,
            2,
            5,
            17,
            0,
            4,
            5,
            17,
            0,
            8,
            1,
            17,
            0,
            4,
            17,
            0,
            1,
            4,
            17,
            0,
            2,
            4,
            17,
            0,
            4,
            4,
            17,
            0,
            8
        ],
        [
            5,
            -15,
            0,
            1,
            5,
            -15,
            0,
            2,
            5,
            -15,
            0,
            4,
            5,
            -15,
            0,
            8,
            1,
            -15,
            0,
            4,
            -15,
            0,
            1,
            4,
            -15,
            0,
            2,
            4,
            -15,
            0,
            4,
            4,
            -15,
            0,
            8
        ],
        [
            5,
            0,
            9,
            1,
            5,
            0,
            9,
            2,
            5,
            0,
            9,
            4,
            5,
            0,
            9,
            8,
            1,
            0,
            9,
            4,
            0,
            9,
            1,
            4,
            0,
            9,
            2,
            4,
            0,
            9,
            4,
            4,
            0,
            9,
            8
        ],
        [
            5,
            -16,
            0,
            1,
            5,
            -16,
            0,
            2,
            5,
            -16,
            0,
            4,
            5,
            -16,
            0,
            8,
            1,
            -16,
            0,
            4,
            -16,
            0,
            1,
            4,
            -16,
            0,
            2,
            4,
            -16,
            0,
            4,
            4,
            -16,
            0,
            8
        ],
        [
            5,
            -17,
            0,
            1,
            5,
            -17,
            0,
            2,
            5,
            -17,
            0,
            4,
            5,
            -17,
            0,
            8,
            1,
            -17,
            0,
            4,
            -17,
            0,
            1,
            4,
            -17,
            0,
            2,
            4,
            -17,
            0,
            4,
            4,
            -17,
            0,
            8
        ],
        [
            5,
            18,
            0,
            1,
            5,
            18,
            0,
            2,
            5,
            18,
            0,
            4,
            5,
            18,
            0,
            8,
            1,
            18,
            0,
            4,
            18,
            0,
            1,
            4,
            18,
            0,
            2,
            4,
            18,
            0,
            4,
            4,
            18,
            0,
            8
        ],
        [
            5,
            0,
            10,
            1,
            5,
            0,
            10,
            2,
            5,
            0,
            10,
            4,
            5,
            0,
            10,
            8,
            1,
            0,
            10,
            4,
            0,
            10,
            1,
            4,
            0,
            10,
            2,
            4,
            0,
            10,
            4,
            4,
            0,
            10,
            8
        ],
        [
            5,
            19,
            0,
            1,
            5,
            19,
            0,
            2,
            5,
            19,
            0,
            4,
            5,
            19,
            0,
            8,
            1,
            19,
            0,
            4,
            19,
            0,
            1,
            4,
            19,
            0,
            2,
            4,
            19,
            0,
            4,
            4,
            19,
            0,
            8
        ],
        [
            5,
            0,
            -10,
            1,
            5,
            0,
            -10,
            2,
            5,
            0,
            -10,
            4,
            5,
            0,
            -10,
            8,
            1,
            0,
            -10,
            4,
            0,
            -10,
            1,
            4,
            0,
            -10,
            2,
            4,
            0,
            -10,
            4,
            4,
            0,
            -10,
            8
        ],
        [
            5,
            -18,
            0,
            1,
            5,
            -18,
            0,
            2,
            5,
            -18,
            0,
            4,
            5,
            -18,
            0,
            8,
            1,
            -18,
            0,
            4,
            -18,
            0,
            1,
            4,
            -18,
            0,
            2,
            4,
            -18,
            0,
            4,
            4,
            -18,
            0,
            8
        ],
        [
            5,
            0,
            -11,
            1,
            5,
            0,
            -11,
            2,
            5,
            0,
            -11,
            4,
            5,
            0,
            -11,
            8,
            1,
            0,
            -11,
            4,
            0,
            -11,
            1,
            4,
            0,
            -11,
            2,
            4,
            0,
            -11,
            4,
            4,
            0,
            -11,
            8
        ],
        [
            5,
            -19,
            0,
            1,
            5,
            -19,
            0,
            2,
            5,
            -19,
            0,
            4,
            5,
            -19,
            0,
            8,
            1,
            -19,
            0,
            4,
            -19,
            0,
            1,
            4,
            -19,
            0,
            2,
            4,
            -19,
            0,
            4,
            4,
            -19,
            0,
            8
        ],
        [
            5,
            -20,
            0,
            1,
            5,
            -20,
            0,
            2,
            5,
            -20,
            0,
            4,
            5,
            -20,
            0,
            8,
            1,
            -20,
            0,
            4,
            -20,
            0,
            1,
            4,
            -20,
            0,
            2,
            4,
            -20,
            0,
            4,
            4,
            -20,
            0,
            8
        ],
        [
            5,
            0,
            12,
            1,
            5,
            0,
            12,
            2,
            5,
            0,
            12,
            4,
            5,
            0,
            12,
            8,
            1,
            0,
            12,
            4,
            0,
            12,
            1,
            4,
            0,
            12,
            2,
            4,
            0,
            12,
            4,
            4,
            0,
            12,
            8
        ],
        [
            5,
            20,
            0,
            1,
            5,
            20,
            0,
            2,
            5,
            20,
            0,
            4,
            5,
            20,
            0,
            8,
            1,
            20,
            0,
            4,
            20,
            0,
            1,
            4,
            20,
            0,
            2,
            4,
            20,
            0,
            4,
            4,
            20,
            0,
            8
        ],
        [
            5,
            21,
            0,
            1,
            5,
            21,
            0,
            2,
            5,
            21,
            0,
            4,
            5,
            21,
            0,
            8,
            1,
            21,
            0,
            4,
            21,
            0,
            1,
            4,
            21,
            0,
            2,
            4,
            21,
            0,
            4,
            4,
            21,
            0,
            8
        ],
        [
            5,
            -21,
            0,
            1,
            5,
            -21,
            0,
            2,
            5,
            -21,
            0,
            4,
            5,
            -21,
            0,
            8,
            1,
            -21,
            0,
            4,
            -21,
            0,
            1,
            4,
            -21,
            0,
            2,
            4,
            -21,
            0,
            4,
            4,
            -21,
            0,
            8
        ],
        [
            5,
            0,
            -12,
            1,
            5,
            0,
            -12,
            2,
            5,
            0,
            -12,
            4,
            5,
            0,
            -12,
            8,
            1,
            0,
            -12,
            4,
            0,
            -12,
            1,
            4,
            0,
            -12,
            2,
            4,
            0,
            -12,
            4,
            4,
            0,
            -12,
            8
        ],
        [
            5,
            -22,
            0,
            1,
            5,
            -22,
            0,
            2,
            5,
            -22,
            0,
            4,
            5,
            -22,
            0,
            8,
            1,
            -22,
            0,
            4,
            -22,
            0,
            1,
            4,
            -22,
            0,
            2,
            4,
            -22,
            0,
            4,
            4,
            -22,
            0,
            8
        ],
        [
            5,
            -23,
            0,
            1,
            5,
            -23,
            0,
            2,
            5,
            -23,
            0,
            4,
            5,
            -23,
            0,
            8,
            1,
            -23,
            0,
            4,
            -23,
            0,
            1,
            4,
            -23,
            0,
            2,
            4,
            -23,
            0,
            4,
            4,
            -23,
            0,
            8
        ],
        [
            5,
            -24,
            0,
            1,
            5,
            -24,
            0,
            2,
            5,
            -24,
            0,
            4,
            5,
            -24,
            0,
            8,
            1,
            -24,
            0,
            4,
            -24,
            0,
            1,
            4,
            -24,
            0,
            2,
            4,
            -24,
            0,
            4,
            4,
            -24,
            0,
            8
        ],
        [
            5,
            22,
            0,
            1,
            5,
            22,
            0,
            2,
            5,
            22,
            0,
            4,
            5,
            22,
            0,
            8,
            1,
            22,
            0,
            4,
            22,
            0,
            1,
            4,
            22,
            0,
            2,
            4,
            22,
            0,
            4,
            4,
            22,
            0,
            8
        ],
        [
            5,
            0,
            -13,
            1,
            5,
            0,
            -13,
            2,
            5,
            0,
            -13,
            4,
            5,
            0,
            -13,
            8,
            1,
            0,
            -13,
            4,
            0,
            -13,
            1,
            4,
            0,
            -13,
            2,
            4,
            0,
            -13,
            4,
            4,
            0,
            -13,
            8
        ],
        [
            5,
            23,
            0,
            1,
            5,
            23,
            0,
            2,
            5,
            23,
            0,
            4,
            5,
            23,
            0,
            8,
            1,
            23,
            0,
            4,
            23,
            0,
            1,
            4,
            23,
            0,
            2,
            4,
            23,
            0,
            4,
            4,
            23,
            0,
            8
        ],
        [
            5,
            24,
            0,
            1,
            5,
            24,
            0,
            2,
            5,
            24,
            0,
            4,
            5,
            24,
            0,
            8,
            1,
            24,
            0,
            4,
            24,
            0,
            1,
            4,
            24,
            0,
            2,
            4,
            24,
            0,
            4,
            4,
            24,
            0,
            8
        ],
        [
            5,
            -25,
            0,
            1,
            5,
            -25,
            0,
            2,
            5,
            -25,
            0,
            4,
            5,
            -25,
            0,
            8,
            1,
            -25,
            0,
            4,
            -25,
            0,
            1,
            4,
            -25,
            0,
            2,
            4,
            -25,
            0,
            4,
            4,
            -25,
            0,
            8
        ],
        [
            5,
            -26,
            0,
            1,
            5,
            -26,
            0,
            2,
            5,
            -26,
            0,
            4,
            5,
            -26,
            0,
            8,
            1,
            -26,
            0,
            4,
            -26,
            0,
            1,
            4,
            -26,
            0,
            2,
            4,
            -26,
            0,
            4,
            4,
            -26,
            0,
            8
        ],
        [
            5,
            0,
            13,
            1,
            5,
            0,
            13,
            2,
            5,
            0,
            13,
            4,
            5,
            0,
            13,
            8,
            1,
            0,
            13,
            4,
            0,
            13,
            1,
            4,
            0,
            13,
            2,
            4,
            0,
            13,
            4,
            4,
            0,
            13,
            8
        ],
        [
            5,
            0,
            -14,
            1,
            5,
            0,
            -14,
            2,
            5,
            0,
            -14,
            4,
            5,
            0,
            -14,
            8,
            1,
            0,
            -14,
            4,
            0,
            -14,
            1,
            4,
            0,
            -14,
            2,
            4,
            0,
            -14,
            4,
            4,
            0,
            -14,
            8
        ],
        [
            5,
            25,
            0,
            1,
            5,
            25,
            0,
            2,
            5,
            25,
            0,
            4,
            5,
            25,
            0,
            8,
            1,
            25,
            0,
            4,
            25,
            0,
            1,
            4,
            25,
            0,
            2,
            4,
            25,
            0,
            4,
            4,
            25,
            0,
            8
        ],
        [
            5,
            26,
            0,
            1,
            5,
            26,
            0,
            2,
            5,
            26,
            0,
            4,
            5,
            26,
            0,
            8,
            1,
            26,
            0,
            4,
            26,
            0,
            1,
            4,
            26,
            0,
            2,
            4,
            26,
            0,
            4,
            4,
            26,
            0,
            8
        ],
        [
            5,
            27,
            0,
            1,
            5,
            27,
            0,
            2,
            5,
            27,
            0,
            4,
            5,
            27,
            0,
            8,
            1,
            27,
            0,
            4,
            27,
            0,
            1,
            4,
            27,
            0,
            2,
            4,
            27,
            0,
            4,
            4,
            27,
            0,
            8
        ],
        [
            5,
            -27,
            0,
            1,
            5,
            -27,
            0,
            2,
            5,
            -27,
            0,
            4,
            5,
            -27,
            0,
            8,
            1,
            -27,
            0,
            4,
            -27,
            0,
            1,
            4,
            -27,
            0,
            2,
            4,
            -27,
            0,
            4,
            4,
            -27,
            0,
            8
        ],
        [
            5,
            -28,
            0,
            1,
            5,
            -28,
            0,
            2,
            5,
            -28,
            0,
            4,
            5,
            -28,
            0,
            8,
            1,
            -28,
            0,
            4,
            -28,
            0,
            1,
            4,
            -28,
            0,
            2,
            4,
            -28,
            0,
            4,
            4,
            -28,
            0,
            8
        ],
        [
            5,
            0,
            14,
            1,
            5,
            0,
            14,
            2,
            5,
            0,
            14,
            4,
            5,
            0,
            14,
            8,
            1,
            0,
            14,
            4,
            0,
            14,
            1,
            4,
            0,
            14,
            2,
            4,
            0,
            14,
            4,
            4,
            0,
            14,
            8
        ],
        [
            5,
            0,
            -15,
            1,
            5,
            0,
            -15,
            2,
            5,
            0,
            -15,
            4,
            5,
            0,
            -15,
            8,
            1,
            0,
            -15,
            4,
            0,
            -15,
            1,
            4,
            0,
            -15,
            2,
            4,
            0,
            -15,
            4,
            4,
            0,
            -15,
            8
        ],
        [
            5,
            28,
            0,
            1,
            5,
            28,
            0,
            2,
            5,
            28,
            0,
            4,
            5,
            28,
            0,
            8,
            1,
            28,
            0,
            4,
            28,
            0,
            1,
            4,
            28,
            0,
            2,
            4,
            28,
            0,
            4,
            4,
            28,
            0,
            8
        ],
        [
            5,
            0,
            -16,
            1,
            5,
            0,
            -16,
            2,
            5,
            0,
            -16,
            4,
            5,
            0,
            -16,
            8,
            1,
            0,
            -16,
            4,
            0,
            -16,
            1,
            4,
            0,
            -16,
            2,
            4,
            0,
            -16,
            4,
            4,
            0,
            -16,
            8
        ],
        [
            5,
            0,
            15,
            1,
            5,
            0,
            15,
            2,
            5,
            0,
            15,
            4,
            5,
            0,
            15,
            8,
            1,
            0,
            15,
            4,
            0,
            15,
            1,
            4,
            0,
            15,
            2,
            4,
            0,
            15,
            4,
            4,
            0,
            15,
            8
        ],
        [
            5,
            -29,
            0,
            1,
            5,
            -29,
            0,
            2,
            5,
            -29,
            0,
            4,
            5,
            -29,
            0,
            8,
            1,
            -29,
            0,
            4,
            -29,
            0,
            1,
            4,
            -29,
            0,
            2,
            4,
            -29,
            0,
            4,
            4,
            -29,
            0,
            8
        ],
        [
            5,
            0,
            16,
            1,
            5,
            0,
            16,
            2,
            5,
            0,
            16,
            4,
            5,
            0,
            16,
            8,
            1,
            0,
            16,
            4,
            0,
            16,
            1,
            4,
            0,
            16,
            2,
            4,
            0,
            16,
            4,
            4,
            0,
            16,
            8
        ],
        [
            5,
            29,
            0,
            1,
            5,
            29,
            0,
            2,
            5,
            29,
            0,
            4,
            5,
            29,
            0,
            8,
            1,
            29,
            0,
            4,
            29,
            0,
            1,
            4,
            29,
            0,
            2,
            4,
            29,
            0,
            4,
            4,
            29,
            0,
            8
        ],
        [
            5,
            30,
            0,
            1,
            5,
            30,
            0,
            2,
            5,
            30,
            0,
            4,
            5,
            30,
            0,
            8,
            1,
            30,
            0,
            4,
            30,
            0,
            1,
            4,
            30,
            0,
            2,
            4,
            30,
            0,
            4,
            4,
            30,
            0,
            8
        ],
        [
            5,
            31,
            0,
            1,
            5,
            31,
            0,
            2,
            5,
            31,
            0,
            4,
            5,
            31,
            0,
            8,
            1,
            31,
            0,
            4,
            31,
            0,
            1,
            4,
            31,
            0,
            2,
            4,
            31,
            0,
            4,
            4,
            31,
            0,
            8
        ],
        [
            5,
            32,
            0,
            1,
            5,
            32,
            0,
            2,
            5,
            32,
            0,
            4,
            5,
            32,
            0,
            8,
            1,
            32,
            0,
            4,
            32,
            0,
            1,
            4,
            32,
            0,
            2,
            4,
            32,
            0,
            4,
            4,
            32,
            0,
            8
        ],
        [
            5,
            -30,
            0,
            1,
            5,
            -30,
            0,
            2,
            5,
            -30,
            0,
            4,
            5,
            -30,
            0,
            8,
            1,
            -30,
            0,
            4,
            -30,
            0,
            1,
            4,
            -30,
            0,
            2,
            4,
            -30,
            0,
            4,
            4,
            -30,
            0,
            8
        ],
        [
            5,
            -31,
            0,
            1,
            5,
            -31,
            0,
            2,
            5,
            -31,
            0,
            4,
            5,
            -31,
            0,
            8,
            1,
            -31,
            0,
            4,
            -31,
            0,
            1,
            4,
            -31,
            0,
            2,
            4,
            -31,
            0,
            4,
            4,
            -31,
            0,
            8
        ],
        [
            5,
            0,
            17,
            1,
            5,
            0,
            17,
            2,
            5,
            0,
            17,
            4,
            5,
            0,
            17,
            8,
            1,
            0,
            17,
            4,
            0,
            17,
            1,
            4,
            0,
            17,
            2,
            4,
            0,
            17,
            4,
            4,
            0,
            17,
            8
        ],
        [
            5,
            33,
            0,
            1,
            5,
            33,
            0,
            2,
            5,
            33,
            0,
            4,
            5,
            33,
            0,
            8,
            1,
            33,
            0,
            4,
            33,
            0,
            1,
            4,
            33,
            0,
            2,
            4,
            33,
            0,
            4,
            4,
            33,
            0,
            8
        ],
        [
            5,
            0,
            -17,
            1,
            5,
            0,
            -17,
            2,
            5,
            0,
            -17,
            4,
            5,
            0,
            -17,
            8,
            1,
            0,
            -17,
            4,
            0,
            -17,
            1,
            4,
            0,
            -17,
            2,
            4,
            0,
            -17,
            4,
            4,
            0,
            -17,
            8
        ],
        [
            5,
            34,
            0,
            1,
            5,
            34,
            0,
            2,
            5,
            34,
            0,
            4,
            5,
            34,
            0,
            8,
            1,
            34,
            0,
            4,
            34,
            0,
            1,
            4,
            34,
            0,
            2,
            4,
            34,
            0,
            4,
            4,
            34,
            0,
            8
        ],
        [
            5,
            -32,
            0,
            1,
            5,
            -32,
            0,
            2,
            5,
            -32,
            0,
            4,
            5,
            -32,
            0,
            8,
            1,
            -32,
            0,
            4,
            -32,
            0,
            1,
            4,
            -32,
            0,
            2,
            4,
            -32,
            0,
            4,
            4,
            -32,
            0,
            8
        ],
        [
            5,
            0,
            -18,
            1,
            5,
            0,
            -18,
            2,
            5,
            0,
            -18,
            4,
            5,
            0,
            -18,
            8,
            1,
            0,
            -18,
            4,
            0,
            -18,
            1,
            4,
            0,
            -18,
            2,
            4,
            0,
            -18,
            4,
            4,
            0,
            -18,
            8
        ],
        [
            5,
            0,
            18,
            1,
            5,
            0,
            18,
            2,
            5,
            0,
            18,
            4,
            5,
            0,
            18,
            8,
            1,
            0,
            18,
            4,
            0,
            18,
            1,
            4,
            0,
            18,
            2,
            4,
            0,
            18,
            4,
            4,
            0,
            18,
            8
        ],
        [
            5,
            -33,
            0,
            1,
            5,
            -33,
            0,
            2,
            5,
            -33,
            0,
            4,
            5,
            -33,
            0,
            8,
            1,
            -33,
            0,
            4,
            -33,
            0,
            1,
            4,
            -33,
            0,
            2,
            4,
            -33,
            0,
            4,
            4,
            -33,
            0,
            8
        ],
        [
            5,
            35,
            0,
            1,
            5,
            35,
            0,
            2,
            5,
            35,
            0,
            4,
            5,
            35,
            0,
            8,
            1,
            35,
            0,
            4,
            35,
            0,
            1,
            4,
            35,
            0,
            2,
            4,
            35,
            0,
            4,
            4,
            35,
            0,
            8
        ],
        [
            5,
            36,
            0,
            1,
            5,
            36,
            0,
            2,
            5,
            36,
            0,
            4,
            5,
            36,
            0,
            8,
            1,
            36,
            0,
            4,
            36,
            0,
            1,
            4,
            36,
            0,
            2,
            4,
            36,
            0,
            4,
            4,
            36,
            0,
            8
        ],
        [
            5,
            -34,
            0,
            1,
            5,
            -34,
            0,
            2,
            5,
            -34,
            0,
            4,
            5,
            -34,
            0,
            8,
            1,
            -34,
            0,
            4,
            -34,
            0,
            1,
            4,
            -34,
            0,
            2,
            4,
            -34,
            0,
            4,
            4,
            -34,
            0,
            8
        ],
        [
            5,
            0,
            19,
            1,
            5,
            0,
            19,
            2,
            5,
            0,
            19,
            4,
            5,
            0,
            19,
            8,
            1,
            0,
            19,
            4,
            0,
            19,
            1,
            4,
            0,
            19,
            2,
            4,
            0,
            19,
            4,
            4,
            0,
            19,
            8
        ],
        [
            5,
            0,
            -19,
            1,
            5,
            0,
            -19,
            2,
            5,
            0,
            -19,
            4,
            5,
            0,
            -19,
            8,
            1,
            0,
            -19,
            4,
            0,
            -19,
            1,
            4,
            0,
            -19,
            2,
            4,
            0,
            -19,
            4,
            4,
            0,
            -19,
            8
        ],
        [
            5,
            37,
            0,
            1,
            5,
            37,
            0,
            2,
            5,
            37,
            0,
            4,
            5,
            37,
            0,
            8,
            1,
            37,
            0,
            4,
            37,
            0,
            1,
            4,
            37,
            0,
            2,
            4,
            37,
            0,
            4,
            4,
            37,
            0,
            8
        ],
        [
            5,
            -35,
            0,
            1,
            5,
            -35,
            0,
            2,
            5,
            -35,
            0,
            4,
            5,
            -35,
            0,
            8,
            1,
            -35,
            0,
            4,
            -35,
            0,
            1,
            4,
            -35,
            0,
            2,
            4,
            -35,
            0,
            4,
            4,
            -35,
            0,
            8
        ],
        [
            5,
            -36,
            0,
            1,
            5,
            -36,
            0,
            2,
            5,
            -36,
            0,
            4,
            5,
            -36,
            0,
            8,
            1,
            -36,
            0,
            4,
            -36,
            0,
            1,
            4,
            -36,
            0,
            2,
            4,
            -36,
            0,
            4,
            4,
            -36,
            0,
            8
        ],
        [
            5,
            0,
            -20,
            1,
            5,
            0,
            -20,
            2,
            5,
            0,
            -20,
            4,
            5,
            0,
            -20,
            8,
            1,
            0,
            -20,
            4,
            0,
            -20,
            1,
            4,
            0,
            -20,
            2,
            4,
            0,
            -20,
            4,
            4,
            0,
            -20,
            8
        ],
        [
            5,
            0,
            20,
            1,
            5,
            0,
            20,
            2,
            5,
            0,
            20,
            4,
            5,
            0,
            20,
            8,
            1,
            0,
            20,
            4,
            0,
            20,
            1,
            4,
            0,
            20,
            2,
            4,
            0,
            20,
            4,
            4,
            0,
            20,
            8
        ],
        [
            5,
            38,
            0,
            1,
            5,
            38,
            0,
            2,
            5,
            38,
            0,
            4,
            5,
            38,
            0,
            8,
            1,
            38,
            0,
            4,
            38,
            0,
            1,
            4,
            38,
            0,
            2,
            4,
            38,
            0,
            4,
            4,
            38,
            0,
            8
        ],
        [
            5,
            -37,
            0,
            1,
            5,
            -37,
            0,
            2,
            5,
            -37,
            0,
            4,
            5,
            -37,
            0,
            8,
            1,
            -37,
            0,
            4,
            -37,
            0,
            1,
            4,
            -37,
            0,
            2,
            4,
            -37,
            0,
            4,
            4,
            -37,
            0,
            8
        ],
        [
            5,
            -38,
            0,
            1,
            5,
            -38,
            0,
            2,
            5,
            -38,
            0,
            4,
            5,
            -38,
            0,
            8,
            1,
            -38,
            0,
            4,
            -38,
            0,
            1,
            4,
            -38,
            0,
            2,
            4,
            -38,
            0,
            4,
            4,
            -38,
            0,
            8
        ],
        [
            5,
            39,
            0,
            1,
            5,
            39,
            0,
            2,
            5,
            39,
            0,
            4,
            5,
            39,
            0,
            8,
            1,
            39,
            0,
            4,
            39,
            0,
            1,
            4,
            39,
            0,
            2,
            4,
            39,
            0,
            4,
            4,
            39,
            0,
            8
        ],
        [
            5,
            40,
            0,
            1,
            5,
            40,
            0,
            2,
            5,
            40,
            0,
            4,
            5,
            40,
            0,
            8,
            1,
            40,
            0,
            4,
            40,
            0,
            1,
            4,
            40,
            0,
            2,
            4,
            40,
            0,
            4,
            4,
            40,
            0,
            8
        ],
        [
            5,
            41,
            0,
            1,
            5,
            41,
            0,
            2,
            5,
            41,
            0,
            4,
            5,
            41,
            0,
            8,
            1,
            41,
            0,
            4,
            41,
            0,
            1,
            4,
            41,
            0,
            2,
            4,
            41,
            0,
            4,
            4,
            41,
            0,
            8
        ],
        [
            5,
            -39,
            0,
            1,
            5,
            -39,
            0,
            2,
            5,
            -39,
            0,
            4,
            5,
            -39,
            0,
            8,
            1,
            -39,
            0,
            4,
            -39,
            0,
            1,
            4,
            -39,
            0,
            2,
            4,
            -39,
            0,
            4,
            4,
            -39,
            0,
            8
        ],
        [
            5,
            42,
            0,
            1,
            5,
            42,
            0,
            2,
            5,
            42,
            0,
            4,
            5,
            42,
            0,
            8,
            1,
            42,
            0,
            4,
            42,
            0,
            1,
            4,
            42,
            0,
            2,
            4,
            42,
            0,
            4,
            4,
            42,
            0,
            8
        ],
        [
            5,
            -40,
            0,
            1,
            5,
            -40,
            0,
            2,
            5,
            -40,
            0,
            4,
            5,
            -40,
            0,
            8,
            1,
            -40,
            0,
            4,
            -40,
            0,
            1,
            4,
            -40,
            0,
            2,
            4,
            -40,
            0,
            4,
            4,
            -40,
            0,
            8
        ],
        [
            5,
            -41,
            0,
            1,
            5,
            -41,
            0,
            2,
            5,
            -41,
            0,
            4,
            5,
            -41,
            0,
            8,
            1,
            -41,
            0,
            4,
            -41,
            0,
            1,
            4,
            -41,
            0,
            2,
            4,
            -41,
            0,
            4,
            4,
            -41,
            0,
            8
        ],
        [
            5,
            0,
            21,
            1,
            5,
            0,
            21,
            2,
            5,
            0,
            21,
            4,
            5,
            0,
            21,
            8,
            1,
            0,
            21,
            4,
            0,
            21,
            1,
            4,
            0,
            21,
            2,
            4,
            0,
            21,
            4,
            4,
            0,
            21,
            8
        ],
        [
            5,
            0,
            22,
            1,
            5,
            0,
            22,
            2,
            5,
            0,
            22,
            4,
            5,
            0,
            22,
            8,
            1,
            0,
            22,
            4,
            0,
            22,
            1,
            4,
            0,
            22,
            2,
            4,
            0,
            22,
            4,
            4,
            0,
            22,
            8
        ],
        [
            5,
            0,
            -21,
            1,
            5,
            0,
            -21,
            2,
            5,
            0,
            -21,
            4,
            5,
            0,
            -21,
            8,
            1,
            0,
            -21,
            4,
            0,
            -21,
            1,
            4,
            0,
            -21,
            2,
            4,
            0,
            -21,
            4,
            4,
            0,
            -21,
            8
        ],
        [
            5,
            0,
            -22,
            1,
            5,
            0,
            -22,
            2,
            5,
            0,
            -22,
            4,
            5,
            0,
            -22,
            8,
            1,
            0,
            -22,
            4,
            0,
            -22,
            1,
            4,
            0,
            -22,
            2,
            4,
            0,
            -22,
            4,
            4,
            0,
            -22,
            8
        ],
        [
            5,
            -42,
            0,
            1,
            5,
            -42,
            0,
            2,
            5,
            -42,
            0,
            4,
            5,
            -42,
            0,
            8,
            1,
            -42,
            0,
            4,
            -42,
            0,
            1,
            4,
            -42,
            0,
            2,
            4,
            -42,
            0,
            4,
            4,
            -42,
            0,
            8
        ],
        [
            5,
            0,
            23,
            1,
            5,
            0,
            23,
            2,
            5,
            0,
            23,
            4,
            5,
            0,
            23,
            8,
            1,
            0,
            23,
            4,
            0,
            23,
            1,
            4,
            0,
            23,
            2,
            4,
            0,
            23,
            4,
            4,
            0,
            23,
            8
        ],
        [
            5,
            0,
            -23,
            1,
            5,
            0,
            -23,
            2,
            5,
            0,
            -23,
            4,
            5,
            0,
            -23,
            8,
            1,
            0,
            -23,
            4,
            0,
            -23,
            1,
            4,
            0,
            -23,
            2,
            4,
            0,
            -23,
            4,
            4,
            0,
            -23,
            8
        ],
        [
            5,
            43,
            0,
            1,
            5,
            43,
            0,
            2,
            5,
            43,
            0,
            4,
            5,
            43,
            0,
            8,
            1,
            43,
            0,
            4,
            43,
            0,
            1,
            4,
            43,
            0,
            2,
            4,
            43,
            0,
            4,
            4,
            43,
            0,
            8
        ],
        [
            5,
            -43,
            0,
            1,
            5,
            -43,
            0,
            2,
            5,
            -43,
            0,
            4,
            5,
            -43,
            0,
            8,
            1,
            -43,
            0,
            4,
            -43,
            0,
            1,
            4,
            -43,
            0,
            2,
            4,
            -43,
            0,
            4,
            4,
            -43,
            0,
            8
        ],
        [
            5,
            -44,
            0,
            1,
            5,
            -44,
            0,
            2,
            5,
            -44,
            0,
            4,
            5,
            -44,
            0,
            8,
            1,
            -44,
            0,
            4,
            -44,
            0,
            1,
            4,
            -44,
            0,
            2,
            4,
            -44,
            0,
            4,
            4,
            -44,
            0,
            8
        ],
        [
            5,
            44,
            0,
            1,
            5,
            44,
            0,
            2,
            5,
            44,
            0,
            4,
            5,
            44,
            0,
            8,
            1,
            44,
            0,
            4,
            44,
            0,
            1,
            4,
            44,
            0,
            2,
            4,
            44,
            0,
            4,
            4,
            44,
            0,
            8
        ],
        [
            5,
            0,
            -24,
            1,
            5,
            0,
            -24,
            2,
            5,
            0,
            -24,
            4,
            5,
            0,
            -24,
            8,
            1,
            0,
            -24,
            4,
            0,
            -24,
            1,
            4,
            0,
            -24,
            2,
            4,
            0,
            -24,
            4,
            4,
            0,
            -24,
            8
        ],
        [
            5,
            0,
            24,
            1,
            5,
            0,
            24,
            2,
            5,
            0,
            24,
            4,
            5,
            0,
            24,
            8,
            1,
            0,
            24,
            4,
            0,
            24,
            1,
            4,
            0,
            24,
            2,
            4,
            0,
            24,
            4,
            4,
            0,
            24,
            8
        ],
        [
            5,
            -45,
            0,
            1,
            5,
            -45,
            0,
            2,
            5,
            -45,
            0,
            4,
            5,
            -45,
            0,
            8,
            1,
            -45,
            0,
            4,
            -45,
            0,
            1,
            4,
            -45,
            0,
            2,
            4,
            -45,
            0,
            4,
            4,
            -45,
            0,
            8
        ],
        [
            5,
            -46,
            0,
            1,
            5,
            -46,
            0,
            2,
            5,
            -46,
            0,
            4,
            5,
            -46,
            0,
            8,
            1,
            -46,
            0,
            4,
            -46,
            0,
            1,
            4,
            -46,
            0,
            2,
            4,
            -46,
            0,
            4,
            4,
            -46,
            0,
            8
        ],
        [
            5,
            45,
            0,
            1,
            5,
            45,
            0,
            2,
            5,
            45,
            0,
            4,
            5,
            45,
            0,
            8,
            1,
            45,
            0,
            4,
            45,
            0,
            1,
            4,
            45,
            0,
            2,
            4,
            45,
            0,
            4,
            4,
            45,
            0,
            8
        ],
        [
            5,
            46,
            0,
            1,
            5,
            46,
            0,
            2,
            5,
            46,
            0,
            4,
            5,
            46,
            0,
            8,
            1,
            46,
            0,
            4,
            46,
            0,
            1,
            4,
            46,
            0,
            2,
            4,
            46,
            0,
            4,
            4,
            46,
            0,
            8
        ],
        [
            5,
            47,
            0,
            1,
            5,
            47,
            0,
            2,
            5,
            47,
            0,
            4,
            5,
            47,
            0,
            8,
            1,
            47,
            0,
            4,
            47,
            0,
            1,
            4,
            47,
            0,
            2,
            4,
            47,
            0,
            4,
            4,
            47,
            0,
            8
        ],
        [
            5,
            0,
            -25,
            1,
            5,
            0,
            -25,
            2,
            5,
            0,
            -25,
            4,
            5,
            0,
            -25,
            8,
            1,
            0,
            -25,
            4,
            0,
            -25,
            1,
            4,
            0,
            -25,
            2,
            4,
            0,
            -25,
            4,
            4,
            0,
            -25,
            8
        ],
        [
            5,
            48,
            0,
            1,
            5,
            48,
            0,
            2,
            5,
            48,
            0,
            4,
            5,
            48,
            0,
            8,
            1,
            48,
            0,
            4,
            48,
            0,
            1,
            4,
            48,
            0,
            2,
            4,
            48,
            0,
            4,
            4,
            48,
            0,
            8
        ],
        [
            5,
            -47,
            0,
            1,
            5,
            -47,
            0,
            2,
            5,
            -47,
            0,
            4,
            5,
            -47,
            0,
            8,
            1,
            -47,
            0,
            4,
            -47,
            0,
            1,
            4,
            -47,
            0,
            2,
            4,
            -47,
            0,
            4,
            4,
            -47,
            0,
            8
        ],
        [
            5,
            49,
            0,
            1,
            5,
            49,
            0,
            2,
            5,
            49,
            0,
            4,
            5,
            49,
            0,
            8,
            1,
            49,
            0,
            4,
            49,
            0,
            1,
            4,
            49,
            0,
            2,
            4,
            49,
            0,
            4,
            4,
            49,
            0,
            8
        ],
        [
            5,
            -48,
            0,
            1,
            5,
            -48,
            0,
            2,
            5,
            -48,
            0,
            4,
            5,
            -48,
            0,
            8,
            1,
            -48,
            0,
            4,
            -48,
            0,
            1,
            4,
            -48,
            0,
            2,
            4,
            -48,
            0,
            4,
            4,
            -48,
            0,
            8
        ],
        [
            5,
            -49,
            0,
            1,
            5,
            -49,
            0,
            2,
            5,
            -49,
            0,
            4,
            5,
            -49,
            0,
            8,
            1,
            -49,
            0,
            4,
            -49,
            0,
            1,
            4,
            -49,
            0,
            2,
            4,
            -49,
            0,
            4,
            4,
            -49,
            0,
            8
        ],
        [
            5,
            -50,
            0,
            1,
            5,
            -50,
            0,
            2,
            5,
            -50,
            0,
            4,
            5,
            -50,
            0,
            8,
            1,
            -50,
            0,
            4,
            -50,
            0,
            1,
            4,
            -50,
            0,
            2,
            4,
            -50,
            0,
            4,
            4,
            -50,
            0,
            8
        ],
        [
            5,
            50,
            0,
            1,
            5,
            50,
            0,
            2,
            5,
            50,
            0,
            4,
            5,
            50,
            0,
            8,
            1,
            50,
            0,
            4,
            50,
            0,
            1,
            4,
            50,
            0,
            2,
            4,
            50,
            0,
            4,
            4,
            50,
            0,
            8
        ],
        [
            5,
            0,
            -26,
            1,
            5,
            0,
            -26,
            2,
            5,
            0,
            -26,
            4,
            5,
            0,
            -26,
            8,
            1,
            0,
            -26,
            4,
            0,
            -26,
            1,
            4,
            0,
            -26,
            2,
            4,
            0,
            -26,
            4,
            4,
            0,
            -26,
            8
        ],
        [
            5,
            -51,
            0,
            1,
            5,
            -51,
            0,
            2,
            5,
            -51,
            0,
            4,
            5,
            -51,
            0,
            8,
            1,
            -51,
            0,
            4,
            -51,
            0,
            1,
            4,
            -51,
            0,
            2,
            4,
            -51,
            0,
            4,
            4,
            -51,
            0,
            8
        ],
        [
            5,
            51,
            0,
            1,
            5,
            51,
            0,
            2,
            5,
            51,
            0,
            4,
            5,
            51,
            0,
            8,
            1,
            51,
            0,
            4,
            51,
            0,
            1,
            4,
            51,
            0,
            2,
            4,
            51,
            0,
            4,
            4,
            51,
            0,
            8
        ],
        [
            5,
            52,
            0,
            1,
            5,
            52,
            0,
            2,
            5,
            52,
            0,
            4,
            5,
            52,
            0,
            8,
            1,
            52,
            0,
            4,
            52,
            0,
            1,
            4,
            52,
            0,
            2,
            4,
            52,
            0,
            4,
            4,
            52,
            0,
            8
        ],
        [
            5,
            0,
            25,
            1,
            5,
            0,
            25,
            2,
            5,
            0,
            25,
            4,
            5,
            0,
            25,
            8,
            1,
            0,
            25,
            4,
            0,
            25,
            1,
            4,
            0,
            25,
            2,
            4,
            0,
            25,
            4,
            4,
            0,
            25,
            8
        ],
        [
            5,
            0,
            -27,
            1,
            5,
            0,
            -27,
            2,
            5,
            0,
            -27,
            4,
            5,
            0,
            -27,
            8,
            1,
            0,
            -27,
            4,
            0,
            -27,
            1,
            4,
            0,
            -27,
            2,
            4,
            0,
            -27,
            4,
            4,
            0,
            -27,
            8
        ],
        [
            5,
            53,
            0,
            1,
            5,
            53,
            0,
            2,
            5,
            53,
            0,
            4,
            5,
            53,
            0,
            8,
            1,
            53,
            0,
            4,
            53,
            0,
            1,
            4,
            53,
            0,
            2,
            4,
            53,
            0,
            4,
            4,
            53,
            0,
            8
        ],
        [
            5,
            54,
            0,
            1,
            5,
            54,
            0,
            2,
            5,
            54,
            0,
            4,
            5,
            54,
            0,
            8,
            1,
            54,
            0,
            4,
            54,
            0,
            1,
            4,
            54,
            0,
            2,
            4,
            54,
            0,
            4,
            4,
            54,
            0,
            8
        ],
        [
            5,
            -52,
            0,
            1,
            5,
            -52,
            0,
            2,
            5,
            -52,
            0,
            4,
            5,
            -52,
            0,
            8,
            1,
            -52,
            0,
            4,
            -52,
            0,
            1,
            4,
            -52,
            0,
            2,
            4,
            -52,
            0,
            4,
            4,
            -52,
            0,
            8
        ],
        [
            5,
            0,
            26,
            1,
            5,
            0,
            26,
            2,
            5,
            0,
            26,
            4,
            5,
            0,
            26,
            8,
            1,
            0,
            26,
            4,
            0,
            26,
            1,
            4,
            0,
            26,
            2,
            4,
            0,
            26,
            4,
            4,
            0,
            26,
            8
        ],
        [
            5,
            -53,
            0,
            1,
            5,
            -53,
            0,
            2,
            5,
            -53,
            0,
            4,
            5,
            -53,
            0,
            8,
            1,
            -53,
            0,
            4,
            -53,
            0,
            1,
            4,
            -53,
            0,
            2,
            4,
            -53,
            0,
            4,
            4,
            -53,
            0,
            8
        ],
        [
            5,
            0,
            27,
            1,
            5,
            0,
            27,
            2,
            5,
            0,
            27,
            4,
            5,
            0,
            27,
            8,
            1,
            0,
            27,
            4,
            0,
            27,
            1,
            4,
            0,
            27,
            2,
            4,
            0,
            27,
            4,
            4,
            0,
            27,
            8
        ],
        [
            5,
            55,
            0,
            1,
            5,
            55,
            0,
            2,
            5,
            55,
            0,
            4,
            5,
            55,
            0,
            8,
            1,
            55,
            0,
            4,
            55,
            0,
            1,
            4,
            55,
            0,
            2,
            4,
            55,
            0,
            4,
            4,
            55,
            0,
            8
        ],
        [
            5,
            56,
            0,
            1,
            5,
            56,
            0,
            2,
            5,
            56,
            0,
            4,
            5,
            56,
            0,
            8,
            1,
            56,
            0,
            4,
            56,
            0,
            1,
            4,
            56,
            0,
            2,
            4,
            56,
            0,
            4,
            4,
            56,
            0,
            8
        ],
        [
            5,
            0,
            -28,
            1,
            5,
            0,
            -28,
            2,
            5,
            0,
            -28,
            4,
            5,
            0,
            -28,
            8,
            1,
            0,
            -28,
            4,
            0,
            -28,
            1,
            4,
            0,
            -28,
            2,
            4,
            0,
            -28,
            4,
            4,
            0,
            -28,
            8
        ],
        [
            5,
            -54,
            0,
            1,
            5,
            -54,
            0,
            2,
            5,
            -54,
            0,
            4,
            5,
            -54,
            0,
            8,
            1,
            -54,
            0,
            4,
            -54,
            0,
            1,
            4,
            -54,
            0,
            2,
            4,
            -54,
            0,
            4,
            4,
            -54,
            0,
            8
        ],
        [
            5,
            57,
            0,
            1,
            5,
            57,
            0,
            2,
            5,
            57,
            0,
            4,
            5,
            57,
            0,
            8,
            1,
            57,
            0,
            4,
            57,
            0,
            1,
            4,
            57,
            0,
            2,
            4,
            57,
            0,
            4,
            4,
            57,
            0,
            8
        ],
        [
            5,
            0,
            28,
            1,
            5,
            0,
            28,
            2,
            5,
            0,
            28,
            4,
            5,
            0,
            28,
            8,
            1,
            0,
            28,
            4,
            0,
            28,
            1,
            4,
            0,
            28,
            2,
            4,
            0,
            28,
            4,
            4,
            0,
            28,
            8
        ],
        [
            5,
            0,
            29,
            1,
            5,
            0,
            29,
            2,
            5,
            0,
            29,
            4,
            5,
            0,
            29,
            8,
            1,
            0,
            29,
            4,
            0,
            29,
            1,
            4,
            0,
            29,
            2,
            4,
            0,
            29,
            4,
            4,
            0,
            29,
            8
        ],
        [
            5,
            -55,
            0,
            1,
            5,
            -55,
            0,
            2,
            5,
            -55,
            0,
            4,
            5,
            -55,
            0,
            8,
            1,
            -55,
            0,
            4,
            -55,
            0,
            1,
            4,
            -55,
            0,
            2,
            4,
            -55,
            0,
            4,
            4,
            -55,
            0,
            8
        ],
        [
            5,
            58,
            0,
            1,
            5,
            58,
            0,
            2,
            5,
            58,
            0,
            4,
            5,
            58,
            0,
            8,
            1,
            58,
            0,
            4,
            58,
            0,
            1,
            4,
            58,
            0,
            2,
            4,
            58,
            0,
            4,
            4,
            58,
            0,
            8
        ],
        [
            5,
            -56,
            0,
            1,
            5,
            -56,
            0,
            2,
            5,
            -56,
            0,
            4,
            5,
            -56,
            0,
            8,
            1,
            -56,
            0,
            4,
            -56,
            0,
            1,
            4,
            -56,
            0,
            2,
            4,
            -56,
            0,
            4,
            4,
            -56,
            0,
            8
        ],
        [
            5,
            -57,
            0,
            1,
            5,
            -57,
            0,
            2,
            5,
            -57,
            0,
            4,
            5,
            -57,
            0,
            8,
            1,
            -57,
            0,
            4,
            -57,
            0,
            1,
            4,
            -57,
            0,
            2,
            4,
            -57,
            0,
            4,
            4,
            -57,
            0,
            8
        ],
        [
            5,
            59,
            0,
            1,
            5,
            59,
            0,
            2,
            5,
            59,
            0,
            4,
            5,
            59,
            0,
            8,
            1,
            59,
            0,
            4,
            59,
            0,
            1,
            4,
            59,
            0,
            2,
            4,
            59,
            0,
            4,
            4,
            59,
            0,
            8
        ],
        [
            5,
            -58,
            0,
            1,
            5,
            -58,
            0,
            2,
            5,
            -58,
            0,
            4,
            5,
            -58,
            0,
            8,
            1,
            -58,
            0,
            4,
            -58,
            0,
            1,
            4,
            -58,
            0,
            2,
            4,
            -58,
            0,
            4,
            4,
            -58,
            0,
            8
        ],
        [
            5,
            0,
            30,
            1,
            5,
            0,
            30,
            2,
            5,
            0,
            30,
            4,
            5,
            0,
            30,
            8,
            1,
            0,
            30,
            4,
            0,
            30,
            1,
            4,
            0,
            30,
            2,
            4,
            0,
            30,
            4,
            4,
            0,
            30,
            8
        ],
        [
            5,
            60,
            0,
            1,
            5,
            60,
            0,
            2,
            5,
            60,
            0,
            4,
            5,
            60,
            0,
            8,
            1,
            60,
            0,
            4,
            60,
            0,
            1,
            4,
            60,
            0,
            2,
            4,
            60,
            0,
            4,
            4,
            60,
            0,
            8
        ],
        [
            5,
            -59,
            0,
            1,
            5,
            -59,
            0,
            2,
            5,
            -59,
            0,
            4,
            5,
            -59,
            0,
            8,
            1,
            -59,
            0,
            4,
            -59,
            0,
            1,
            4,
            -59,
            0,
            2,
            4,
            -59,
            0,
            4,
            4,
            -59,
            0,
            8
        ],
        [
            5,
            -60,
            0,
            1,
            5,
            -60,
            0,
            2,
            5,
            -60,
            0,
            4,
            5,
            -60,
            0,
            8,
            1,
            -60,
            0,
            4,
            -60,
            0,
            1,
            4,
            -60,
            0,
            2,
            4,
            -60,
            0,
            4,
            4,
            -60,
            0,
            8
        ],
        [
            5,
            0,
            -29,
            1,
            5,
            0,
            -29,
            2,
            5,
            0,
            -29,
            4,
            5,
            0,
            -29,
            8,
            1,
            0,
            -29,
            4,
            0,
            -29,
            1,
            4,
            0,
            -29,
            2,
            4,
            0,
            -29,
            4,
            4,
            0,
            -29,
            8
        ],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        []
    ]
};
// --- QuantizedPulseEffect.js ---
class QuantizedPulseEffect extends QuantizedBaseEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "QuantizedPulse";
        this.active = false;
        this.configPrefix = "quantizedPulse";
        this.timer = 0;
        this.state = 'IDLE'; // IDLE, FADE_IN, SUSTAIN, FADE_OUT
        this.alpha = 0.0;
        // Grid properties
        this.offsetX = 0;
        this.offsetY = 0;
        // Animation Sequence Data
        this.sequence = [[]]; 
        this.expansionPhase = 0;
        this.maskOps = [];
        this.editorHighlight = false;
        // Flicker Fix: Swap Transition State
        this.isSwapping = false;
        this.swapTimer = 0;
    }
    trigger(force = false) {
        // 1. Strict Active Check
        if (this.active) return false;
        // 2. Mutually Exclusive Lock
        if (window.matrix && window.matrix.effectRegistry) {
            const siblings = ["QuantizedAdd", "QuantizedRetract", "QuantizedClimb", "QuantizedZoom"];
            for (const name of siblings) {
                const eff = window.matrix.effectRegistry.get(name);
                if (eff && eff.active) {
                    return false;
                }
            }
        }
        if (!super.trigger(force)) return false;
        this.state = 'FADE_IN';
        this.timer = 0;
        this.alpha = 0.0;
        this.offsetX = 0.5; 
        this.offsetY = 0.5;
        this.expansionPhase = 0;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.manualStep = false;
        this._initShadowWorld();
        this.hasSwapped = false;
        this.isSwapping = false;
        // Ensure renderGrid is initialized
        if (this.renderGrid) {
            this.renderGrid.fill(-1);
        }
        return true;
    }
    update() {
        const s = this.c.state;
        const fps = 60;
        if (!this.active) return;
        // 1. Update Shadow Simulation & Warmup
        if (!this.hasSwapped && !this.isSwapping) {
            if (super._updateShadowSim()) return;
        } else if (this.isSwapping) {
            super.updateTransition(true);
        }
        this.animFrame++;
        // 2. Animation Cycle (Grid Expansion) - Logic Update
        const baseDuration = Math.max(1, this.c.derived.cycleDuration);
        const userSpeed = (s.quantizedPulseSpeed !== undefined) ? s.quantizedPulseSpeed : 5;
        // Map 1 (Slowest) -> 10 (Fastest) to internal delayMult 10 -> 1
        const delayMult = 11 - userSpeed;
        const effectiveInterval = baseDuration * (delayMult / 4.0);
        this.cycleTimer++;
        if (this.cycleTimer >= effectiveInterval) {
            if (!this.debugMode || this.manualStep) {
                this.cycleTimer = 0;
                this.cyclesCompleted++;
                if (this.expansionPhase < this.sequence.length) {
                    this._processAnimationStep();
                } else if (this.getConfig('AutoGenerateRemaining')) {
                    this._attemptGrowth();
                }
                this.manualStep = false;
            }
        }
        // Update Render Grid Logic immediately
        this._updateRenderGridLogic();
        // 3. Lifecycle State Machine
        const fadeInFrames = Math.max(1, s.quantizedPulseFadeInFrames);
        const fadeOutFrames = Math.max(1, s.quantizedPulseFadeFrames);
        const durationFrames = s.quantizedPulseDurationSeconds * fps;
        const setAlpha = (val) => { this.alpha = Math.max(0, Math.min(1, val)); };
        if (this.state === 'FADE_IN') {
            this.timer++;
            setAlpha(this.timer / fadeInFrames);
            if (this.timer >= fadeInFrames) {
                this.state = 'SUSTAIN';
                this.timer = 0;
                this.alpha = 1.0;
            }
        } else if (this.state === 'SUSTAIN') {
            this.timer++;
            const isFinished = (this.timer >= durationFrames);
            const procFinished = this.getConfig('AutoGenerateRemaining') && this._isProceduralFinished();
            if (!this.debugMode && (isFinished || procFinished)) {
                this.state = 'FADE_OUT';
                this.timer = 0;
                if (!this.hasSwapped && !this.isSwapping) {
                    this._swapStates();
                }
            }
        } else if (this.state === 'FADE_OUT') {
            // If swapping, we handle termination in swap logic.
            // If just fading out (e.g. cancelled), handle standard fade.
            if (!this.isSwapping) {
                this.timer++;
                setAlpha(1.0 - (this.timer / fadeOutFrames));
                if (this.timer >= fadeOutFrames) {
                    this.active = false;
                    this.state = 'IDLE';
                    this.alpha = 0.0;
                    window.removeEventListener('keydown', this._boundDebugHandler);
                    this.g.clearAllOverrides();
                    this.shadowGrid = null;
                    this.shadowSim = null;
                }
            }
        }
        // 4. Animation Transition Management (Dirtiness)
        this._checkDirtiness();
    }
    applyToGrid(grid) {
    }
}
// --- QuantizedRenderer.js ---
class QuantizedRenderer {
    constructor() {
        this._bfsQueue = new Int32Array(65536);
        this._distMap = null;
        this._distMapWidth = 0;
        this._distMapHeight = 0;
        this._distMapDirty = true;
    }
    // --- Core Rendering ---
    updateMask(fx, w, h, s, d) {
        if (!fx.maskCtx || !fx.lineMaskCanvas) {
            fx._warn("[QuantizedRenderer] Canvas Context missing. Re-initializing.");
            fx._ensureCanvases(w, h);
        }
        const ctx = fx.maskCtx;
        const colorLayerCtx = fx.perimeterMaskCanvas.getContext('2d');
        const lineCtx = fx.lineMaskCanvas.getContext('2d');
        ctx.clearRect(0, 0, w, h);
        colorLayerCtx.clearRect(0, 0, w, h);
        lineCtx.clearRect(0, 0, w, h);
        if (!fx.renderGrid) return;
        const screenStepX = d.cellWidth * s.stretchX;
        const screenStepY = d.cellHeight * s.stretchY;
        const thickness = fx.getConfig('PerimeterThickness') !== undefined ? fx.getConfig('PerimeterThickness') : 1.0;
        const innerThickness = fx.getConfig('InnerThickness') !== undefined ? fx.getConfig('InnerThickness') : thickness;
        const baseStep = Math.min(screenStepX, screenStepY);
        const unifiedWidth = baseStep * 0.1 * thickness;
        const lineWidthX = unifiedWidth;
        const lineWidthY = unifiedWidth;
        const halfLineX = lineWidthX / 2;
        const halfLineY = lineWidthY / 2;
        const innerUnifiedWidth = baseStep * 0.1 * innerThickness;
        const innerLineWidthX = innerUnifiedWidth;
        const innerLineWidthY = innerUnifiedWidth;
        const gridPixW = fx.g.cols * d.cellWidth; 
        const gridPixH = fx.g.rows * d.cellHeight;
        const bs = fx.getBlockSize();
        const screenOriginX = ((0 - (gridPixW * 0.5)) * s.stretchX) + (w * 0.5);
        const screenOriginY = ((0 - (gridPixH * 0.5)) * s.stretchY) + (h * 0.5);
        const cellPitchX = Math.max(1, bs.w);
        const cellPitchY = Math.max(1, bs.h);
        fx.layout = {
            screenStepX, screenStepY,
            lineWidthX, lineWidthY,
            innerLineWidthX, innerLineWidthY,
            halfLineX, halfLineY,
            screenOriginX, screenOriginY,
            gridPixW, gridPixH,
            cellPitchX, cellPitchY,
            userBlockOffX: 0, userBlockOffY: 0,
            pixelOffX: 0,
            pixelOffY: 0
        };
        const l = fx.layout;
        const blocksX = fx.logicGridW;
        const blocksY = fx.logicGridH;
        const { offX, offY } = fx._computeCenteredOffset(blocksX, blocksY, cellPitchX, cellPitchY);
        fx.layout.offX = offX;
        fx.layout.offY = offY;
        const snapThreshX = screenStepX * 1.0; 
        const snapThreshY = screenStepY * 1.0;
        fx._snapSettings = { w, h, tx: snapThreshX, ty: snapThreshY };
        // Populate Suppressed Fades (Keys to ignore for fading this frame)
        fx.suppressedFades.clear();
        // Block Erasure Pass
        colorLayerCtx.globalCompositeOperation = 'destination-out';
        const now = fx.animFrame;
        const fadeOutFrames = fx.getConfig('FadeFrames') || 0;
        for (const op of fx.maskOps) {
            if (op.type !== 'removeBlock') continue;
            let opacity = 1.0;
            if (now > op.startFrame && fadeOutFrames > 0) {
                opacity = Math.min(1.0, (now - op.startFrame) / fadeOutFrames);
            }
            colorLayerCtx.globalAlpha = opacity;
            const cx = Math.floor(blocksX / 2);
            const cy = Math.floor(blocksY / 2);
            const x1 = Math.min(op.x1, op.x2);
            const x2 = Math.max(op.x1, op.x2);
            const y1 = Math.min(op.y1, op.y2);
            const y2 = Math.max(op.y1, op.y2);
            for (let by_rel = y1; by_rel <= y2; by_rel++) {
                for (let bx_rel = x1; bx_rel <= x2; bx_rel++) {
                    const gx = cx + bx_rel;
                    const gy = cy + by_rel;
                    if (gx < 0 || gx >= blocksX || gy < 0 || gy >= blocksY) continue;
                    const idx = gy * blocksX + gx;
                    // Only erase if this cell is NOT occupied by ANY visible layer in the final composition
                    if (fx.renderGrid[idx] === -1) {
                        this._addBlockToCtx(fx, colorLayerCtx, l, {x: gx, y: gy}, {x: gx, y: gy});
                    }
                }
            }
        }
        // Global Fade Check for Removal Grids
        colorLayerCtx.globalCompositeOperation = 'destination-out';
        for (let by = 0; by < blocksY; by++) {
            for (let bx = 0; bx < blocksX; bx++) {
                const idx = by * blocksX + bx;
                if (fx.renderGrid[idx] === -1) {
                    let isFading = false;
                    if (fadeOutFrames > 0) {
                        for (let layerIdx = 0; layerIdx < 3; layerIdx++) {
                            const rGrid = fx.removalGrids[layerIdx];
                            if (rGrid && rGrid[idx] !== -1 && now < rGrid[idx] + fadeOutFrames) {
                                isFading = true; break;
                            }
                        }
                    }
                    if (!isFading) {
                        const sx = Math.round((bx - l.offX + l.userBlockOffX) * l.cellPitchX);
                        const ex = Math.round((bx + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                        const sy = Math.round((by - l.offY + l.userBlockOffY) * l.cellPitchY);
                        const ey = Math.round((by + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                        const x = l.screenOriginX + (sx * l.screenStepX) + l.pixelOffX;
                        const y = l.screenOriginY + (sy * l.screenStepY) + l.pixelOffY;
                        const w = (ex - sx) * l.screenStepX;
                        const h = (ey - sy) * l.screenStepY;
                        colorLayerCtx.fillRect(x - 0.5, y - 0.5, w + 1.0, h + 1.0);
                    }
                }
            }
        }
        colorLayerCtx.globalCompositeOperation = 'source-over';
        // Unified Shared Edge Rendering
        if (!s.quantizedLineGfxEnabled) {
            this.renderEdges(fx, ctx, lineCtx, now, blocksX, blocksY, l.offX, l.offY);
            this.renderEdges(fx, colorLayerCtx, lineCtx, now, blocksX, blocksY, l.offX, l.offY);
        }
        // Corner Cleanup
        this._renderCornerCleanup(fx, colorLayerCtx, now);
        fx.lastMaskUpdateFrame = now;
        fx._snapSettings = null;
    }
    _addBlockToCtx(fx, ctx, l, blockStart, blockEnd) {
        const offX = l.offX || 0;
        const offY = l.offY || 0;
        let startX = Math.round((blockStart.x - offX + l.userBlockOffX) * l.cellPitchX);
        let endX = Math.round((blockEnd.x + 1 - offX + l.userBlockOffX) * l.cellPitchX);
        let startY = Math.round((blockStart.y - offY + l.userBlockOffY) * l.cellPitchY);
        let endY = Math.round((blockEnd.y + 1 - offY + l.userBlockOffY) * l.cellPitchY);
        startX = Math.max(0, Math.min(fx.g.cols, startX));
        endX = Math.max(0, Math.min(fx.g.cols, endX));
        startY = Math.max(0, Math.min(fx.g.rows, startY));
        endY = Math.max(0, Math.min(fx.g.rows, endY));
        ctx.beginPath();
        const xPos = l.screenOriginX + (startX) * l.screenStepX + l.pixelOffX;
        const yPos = l.screenOriginY + (startY) * l.screenStepY + l.pixelOffY;
        const w = (endX - startX) * l.screenStepX;
        const h = (endY - startY) * l.screenStepY;
        const sLeft = this._getSnap(fx, xPos, 'x');
        const sTop = this._getSnap(fx, yPos, 'y');
        const sRight = this._getSnap(fx, xPos + w, 'x');
        const sBottom = this._getSnap(fx, yPos + h, 'y');
        ctx.rect(sLeft - 0.5, sTop - 0.5, (sRight - sLeft) + 1.0, (sBottom - sTop) + 1.0);
        ctx.fill();
    }
    _getSnap(fx, val, axis) {
        if (!fx._snapSettings) return val;
        const s = fx._snapSettings;
        const max = (axis === 'x') ? s.w : s.h;
        const thresh = (axis === 'x') ? s.tx : s.ty;
        if (val < thresh) return 0;
        if (val > max - thresh) return max;
        return val;
    }
    renderEdges(fx, maskCtx, colorCtx, now, blocksX, blocksY, offX, offY) {
        const color = fx.getConfig('PerimeterColor') || "#FFD700";
        const fadeColor = fx.getConfig('PerimeterFadeColor') || (fx.getConfig('InnerColor') || "#FFD700");
        const fadeOutFrames = fx.getConfig('FadeFrames') || 0;
        const fadeInFrames = fx.getConfig('FadeInFrames') || 0;
        const batches = new Map();
        const maskBatches = new Map();
        const getBatch = (c, o) => {
            const key = `${c}|${o.toFixed(3)}`;
            if (!batches.has(key)) batches.set(key, new Path2D());
            return batches.get(key);
        };
        const getMaskBatch = (o) => {
            const key = o.toFixed(3);
            if (!maskBatches.has(key)) maskBatches.set(key, new Path2D());
            return maskBatches.get(key);
        };
        const getBlock = (grid, bx, by) => {
            if (bx < 0 || bx >= blocksX || by < 0 || by >= blocksY) return -1;
            return grid[by * blocksX + bx];
        };
        const getFadeState = (deathFrame) => {
             if (fadeOutFrames <= 0 || deathFrame === -1) return null;
             const progress = (now - deathFrame) / fadeOutFrames;
             if (progress < 0 || progress >= 1) return null;
             const colorPhase = 0.25;  
             if (progress < colorPhase) {
                 const t = progress / colorPhase;
                 return { c: this._lerpColor(color, fadeColor, t), o: 1.0 };
             } else {
                 const t = (progress - colorPhase) / (1.0 - colorPhase);
                 return { c: fadeColor, o: 1.0 - t };
             }
        };
        const getBirthState = (birthFrame) => {
            if (fadeInFrames <= 0 || birthFrame === -1) return { c: color, o: 1.0 };
            const progress = (now - birthFrame) / fadeInFrames;
            if (progress < 0) return null;
            if (progress >= 1) return { c: color, o: 1.0 };
            return { c: color, o: progress };
        };
        const resolveEdge = (x, y, type) => {
            let ax, ay, bx, by; 
            if (type === 'V') {
                ax = x - 1; ay = y;
                bx = x;     by = y;
            } else {
                ax = x;     ay = y - 1;
                bx = x;     by = y;
            }
            const activeA = (getBlock(fx.renderGrid, ax, ay) !== -1);
            const activeB = (getBlock(fx.renderGrid, bx, by) !== -1);
            const globalPerimeter = (activeA !== activeB);
            let isVisibleNow = false;
            let edgeBirthFrame = -1;
            const key = `${type}_${x}_${y}`;
            // Layering Logic: Layers 0, 1, 2 always visible.
            const visibleLayerIndices = fx.layerOrder.filter(l => l <= 2);
            for (let iOrder = 0; iOrder < visibleLayerIndices.length; iOrder++) {
                const L = visibleLayerIndices[iOrder];
                const grid = fx.layerGrids[L];
                if (!grid) continue;
                const aL = (getBlock(grid, ax, ay) !== -1);
                const bL = (getBlock(grid, bx, by) !== -1);
                if (aL !== bL) {
                    // Perimeter of Layer L. Is it obscured?
                    let obscured = false;
                    for (let m = 0; m < iOrder; m++) {
                        const M = visibleLayerIndices[m];
                        if (getBlock(fx.layerGrids[M], ax, ay) !== -1 || getBlock(fx.layerGrids[M], bx, by) !== -1) {
                            obscured = true;
                            break;
                        }
                    }
                    if (!obscured) {
                        isVisibleNow = true;
                        const fA = getBlock(grid, ax, ay);
                        const fB = getBlock(grid, bx, by);
                        edgeBirthFrame = Math.max(fA, fB);
                        break; 
                    }
                }
            }
            let state = fx.lineStates.get(key);
            if (!state) {
                state = { visible: false, deathFrame: -1, birthFrame: -1 };
                fx.lineStates.set(key, state);
            }
            if (isVisibleNow) {
                if (!state.visible) {
                    state.visible = true;
                    fx.lastVisibilityChangeFrame = now;
                    state.deathFrame = -1;
                    const isNew = (edgeBirthFrame === now);
                    state.birthFrame = (isNew) ? now : -1;
                }
            } else {
                if (state.visible) {
                    state.visible = false;
                    fx.lastVisibilityChangeFrame = now;
                    state.birthFrame = -1;
                    if (state.deathFrame === -1) {
                        state.deathFrame = now;
                    }
                }
            }
            const face = (type === 'V') ? 'W' : 'N';
            if (state.visible) {
                const birth = getBirthState(state.birthFrame);
                if (birth) {
                    const path = getBatch(birth.c, birth.o);
                    const mPath = getMaskBatch(birth.o);
                    this._addFaceToPath(path, fx, x, y, face);
                    this._addFaceToPath(mPath, fx, x, y, face);
                }
            } else if (state.deathFrame !== -1) {
                const fade = getFadeState(state.deathFrame);
                if (fade) {
                    const path = getBatch(fade.c, fade.o);
                    const mPath = getMaskBatch(fade.o);
                    this._addFaceToPath(path, fx, x, y, face);
                    this._addFaceToPath(mPath, fx, x, y, face);
                } else {
                    state.deathFrame = -1;
                }
            }
        };
        for (let x = 0; x <= blocksX; x++) {
            for (let y = 0; y < blocksY; y++) {
                resolveEdge(x, y, 'V');
            }
        }
        for (let y = 0; y <= blocksY; y++) {
            for (let x = 0; x < blocksX; x++) {
                resolveEdge(x, y, 'H');
            }
        }
        batches.forEach((path, key) => {
            const [c, oStr] = key.split('|');
            colorCtx.fillStyle = c;
            colorCtx.globalAlpha = parseFloat(oStr);
            colorCtx.fill(path);
        });
        maskCtx.fillStyle = "#FFFFFF";
        maskBatches.forEach((path, oStr) => {
            maskCtx.globalAlpha = parseFloat(oStr);
            maskCtx.fill(path);
        });
    }
    _addFaceToPath(path, fx, bx, by, face) {
        const l = fx.layout;
        const offX = l.offX || 0;
        const offY = l.offY || 0;
        const lwX = l.lineWidthX;
        const lwY = l.lineWidthY;
        let startCellX = Math.round((bx - offX + l.userBlockOffX) * l.cellPitchX);
        let endCellX = Math.round((bx + 1 - offX + l.userBlockOffX) * l.cellPitchX);
        let startCellY = Math.round((by - offY + l.userBlockOffY) * l.cellPitchY);
        let endCellY = Math.round((by + 1 - offY + l.userBlockOffY) * l.cellPitchY);
        startCellX = Math.max(0, Math.min(fx.g.cols, startCellX));
        endCellX = Math.max(0, Math.min(fx.g.cols, endCellX));
        startCellY = Math.max(0, Math.min(fx.g.rows, startCellY));
        endCellY = Math.max(0, Math.min(fx.g.rows, endCellY));
        let drawX, drawY, drawW, drawH;
        if (face === 'N') {
            let cy = l.screenOriginY + ((startCellY) * l.screenStepY) + l.pixelOffY;
            let leftX = l.screenOriginX + ((startCellX) * l.screenStepX) + l.pixelOffX;
            let rightX = l.screenOriginX + ((endCellX) * l.screenStepX) + l.pixelOffX;
            cy = this._getSnap(fx, cy, 'y');
            leftX = this._getSnap(fx, leftX, 'x');
            rightX = this._getSnap(fx, rightX, 'x');
            drawY = cy - (lwY * 0.5); 
            drawH = lwY; 
            drawX = leftX - (lwX * 0.5);
            drawW = (rightX - leftX) + lwX;
        } else if (face === 'W') {
            let topY = l.screenOriginY + ((startCellY) * l.screenStepY) + l.pixelOffY;
            let bottomY = l.screenOriginY + ((endCellY) * l.screenStepY) + l.pixelOffY;
            let leftX = l.screenOriginX + ((startCellX) * l.screenStepX) + l.pixelOffX;
            topY = this._getSnap(fx, topY, 'y');
            bottomY = this._getSnap(fx, bottomY, 'y');
            leftX = this._getSnap(fx, leftX, 'x');
            drawX = leftX - (lwX * 0.5); 
            drawW = lwX; 
            drawY = topY - (lwY * 0.5);
            drawH = (bottomY - topY) + lwY;
        }
        path.rect(drawX, drawY, drawW, drawH);
    }
    _renderCornerCleanup(fx, ctx, now) {
        // Corner cleanup no longer needs manual removal tracking
    }
    _removeBlockCorner(fx, ctx, bx, by, corner) {
        const l = fx.layout;
        const offX = l.offX || 0;
        const offY = l.offY || 0;
        const startCellX = Math.round((bx - offX + l.userBlockOffX) * l.cellPitchX);
        const endCellX = Math.round((bx + 1 - offX + l.userBlockOffX) * l.cellPitchX);
        const startCellY = Math.round((by - offY + l.userBlockOffY) * l.cellPitchY);
        const endCellY = Math.round((by + 1 - offY + l.userBlockOffY) * l.cellPitchY);
        let cx, cy;
        if (corner === 'NW') {
            cx = l.screenOriginX + ((startCellX) * l.screenStepX) + l.pixelOffX;
            cy = l.screenOriginY + ((startCellY) * l.screenStepY) + l.pixelOffY;
        } else if (corner === 'NE') {
            cx = l.screenOriginX + ((endCellX) * l.screenStepX) + l.pixelOffX;
            cy = l.screenOriginY + ((startCellY) * l.screenStepY) + l.pixelOffY;
        } else if (corner === 'SW') {
            cx = l.screenOriginX + ((startCellX) * l.screenStepX) + l.pixelOffX;
            cy = l.screenOriginY + ((endCellY) * l.screenStepY) + l.pixelOffY;
        } else if (corner === 'SE') {
            cx = l.screenOriginX + ((endCellX) * l.screenStepX) + l.pixelOffX;
            cy = l.screenOriginY + ((endCellY) * l.screenStepY) + l.pixelOffY;
        }
        cx = this._getSnap(fx, cx, 'x');
        cy = this._getSnap(fx, cy, 'y');
        const inflate = 1.0; 
        ctx.beginPath();
        ctx.rect(cx - l.halfLineX - inflate, cy - l.halfLineY - inflate, l.lineWidthX + (inflate*2), l.lineWidthY + (inflate*2));
        ctx.fill();
    }
    computeTrueOutside(fx, blocksX, blocksY) {
        if (fx._outsideMap && fx._outsideMapWidth === blocksX && fx._outsideMapHeight === blocksY && !fx._outsideMapDirty) {
            return fx._outsideMap;
        }
        const size = blocksX * blocksY;
        this._ensureBfsQueueSize(size);
        if (!fx._outsideMap || fx._outsideMap.length !== size) {
            fx._outsideMap = new Uint8Array(size);
        }
        const status = fx._outsideMap;
        status.fill(0);
        const queue = this._bfsQueue;
        let head = 0;
        let tail = 0;
        const add = (idx) => {
            if (status[idx] === 0 && fx.renderGrid[idx] === -1) { 
                status[idx] = 1;
                queue[tail++] = idx;
            }
        };
        for (let x = 0; x < blocksX; x++) { 
            add(x); 
            add((blocksY - 1) * blocksX + x); 
        }
        for (let y = 1; y < blocksY - 1; y++) {
            add(y * blocksX); 
            add(y * blocksX + (blocksX - 1)); 
        }
        while (head < tail) {
            const idx = queue[head++];
            const cx = idx % blocksX;
            const cy = (idx / blocksX) | 0;
            if (cy > 0) add(idx - blocksX);
            if (cy < blocksY - 1) add(idx + blocksX);
            if (cx > 0) add(idx - 1);
            if (cx < blocksX - 1) add(idx + 1);
        }
        fx._outsideMapWidth = blocksX;
        fx._outsideMapHeight = blocksY;
        fx._outsideMapDirty = false;
        return status;
    }
    computeDistanceField(fx, blocksX, blocksY) {
        if (this._distMap && this._distMapWidth === blocksX && this._distMapHeight === blocksY && !this._distMapDirty) {
            return this._distMap;
        }
        const size = blocksX * blocksY;
        this._ensureBfsQueueSize(size);
        if (!this._distMap || this._distMap.length !== size) {
            this._distMap = new Uint16Array(size);
        }
        const dist = this._distMap;
        const maxDist = 999;
        dist.fill(maxDist);
        const queue = this._bfsQueue;
        let head = 0;
        let tail = 0;
        for (let i = 0; i < size; i++) {
            if (fx.renderGrid[i] === -1) {
                dist[i] = 0;
                queue[tail++] = i;
            }
        }
        while(head < tail) {
            const idx = queue[head++];
            const d = dist[idx];
            const cx = idx % blocksX;
            const cy = (idx / blocksX) | 0;
            if (cy > 0) {
                const nIdx = idx - blocksX;
                if (dist[nIdx] === maxDist) { dist[nIdx] = d + 1; queue[tail++] = nIdx; }
            }
            if (cy < blocksY - 1) {
                const nIdx = idx + blocksX;
                if (dist[nIdx] === maxDist) { dist[nIdx] = d + 1; queue[tail++] = nIdx; }
            }
            if (cx > 0) {
                const nIdx = idx - 1;
                if (dist[nIdx] === maxDist) { dist[nIdx] = d + 1; queue[tail++] = nIdx; }
            }
            if (cx < blocksX - 1) {
                const nIdx = idx + 1;
                if (dist[nIdx] === maxDist) { dist[nIdx] = d + 1; queue[tail++] = nIdx; }
            }
        }
        this._distMapWidth = blocksX;
        this._distMapHeight = blocksY;
        this._distMapDirty = false;
        return dist;
    }
    _ensureBfsQueueSize(size) {
        if (!this._bfsQueue || this._bfsQueue.length < size) {
            this._bfsQueue = new Int32Array(size);
        }
    }
    _lerpColor(c1, c2, t) {
        if (!c1 || !c2) return c1 || c2 || '#FFFFFF';
        t = Math.max(0, Math.min(1, t));
        const parse = (c) => {
            const hex = c.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return {r, g, b};
        };
        const rgb1 = parse(c1);
        const rgb2 = parse(c2);
        const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
        const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
        const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
        return `rgb(${r},${g},${b})`;
    }
}
// --- QuantizedRetractEffect.js ---
class QuantizedRetractEffect extends QuantizedBaseEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "QuantizedRetract";
        this.active = false;
        this.configPrefix = "quantizedRetract";
        this.timer = 0;
        this.state = 'IDLE'; // IDLE, FADE_IN, SUSTAIN, FADE_OUT
        this.alpha = 0.0;
        // Grid properties
        this.offsetX = 0;
        this.offsetY = 0;
        // Animation Sequence Data
        this.sequence = [[]]; 
        this.expansionPhase = 0;
        this.maskOps = [];
        this.editorHighlight = false;
        // Flicker Fix: Swap Transition State
        this.isSwapping = false;
        this.swapTimer = 0;
    }
    trigger(force = false) {
        // 1. Strict Active Check
        if (this.active) return false;
        // 2. Mutually Exclusive Lock
        if (window.matrix && window.matrix.effectRegistry) {
            const siblings = ["QuantizedPulse", "QuantizedAdd", "QuantizedClimb", "QuantizedZoom"];
            for (const name of siblings) {
                const eff = window.matrix.effectRegistry.get(name);
                if (eff && eff.active) {
                    return false;
                }
            }
        }
        if (!super.trigger(force)) return false;
        this.state = 'FADE_IN';
        this.timer = 0;
        this.alpha = 0.0;
        this.offsetX = 0.5; 
        this.offsetY = 0.5;
                this.expansionPhase = 0;
        this.cycleTimer = 0;
        this.cyclesCompleted = 0;
        this.manualStep = false;
        this._initShadowWorld();
        this.hasSwapped = false;
        this.isSwapping = false;
        // Ensure renderGrid is initialized
        if (this.renderGrid) {
            this.renderGrid.fill(-1);
        }
        return true;
    }
    update() {
        const s = this.c.state;
        const fps = 60;
        if (!this.active) return;
        // 1. Update Shadow Simulation & Warmup
        if (!this.hasSwapped && !this.isSwapping) {
            if (this._updateShadowSim()) return;
        } else if (this.isSwapping) {
            super.updateTransition(true);
        }
        this.animFrame++;
        // 2. Animation Cycle (Grid Expansion) - Logic Update
        const baseDuration = Math.max(1, this.c.derived.cycleDuration);
        const userSpeed = (s.quantizedRetractSpeed !== undefined) ? s.quantizedRetractSpeed : 5;
        // Map 1 (Slowest) -> 10 (Fastest) to internal delayMult 10 -> 1
        const delayMult = 11 - userSpeed;
        const effectiveInterval = baseDuration * (delayMult / 4.0);
        this.cycleTimer++;
        if (this.cycleTimer >= effectiveInterval) {
            if (!this.debugMode || this.manualStep) {
                this.cycleTimer = 0;
                this.cyclesCompleted++;
                if (this.expansionPhase < this.sequence.length) {
                    this._processAnimationStep();
                } else if (this.getConfig('AutoGenerateRemaining')) {
                    this._attemptGrowth();
                }
                this.manualStep = false;
            }
        }
        // Update Render Grid Logic immediately 
        this._updateRenderGridLogic();
        // 3. Lifecycle State Machine
        const fadeInFrames = Math.max(1, (s.quantizedRetractFadeInFrames !== undefined) ? s.quantizedRetractFadeInFrames : 60);
        const fadeOutFrames = Math.max(1, (s.quantizedRetractFadeFrames !== undefined) ? s.quantizedRetractFadeFrames : 60);
        const durationFrames = (s.quantizedRetractDurationSeconds || 2) * fps;
        const setAlpha = (val) => { this.alpha = Math.max(0, Math.min(1, val)); };
        if (this.state === 'FADE_IN') {
            this.timer++;
            setAlpha(this.timer / fadeInFrames);
            if (this.timer >= fadeInFrames) {
                this.state = 'SUSTAIN';
                this.timer = 0;
                this.alpha = 1.0;
            }
        } else if (this.state === 'SUSTAIN') {
            this.timer++;
            const isFinished = (this.timer >= durationFrames);
            const procFinished = this.getConfig('AutoGenerateRemaining') && this._isProceduralFinished();
            if (!this.debugMode && (isFinished || procFinished)) {
                this.state = 'FADE_OUT';
                this.timer = 0;
                if (!this.hasSwapped && !this.isSwapping) {
                    this._swapStates();
                }
            }
        } else if (this.state === 'FADE_OUT') {
            // If swapping, we handle termination in swap logic.
            // If just fading out (e.g. cancelled), handle standard fade.
            if (!this.isSwapping) {
                this.timer++;
                setAlpha(1.0 - (this.timer / fadeOutFrames));
                if (this.timer >= fadeOutFrames) {
                    this.active = false;
                    this.state = 'IDLE';
                    this.alpha = 0.0;
                    window.removeEventListener('keydown', this._boundDebugHandler);
                    this.g.clearAllOverrides();
                    this.shadowGrid = null;
                    this.shadowSim = null;
                }
            }
        }
        // 4. Animation Transition Management (Dirtiness)
        this._checkDirtiness();
    }
    applyToGrid(grid) {
        // No grid overrides - we render directly to overlayCanvas
    }
}
// --- QuantizedSequence.js ---
class QuantizedSequence {
    constructor() {
        this.OPS_INV = { 1: 'add', 2: 'rem', 3: 'addRect', 6: 'addSmart', 7: 'removeBlock', 12: 'nudge' };
    }
    executeStepOps(fx, step, startFrameOverride) {
        const cx = Math.floor(fx.logicGridW / 2);
        const cy = Math.floor(fx.logicGridH / 2);
        const now = startFrameOverride !== undefined ? startFrameOverride : fx.animFrame;
        const getIdx = (bx, by) => {
            if (bx < 0 || bx >= fx.logicGridW || by < 0 || by >= fx.logicGridH) return -1;
            return by * fx.logicGridW + bx;
        };
        const isActive = (dx, dy) => {
            const idx = getIdx(cx + dx, cy + dy);
            return (idx >= 0 && fx.logicGrid[idx] === 1);
        };
        const setLocalActive = (dx, dy) => {
             const idx = getIdx(cx + dx, cy + dy);
             if (idx >= 0) {
                 fx.logicGrid[idx] = 1;
                 if (fx.renderGrid && startFrameOverride !== undefined) {
                     if (fx.renderGrid[idx] === -1) fx.renderGrid[idx] = now;
                 }
             }
        };
        const setLocalInactive = (dx, dy) => {
             const idx = getIdx(cx + dx, cy + dy);
             if (idx >= 0) {
                 let stillActive = false;
                 for (let i = 0; i < 3; i++) {
                     if (fx.layerGrids[i] && fx.layerGrids[i][idx] !== -1) { stillActive = true; break; }
                 }
                 if (!stillActive) {
                     fx.logicGrid[idx] = 0;
                 }
             }
        };
        const setLayerActive = (dx, dy, l, frame) => {
             const idx = getIdx(cx + dx, cy + dy);
             if (idx >= 0 && fx.layerGrids[l]) {
                 fx.layerGrids[l][idx] = frame;
                 if (l !== 0) fx._updateLayerOrder(l);
             }
        };
        const setLayerInactive = (dx, dy, l) => {
             const idx = getIdx(cx + dx, cy + dy);
             if (idx >= 0) {
                 if (l !== undefined && fx.layerGrids[l]) {
                     fx.layerGrids[l][idx] = -1;
                 } else {
                     for(let i=0; i<3; i++) if (fx.layerGrids[i]) fx.layerGrids[i][idx] = -1;
                 }
             }
        };
        const ctx = {
            cx, cy, now, getIdx, isActive, setLocalActive, setLocalInactive, setLayerActive, setLayerInactive
        };
        this._executeOps(fx, step, ctx);
    }
    _executeOps(fx, ops, ctx) {
        if (!ops) return;
        let i = 0;
        while (i < ops.length) {
            const opData = ops[i];
            if (typeof opData === 'number') {
                i = this._decodeNumericOp(fx, ops, i, ctx);
            } else {
                this._executeSingleOp(fx, opData, ctx);
                i++;
            }
        }
    }
    _decodeNumericOp(fx, step, i, ctx) {
        const { now } = ctx;
        const opCode = step[i++];
        if (opCode === 1) { // add(x, y)
            const dx = step[i++];
            const dy = step[i++];
            ctx.setLocalActive(dx, dy);
            ctx.setLayerActive(dx, dy, 0, now);
            fx.maskOps.push({ type: 'add', x1: dx, y1: dy, x2: dx, y2: dy, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: 0 });
            if (fx.activeBlocks) fx.activeBlocks.push({ x: dx, y: dy, w: 1, h: 1, layer: 0, startFrame: now, id: fx.nextBlockId++ });
        } else if (opCode === 2) { // rem(x, y, mask)
            const dx = step[i++];
            const dy = step[i++];
            let mask = step[i++];
            const layer = (mask >> 4) & 0x7;
            fx.maskOps.push({ type: 'removeBlock', x1: dx, y1: dy, x2: dx, y2: dy, startFrame: now, startPhase: fx.expansionPhase, layer: layer, fade: undefined });
            ctx.setLayerInactive(dx, dy, layer);
            ctx.setLocalInactive(dx, dy);
            if (fx.activeBlocks) fx.activeBlocks = fx.activeBlocks.filter(b => !(b.layer === layer && b.x === dx && b.y === dy && b.w === 1 && b.h === 1));
        } else if (opCode === 3) { // addRect(x1, y1, x2, y2)
            const dx1 = step[i++];
            const dy1 = step[i++];
            const dx2 = step[i++];
            const dy2 = step[i++];
            const layer = 0;
            fx.maskOps.push({ type: 'add', x1: dx1, y1: dy1, x2: dx2, y2: dy2, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: layer });
            const x = Math.min(dx1, dx2), y = Math.min(dy1, dy2);
            const w = Math.abs(dx2 - dx1) + 1, h = Math.abs(dy2 - dy1) + 1;
            if (fx.activeBlocks) fx.activeBlocks.push({ x, y, w, h, layer, startFrame: now, id: fx.nextBlockId++ });
            for (let gy = 0; gy < h; gy++) {
                for (let gx = 0; gx < w; gx++) {
                    ctx.setLocalActive(x + gx, y + gy);
                    ctx.setLayerActive(x + gx, y + gy, layer, now);
                }
            }
        } else if (opCode === 6) { // addSmart(x, y)
            const dx = step[i++];
            const dy = step[i++];
            ctx.setLocalActive(dx, dy);
            ctx.setLayerActive(dx, dy, 0, now);
            fx.maskOps.push({ type: 'addSmart', x1: dx, y1: dy, x2: dx, y2: dy, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: 0 });
            if (fx.activeBlocks) fx.activeBlocks.push({ x: dx, y: dy, w: 1, h: 1, layer: 0, startFrame: now, id: fx.nextBlockId++ });
        } else if (opCode === 7) { // removeBlock(x, y)
            const dx = step[i++];
            const dy = step[i++];
            fx.maskOps.push({ type: 'removeBlock', x1: dx, y1: dy, x2: dx, y2: dy, startFrame: now, startPhase: fx.expansionPhase, fade: undefined });
            ctx.setLayerInactive(dx, dy);
            ctx.setLocalInactive(dx, dy);
            if (fx.activeBlocks) fx.activeBlocks = fx.activeBlocks.filter(b => !(b.x === dx && b.y === dy && b.w === 1 && b.h === 1));
        } else if (opCode === 8) { // addLayered(x, y, layer)
            const dx = step[i++];
            const dy = step[i++];
            const l = step[i++];
            ctx.setLocalActive(dx, dy);
            ctx.setLayerActive(dx, dy, l, now);
            fx.maskOps.push({ type: 'add', x1: dx, y1: dy, x2: dx, y2: dy, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: l });
            if (fx.activeBlocks) fx.activeBlocks.push({ x: dx, y: dy, w: 1, h: 1, layer: l, startFrame: now, id: fx.nextBlockId++ });
        } else if (opCode === 9) { // addRectLayered(x1, y1, x2, y2, layer)
            const dx1 = step[i++];
            const dy1 = step[i++];
            const dx2 = step[i++];
            const dy2 = step[i++];
            const l = step[i++];
            fx.maskOps.push({ type: 'add', x1: dx1, y1: dy1, x2: dx2, y2: dy2, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: l });
            const x = Math.min(dx1, dx2), y = Math.min(dy1, dy2);
            const w = Math.abs(dx2 - dx1) + 1, h = Math.abs(dy2 - dy1) + 1;
            if (fx.activeBlocks) fx.activeBlocks.push({ x, y, w, h, layer: l, startFrame: now, id: fx.nextBlockId++ });
            for (let gy = 0; gy < h; gy++) {
                for (let gx = 0; gx < w; gx++) {
                    ctx.setLocalActive(x + gx, y + gy);
                    ctx.setLayerActive(x + gx, y + gy, l, now);
                }
            }
        } else if (opCode === 10) { // addSmartLayered
            const dx = step[i++];
            const dy = step[i++];
            const l = step[i++];
            ctx.setLocalActive(dx, dy);
            ctx.setLayerActive(dx, dy, l, now);
            fx.maskOps.push({ type: 'addSmart', x1: dx, y1: dy, x2: dx, y2: dy, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: l });
            if (fx.activeBlocks) fx.activeBlocks.push({ x: dx, y: dy, w: 1, h: 1, layer: l, startFrame: now, id: fx.nextBlockId++ });
        } else if (opCode === 11) { // removeBlockLayered
            const dx = step[i++];
            const dy = step[i++];
            const l = step[i++];
            fx.maskOps.push({ type: 'removeBlock', x1: dx, y1: dy, x2: dx, y2: dy, startFrame: now, startPhase: fx.expansionPhase, layer: l, fade: undefined });
            ctx.setLayerInactive(dx, dy, l);
            ctx.setLocalInactive(dx, dy);
            if (fx.activeBlocks) fx.activeBlocks = fx.activeBlocks.filter(b => !(b.layer === l && b.x === dx && b.y === dy && b.w === 1 && b.h === 1));
        } else if (opCode === 12) { // nudge(dx, dy, w, h, layer, faceMask)
            const dx = step[i++];
            const dy = step[i++];
            const w = step[i++];
            const h = step[i++];
            const l = step[i++];
            const FACES_INV = { 1: 'N', 2: 'S', 4: 'E', 8: 'W' };
            const fMask = step[i++];
            const face = FACES_INV[fMask] || null;
            this._executeNudge(fx, dx, dy, w, h, face, l, ctx);
        }
        return i;
    }
    _executeSingleOp(fx, opData, ctx) {
        const { now, setLocalActive, setLocalInactive, setLayerActive, setLayerInactive } = ctx;
        let op, args, layer;
        if (Array.isArray(opData)) {
            op = opData[0];
            args = opData.slice(1);
        } else {
            op = opData.op;
            args = opData.args;
            layer = opData.layer;
        }
        if (op === 'group' && opData.ops) {
            this._executeOps(fx, opData.ops, ctx);
            return;
        }
        const targetLayer = layer !== undefined ? layer : 0;
        if (op === 'add' || op === 'addSmart') {
            const [dx, dy] = args;
            setLocalActive(dx, dy);
            setLayerActive(dx, dy, targetLayer, now);
            fx.maskOps.push({ type: op, x1: dx, y1: dy, x2: dx, y2: dy, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: targetLayer });
            if (fx.activeBlocks) fx.activeBlocks.push({ x: dx, y: dy, w: 1, h: 1, layer: targetLayer, startFrame: now, id: fx.nextBlockId++ });
        } else if (op === 'addRect') {
            const [dx1, dy1, dx2, dy2] = args;
            fx.maskOps.push({ type: 'add', x1: dx1, y1: dy1, x2: dx2, y2: dy2, ext: false, startFrame: now, startPhase: fx.expansionPhase, layer: targetLayer });
            const x = Math.min(dx1, dx2), y = Math.min(dy1, dy2);
            const w = Math.abs(dx2 - dx1) + 1, h = Math.abs(dy2 - dy1) + 1;
            if (fx.activeBlocks) fx.activeBlocks.push({ x, y, w, h, layer: targetLayer, startFrame: now, id: fx.nextBlockId++ });
            for (let gy = 0; gy < h; gy++) {
                for (let gx = 0; gx < w; gx++) {
                    setLocalActive(x + gx, y + gy);
                    setLayerActive(x + gx, y + gy, targetLayer, now);
                }
            }
        } else if (op === 'removeBlock' || op === 'rem' || op === 'removeBlockLayered') {
            let x1, y1, x2, y2;
            if (args.length >= 4) { [x1, y1, x2, y2] = args; } 
            else { [x1, y1] = args; x2 = x1; y2 = y1; }
            fx.maskOps.push({ type: 'removeBlock', x1: x1, y1: y1, x2: x2, y2: y2, startFrame: now, startPhase: fx.expansionPhase, layer: targetLayer, fade: opData.fade });
            const rx1 = Math.min(x1, x2), ry1 = Math.min(y1, y2);
            const rx2 = Math.max(x1, x2), ry2 = Math.max(y1, y2);
            for (let gy = ry1; gy <= ry2; gy++) {
                for (let gx = rx1; gx <= rx2; gx++) {
                    setLayerInactive(gx, gy, targetLayer);
                    setLocalInactive(gx, gy);
                }
            }
            if (fx.activeBlocks) {
                fx.activeBlocks = fx.activeBlocks.filter(b => {
                    if (b.layer !== targetLayer) return true;
                    const bx1 = b.x, by1 = b.y, bx2 = b.x + b.w - 1, by2 = b.y + b.h - 1;
                    const overlap = !(bx1 > rx2 || bx2 < rx1 || by1 > ry2 || by2 < ry1);
                    return !overlap;
                });
            }
        } else if (op === 'nudge') {
            const [dx, dy, w, h, face] = args;
            this._executeNudge(fx, dx, dy, w, h, face, targetLayer, ctx);
        }
    }
    _executeNudge(fx, dx, dy, w, h, face, layer, ctx) {
        const oldFrame = fx.animFrame;
        fx.animFrame = ctx.now;
        fx._nudge(dx, dy, w, h, face, layer);
        fx.animFrame = oldFrame;
    }
}
// --- QuantizedSequenceCache.js ---
class QuantizedSequenceCache {
    constructor() {
        this.cache = new Map(); // Key: Config String, Value: Array of Sequences
        this.maxCacheSize = 5; 
    }
    get(configKey) {
        const sequences = this.cache.get(configKey);
        if (sequences && sequences.length > 0) {
            return sequences.shift(); // Return and remove from cache
        }
        return null;
    }
    put(configKey, sequence) {
        if (!this.cache.has(configKey)) {
            this.cache.set(configKey, []);
        }
        const sequences = this.cache.get(configKey);
        if (sequences.length < this.maxCacheSize) {
            sequences.push(sequence);
        }
    }
    has(configKey) {
        const sequences = this.cache.get(configKey);
        return sequences && sequences.length > 0;
    }
    clear() {
        this.cache.clear();
    }
}
// Global Instance
window.sequenceCache = new QuantizedSequenceCache();
// --- QuantizedSequenceGenerator.js ---
class QuantizedSequenceGenerator {
    constructor() {
        this.sequence = [];
        this.grid = null; 
        this.width = 0;
        this.height = 0;
        this.cx = 0;
        this.cy = 0;
        this.scheduledOps = new Map();
    }
    generate(width, height, maxSteps = 500, params = {}) {
        // console.log("QuantizedSequenceGenerator: generate() called. Mode: ISOLATED CROSS");
        this.width = width;
        this.height = height;
        this.cx = Math.floor(width / 2);
        this.cy = Math.floor(height / 2);
        this.grid = new Uint8Array(width * height).fill(0);
        this.sequence = [];
        this.scheduledOps = new Map(); // Reset scheduled ops
        const config = {
            blocksPerStep: 2,           // Start count (min)
            maxBlocksPerStep: 6,       // Peak count (mid-expansion) - STRICT LIMIT
            redistributeChance: 0.3,    // Chance to convert lines to rects
            thickenChance: 0.2,         // Chance to thicken existing thin lines
            erosionRate: 0.2,           // Default erosion rate if not passed
            innerLineDuration: 1,       // Default duration
            // Shape Probabilities (Normalized)
            shapeWeights: {
                rect1x1: 0.05,
                rect2x1: 0.1, 
                rect3x1: 0.1,
                rect4x1: 0.1,
                rect5x1: 0.05,
                rect6x1: 0.05,
                rect2x2: 0.2,
                rect2x3: 0.15, 
                rect2x4: 0.1,  
                rect4x2: 0.05, 
                rect3x2: 0.05
            },
            ...params
        };
        // Seed: Default to center, but allow override
        const seedX = (params.seedX !== undefined) ? params.seedX : this.cx;
        const seedY = (params.seedY !== undefined) ? params.seedY : this.cy;
        const totalCells = width * height;
        let filledCells = 0;
        let startStep = 1;
        // 1. Handle Initial Sequence (if provided)
        if (params.initialSequence && Array.isArray(params.initialSequence) && params.initialSequence.length > 0) {
            // Copy existing sequence
            this.sequence = [...params.initialSequence];
            startStep = this.sequence.length;
            // Replay state to populate grid
            for (const step of this.sequence) {
                if (!step) continue;
                for (const opData of step) {
                    if (!Array.isArray(opData)) continue;
                    const op = opData[0];
                    if (op === 'add') {
                        const dx = opData[1];
                        const dy = opData[2];
                        const idx = this._idx(this.cx + dx, this.cy + dy);
                        if (idx !== -1 && this.grid[idx] === 0) {
                            this.grid[idx] = 1;
                            filledCells++;
                        }
                    } else if (op === 'addRect') {
                        const x1 = this.cx + opData[1];
                        const y1 = this.cy + opData[2];
                        const x2 = this.cx + opData[3];
                        const y2 = this.cy + opData[4];
                        const minX = Math.min(x1, x2);
                        const maxX = Math.max(x1, x2);
                        const minY = Math.min(y1, y2);
                        const maxY = Math.max(y1, y2);
                        for(let y=minY; y<=maxY; y++) {
                            for(let x=minX; x<=maxX; x++) {
                                const idx = this._idx(x, y);
                                if (idx !== -1 && this.grid[idx] === 0) {
                                    this.grid[idx] = 1;
                                    filledCells++;
                                }
                            }
                        }
                    } else if (op === 'removeBlock') {
                        const x1 = this.cx + opData[1];
                        const y1 = this.cy + opData[2];
                        const x2 = this.cx + opData[3];
                        const y2 = this.cy + opData[4];
                        const minX = Math.min(x1, x2);
                        const maxX = Math.max(x1, x2);
                        const minY = Math.min(y1, y2);
                        const maxY = Math.max(y1, y2);
                        for(let y=minY; y<=maxY; y++) {
                            for(let x=minX; x<=maxX; x++) {
                                const idx = this._idx(x, y);
                                if (idx !== -1 && this.grid[idx] === 1) {
                                    this.grid[idx] = 0;
                                    filledCells--;
                                }
                            }
                        }
                    }
                }
            }
            // console.log(`[Generator] Resuming from step ${startStep}, filled: ${filledCells}`);
        } else {
            // 2. Default Seeding
            const centerIdx = this._idx(seedX, seedY);
            if (centerIdx !== -1) {
                this.grid[centerIdx] = 1;
                filledCells = 1;
                // Initial step: Add seed relative to geometric center.
                // Use 'addSmart' to ensure it respects the natural perimeter logic.
                const seedStepOps = [['addSmart', seedX - this.cx, seedY - this.cy]];
                // REMOVED: this._addPerimeterLines call. We want the seed to have no persistent internal lines.
                this.sequence.push(seedStepOps);
            } else {
                console.warn("QuantizedSequenceGenerator: Invalid seed position", seedX, seedY);
                // Fallback
                const fallbackIdx = this._idx(this.cx, this.cy);
                this.grid[fallbackIdx] = 1;
                filledCells = 1;
                const seedStepOps = [['addSmart', 0, 0]];
                // REMOVED: this._addPerimeterLines call.
                this.sequence.push(seedStepOps);
            }
        }
        let crossComplete = false;
        // Hoist buffer allocation to reduce GC pressure
        const stepOccupancy = new Uint8Array(totalCells);
        for (let s = startStep; s < maxSteps; s++) {
            const stepOps = [];
            // Reset step occupancy
            stepOccupancy.fill(0);
            // Check Cross Completion (if not yet complete)
            if (!crossComplete) {
                crossComplete = this._checkCrossCompletion();
                // If still not complete, run startCross logic (isolated behavior)
                if (!crossComplete) {
                    const added = this._startCross(s, stepOps, stepOccupancy, config.innerLineDuration);
                    filledCells += added;
                }
            }
            // Apply scheduled operations for this step
            if (this.scheduledOps.has(s)) {
                const ops = this.scheduledOps.get(s);
                stepOps.push(...ops);
                this.scheduledOps.delete(s); // Clean up
            }
            const isFull = (filledCells >= totalCells);
            // Loop Termination: 
            // Continue if not full OR if we still have scheduled ops pending.
            if (isFull && this.scheduledOps.size === 0) {
                break;
            }
            // Only run expansion logic if grid isn't full
            if (!isFull) {
                let currentBlocksPerStep = Math.min(7, Math.max(1, s));
                // Constraint: Until cross is complete, limit growth to maintain consistent cross formation
                if (!crossComplete) {
                    currentBlocksPerStep = Math.min(4, Math.max(2, currentBlocksPerStep));
                }
                let dynamicWeights = config.shapeWeights; 
                if (s <= 4) {
                    dynamicWeights = { rect1x1: 1.0 };
                } else if (s <= 12) {
                    dynamicWeights = {
                        rect1x1: 0.2,
                        rect2x1: 0.3, 
                        rect1x2: 0.3, 
                        rect2x1: 0.4, 
                        rect2x2: 0.4
                    };
                }
                let massAdded = 0;
                let attempts = 0;
            }
            if (stepOps.length > 0) {
                this.sequence.push(stepOps);
            } else {
                // If not full but stalled, force expansion to ensure completion
                if (!isFull) {
                    // Force expansion needs a temp stepOccupancy if one wasn't created (rare case logic flow)
                    const fallbackOccupancy = new Uint8Array(totalCells).fill(0);
                    this.sequence.push([]); 
                } else {
                    // Full, just pumping empty frames for scheduled ops
                    this.sequence.push([]);
                }
            }
        }
        return this.sequence;
    }
    _forceExpansion(s, stepOps, stepOccupancy, innerDuration) {
        // Fallback: Pick ANY frontier block uniformly and fill it with 1x1
        // This bypasses the axis weighting and shape sizing that might cause stalls at the corners.
        const frontier = this._getFrontier();
        if (frontier.length === 0) return 0;
        // Shuffle or pick random
        const idx = Math.floor(Math.random() * frontier.length);
        const origin = frontier[idx];
        const gridIdx = this._idx(origin.x, origin.y);
        // Check step occupancy
        if (stepOccupancy && stepOccupancy[gridIdx] === 1) return 0;
        this.grid[gridIdx] = 1;
        if (stepOccupancy) stepOccupancy[gridIdx] = 1;
        stepOps.push(['add', origin.x - this.cx, origin.y - this.cy]);
        return 1;
    }
    _computeOutsideMap() {
        const w = this.width;
        const h = this.height;
        const map = new Uint8Array(w * h); // 0 = Inside/Filled, 1 = True Outside
        const queue = [];
        // Seed edges
        for (let x = 0; x < w; x++) {
            const i1 = this._idx(x, 0);
            if (i1 !== -1 && this.grid[i1] === 0) { map[i1] = 1; queue.push(i1); }
            const i2 = this._idx(x, h - 1);
            if (i2 !== -1 && this.grid[i2] === 0) { map[i2] = 1; queue.push(i2); }
        }
        for (let y = 1; y < h - 1; y++) {
            const i1 = this._idx(0, y);
            if (i1 !== -1 && this.grid[i1] === 0) { map[i1] = 1; queue.push(i1); }
            const i2 = this._idx(w - 1, y);
            if (i2 !== -1 && this.grid[i2] === 0) { map[i2] = 1; queue.push(i2); }
        }
        let head = 0;
        while (head < queue.length) {
            const idx = queue[head++];
            const cx = idx % w;
            const cy = Math.floor(idx / w);
            const neighbors = [
                {x: cx, y: cy - 1}, {x: cx, y: cy + 1},
                {x: cx - 1, y: cy}, {x: cx + 1, y: cy}
            ];
            for (const n of neighbors) {
                if (n.x >= 0 && n.x < w && n.y >= 0 && n.y < h) {
                    const nIdx = n.y * w + n.x;
                    if (this.grid[nIdx] === 0 && map[nIdx] === 0) {
                        map[nIdx] = 1;
                        queue.push(nIdx);
                    }
                }
            }
        }
        return map;
    }
    _idx(x, y) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return -1;
        return y * this.width + x;
    }
    _clearAreaLines(x, y, w, h, stepOps) {
        // No manual line management needed, relying on renderer's perimeter logic.
    }
    _getFrontier() {
        const frontier = [];
        const visited = new Uint8Array(this.width * this.height);
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const idx = y * this.width + x;
                if (this.grid[idx] === 1) {
                    const neighbors = [
                        {x:x, y:y-1}, {x:x, y:y+1}, {x:x-1, y:y}, {x:x+1, y:y}
                    ];
                    for (const n of neighbors) {
                        const nIdx = this._idx(n.x, n.y);
                        if (nIdx !== -1 && this.grid[nIdx] === 0 && visited[nIdx] === 0) {
                            visited[nIdx] = 1;
                            frontier.push(n);
                        }
                    }
                }
            }
        }
        return frontier;
    }
    _getExposedBlocks() {
        const exposed = [];
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const idx = y * this.width + x;
                if (this.grid[idx] === 1) {
                    const neighbors = [
                        {x:x, y:y-1}, {x:x, y:y+1}, {x:x-1, y:y}, {x:x+1, y:y}
                    ];
                    let isExposed = false;
                    for (const n of neighbors) {
                        const nIdx = this._idx(n.x, n.y);
                        if (nIdx === -1 || this.grid[nIdx] === 0) {
                            isExposed = true;
                            break;
                        }
                    }
                    if (isExposed) {
                        exposed.push({x, y});
                    }
                }
            }
        }
        return exposed;
    }
    _attemptErosion(stepOps, currentMass) {
        // Guard: Do not erode if mass is too low (protect the seed)
        // This prevents the generator from deleting the initial seed block and terminating early.
        if (currentMass <= 10) return 0;
        // 1. Compute Outside Map to identify True Perimeter
        // We only want to erode blocks that touch the "True Outside", ensuring we peel from the outside in.
        // This prevents "internal" erosion (drilling holes inside the main blob).
        const outsideMap = this._computeOutsideMap();
        const perimeterCandidates = [];
        for(let y=0; y<this.height; y++) {
            for(let x=0; x<this.width; x++) {
                const idx = this._idx(x, y);
                if (this.grid[idx] === 1) {
                    // Check if any neighbor is True Outside
                    const neighbors = [{x:x, y:y-1}, {x:x, y:y+1}, {x:x-1, y:y}, {x:x+1, y:y}];
                    let isExposed = false;
                    for(const n of neighbors) {
                        const nIdx = this._idx(n.x, n.y);
                        // If neighbor is out of bounds, it's outside. 
                        // If neighbor is in bounds and outsideMap is 1, it's outside.
                        if (nIdx === -1 || outsideMap[nIdx] === 1) {
                            isExposed = true;
                            break;
                        }
                    }
                    if (isExposed) perimeterCandidates.push({x, y});
                }
            }
        }
        if (perimeterCandidates.length === 0) return 0;
        // Shuffle candidates to avoid bias
        for (let i = perimeterCandidates.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [perimeterCandidates[i], perimeterCandidates[j]] = [perimeterCandidates[j], perimeterCandidates[i]];
        }
        // 2. Shape Matching: Prefer deleting larger "written blocks" (2x2) over single pixels
        // We iterate candidates and try to fit the largest shape first.
        const shapes = [
            {w:3, h:1},
            {w:1, h:3},
            {w:2, h:2}, // Priority 1: 2x2 Block
            {w:2, h:1}, // Priority 2: 2x1 Horizontal
            {w:1, h:2}, // Priority 2: 1x2 Vertical
            {w:1, h:1}  // Fallback: Single block (only if nothing else fits)
        ];
        for (const origin of perimeterCandidates) {
            for (const shape of shapes) {
                let fits = true;
                if (origin.x + shape.w > this.width || origin.y + shape.h > this.height) {
                    fits = false;
                } else {
                    for(let by=0; by<shape.h; by++) {
                        for(let bx=0; bx<shape.w; bx++) {
                            const idx = this._idx(origin.x+bx, origin.y+by);
                            if (this.grid[idx] === 0) {
                                fits = false;
                                break;
                            }
                        }
                        if (!fits) break;
                    }
                }
                if (fits) {
                    // Execute Deletion
                    for(let by=0; by<shape.h; by++) {
                        for(let bx=0; bx<shape.w; bx++) {
                            this.grid[this._idx(origin.x+bx, origin.y+by)] = 0;
                        }
                    }
                    if (shape.w === 1 && shape.h === 1) {
                         stepOps.push(['removeBlock', origin.x - this.cx, origin.y - this.cy, origin.x - this.cx, origin.y - this.cy]);
                    } else {
                         stepOps.push(['removeBlock', 
                            origin.x - this.cx, 
                            origin.y - this.cy, 
                            (origin.x + shape.w - 1) - this.cx, 
                            (origin.y + shape.h - 1) - this.cy
                        ]);
                    }
                    // Clean line removal: Ensure no ghost lines remain
                    this._clearAreaLines(origin.x, origin.y, shape.w, shape.h, stepOps);
                    return shape.w * shape.h;
                }
            }
        }
        return 0;
    }
    _attemptThickening(stepOps) {
        const frontier = this._getFrontier();
        if (frontier.length === 0) return 0;
        for (let i = frontier.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [frontier[i], frontier[j]] = [frontier[j], frontier[i]];
        }
        for (const pt of frontier) {
            let neighbors = 0;
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            for(const d of dirs) {
                const idx = this._idx(pt.x + d.x, pt.y + d.y);
                if (idx !== -1 && this.grid[idx] === 1) neighbors++;
            }
            if (neighbors >= 2) {
                this.grid[this._idx(pt.x, pt.y)] = 1;
                stepOps.push(['add', pt.x - this.cx, pt.y - this.cy]);
                return 1;
            }
        }
        return 0;
    }
    _attemptLineThickening(stepOps) {
        const candidates = [];
        const startX = Math.floor(Math.random() * this.width);
        const startY = Math.floor(Math.random() * this.height);
        for (let i = 0; i < this.width * this.height; i++) {
            const rawIdx = (startY * this.width + startX + i) % (this.width * this.height);
            const x = rawIdx % this.width;
            const y = Math.floor(rawIdx / this.width);
            if (this.grid[rawIdx] === 0) continue;
            for(let len of [6, 5, 4]) {
                if (this._checkLine(x, y, len, 1)) {
                    candidates.push({x, y, len, dir: 'H'});
                    if (candidates.length > 5) break; 
                }
            }
            for(let len of [6, 5, 4]) {
                if (this._checkLine(x, y, 1, len)) {
                    candidates.push({x, y, len, dir: 'V'});
                    if (candidates.length > 5) break;
                }
            }
            if (candidates.length > 5) break;
        }
        if (candidates.length === 0) return 0;
        const target = candidates[Math.floor(Math.random() * candidates.length)];
        const {x, y, len, dir} = target;
        const sides = (dir === 'H') ? [y-1, y+1] : [x-1, x+1];
        const side = sides[Math.floor(Math.random() * sides.length)];
        const offset = Math.floor(Math.random() * 3) - 1; 
        let nx, ny, nw, nh;
        if (dir === 'H') { nx = x + offset; ny = side; nw = len; nh = 1; }
        else { nx = side; ny = y + offset; nw = 1; nh = len; }
        let valid = true;
        if (nx < 0 || ny < 0 || nx + nw > this.width || ny + nh > this.height) { valid = false; }
        else {
            for(let by=0; by<nh; by++) {
                for(let bx=0; bx<nw; bx++) {
                    if (this.grid[this._idx(nx+bx, ny+by)] !== 0) { valid = false; break; }
                }
            }
        }
        if (valid) {
            this._clearAreaLines(nx, ny, nw, nh, stepOps); // Clear existing lines before placing
            for(let by=0; by<nh; by++) {
                for(let bx=0; bx<nw; bx++) { this.grid[this._idx(nx+bx, ny+by)] = 1; }
            }
            stepOps.push(['addRect', nx - this.cx, ny - this.cy, (nx + nw - 1) - this.cx, (ny + nh - 1) - this.cy]);
            return nw * nh;
        }
        return 0;
    }
    _attemptTendril(s, stepOps, innerDuration, stepOccupancy) {
        const len = Math.random() < 0.5 ? 6 : 7;
        const arm = ['N', 'S', 'E', 'W'][Math.floor(Math.random() * 4)];
        let anchorX, anchorY, dx, dy;
        // Calculate max distance based on the chosen arm's axis
        const maxDist = (arm === 'N' || arm === 'S') ? (this.height / 2) : (this.width / 2);
        const dist = Math.floor(Math.random() * maxDist);
        if (arm === 'N') { anchorX = this.cx; anchorY = this.cy - dist; dx = 1; dy = 0; } 
        else if (arm === 'S') { anchorX = this.cx; anchorY = this.cy + dist; dx = 1; dy = 0; }
        else if (arm === 'E') { anchorX = this.cx + dist; anchorY = this.cy; dx = 0; dy = 1; } 
        else if (arm === 'W') { anchorX = this.cx - dist; anchorY = this.cy; dx = 0; dy = 1; }
        const sign = Math.random() < 0.5 ? 1 : -1;
        const doPair = Math.random() < 0.5;
        const sides = doPair ? [1, -1] : [sign];
        let totalAdded = 0;
        // Compute outside map once for this step
        const outsideMap = this._computeOutsideMap();
        for (const side of sides) {
            let tx, ty, tw, th;
            if (dx !== 0) { 
                tx = (side === 1) ? anchorX + 1 : anchorX - len;
                ty = anchorY;
                tw = len;
                th = 1;
            } else { 
                tx = anchorX;
                ty = (side === 1) ? anchorY + 1 : anchorY - len;
                tw = 1;
                th = len;
            }
            if (tx < 0 || ty < 0 || tx + tw > this.width || ty + th > this.height) continue;
            // Check Exposure
            let isExposed = false;
            for(let by=0; by<th; by++) {
                for(let bx=0; bx<tw; bx++) {
                    const idx = this._idx(tx+bx, ty+by);
                    if (outsideMap[idx] === 1) {
                        isExposed = true;
                        break;
                    }
                }
                if (isExposed) break;
            }
            let valid = true;
            let overwriteCount = 0;
            if (this.grid[this._idx(anchorX, anchorY)] === 0) valid = false;
            if (valid) {
                this._clearAreaLines(tx, ty, tw, th, stepOps); // Clear existing lines before placing
                for(let by=0; by<th; by++) {
                    for(let bx=0; bx<tw; bx++) { 
                        if (this.grid[this._idx(tx+bx, ty+by)] === 1) overwriteCount++;
                        this.grid[this._idx(tx+bx, ty+by)] = 1; 
                    }
                }
                stepOps.push(['addRect', tx - this.cx, ty - this.cy, (tx + tw - 1) - this.cx, (ty + th - 1) - this.cy]);
                totalAdded += (tw * th) - overwriteCount;
            }
        }
        return totalAdded;
    }
    _attemptMultiBlockMove(s, stepOps, innerDuration, stepOccupancy) {
        const exposed = this._getExposedBlocks();
        if (exposed.length === 0) return 0;
        // Pick random exposed block
        const origin = exposed[Math.floor(Math.random() * exposed.length)];
        const dx = origin.x - this.cx;
        const dy = origin.y - this.cy;
        // Determine Axis and Direction
        let moveX = 0, moveY = 0;
        if (Math.abs(dx) < Math.abs(dy)) {
            moveY = (dy < 0) ? -1 : 1; 
        } else {
            moveX = (dx < 0) ? -1 : 1;
        }
        if (moveX === 0 && moveY === 0) return 0; 
        // Multi-step animation parameters
        const steps = 3; 
        // Define shape to copy (Chunk) - 3-4 blocks
        const shapes = [
            {w:3, h:1}, {w:1, h:3},
            {w:4, h:1}, {w:1, h:4},
            {w:2, h:2} 
        ];
        // Filter shapes valid at origin
        const validShapes = [];
        for(const sh of shapes) {
            let matches = true;
            if (origin.x + sh.w > this.width || origin.y + sh.h > this.height) matches = false;
            else {
                for(let by=0; by<sh.h; by++) {
                    for(let bx=0; bx<sh.w; bx++) {
                        if (this.grid[this._idx(origin.x+bx, origin.y+by)] === 0) { matches = false; break; }
                    }
                }
            }
            if (matches) validShapes.push(sh);
        }
        if (validShapes.length === 0) return 0;
        const shape = validShapes[Math.floor(Math.random() * validShapes.length)];
        // Targets: Original + 3 Mirrors
        const candidates = [
            { rx: dx, ry: dy, rmx: moveX, rmy: moveY },
            { rx: -dx, ry: dy, rmx: -moveX, rmy: moveY },
            { rx: dx, ry: -dy, rmx: moveX, rmy: -moveY },
            { rx: -dx, ry: -dy, rmx: -moveX, rmy: -moveY }
        ];
        const uniqueCandidates = [];
        const seen = new Set();
        for (const c of candidates) {
            const ax = this.cx + c.rx;
            const ay = this.cy + c.ry;
            const key = `${ax},${ay}`;
            if (seen.has(key)) continue;
            seen.add(key);
            // Validate Source Existence
            let sourceValid = true;
            if (ax < 0 || ay < 0 || ax + shape.w > this.width || ay + shape.h > this.height) sourceValid = false;
            else {
                for(let by=0; by<shape.h; by++) {
                    for(let bx=0; bx<shape.w; bx++) {
                        if (this.grid[this._idx(ax+bx, ay+by)] === 0) { sourceValid = false; break; }
                    }
                }
            }
            if (sourceValid) uniqueCandidates.push(c);
        }
        // Validate the entire 3-step path for all candidates
        let validSteps = 0;
        for (let k = 1; k <= steps; k++) {
            let allValid = true;
            for (const c of uniqueCandidates) {
                const ax = this.cx + c.rx;
                const ay = this.cy + c.ry;
                const tx = ax + (c.rmx * k);
                const ty = ay + (c.rmy * k);
                if (tx < 0 || ty < 0 || tx + shape.w > this.width || ty + shape.h > this.height) {
                    allValid = false; break; 
                }
                // Collision with current step's NEW blocks (only relevant for k=1)
                if (k === 1) {
                    for(let by=0; by<shape.h; by++) {
                        for(let bx=0; bx<shape.w; bx++) {
                            const idx = this._idx(tx+bx, ty+by);
                            if (stepOccupancy[idx] === 1) { allValid = false; break; }
                        }
                        if (!allValid) break;
                    }
                }
                if (!allValid) break;
            }
            if (allValid) validSteps = k;
            else break;
        }
        if (validSteps === 0) return 0;
        let totalAdded = 0;
        // Execute Valid Steps
        for (let k = 1; k <= validSteps; k++) {
            const targetStep = s + (k - 1);
            // Recompute outside map to ensure correct exposure for each step of the animation
            const outsideMap = this._computeOutsideMap(); 
            for (const c of uniqueCandidates) {
                const ax = this.cx + c.rx;
                const ay = this.cy + c.ry;
                const tx = ax + (c.rmx * k);
                const ty = ay + (c.rmy * k);
                // Determine Ops Array (Current or Future)
                let currentOps = null;
                if (k === 1) {
                    currentOps = stepOps;
                } else {
                    if (!this.scheduledOps.has(targetStep)) this.scheduledOps.set(targetStep, []);
                    currentOps = this.scheduledOps.get(targetStep);
                }
                // Check Exposure (Lines)
                let isExposed = false;
                for(let by=0; by<shape.h; by++) {
                    for(let bx=0; bx<shape.w; bx++) {
                        const idx = this._idx(tx+bx, ty+by);
                        if (outsideMap[idx] === 1) {
                            isExposed = true;
                            break;
                        }
                    }
                    if (isExposed) break;
                }
                // Clear Old Lines
                this._clearAreaLines(tx, ty, shape.w, shape.h, currentOps);
                // Add Blocks & Update Grid Immediately
                let addedHere = 0;
                for(let by=0; by<shape.h; by++) {
                    for(let bx=0; bx<shape.w; bx++) {
                        const idx = this._idx(tx+bx, ty+by);
                        if (this.grid[idx] === 0) addedHere++;
                        this.grid[idx] = 1;
                        if (k === 1) stepOccupancy[idx] = 1; // Mark collision for current frame
                    }
                }
                totalAdded += addedHere;
                // Add Ops
                if (shape.w === 1 && shape.h === 1) {
                     currentOps.push(['add', tx - this.cx, ty - this.cy]);
                } else {
                     currentOps.push(['addRect', tx - this.cx, ty - this.cy, (tx + shape.w - 1) - this.cx, (ty + shape.h - 1) - this.cy]);
                }
            }
        }
        return totalAdded;
    }
    _attemptRedistribution(stepOps, stepOccupancy) {
        const startX = Math.floor(Math.random() * this.width);
        const startY = Math.floor(Math.random() * this.height);
        for (let i = 0; i < this.width * this.height; i++) { 
            const rawIdx = (startY * this.width + startX + i) % (this.width * this.height);
            const x = rawIdx % this.width;
            const y = Math.floor(rawIdx / this.width);
            if (this.grid[rawIdx] === 0) continue;
            if (this._checkLine(x, y, 6, 1)) {
                // Check if target area for new rect is free in stepOccupancy
                const nx = x + 1;
                const ny = Math.max(0, y - 1); 
                let valid = true;
                if (nx + 3 <= this.width && ny + 2 <= this.height) {
                     for(let by=0; by<2; by++) {
                        for(let bx=0; bx<3; bx++) {
                            const idx = this._idx(nx+bx, ny+by);
                            if (stepOccupancy[idx] === 1) { valid = false; break; }
                        }
                        if (!valid) break;
                    }
                } else { valid = false; }
                if (valid) {
                    for(let k=0; k<6; k++) {
                        this.grid[this._idx(x+k, y)] = 0;
                        stepOps.push(['removeBlock', (x+k)-this.cx, y-this.cy, (x+k)-this.cx, y-this.cy]);
                    }
                    for(let by=0; by<2; by++) {
                        for(let bx=0; bx<3; bx++) {
                            const idx = this._idx(nx+bx, ny+by);
                            this.grid[idx] = 1;
                            stepOccupancy[idx] = 1;
                        }
                    }
                    stepOps.push(['addRect', nx-this.cx, ny-this.cy, (nx+2)-this.cx, (ny+1)-this.cy]);
                    return;
                }
            }
            if (this._checkLine(x, y, 1, 6)) {
                 // Check if target area for new rect is free in stepOccupancy
                const nx = Math.max(0, x - 1);
                const ny = y + 1;
                let valid = true;
                if (nx + 2 <= this.width && ny + 3 <= this.height) {
                     for(let by=0; by<3; by++) {
                        for(let bx=0; bx<2; bx++) {
                            const idx = this._idx(nx+bx, ny+by);
                            if (stepOccupancy[idx] === 1) { valid = false; break; }
                        }
                        if (!valid) break;
                    }
                } else { valid = false; }
                if (valid) {
                    for(let k=0; k<6; k++) {
                        this.grid[this._idx(x, y+k)] = 0;
                        stepOps.push(['removeBlock', x-this.cx, (y+k)-this.cy, x-this.cx, (y+k)-this.cy]);
                    }
                    for(let by=0; by<3; by++) {
                        for(let bx=0; bx<2; bx++) {
                             const idx = this._idx(nx+bx, ny+by);
                            this.grid[idx] = 1;
                            stepOccupancy[idx] = 1;
                        }
                    }
                    stepOps.push(['addRect', nx-this.cx, ny-this.cy, (nx+1)-this.cx, (ny+2)-this.cy]);
                    return;
                }
            }
        }
    }
    _checkLine(x, y, w, h) {
        if (x + w > this.width || y + h > this.height) return false;
        for(let by=0; by<h; by++) {
            for(let bx=0; bx<w; bx++) {
                if (this.grid[this._idx(x+bx, y+by)] === 0) return false;
            }
        }
        return true;
    }
    _attemptExpansion(s, stepOps, weights, innerDuration, stepOccupancy, crossComplete) {
        const frontier = this._getFrontier();
        if (frontier.length === 0) return 0;
        let bestIdx = -1;
        // Calculate current extents for balancing during Phase 1
        let extN = 0, extS = 0, extW = 0, extE = 0;
        if (!crossComplete) {
            for (let i = 0; i < this.grid.length; i++) {
                if (this.grid[i] === 1) {
                    const rx = (i % this.width) - this.cx;
                    const ry = Math.floor(i / this.width) - this.cy;
                    if (ry < 0) extN = Math.max(extN, -ry);
                    else if (ry > 0) extS = Math.max(extS, ry);
                    if (rx < 0) extW = Math.max(extW, -rx);
                    else if (rx > 0) extE = Math.max(extE, rx);
                }
            }
        }
        const frontierWeights = new Float32Array(frontier.length);
        let totalWeight = 0;
        for (let i = 0; i < frontier.length; i++) {
            const pt = frontier[i];
            const rx = pt.x - this.cx;
            const ry = pt.y - this.cy;
            const arx = Math.abs(rx);
            const ary = Math.abs(ry);
            // 1. Determine Axis Bias (Aspect Ratio) - This is the "Meta" consideration
            // Use arx and ary to determine which arm this block belongs to
            const isVertical = (ary > arx);
            const axisBias = isVertical ? this.height : this.width;
            // 2. Base Weighting Logic (Density vs Distance)
            let baseWeight;
            if (crossComplete) {
                // Phase 2: Expansive bias
                baseWeight = Math.pow(Math.sqrt(arx*arx + ary*ary) + 1, 1.5);
            } else {
                // Phase 1: Density bias
                baseWeight = Math.pow(100 / (Math.min(arx, ary) + 1), 3);
            }
            // 3. Opposite-Arm Balancing (Isolated Pair Synchronization)
            let balanceWeight = 1.0;
            if (!crossComplete) {
                // Only throttle if one arm is leading its OPPOSITE by more than 3 blocks
                if (isVertical) {
                    // North/South Pair
                    if (ry < 0 && extN > extS + 3) balanceWeight = 0.3;
                    else if (ry > 0 && extS > extN + 3) balanceWeight = 0.3;
                } else if (arx > ary) {
                    // East/West Pair
                    if (rx < 0 && extW > extE + 3) balanceWeight = 0.3;
                    else if (rx > 0 && extE > extW + 3) balanceWeight = 0.3;
                }
            }
            // 4. Phase 0: Cardinal Constraint (Steps 1-6)
            // Restrict expansion strictly to the central cross axes.
            // We use a tolerance of 1 to allow for even-width center lines (2px wide).
            if (s <= 6) {
                if (Math.abs(rx) > 1 && Math.abs(ry) > 1) {
                    balanceWeight = 0; // Disable diagonal growth
                }
            }
            const weight = baseWeight * axisBias * balanceWeight;
            frontierWeights[i] = weight;
            totalWeight += weight;
        }
        let r = Math.random() * totalWeight;
        for (let i = 0; i < frontier.length; i++) {
            r -= frontierWeights[i];
            if (r <= 0) { bestIdx = i; break; }
        }
        if (bestIdx === -1) bestIdx = frontier.length - 1;
        const origin = frontier[bestIdx];
        const shapeKeys = Object.keys(weights);
        let wSum = 0;
        for(const k of shapeKeys) wSum += weights[k];
        let rw = Math.random() * wSum;
        let selectedShape = shapeKeys[shapeKeys.length-1];
        for(const k of shapeKeys) {
            rw -= weights[k];
            if (rw <= 0) { selectedShape = k; break; }
        }
        let w = 1, h = 1;
        if (selectedShape.startsWith('rect')) {
            const dims = selectedShape.substring(4).split('x').map(Number);
            if (dims.length === 2) { w = dims[0]; h = dims[1]; }
        }
        if (w !== h && Math.random() < 0.5) { [w, h] = [h, w]; }
        // Calculate Outside Map to determine exposure
        const outsideMap = this._computeOutsideMap();
        // RESOLUTION 1: Boundary Clamping
        // Instead of rejecting shapes that hit the edge, clamp them to fit.
        // This fixes the South/East bias where large shapes were impossible to place at the boundary.
        const safeW = Math.min(w, this.width - origin.x);
        const safeH = Math.min(h, this.height - origin.y);
        if (safeW > 0 && safeH > 0) {
            // Check Step Occupancy using clamped dimensions
            for(let by=0; by<safeH; by++) {
                for(let bx=0; bx<safeW; bx++) {
                    const idx = this._idx(origin.x+bx, origin.y+by);
                    if (stepOccupancy[idx] === 1) return 0; // Abort if overlaps new
                }
            }
            // Check if target area touches the True Outside
            let isExposed = false;
            for(let by=0; by<safeH; by++) {
                for(let bx=0; bx<safeW; bx++) {
                    const idx = this._idx(origin.x+bx, origin.y+by);
                    if (outsideMap[idx] === 1) {
                        isExposed = true;
                        break;
                    }
                }
                if (isExposed) break;
            }
            let actualAdded = 0;
            let overwriteCount = 0;
            for(let by=0; by<safeH; by++) {
                for(let bx=0; bx<safeW; bx++) {
                    const idx = this._idx(origin.x+bx, origin.y+by);
                    if (this.grid[idx] === 1) overwriteCount++;
                    else {
                        this.grid[idx] = 1;
                        actualAdded++;
                    }
                    stepOccupancy[idx] = 1;
                }
            }
            this._clearAreaLines(origin.x, origin.y, safeW, safeH, stepOps); // Clear existing lines before placing
            if (safeW === 1 && safeH === 1) {
                stepOps.push(['add', origin.x - this.cx, origin.y - this.cy]);
            } else {
                stepOps.push(['addRect', 
                    origin.x - this.cx, 
                    origin.y - this.cy, 
                    (origin.x + safeW - 1) - this.cx, 
                    (origin.y + safeH - 1) - this.cy
                ]);
            }
            return actualAdded;
        }
        const idx = this._idx(origin.x, origin.y);
        if (this.grid[idx] === 0) {
            if (stepOccupancy[idx] === 1) return 0;
            this.grid[idx] = 1;
            stepOccupancy[idx] = 1;
            this._clearAreaLines(origin.x, origin.y, 1, 1, stepOps); // Clear existing lines before placing
            stepOps.push(['add', origin.x - this.cx, origin.y - this.cy]);
            return 1;
        }
        return 0;
    }
    _checkAxisComplete(axis) {
        // Axis: 'X' or 'Y'
        const w = this.width;
        const h = this.height;
        const range = 5; // Scan width/height around center
        const depth = 2; // Depth from edge
        const checkRegion = (x, y, rw, rh) => {
            for(let i=0; i<rw; i++) {
                for(let j=0; j<rh; j++) {
                    const idx = this._idx(x+i, y+j);
                    if (idx !== -1 && this.grid[idx] === 1) return true;
                }
            }
            return false;
        };
        if (axis === 'Y') {
            const top = checkRegion(this.cx - Math.floor(range/2), 0, range, depth);
            const bottom = checkRegion(this.cx - Math.floor(range/2), h - depth, range, depth);
            return (top && bottom);
        } else if (axis === 'X') {
            const left = checkRegion(0, this.cy - Math.floor(range/2), depth, range);
            const right = checkRegion(w - depth, this.cy - Math.floor(range/2), depth, range);
            return (left && right);
        }
        return false;
    }
    _checkCrossCompletion() {
        return this._checkAxisComplete('X') && this._checkAxisComplete('Y');
    }
    _startCross(s, stepOps, stepOccupancy, innerDuration) {
        const arms = ['N', 'S', 'E', 'W'];
        const armLens = {};
        for (const arm of arms) {
            let len = 0;
            let dx = 0, dy = 0;
            if (arm === 'N') dy = -1;
            else if (arm === 'S') dy = 1;
            else if (arm === 'E') dx = 1;
            else if (arm === 'W') dx = -1;
            while (true) {
                const tx = this.cx + (dx * (len + 1));
                const ty = this.cy + (dy * (len + 1));
                if (this._idx(tx, ty) === -1 || this.grid[this._idx(tx, ty)] === 0) break;
                len++;
            }
            armLens[arm] = len;
        }
        const maxN = this.cy;
        const maxS = this.height - 1 - this.cy;
        const maxE = this.width - 1 - this.cx;
        const maxW = this.cx;
        const progress = {};
        progress['N'] = maxN > 0 ? armLens['N'] / maxN : 1;
        progress['S'] = maxS > 0 ? armLens['S'] / maxS : 1;
        progress['E'] = maxE > 0 ? armLens['E'] / maxE : 1;
        progress['W'] = maxW > 0 ? armLens['W'] / maxW : 1;
        let minP = 2.0;
        for (const p of Object.values(progress)) if (p < minP) minP = p;
        const candidates = [];
        const tolerance = 0.05; 
        for (const arm of arms) {
            if (progress[arm] <= minP + tolerance && progress[arm] < 1.0) {
                candidates.push(arm);
            }
        }
        if (candidates.length === 0) return 0;
        const arm = candidates[Math.floor(Math.random() * candidates.length)];
        let dx = 0, dy = 0;
        if (arm === 'N') dy = -1;
        else if (arm === 'S') dy = 1;
        else if (arm === 'E') dx = 1;
        else if (arm === 'W') dx = -1;
        const len = armLens[arm];
        const tx = this.cx + (dx * (len + 1));
        const ty = this.cy + (dy * (len + 1));
        const idx = this._idx(tx, ty);
        if (idx !== -1 && this.grid[idx] === 0 && stepOccupancy[idx] === 0) {
            this.grid[idx] = 1;
            stepOccupancy[idx] = 1;
            this._clearAreaLines(tx, ty, 1, 1, stepOps);
            // Use 'addSmart' for cross arms to avoid persistent internal lines at the center intersection
            stepOps.push(['addSmart', tx - this.cx, ty - this.cy]);
            // REMOVED: this._addPerimeterLines(s, tx, ty, 1, 1, innerDuration, stepOps);
            return 1;
        }
        return 0;
    }
}
// --- QuantizedShadow.js ---
class QuantizedShadow {
    constructor() {
        this.shadowGrid = null;
        this.shadowSim = null;
        this.warmupRemaining = 0;
        this.shadowSimFrame = 0;
    }
    initShadowWorld(fx) {
        this.initShadowWorldBase(fx, false);
        const s = fx.c.state;
        const d = fx.c.derived;
        const sm = this.shadowSim.streamManager;
        const cols = this.shadowGrid.cols;
        const rows = this.shadowGrid.rows;
        // --- Stream Injection (Pre-population) ---
        for (let x = 0; x < cols; x++) {
            if (Math.random() < 0.30) {
                const y = Math.floor(Math.random() * (rows + 10));
                sm.injectStream(x, y, false);
                if (Math.random() < 0.15) {
                    const ey = Math.floor(Math.random() * (y - 5));
                    sm.injectStream(x, ey, true);
                }
            } else if (Math.random() < 0.15) {
                const y = Math.floor(Math.random() * (rows + 10));
                sm.injectStream(x, y, true);
            }
        }
        const avgTickInterval = Math.max(1, 21 - (s.streamSpeed || 10));
        let warmupFrames = Math.floor(rows * avgTickInterval * 2.5);
        warmupFrames = Math.max(200, warmupFrames);
        warmupFrames = Math.min(5000, warmupFrames);
        this.warmupRemaining = warmupFrames;
        fx.warmupRemaining = warmupFrames;
        this.shadowSimFrame = 0;
        fx.shadowSimFrame = 0;
    }
    initShadowWorldBase(fx, workerEnabled = false) {
        this.shadowGrid = new CellGrid(fx.c);
        const d = fx.c.derived;
        const w = fx.g.cols * d.cellWidth; 
        const h = fx.g.rows * d.cellHeight;
        this.shadowGrid.resize(w, h);
        this.shadowSim = new SimulationSystem(this.shadowGrid, fx.c, false);
        this.shadowSim.useWorker = workerEnabled;
        if (!workerEnabled && this.shadowSim.worker) {
            this.shadowSim.worker.terminate();
            this.shadowSim.worker = null;
        }
        const sm = this.shadowSim.streamManager;
        sm.resize(this.shadowGrid.cols);
        this.shadowSim.timeScale = 1.0;
        fx.shadowGrid = this.shadowGrid;
        fx.shadowSim = this.shadowSim;
        fx.warmupRemaining = 0;
        fx.shadowSimFrame = 0;
        return this.shadowSim;
    }
    updateShadowSim(fx) {
        if (!this.shadowSim) return false;
        if (fx.warmupRemaining !== undefined && fx.warmupRemaining !== this.warmupRemaining) {
            this.warmupRemaining = fx.warmupRemaining;
        }
        if (this.warmupRemaining > 0) {
            const batch = 50; 
            const toRun = Math.min(this.warmupRemaining, batch);
            for (let i = 0; i < toRun; i++) {
                this.shadowSim.update(++this.shadowSimFrame);
            }
            this.warmupRemaining -= toRun;
            fx.warmupRemaining = this.warmupRemaining; 
            fx.shadowSimFrame = this.shadowSimFrame;
            return true; 
        }
        this.shadowSim.update(++this.shadowSimFrame);
        fx.shadowSimFrame = this.shadowSimFrame;
        if (!fx.renderGrid || !fx._lastBlocksX) return false;
        const blocksX = fx._lastBlocksX;
        const blocksY = fx._lastBlocksY;
        const pitchX = fx._lastPitchX;
        const pitchY = fx._lastPitchY;
        const outsideMask = fx.renderer.computeTrueOutside(fx, blocksX, blocksY);
        const sg = this.shadowGrid;
        const g = fx.g;
        const { offX, offY } = fx._computeCenteredOffset(blocksX, blocksY, pitchX, pitchY);
        const screenBlocksX = Math.ceil(g.cols / pitchX);
        const screenBlocksY = Math.ceil(g.rows / pitchY);
        const userBlockOffX = 0;
        const userBlockOffY = 0;
        for (let by = 0; by < blocksY; by++) {
            for (let bx = 0; bx < blocksX; bx++) {
                const idx = by * blocksX + bx;
                if (outsideMask[idx] !== 1) continue; 
                const destBx = bx - offX + userBlockOffX;
                const destBy = by - offY + userBlockOffY;
                if (destBx < -1.5 || destBx > screenBlocksX + 1.5 || destBy < -1.5 || destBy > screenBlocksY + 1.5) continue;
                const startCellX = Math.round(destBx * pitchX);
                const startCellY = Math.round(destBy * pitchY);
                const endCellX = Math.round((destBx + 1) * pitchX);
                const endCellY = Math.round((destBy + 1) * pitchY);                
                for (let cy = startCellY; cy < endCellY; cy++) {
                    if (cy >= g.rows || cy < 0) continue;
                    for (let cx = startCellX; cx < endCellX; cx++) {
                        if (cx >= g.cols || cx < 0) continue;
                        const destIdx = cy * g.cols + cx;
                        if (g.overrideActive[destIdx] === 3) {
                            g.overrideActive[destIdx] = 0;
                        }
                    }
                }
            }
        }
        if (fx.c.state.layerEnableShadowWorld !== false) {
            for (let by = 0; by < blocksY; by++) {
                for (let bx = 0; bx < blocksX; bx++) {
                    const idx = by * blocksX + bx;
                    if (outsideMask[idx] === 1) continue; 
                    const destBx = bx - offX + userBlockOffX;
                    const destBy = by - offY + userBlockOffY;
                    if (destBx < -1.5 || destBx > screenBlocksX + 1.5 || destBy < -1.5 || destBy > screenBlocksY + 1.5) continue;
                    const startCellX = Math.round(destBx * pitchX);
                    const startCellY = Math.round(destBy * pitchY);
                    const endCellX = Math.round((destBx + 1) * pitchX);
                    const endCellY = Math.round((destBy + 1) * pitchY);                    
                    for (let cy = startCellY; cy < endCellY; cy++) {
                        if (cy >= g.rows || cy < 0) continue;
                        for (let cx = startCellX; cx < endCellX; cx++) {
                            if (cx >= g.cols || cx < 0) continue;
                            const destIdx = cy * g.cols + cx;
                            const srcIdx = cy * sg.cols + cx;
                            if (sg && sg.chars && srcIdx < sg.chars.length) {
                                g.overrideActive[destIdx] = 3; 
                                g.overrideChars[destIdx] = sg.chars[srcIdx];
                                g.overrideColors[destIdx] = sg.colors[srcIdx];
                                g.overrideAlphas[destIdx] = sg.alphas[srcIdx];
                                g.overrideGlows[destIdx] = sg.glows[srcIdx];
                                g.overrideMix[destIdx] = sg.mix[srcIdx];
                                g.overrideNextChars[destIdx] = sg.nextChars[srcIdx];
                                g.overrideFontIndices[destIdx] = sg.fontIndices[srcIdx];
                            }
                        }
                    }
                }
            }
        }
    }
    commitShadowState(fx) {
        if (!this.shadowGrid || !this.shadowSim) return false;
        try {
            const g = fx.g;
            const sg = this.shadowGrid;
            this._copyGridBuffers(g, sg);
            if (window.matrix && window.matrix.simulation) {
                const mainSim = window.matrix.simulation;
                const shadowMgr = this.shadowSim.streamManager;
                const streamsToSerialize = new Set(shadowMgr.activeStreams);
                const addRefs = (arr) => { for (const s of arr) { if (s) streamsToSerialize.add(s); } };
                addRefs(shadowMgr.lastStreamInColumn);
                addRefs(shadowMgr.lastEraserInColumn);
                addRefs(shadowMgr.lastUpwardTracerInColumn);
                const streamMap = new Map();
                const serializedActiveStreams = [];
                for (const s of streamsToSerialize) {
                    const copy = {...s};
                    if (copy.holes instanceof Set) copy.holes = Array.from(copy.holes);
                    streamMap.set(s, copy);
                    if (shadowMgr.activeStreams.includes(s)) serializedActiveStreams.push(copy);
                }
                const serializeRefArray = (arr) => arr.map(s => (s && streamMap.has(s)) ? streamMap.get(s) : null);
                const state = {
                    activeStreams: serializedActiveStreams, 
                    columnSpeeds: shadowMgr.columnSpeeds,
                    streamsPerColumn: shadowMgr.streamsPerColumn,   
                    lastStreamInColumn: serializeRefArray(shadowMgr.lastStreamInColumn),
                    lastEraserInColumn: serializeRefArray(shadowMgr.lastEraserInColumn),
                    lastUpwardTracerInColumn: serializeRefArray(shadowMgr.lastUpwardTracerInColumn),
                    nextSpawnFrame: shadowMgr.nextSpawnFrame,
                    overlapInitialized: this.shadowSim.overlapInitialized,
                    _lastOverlapDensity: this.shadowSim._lastOverlapDensity,
                    activeIndices: Array.from(sg.activeIndices)
                };
                const frameOffset = mainSim.frame || 0; 
                const shadowFrame = (this.shadowSimFrame !== undefined) ? this.shadowSimFrame : (fx.localFrame || 0);
                const delta = frameOffset - shadowFrame;
                state.nextSpawnFrame = shadowMgr.nextSpawnFrame + delta;
                if (mainSim.useWorker && mainSim.worker) {
                    mainSim.worker.postMessage({ type: 'replace_state', state: state });
                    mainSim.worker.postMessage({ type: 'config', config: { state: JSON.parse(JSON.stringify(fx.c.state)), derived: fx.c.derived } });
                    return 'ASYNC';
                } else {
                    state.activeStreams.forEach(s => { if (Array.isArray(s.holes)) s.holes = new Set(s.holes); });
                    const mainMgr = mainSim.streamManager;
                    mainMgr.activeStreams = state.activeStreams;
                    mainMgr.columnSpeeds.set(state.columnSpeeds);
                    if (mainMgr.streamsPerColumn && state.streamsPerColumn) mainMgr.streamsPerColumn.set(state.streamsPerColumn);
                    mainMgr.lastStreamInColumn = state.lastStreamInColumn;
                    mainMgr.lastEraserInColumn = state.lastEraserInColumn;
                    mainMgr.lastUpwardTracerInColumn = state.lastUpwardTracerInColumn;
                    mainMgr.nextSpawnFrame = state.nextSpawnFrame;
                    mainSim.overlapInitialized = state.overlapInitialized;
                    mainSim._lastOverlapDensity = state._lastOverlapDensity;
                    if (state.activeIndices) {
                        mainSim.grid.activeIndices.clear();
                        state.activeIndices.forEach(idx => mainSim.grid.activeIndices.add(idx));
                    }
                    return 'SYNC';
                }
            }
            return 'SYNC';
        } catch (e) {
            console.error("[QuantizedShadow] Swap failed:", e);
            return false;
        }
    }
    _copyGridBuffers(g, sg) {
        const copyData = (target, source) => {
            if (!target || !source) return;
            if (source.length === target.length && sg.cols === g.cols) {
                target.set(source);
            } else {
                const rows = Math.min(sg.rows, g.rows);
                const cols = Math.min(sg.cols, g.cols);
                for (let y = 0; y < rows; y++) {
                    const srcOff = y * sg.cols;
                    const dstOff = y * g.cols;
                    target.set(source.subarray(srcOff, srcOff + cols), dstOff);
                }
            }
        };
        copyData(g.state, sg.state); 
        copyData(g.chars, sg.chars);
        copyData(g.colors, sg.colors);
        copyData(g.baseColors, sg.baseColors); 
        copyData(g.alphas, sg.alphas);
        copyData(g.glows, sg.glows);
        copyData(g.fontIndices, sg.fontIndices);
        copyData(g.renderMode, sg.renderMode); 
        copyData(g.types, sg.types);
        copyData(g.decays, sg.decays);
        copyData(g.maxDecays, sg.maxDecays);
        copyData(g.ages, sg.ages);
        copyData(g.brightness, sg.brightness);
        copyData(g.rotatorOffsets, sg.rotatorOffsets);
        copyData(g.cellLocks, sg.cellLocks);
        copyData(g.nextChars, sg.nextChars);
        copyData(g.nextOverlapChars, sg.nextOverlapChars);
        copyData(g.secondaryChars, sg.secondaryChars);
        copyData(g.secondaryColors, sg.secondaryColors);
        copyData(g.secondaryAlphas, sg.secondaryAlphas);
        copyData(g.secondaryGlows, sg.secondaryGlows);
        copyData(g.secondaryFontIndices, sg.secondaryFontIndices);
        copyData(g.mix, sg.mix);
        if (sg.activeIndices.size > 0) {
            g.activeIndices.clear();
            for (const idx of sg.activeIndices) {
                const x = idx % sg.cols;
                const y = Math.floor(idx / sg.cols);
                if (x < g.cols && y < g.rows) {
                    const newIdx = y * g.cols + x;
                    g.activeIndices.add(newIdx);
                }
            }
        }
        g.complexStyles.clear();
        for (const [key, value] of sg.complexStyles) {
            const x = key % sg.cols;
            const y = Math.floor(key / sg.cols);
            if (x < g.cols && y < g.rows) {
                const newKey = y * g.cols + x;
                g.complexStyles.set(newKey, {...value});
            }
        }
    }
}
// --- QuantizedZoomEffect.js ---
class QuantizedZoomEffect extends QuantizedBaseEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "QuantizedZoom";
        this.active = false;
        this.configPrefix = "quantizedZoom";
        // Simulation State
        this.timer = 0;
        this.state = 'IDLE'; // IDLE, FADE_IN, SUSTAIN, FADE_OUT
        this.alpha = 0.0;
        // Sequence State
        this.sequence = [[]]; 
        this.expansionPhase = 0;
        this.maskOps = [];
        // Zoom Effect State
        this.snapshotCanvas = null;
        this.zoomScale = 1.0;
        this.hasCaptured = false;
        // Logic Grid expansion for safety (like GenerateEffect)
        this.logicScale = 3.0; 
        this.useShadowWorld = false;
    }
    trigger(force = false) {
        // 1. Strict Active Check
        if (this.active) return false;
        // 2. Mutually Exclusive Lock
        if (window.matrix && window.matrix.effectRegistry) {
            const siblings = ["QuantizedPulse", "QuantizedAdd", "QuantizedRetract", "QuantizedClimb"];
            for (const name of siblings) {
                const eff = window.matrix.effectRegistry.get(name);
                if (eff && eff.active) {
                    return false;
                }
            }
        }
        if (!super.trigger(force)) return false;
        // Start in WAITING state to allow screenshot capture to stabilize
        this.state = 'WAITING';
        this.timer = 60; // 1 Second Delay
        this.alpha = 0.0;
        this.hasCaptured = false;
        this.zoomScale = 1.0;
        this.zoomProgress = 0;
        // 1. Initialize Grid Dimensions First
        this._initLogicGrid();
        if (this.useShadowWorld) {
            this.expansionPhase = 0;
            this.cycleTimer = 0;
            this.cyclesCompleted = 0;
            this.manualStep = false;
            this._initShadowWorld();
        }
        // 2. Capture Current State
        this._captureSnapshot();
        // 3. Generate Expansion Sequence (Bottom Center)
        if (typeof QuantizedSequenceGenerator !== 'undefined') {
            const generator = new QuantizedSequenceGenerator();
            // Use erosion/innerLine logic to match GenerateEffect style
            // Allow Zoom-specific config, fallback to standard Generate defaults (0.2, 1)
            const erosionRate = (this.c.state.quantizedZoomErosionRate !== undefined) ? this.c.state.quantizedZoomErosionRate : 0.2;
            const innerLineDuration = (this.c.state.quantizedZoomInnerLineDuration !== undefined) ? this.c.state.quantizedZoomInnerLineDuration : 1;
            // Calculate seed position relative to the screen within the scaled grid
            // logicGridH is 3.0x screen height. We want to start at the bottom of the screen portion.
            const bs = this.getBlockSize();
            const cellPitchY = Math.max(1, bs.h);
            const blocksY = Math.ceil(this.g.rows / cellPitchY); // Screen height in blocks
            const scaledH = this.logicGridH;
            const offY = Math.floor((scaledH - blocksY) / 2); // Top offset
            const seedX = Math.floor(this.logicGridW / 2);
            // Start at the bottom of the visible screen area (offY + blocksY)
            const seedY = Math.min(this.logicGridH - 1, offY + blocksY); 
            // Check for pre-loaded animation sequence (from super.trigger loading matrixPatterns)
            let initialSequence = null;
            if (this.sequence && this.sequence.length > 1) {
                initialSequence = this.sequence;
            }
                        this.sequence = generator.generate(this.logicGridW, this.logicGridH, 1000, {
                            seedX, 
                            seedY,
                            erosionRate, 
                            innerLineDuration,
                            initialSequence
                        });            console.log(`[QuantizedZoom] Sequence: ${this.sequence.length} steps.`);
        } else {
            console.error("QuantizedSequenceGenerator not found!");
            this.active = false;
            return false;
        }
        if (this.renderGrid) this.renderGrid.fill(-1);
        return true;
    }
    _captureSnapshot() {
        const d = this.c.derived;
        const s = this.c.state;
        // 1. Setup 3x Resolution Grid
        const factor = 3;
        const cols = this.g.cols * factor;
        const rows = this.g.rows * factor;
        // Create Temp Grid
        const tempGrid = new CellGrid(this.c);
        // Calculate dimensions matching 3x grid
        const pixelW = cols * d.cellWidth;
        const pixelH = rows * d.cellHeight;
        tempGrid.resize(pixelW, pixelH); 
        // Create Temp Simulation
        const tempSim = new SimulationSystem(tempGrid, this.c, false);
        tempSim.useWorker = false;
        // Initialize Stream Manager with high density
        const sm = tempSim.streamManager;
        sm.resize(tempGrid.cols);
        tempSim.timeScale = 1.0;
        // Populate Simulation (Fast Warmup)
        // High density injection (300% density - 3 streams per column on average)
        const densityMultiplier = 3.0; 
        const injectionCount = Math.floor(tempGrid.cols * densityMultiplier);
        for (let k = 0; k < injectionCount; k++) {
            const col = Math.floor(Math.random() * tempGrid.cols);
            // Distribute startY to create full screen coverage immediately
            const startY = Math.floor(Math.random() * (tempGrid.rows + 20)) - 10; 
            const isEraser = Math.random() < 0.15; 
            const stream = sm._initializeStream(col, isEraser, s);
            stream.y = startY;
            // Randomize trail length significantly (0.5x to 3.0x) for variety
            stream.visibleLen = Math.floor(stream.visibleLen * (0.5 + Math.random() * 2.5));
            // Manually set age to ensure immediate visibility if needed
            sm.addActiveStream(stream);
        }
        // Run Warmup
        const warmupFrames = 120;
        for (let i = 0; i < warmupFrames; i++) {
            // Force fade logic to run by updating simulation fully
            tempSim.update(i);
            // Inject CONTINUOUS streams during warmup to maintain density
            if (i % 2 === 0) {
                 const refillCount = Math.floor(tempGrid.cols * 0.1); // Refill 10% every other frame
                 for(let r=0; r<refillCount; r++) {
                     const col = Math.floor(Math.random() * tempGrid.cols);
                     const stream = sm._initializeStream(col, Math.random() < 0.15, s);
                     stream.y = 0; 
                     // Apply same variance to refill
                     stream.visibleLen = Math.floor(stream.visibleLen * (0.5 + Math.random() * 2.5));
                     sm.addActiveStream(stream);
                 }
            }
        }
        // 2. Render to Snapshot Canvas
        const snapW = tempGrid.cols * d.cellWidth;
        const snapH = tempGrid.rows * d.cellHeight;
        if (!this.snapshotCanvas) {
            this.snapshotCanvas = document.createElement('canvas');
        }
        this.snapshotCanvas.width = snapW;
        this.snapshotCanvas.height = snapH;
        const ctx = this.snapshotCanvas.getContext('2d');
        // Fill Background
        ctx.fillStyle = s.backgroundColor;
        ctx.fillRect(0, 0, snapW, snapH);
        // Setup Secondary Transparent Canvas for Border Tinting
        if (!this.charSnapshotCanvas) {
            this.charSnapshotCanvas = document.createElement('canvas');
        }
        this.charSnapshotCanvas.width = snapW;
        this.charSnapshotCanvas.height = snapH;
        const charCtx = this.charSnapshotCanvas.getContext('2d');
        charCtx.clearRect(0, 0, snapW, snapH);
        // Setup Font
        const visualFontSize = s.fontSize;
        const style = s.italicEnabled ? 'italic ' : '';
        const weight = s.fontWeight;
        const family = s.fontFamily;
        const fontStr = `${style}${weight} ${visualFontSize}px ${family}`;
        ctx.font = fontStr;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        charCtx.font = fontStr;
        charCtx.textAlign = 'center';
        charCtx.textBaseline = 'middle';
        const cellW = d.cellWidth;
        const cellH = d.cellHeight;
        const halfW = cellW / 2;
        const halfH = cellH / 2;
        // Render pass: Column-based scanning
        for (let x = 0; x < tempGrid.cols; x++) {
            let currentRun = [];
            // Scan from bottom to top to find streams
            for (let y = tempGrid.rows - 1; y >= 0; y--) {
                const idx = y * tempGrid.cols + x;
                const char = tempGrid.chars[idx];
                // Check if cell is occupied (char > 32)
                if (char > 32) {
                    currentRun.push({y, idx, char, color: tempGrid.colors[idx]});
                } else {
                    // End of a run (or empty space)
                    if (currentRun.length > 0) {
                        this._drawStreamRun(ctx, currentRun, cellW, cellH, halfW, halfH, x);
                        this._drawStreamRun(charCtx, currentRun, cellW, cellH, halfW, halfH, x);
                        currentRun = [];
                    }
                }
            }
            // Flush remaining run at top
            if (currentRun.length > 0) {
                this._drawStreamRun(ctx, currentRun, cellW, cellH, halfW, halfH, x);
                this._drawStreamRun(charCtx, currentRun, cellW, cellH, halfW, halfH, x);
            }
        }
        this.hasCaptured = true;
        // Cleanup
        tempSim.grid = null;
    }
    _drawStreamRun(ctx, run, cellW, cellH, halfW, halfH, colX) {
        const runLen = run.length;
        // Filter: Ignore isolated noise for Tracer logic
        // If run is very short, render it faint and uniform, NO white head.
        const isValidStream = runLen >= 4; 
        for (let i = 0; i < runLen; i++) {
            const cell = run[i];
            const isHead = (i === 0);
            let r, g, b, alpha;
            if (isValidStream && isHead) {
                // White Tracer
                r = 255; g = 255; b = 255;
                alpha = 1.0;
            } else {
                // Tail / Body
                const cVal = cell.color;
                r = cVal & 0xFF;
                g = (cVal >> 8) & 0xFF;
                b = (cVal >> 16) & 0xFF;
                if (!isValidStream) {
                    // Debris: Faint, uniform
                    alpha = 0.3;
                } else {
                    // Fade Calculation
                    // i=1 is right after head. i=runLen-1 is tail tip.
                    // Normalize position 0.0 (near head) to 1.0 (tip)
                    // We exclude the head (i=0) from this range
                    const tailPos = (i - 1) / Math.max(1, runLen - 1);
                    // Quadratic Fade: Starts at 1.0, curves down to 0.0
                    // alpha = (1 - x)^2
                    alpha = Math.pow(1.0 - tailPos, 2);
                    // Boost min alpha slightly so body isn't invisible immediately
                    // But tail tip goes to 0
                    if (alpha < 0.05) alpha = 0; 
                }
            }
            if (alpha <= 0.01) continue;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            const cx = (colX * cellW) + halfW;
            const cy = (cell.y * cellH) + halfH;
            ctx.fillText(String.fromCharCode(cell.char), cx, cy);
        }
    }
    update() {
        if (!this.active) return;
        // 0. Update Shadow Simulation & Warmup
        if (this.useShadowWorld) {
            if (!this.hasSwapped && !this.isSwapping) {
                if (this._updateShadowSim()) return;
            } else if (this.isSwapping) {
                super.updateTransition(false);
            }
        }
        const s = this.c.state;
        const fps = 60;
        this.animFrame++;
        // 1. WAITING State (Delay Start)
        if (this.state === 'WAITING') {
            this.timer--;
            if (this.timer <= 0) {
                this.state = 'FADE_IN';
                this.timer = 0;
                this.alpha = 0.0;
            }
            return; // Skip update while waiting
        }
        // 1. Animation Cycle
        const baseDuration = Math.max(1, this.c.derived.cycleDuration);
        const userSpeed = (s.quantizedZoomSpeed !== undefined) ? s.quantizedZoomSpeed : 5;
        // Map 1 (Slowest) -> 10 (Fastest) to internal delayMult 10 -> 1
        const delayMult = 11 - userSpeed;
        const effectiveInterval = baseDuration * (delayMult / 4.0);
                this.cycleTimer++;
                if (this.cycleTimer >= effectiveInterval) {
                    if (!this.debugMode || this.manualStep) {
                        this.cycleTimer = 0;
                        this.cyclesCompleted++;
                        if (this.expansionPhase < this.sequence.length) {
                            this._processAnimationStep();
                        } else if (this.getConfig('AutoGenerateRemaining')) {
                            this._attemptGrowth();
                        }
                        this.manualStep = false;
                    }
                }
        // Optimize: Update render logic
        this._updateRenderGridLogic();
        // 2. Zoom & Fade Logic
        const totalSteps = this.sequence.length;
        const currentStep = this.expansionPhase;
        const progress = Math.min(1.0, currentStep / Math.max(1, totalSteps));
        // Decoupled Zoom Logic
        const zoomDelayFrames = (s.quantizedZoomDelay !== undefined) ? s.quantizedZoomDelay * 60 : 0; // delay in seconds -> frames
        const zoomRate = (s.quantizedZoomZoomRate !== undefined) ? s.quantizedZoomZoomRate : 1.0;
        if (this.timer >= zoomDelayFrames) {
             // Actual zoom progress
             if (!this.zoomProgress) this.zoomProgress = 0;
             // Base speed: 0.005 per frame * zoomRate
             this.zoomProgress += 0.005 * zoomRate; 
             const t = Math.min(1.0, this.zoomProgress);
             const smoothT = t * t * (3 - 2 * t);
             this.zoomScale = 1.0 + (3.0 * smoothT);
        } else {
             this.zoomScale = 1.0;
        }
        // 3. Lifecycle & Alpha
        const fadeInFrames = Math.max(1, (s.quantizedZoomFadeInFrames !== undefined) ? s.quantizedZoomFadeInFrames : 60);
        const fadeOutFrames = Math.max(1, (s.quantizedZoomFadeFrames !== undefined) ? s.quantizedZoomFadeFrames : 60);
        const durationFrames = ((s.quantizedZoomDurationSeconds !== undefined) ? s.quantizedZoomDurationSeconds : 5.0) * fps;
        if (this.state === 'FADE_IN') {
            this.timer++;
            this.alpha = Math.min(1.0, this.timer / fadeInFrames);
            if (this.timer >= fadeInFrames) {
                this.state = 'SUSTAIN';
                this.timer = 0; // Reset timer for sustain duration
                this.alpha = 1.0;
            }
        } else if (this.state === 'SUSTAIN') {
            this.timer++;
            this.alpha = 1.0;
            const isFinished = (this.timer >= durationFrames);
            const procFinished = this.getConfig('AutoGenerateRemaining') && this._isProceduralFinished();
            if (!this.debugMode && (isFinished || procFinished)) {
                this.state = 'FADE_OUT';
                this.fadeTimer = 0;
            }
        } else if (this.state === 'HOLD') {
            // Deprecated state, but kept for logic safety if manually set
            this.state = 'FADE_OUT';
            this.fadeTimer = 0;
        } else if (this.state === 'FADE_OUT') {
            this.timer++;
            this.fadeTimer++;
            this.alpha = Math.max(0.0, 1.0 - (this.fadeTimer / fadeOutFrames));
            if (this.fadeTimer >= fadeOutFrames) {
                this.active = false;
                this.state = 'IDLE';
                window.removeEventListener('keydown', this._boundDebugHandler);
                this.snapshotCanvas = null; 
                this.charSnapshotCanvas = null;
            }
        }
        // 4. Animation Transition Management (Dirtiness)
        this._checkDirtiness();
    }
    // _updateMask removed to use Base implementation
    render(ctx, d) {
        if (!this.active || (this.alpha <= 0.01 && !this.debugMode)) return;
        if (!this.hasCaptured || !this.snapshotCanvas) return;
        const s = this.c.state;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        this._ensureCanvases(width, height); 
        // Update masks
        if (this._maskDirty || this.maskCanvas.width !== width || this.maskCanvas.height !== height) {
             this._updateMask(width, height, s, d);
             this._maskDirty = false;
        }
        const scratchCtx = this.scratchCtx;
        // --- Layer 1: Interior (Zoom Window) ---
        // 1A. Draw Solid Background (Black/BG Color) masked by Window
        scratchCtx.globalCompositeOperation = 'source-over';
        scratchCtx.clearRect(0, 0, width, height);
        scratchCtx.fillStyle = s.backgroundColor || '#000000';
        scratchCtx.globalAlpha = 0.6;
        scratchCtx.fillRect(0, 0, width, height);
        scratchCtx.globalCompositeOperation = 'destination-in';
        scratchCtx.drawImage(this.maskCanvas, 0, 0);
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = this.alpha;
        ctx.drawImage(this.scratchCanvas, 0, 0);
        ctx.restore();
        // 1B. Draw Zoomed Snapshot (Characters) masked by Window
        const drawZoomLayer = (mask, scale, tintColor = null, sourceCanvas = this.snapshotCanvas) => {
            scratchCtx.globalCompositeOperation = 'source-over';
            scratchCtx.clearRect(0, 0, width, height);
            const gridW = this.g.cols * d.cellWidth;
            const gridH = this.g.rows * d.cellHeight;
            const drawW = gridW * s.stretchX * scale;
            const drawH = gridH * s.stretchY * scale;
            const drawX = (width - drawW) / 2;
            const drawY = (height - drawH) / 2; 
            scratchCtx.save();
            scratchCtx.imageSmoothingEnabled = (scale !== 1.0);
            scratchCtx.globalAlpha = 1.0; 
            scratchCtx.drawImage(sourceCanvas, drawX, drawY, drawW, drawH);
            scratchCtx.restore();
            if (tintColor) {
                scratchCtx.globalCompositeOperation = 'source-in';
                scratchCtx.fillStyle = tintColor;
                scratchCtx.fillRect(0, 0, width, height);
            }
            scratchCtx.globalCompositeOperation = 'destination-in';
            scratchCtx.drawImage(mask, 0, 0);
            ctx.save();
            ctx.globalCompositeOperation = 'source-over'; 
            ctx.globalAlpha = this.alpha;
            if (tintColor) ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(this.scratchCanvas, 0, 0);
            ctx.restore();
        };
        // Draw Interior Characters
        drawZoomLayer(this.maskCanvas, this.zoomScale, null, this.snapshotCanvas);
        // --- Layer 2: Overlay (Border + Lines) ---
        const pColor = this.getConfig('PerimeterColor') || '#FFD700';
        const iColor = this.getConfig('InnerColor') || '#00FF00';
        const glowStrength = this.getConfig('BorderIllumination') || 4.0;
        const alphaMult = Math.min(1.0, glowStrength / 4.0);
        // Ensure Grid Cache (Dense Characters) is updated
        this._updateGridCache(width, height, s, d);
        // Helper to draw a masked layer with dense code texture
        const drawCodeLayer = (maskCanvas, color) => {
            if (!maskCanvas) return;
            scratchCtx.globalCompositeOperation = 'source-over';
            scratchCtx.clearRect(0, 0, width, height);
            // 1. Draw Dense Code Grid
            scratchCtx.globalAlpha = 1.0;
            scratchCtx.drawImage(this.gridCacheCanvas, 0, 0);
            // 2. Tint
            scratchCtx.globalCompositeOperation = 'source-in';
            scratchCtx.fillStyle = color;
            scratchCtx.fillRect(0, 0, width, height);
            // 3. Mask
            scratchCtx.globalCompositeOperation = 'destination-in';
            scratchCtx.drawImage(maskCanvas, 0, 0);
            // 4. Composite to Screen
            ctx.save();
            ctx.globalAlpha = this.alpha * alphaMult;
            // Glow
            if (glowStrength > 2.0) {
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = color;
                ctx.shadowBlur = glowStrength * 3.0; 
                ctx.drawImage(this.scratchCanvas, 0, 0);
            }
            // Solid
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
            ctx.drawImage(this.scratchCanvas, 0, 0);
            ctx.restore();
        };
        // Draw Interior Lines (Green/Cyan)
        if (this.lineMaskCanvas) {
             drawCodeLayer(this.lineMaskCanvas, iColor);
        }
        // Draw Perimeter (Gold)
        if (this.perimeterMaskCanvas) {
             drawCodeLayer(this.perimeterMaskCanvas, pColor);
        }
    }
    _ensureCanvases(w, h) {
        if (!this.maskCanvas) {
            this.maskCanvas = document.createElement('canvas');
            this.maskCtx = this.maskCanvas.getContext('2d');
            this._maskDirty = true;
        }
        if (!this.scratchCanvas) {
            this.scratchCanvas = document.createElement('canvas');
            this.scratchCtx = this.scratchCanvas.getContext('2d');
        }
        if (!this.gridCacheCanvas) {
            this.gridCacheCanvas = document.createElement('canvas');
            this.gridCacheCtx = this.gridCacheCanvas.getContext('2d');
        }
        if (!this.perimeterMaskCanvas) {
            this.perimeterMaskCanvas = document.createElement('canvas');
            this.perimeterMaskCtx = this.perimeterMaskCanvas.getContext('2d');
        }
        if (!this.lineMaskCanvas) {
            this.lineMaskCanvas = document.createElement('canvas');
            this.lineMaskCtx = this.lineMaskCanvas.getContext('2d');
        }
        if (this.maskCanvas.width !== w || this.maskCanvas.height !== h) {
            this.maskCanvas.width = w;
            this.maskCanvas.height = h;
            this._maskDirty = true;
        }
        if (this.scratchCanvas.width !== w || this.scratchCanvas.height !== h) {
            this.scratchCanvas.width = w;
            this.scratchCanvas.height = h;
        }
        if (this.gridCacheCanvas.width !== w || this.gridCacheCanvas.height !== h) {
            this.gridCacheCanvas.width = w;
            this.gridCacheCanvas.height = h;
            this.lastGridSeed = -1; 
        }
        if (this.perimeterMaskCanvas.width !== w || this.perimeterMaskCanvas.height !== h) {
            this.perimeterMaskCanvas.width = w;
            this.perimeterMaskCanvas.height = h;
        }
        if (this.lineMaskCanvas.width !== w || this.lineMaskCanvas.height !== h) {
            this.lineMaskCanvas.width = w;
            this.lineMaskCanvas.height = h;
        }
        // RenderGrid Sizing (SCALED)
        const blocksX = this.logicGridW;
        const blocksY = this.logicGridH;
        if (blocksX && blocksY) {
            const requiredSize = blocksX * blocksY;
            if (!this.renderGrid || this.renderGrid.length !== requiredSize) {
                 this.renderGrid = new Int32Array(requiredSize);
                 this.renderGrid.fill(-1);
                 // We must mark logic dirty so it repopulates if resized
                 // But typically renderGrid is populated by _updateRenderGridLogic
            }
        }
    }
}
// --- ReverseEffect.js ---
class ReverseEffect extends AbstractEffect {
    constructor(grid, config, effectRegistry) {
        super(grid, config);
        this.name = "ReverseTime";
        this.effectRegistry = effectRegistry;
        this.active = false;
        // Sequence phases
        // 0: Idle
        // 1: Slow Down
        // 2: Stop
        // 3: Reverse (Rewind)
        // 4: Reset (Pulse Handoff)
        this.phase = 0;
        this.timer = 0;
        // Configuration
        this.durationSlow = 60;  // Frames to slow down (1s)
        this.durationStop = 20;   // Frames to hold stop (~0.3s)
        this.durationRewind = 100; // Frames to rewind (~1.6s)
        this.rewindSpeed = -3.0;   // Rewind speed multiplier
    }
    trigger() {
        return this.start();
    }
    getOverride(i) {
        return null;
    }
    getActiveIndices() {
        return null;
    }
    start() {
        if (this.active) return false;
        this.active = true;
        this.phase = 1;
        this.timer = 0;
        this.sim = window.matrix ? window.matrix.simulation : null;
        if (!this.sim) {
            console.error("ReverseEffect: SimulationSystem not found.");
            this.active = false;
            return false;
        }
        return true;
    }
    update() {
        if (!this.active || !this.sim) return;
        this.timer++;
        switch (this.phase) {
            case 1: // SLOW DOWN
                {
                    const progress = this.timer / this.durationSlow;
                    const t = 1.0 - Math.pow(1 - progress, 3); 
                    this.sim.timeScale = 1.0 - t;
                    if (this.timer >= this.durationSlow) {
                        this.sim.timeScale = 0;
                        this.phase = 2;
                        this.timer = 0;
                    }
                }
                break;
            case 2: // STOP (HOLD)
                {
                    this.sim.timeScale = 0;
                    if (this.timer >= this.durationStop) {
                        this.phase = 3;
                        this.timer = 0;
                    }
                }
                break;
            case 3: // REWIND
                {
                    if (this.timer < 60) {
                        const t = this.timer / 60;
                        this.sim.timeScale = -t * Math.abs(this.rewindSpeed);
                    } else {
                        this.sim.timeScale = this.rewindSpeed;
                    }
                    if (this.timer >= this.durationRewind) {
                        this.phase = 4;
                        this.timer = 0;
                    }
                }
                break;
            case 4: // PULSE HANDOFF
                {
                    // Resume Normal Simulation
                    this.sim.timeScale = 1.0;
                    // Trigger Standard Pulse Effect (runs correctly with its own freeze/dim)
                    // We assume the user has configured the Pulse effect as desired (e.g. Movie Accurate)
                    this.effectRegistry.trigger('Pulse');
                    // Deactivate Time Control
                    this.active = false;
                    this.phase = 0;
                }
                break;
        }
    }
}
// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.afterimages = new Map(); 
                this.timer = 0;
                this.spawnX = 0;
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this.spawnX = 0;
                this.afterimages.clear();
                this._generateBolt();
                return true; 
            }
            update() {
                const s = this.c.state;
                // Update afterimages (fade out)
                if (this.afterimages.size > 0) {
                    // Fade speed: higher = slower. Default ~20.
                    // 20 -> 0.05 decay. 
                    const decay = 1.0 / Math.max(1, s.supermanFadeSpeed || 20); 
                    for (const [index, alpha] of this.afterimages) {
                        const newAlpha = alpha - decay;
                        if (newAlpha <= 0.01) {
                            this.afterimages.delete(index);
                        } else {
                            this.afterimages.set(index, newAlpha);
                        }
                    }
                }
                if(!this.active && this.afterimages.size === 0) {
                     return;
                }
                if (this.active) {
                    this.timer--;
                    // Spawning logic
                    // Speed 40 ~ crosses screen in roughly 0.5-1s depending on refresh rate.
                    // Factor: Speed 40 -> 0.04 * cols per frame. 
                    // If cols=100, 4 cells/frame. 25 frames total.
                    const speedVal = s.supermanSpawnSpeed || 40;
                    const speedFactor = Math.max(1, speedVal) / 1000; 
                    this.spawnX += (this.g.cols * speedFactor);
                    if (this.spawnX > this.g.cols) this.spawnX = this.g.cols;
                    if (this.timer <= 0) {
                        this.active = false;
                        this.lightningPath.clear();
                        return;
                    }
                    this.flickerTimer++;
                    if (this.flickerTimer >= s.supermanFlickerRate) {
                        this._generateBolt();
                        this.flickerTimer = 0;
                    } else {
                        this._refreshAfterimages();
                    }
                }
            }
            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                let cy = startY;
                const limitX = Math.floor(this.spawnX);
                for (let x = 0; x < this.g.cols; x++) {
                    if (x > limitX) break;
                    // Jitter / Width logic
                    const variance = Math.max(1, s.supermanWidth); 
                    const noise = Utils.randomInt(-variance, variance);
                    // Gentle center pull to keep it on screen but allow jitter
                    const distFromCenter = (this.g.rows / 2) - cy;
                    cy += noise + (distFromCenter * 0.05); 
                    if (cy < 0) cy = 0;
                    if (cy >= this.g.rows) cy = this.g.rows - 1;
                    const thickness = s.supermanBoltThickness; 
                    const halfThick = Math.floor(thickness / 2);
                    for (let dy = -halfThick; dy <= halfThick; dy++) {
                        const thickY = Math.round(cy) + dy;
                        if (thickY >= 0 && thickY < this.g.rows) {
                            const idx = this.g.getIndex(x, thickY);
                            if (idx !== -1) {
                                this.lightningPath.add(idx);
                            }
                        }
                    }
                }
                this._refreshAfterimages();
            }
            _refreshAfterimages() {
                for (const idx of this.lightningPath) {
                    this.afterimages.set(idx, 1.0);
                }
            }
            getOverride(i) {
                if (this.afterimages.has(i)) {
                    const alphaChar = this.g.alphas[i];
                    if (alphaChar <= 0.05) return null;
                    const effectAlpha = this.afterimages.get(i);
                    const s = this.c.state;
                    const fontIdx = this.g.fontIndices[i];
                    const fontName = this.c.derived.activeFonts[fontIdx]?.name || s.fontFamily;
                    return {
                        char: this.g.getChar(i),
                        font: fontName,
                        color: this.c.derived.streamColorStr, 
                        alpha: effectAlpha, 
                        glow: s.supermanGlow, 
                        size: 1,
                        solid: false, 
                        blend: true 
                    };
                }
                return null;
            }
            getActiveIndices() {
                if ((!this.active && this.afterimages.size === 0)) return new Set();
                return this.afterimages.keys();
            }
        }
    // =========================================================================
    // 7.0 CANVAS RENDERER
    // =========================================================================
// --- GlyphAtlas.js ---
// =========================================================================
// GLYPH ATLAS
// =========================================================================
class GlyphAtlas {
    constructor(config, fontName = null, customChars = null) {
        this.config = config;
        this.fontName = fontName;
        this.customChars = customChars;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true, willReadFrequently: true });
        // Map character strings to their rect in the atlas
        this.charMap = new Map();
        // Atlas dimensions and cell size
        this.cellSize = 0;
        this.atlasWidth = 0;
        this.atlasHeight = 0;
        // State tracking for updates
        this.currentFont = '';
        this.currentPalette = '';
        this.needsUpdate = true;
        // Pre-calculated half sizes for centering
        this.halfCell = 0;
        // Internal caches for differential updates
        this.fixedCols = 16; // Strategy 4: Default safety
        this._lastCols = 0;
        this._lastRows = 0;
        this._lastCharListKey = '';
        // Safety flags
        this.valid = true;
        this.MAX_HEIGHT = 8192; // Common safe limit for mobile/desktop
        // Fast Lookup for Renderer (CharCode -> AtlasID)
        this.codeToId = new Int16Array(65536).fill(-1);
        // Glyph Cache Optimization: Filter unsupported characters
        this.testCanvas = document.createElement('canvas');
        this.testCanvas.width = 20;
        this.testCanvas.height = 20;
        this.testCtx = this.testCanvas.getContext('2d', { willReadFrequently: true });
        this._cachedFilteredChars = null;
        this._cachedFilterKey = '';
        // Lazy Loading State
        this.usedChars = []; // List of characters currently in atlas
        this.capacity = 0;   // Current max characters
        this.minCapacity = 256; // Starting capacity
        this.hasChanges = false;
        this.fontReady = false;
    }
    /**
     * Initializes or updates the atlas configuration.
     * Clears the atlas and resets state to allow lazy loading.
     */
    update() {
        const s = this.config.state;
        const d = this.config.derived;
        // Determine font info (but NOT the full char list anymore for pre-fill)
        const fontFamily = this.fontName || s.fontFamily;
        // Check sizing dependencies
        const maxSize = s.fontSize + s.tracerSizeIncrease;
        const style = s.italicEnabled ? 'italic ' : '';
        const fontBase = `${style}${s.fontWeight} ${maxSize}px ${fontFamily}`;
        const padding = 10 * 2; // Fixed padding, decoupled from tracerGlow
        const paletteStr = d.paletteColorsStr.join(',');
        const fullConfigStr = paletteStr + '|' + s.overlapColor + '|' + fontBase + '|' + padding;
        const isFontReady = document.fonts.check(fontBase);
        if (this.currentFont === fontBase && 
            this.currentPalette === fullConfigStr && 
            this.fontReady === isFontReady && 
            !this.needsUpdate) {
            return;
        }
        // Configuration changed: Reset everything
        this.currentFont = fontBase;
        this.currentPalette = fullConfigStr;
        this.fontReady = isFontReady;
        // If font isn't ready, we force a retry next frame, but we TRY to render anyway (Canvas fallback)
        if (!isFontReady) {
            this.needsUpdate = true;
            // console.warn(`[GlyphAtlas] Font ${fontBase} not ready. Rendering with fallback.`);
        } else {
            this.needsUpdate = false;
        }
        // Reset dynamic state
        // Use a representative string with high/low chars
        this.ctx.font = fontBase;
        const metrics = this.ctx.measureText("Mjg|[]{}()"); 
        // fallback if metrics not supported
        let actualHeight = maxSize;
        if (metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent) {
            actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        } else {
            actualHeight = maxSize * 1.2; // generous fallback
        }
        this.cellSize = Math.ceil(Math.max(maxSize, actualHeight) + padding);
        this.halfCell = this.cellSize / 2;
        // Strategy 4: Fixed Width, Vertical Expansion
        // Fix columns based on a reasonable texture width (e.g., 2048)
        const TARGET_WIDTH = 2048;
        this.fixedCols = Math.max(1, Math.floor(TARGET_WIDTH / this.cellSize));
        // Reset dynamic state
        this.usedChars = [];
        this.charMap.clear();
        this.capacity = this.minCapacity;
        // Initial sizing (reset = true)
        this._resizeAtlas(d, true);
    }
    _resizeAtlas(d, reset = false) {
        // Use fixed columns
        const cols = this.fixedCols;
        const rows = Math.ceil(this.capacity / cols);
        this._lastCols = cols;
        this._lastRows = rows;
        const newAtlasWidth = cols * this.cellSize;
        const newAtlasHeight = rows * this.cellSize;
        if (newAtlasHeight > this.MAX_HEIGHT) {
             console.error(`[GlyphAtlas] Texture Limit Exceeded: Height ${newAtlasHeight} > ${this.MAX_HEIGHT}`);
             console.error(`Details: Capacity=${this.capacity}, Cols=${cols}, Rows=${rows}, CellSize=${this.cellSize}`);
             this.valid = false;
             return;
        }
        this.valid = true;
        this.atlasWidth = newAtlasWidth;
        this.atlasHeight = newAtlasHeight;
        // Preserve existing content if not resetting
        let savedContent = null;
        if (!reset && this.canvas.width > 0 && this.canvas.height > 0) {
             savedContent = document.createElement('canvas');
             savedContent.width = this.canvas.width;
             savedContent.height = this.canvas.height;
             savedContent.getContext('2d').drawImage(this.canvas, 0, 0);
        }
        // Resize Canvas (clears content)
        if (this.canvas.width !== this.atlasWidth || this.canvas.height !== this.atlasHeight) {
            this.canvas.width = this.atlasWidth;
            this.canvas.height = this.atlasHeight;
        } else {
            this.ctx.clearRect(0, 0, this.atlasWidth, this.atlasHeight);
        }
        // Restore content
        if (savedContent) {
            this.ctx.drawImage(savedContent, 0, 0);
        }
        // Full update required on resize/clear (GPU texture must be resized)
        this.needsFullUpdate = true;
        this.dirtyRects = []; // Clear partial updates as we are doing full
        // Setup Context (State is lost on resize)
        this.ctx.font = this.currentFont;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.ctx.fillStyle = '#FFFFFF';
        if (reset) {
            this.codeToId.fill(-1);
        }
    }
    /**
     * Adds a character to the atlas if space permits, expanding if necessary.
     */
    addChar(char) {
        if (!this.valid) return null;
        // Safety: Check if already exists to prevent duplicates
        if (this.charMap.has(char)) {
            const rect = this.charMap.get(char);
            const code = char.charCodeAt(0);
            if (code < 65536) this.codeToId[code] = rect.id;
            return rect;
        }
        // Check if supported first
        const checkFont = this.currentFont.replace(/\d+px/, '16px'); 
        const sig = this._getCharSignature(checkFont, char);
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        if (!sig || sig === emptySig) {
            // Unsupported, do not add
            return null;
        }
        this.usedChars.push(char);
        if (this.usedChars.length > this.capacity) {
            this._expandAtlas();
        }
        // Always draw the new char (even after expansion)
        if (this.valid) {
            const index = this.usedChars.length - 1;
            this._drawSingleChar(char, index);
        }
        // Return the new mapping
        return this.charMap.get(char);
    }
    _expandAtlas() {
        // Double capacity
        this.capacity *= 2;
        // Re-calculate dimensions and resize canvas (preserving content)
        const d = this.config.derived; 
        this._resizeAtlas(d, false);
    }
    _drawSingleChar(char, index) {
        const col = index % this._lastCols;
        const row = (index / this._lastCols) | 0;
        const x = col * this.cellSize + this.halfCell;
        const y = row * this.cellSize + this.halfCell;
        const rect = {
            x: col * this.cellSize,
            y: row * this.cellSize,
            w: this.cellSize,
            h: this.cellSize,
            id: index // Store index for shader lookup
        };
        this.charMap.set(char, rect);
        this.ctx.fillText(char, x, y);
        // Strategy 2: Incremental Updates - Capture pixel data
        const imageData = this.ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
        this.dirtyRects.push({
            x: rect.x,
            y: rect.y,
            w: rect.w,
            h: rect.h,
            data: imageData
        });
        // Update fast lookup
        const code = char.charCodeAt(0);
    }
    resetChanges() {
        this.hasChanges = false; // Keep for compatibility if used elsewhere
        this.dirtyRects = [];
        this.needsFullUpdate = false;
    }
    /**
     * Returns the source coordinates for a character.
     * Lazily adds the character if not present.
     * @param {string} char 
         * @returns {Object|null} Source rect {x,y,w,h} or null
     */
    get(char) {
        const rect = this.charMap.get(char);
        if (rect) return rect;
        // Lazy Load
        return this.addChar(char);
    }
    /**
     * Filters the character list to only include those supported by the font.
     * Caches the result to avoid expensive re-scans.
     */
    _getFilteredChars(rawList, font) {
        // Use a key that includes the font (with size replaced by standard) and the raw list
        // Note: We use the full fontBase as key because if size changes significantly, 
        // we might want to re-check (though unlikely to change support).
        const key = font + '::' + rawList.length + ':' + rawList;
        if (this._cachedFilteredChars !== null && this._cachedFilterKey === key) {
            return this._cachedFilteredChars;
        }
        const filtered = [];
        // Pre-calculate empty signature (tofu)
        // We use a fixed size for checking to avoid large canvas requirements
        const checkFont = font.replace(/\d+px/, '16px'); 
        const emptySig = this._getCharSignature(checkFont, '\uFFFF');
        for (let i = 0; i < rawList.length; i++) {
            const char = rawList[i];
            const sig = this._getCharSignature(checkFont, char);
            // If signature exists and is different from tofu, it's supported.
            // (We assume space ' ' is either not in list or handled by renderer if empty)
            if (sig && sig !== emptySig) {
                filtered.push(char);
            }
        }
        this._cachedFilteredChars = (typeof rawList === 'string') ? filtered.join('') : filtered;
        this._cachedFilterKey = key;
        // console.log(`[GlyphAtlas] Filtered chars: ${rawList.length} -> ${filtered.length}`);
        return this._cachedFilteredChars;
    }
    /**
     * Computes a simple pixel sum signature for a character to detect 'tofu'.
     */
    _getCharSignature(font, char) {
        this.testCtx.clearRect(0, 0, 20, 20);
        this.testCtx.font = font;
        this.testCtx.textBaseline = 'middle';
        this.testCtx.textAlign = 'center';
        this.testCtx.fillStyle = '#fff';
        this.testCtx.fillText(char, 10, 10);
        const data = this.testCtx.getImageData(5, 5, 10, 10).data;
        let sum = 0;
        // Check alpha channel
        for(let i = 3; i < data.length; i += 4) {
            sum += data[i];
        }
        return sum;
    }
}
// --- PostProcessor.js ---
// =========================================================================
// POST PROCESSOR
// =========================================================================
class PostProcessor {
    constructor(config) {
        this.config = config;
        this.gl = null;
        this.program = null; // Custom User Shader
        this.effectProgram = null; // System Effect Shader (e.g. Deja Vu)
        this.canvas = document.createElement('canvas'); // Offscreen WebGL canvas
        // Textures
        this.texture = null; // Source Input
        this.intermediateTexture = null; // Output of Pass 1
        // Buffers
        this.positionBuffer = null;
        this.framebuffer = null; // For Pass 1
        this.defaultFragmentShader = `
            precision mediump float;
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uParameter;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = texture2D(uTexture, vTexCoord);
            }
        `;
        this.vertexShaderSource = `
            attribute vec2 aPosition;
            varying vec2 vTexCoord;
            uniform float uFlipY;
            void main() {
                // Map -1..1 to 0..1 for tex coords
                vTexCoord = (aPosition + 1.0) * 0.5;
                if (uFlipY > 0.5) {
                    vTexCoord.y = 1.0 - vTexCoord.y; 
                }
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        this._initWebGL();
    }
    _initWebGL() {
        this.gl = this.canvas.getContext('webgl', { 
            alpha: true, 
            preserveDrawingBuffer: true 
        });
        if (!this.gl) {
            console.warn("WebGL not supported for Post Processing");
            return;
        }
        // Full screen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1
        ]);
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        // Input Texture
        this.texture = this._createTexture();
        // Intermediate Texture (for Pass 1 output)
        this.intermediateTexture = this._createTexture();
        // Framebuffer for Pass 1
        this.framebuffer = this.gl.createFramebuffer();
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.intermediateTexture, 0);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.defaultProgram = this._compileProgram(this.defaultFragmentShader);
        this.compileShader(this.config.get('customShader'));
        this.compileEffectShader(this.config.get('effectShader'));
    }
    _createTexture() {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        return tex;
    }
    compileShader(fragSource) {
        if (!fragSource) {
            this.program = null;
            return;
        }
        this.program = this._compileProgram(fragSource);
    }
    compileEffectShader(fragSource) {
        if (!fragSource) {
            this.effectProgram = null;
            return;
        }
        this.effectProgram = this._compileProgram(fragSource);
    }
    _compileProgram(fragSource) {
        if (!this.gl) return null;
        if (!fragSource) fragSource = this.defaultFragmentShader;
        const createShader = (type, source) => {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                console.warn(type === this.gl.VERTEX_SHADER ? 'Vertex Shader Error' : 'Fragment Shader Error', this.gl.getShaderInfoLog(shader));
                this.gl.deleteShader(shader);
                return null;
            }
            return shader;
        };
        const vs = createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        const fs = createShader(this.gl.FRAGMENT_SHADER, fragSource);
        if (!vs || !fs) return null;
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.warn("Program Link Error", this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    resize(width, height) {
        if (!this.gl) return;
        this.canvas.width = width;
        this.canvas.height = height;
        // Resize textures
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.intermediateTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
    }
    render(sourceCanvas, time, mouseX = 0, mouseY = 0, param = 0.5, effectParam = 0.0) {
        if (!this.gl) return;
        // Ensure state is clean before we start
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        // Upload Source to Input Texture
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceCanvas);
        let inputTex = this.texture;
        let flipY = 1.0; // Default: Flip Y for Canvas source
        // PASS 1: Effect Shader (e.g. Deja Vu)
        if (this.effectProgram) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT); // Clear intermediate FBO
            this._drawPass(this.effectProgram, inputTex, time, mouseX, mouseY, effectParam, flipY);
            // Output of Pass 1 becomes Input of Pass 2
            inputTex = this.intermediateTexture;
            flipY = 0.0; // Next pass uses FBO source, no flip needed
        }
        // PASS 2: Custom Shader (Final Post-Process)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null); // Draw to screen (canvas)
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        const prog = this.program || this.defaultProgram;
        this._drawPass(prog, inputTex, time, mouseX, mouseY, param, flipY);
    }
    _drawPass(prog, texture, time, mouseX, mouseY, param, flipY) {
        this.gl.useProgram(prog);
        const posLoc = this.gl.getAttribLocation(prog, 'aPosition');
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(posLoc);
        this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        const uTex = this.gl.getUniformLocation(prog, 'uTexture');
        this.gl.uniform1i(uTex, 0);
        const uRes = this.gl.getUniformLocation(prog, 'uResolution');
        this.gl.uniform2f(uRes, this.canvas.width, this.canvas.height);
        const uTime = this.gl.getUniformLocation(prog, 'uTime');
        this.gl.uniform1f(uTime, time);
        const uMouse = this.gl.getUniformLocation(prog, 'uMouse');
        if (uMouse) this.gl.uniform2f(uMouse, mouseX, mouseY);
        const uParam = this.gl.getUniformLocation(prog, 'uParameter');
        if (uParam) this.gl.uniform1f(uParam, param);
        const uFlip = this.gl.getUniformLocation(prog, 'uFlipY');
        if (uFlip) this.gl.uniform1f(uFlip, flipY);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
}
// --- WebGLRenderer.js ---
// =========================================================================
// WEBGL RENDERER
// =========================================================================
class WebGLRenderer {
    constructor(canvasId, grid, config, effects) {
        this.cvs = document.getElementById(canvasId);
        // Enforce WebGL2
        this.gl = this.cvs.getContext('webgl2', { alpha: false, preserveDrawingBuffer: false });
        if (!this.gl) {
            console.error("WebGLRenderer: WebGL 2 hardware acceleration not supported.");
            throw new Error("WebGL 2 not supported");
        }
        // Check for Float Texture Support (for HDR Bloom)
        this.canUseFloat = false;
        const ext = this.gl.getExtension('EXT_color_buffer_float');
        if (ext) this.canUseFloat = true;
        this.grid = grid;
        this.config = config;
        this.effects = effects;
        this.glyphAtlases = new Map();
        // --- Core WebGL State ---
        this.program = null;       
        this.bloomProgram = null;  
        this.colorProgram = null;  
        this.atlasTexture = null;  
        this.vao = null;           
        // --- Buffers ---
        this.instanceCapacity = 0; 
        this.instanceData = null; 
        this.instanceBuffer = null;
        this.depthBuffer = null; // New Depth Buffer
        // --- Framebuffers for Bloom ---
        this.fboA = null; 
        this.fboB = null; 
        this.fboC = null; // New Scratch FBO
        this.texA = null; 
        this.texB = null; 
        this.texC = null; // New Scratch Texture
        this.bloomWidth = 0;
        this.bloomHeight = 0;
        // --- State Tracking ---
        this.w = 0;
        this.h = 0;
        this.needsAtlasUpdate = true;
        this.mouseX = 0.5;
        this.mouseY = 0.5;
        this._setupMouseTracking();
        this._initGlimmerTexture(); // Generate Optimization Texture
        this._initShaders();
        this._initBuffers();
        this._initBloomBuffers();
        this._initLineGfxBuffers();
        console.log("Rendering Engine: WebGL 2 (v8 CellGrid Optimized Fixed)");
        if (typeof PostProcessor !== 'undefined') {
            this.postProcessor = new PostProcessor(config);
            this.postProcessor.canvas.id = 'shaderCanvas';
            this.postProcessor.canvas.style.position = 'absolute';
            this.postProcessor.canvas.style.top = '0';
            this.postProcessor.canvas.style.left = '0';
            this.postProcessor.canvas.style.zIndex = '2'; 
            this.postProcessor.canvas.style.display = 'none'; 
            if (this.cvs.parentNode) {
                this.cvs.parentNode.insertBefore(this.postProcessor.canvas, this.cvs.nextSibling);
            }
            this.lastShaderSource = null;
            this.lastEffectSource = null;
        }
    }
    dispose() {
        if (this._mouseMoveHandler) window.removeEventListener('mousemove', this._mouseMoveHandler);
        if (this._touchMoveHandler) window.removeEventListener('touchmove', this._touchMoveHandler);
        if (this.postProcessor && this.postProcessor.canvas && this.postProcessor.canvas.parentNode) {
            this.postProcessor.canvas.parentNode.removeChild(this.postProcessor.canvas);
        }
        if (this.gl) {
            if (this.program2D) this.gl.deleteProgram(this.program2D);
            if (this.program && this.program !== this.program2D) this.gl.deleteProgram(this.program);
            if (this.bloomProgram) this.gl.deleteProgram(this.bloomProgram);
            if (this.colorProgram) this.gl.deleteProgram(this.colorProgram);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        }
    }
    _isMenuOpen() {
        const panel = document.getElementById('settingsPanel');
        return panel && panel.classList.contains('open');
    }
    _setupMouseTracking() {
        this._mouseMoveHandler = (e) => {
            if (this._isMenuOpen()) return;
            // Fallback for 2D or unlocked 3D (standard cursor tracking)
            const rect = this.cvs.getBoundingClientRect();
            this.mouseX = (e.clientX - rect.left) / rect.width;
            this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height);
        };
        this._touchMoveHandler = (e) => {
            if (this._isMenuOpen()) return;
            if (e.touches.length > 0) {
                const rect = this.cvs.getBoundingClientRect();
                this.mouseX = (e.clientX - rect.left) / rect.width;
                this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height);
            }
        };
        window.addEventListener('mousemove', this._mouseMoveHandler);
        window.addEventListener('touchmove', this._touchMoveHandler, { passive: true });
    }
    _initGlimmerTexture() {
        // Generate a 64x256 Noise Texture for Glimmer Optimization
        // Uses Strict Orthogonal "Manhattan" Walkers for Tetris-like connectivity
        const w = 64;
        const h = 256;
        const data = new Uint8Array(w * h);
        data.fill(0);
        // More walkers, but much sparser trail (fragmented)
        const numWalkers = 40;
        for (let n = 0; n < numWalkers; n++) {
            let x = Math.floor(Math.random() * w);
            let y = 0;
            let steps = 0;
            const maxSteps = h * 4; 
            while (y < h && steps < maxSteps) {
                // Fragmented: Only 40% chance to draw a block at current step
                // This creates "broken" connections and inconsistency
                if (Math.random() < 0.4) {
                    data[y * w + x] = 255;
                }
                const r = Math.random();
                if (r < 0.65) {
                    // Move UP (65% chance)
                    y++;
                } else if (r < 0.825) {
                    // Move LEFT
                    x = (x - 1 + w) % w;
                } else {
                    // Move RIGHT
                    x = (x + 1) % w;
                }
                steps++;
            }
        }
        this.glimmerTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.glimmerTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, w, h, 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, data);
        // Use NEAREST to preserve "Blocky/Digital" look
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    }
    _createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    _createProgram(vsSource, fsSource) {
        const vs = this._createShader(this.gl.VERTEX_SHADER, vsSource);
        const fs = this._createShader(this.gl.FRAGMENT_SHADER, fsSource);
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
        _initShaders() {
            // --- SHADOW MASK SHADER ---
            const shadowVS = `#version 300 es
                layout(location=0) in vec2 a_quad;
                layout(location=1) in vec4 a_rect;
                layout(location=2) in float a_alpha;
                layout(location=3) in float a_blur;
                uniform vec2 u_gridSize;
                out vec2 v_uv;
                out float v_alpha;
                out float v_blur;
                void main() {
                    vec2 size = a_rect.zw;
                    vec2 pos = a_rect.xy;
                    vec2 worldPos = pos + (a_quad * size);
                    vec2 uv = worldPos / u_gridSize;
                    gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
                    v_uv = a_quad;
                    v_alpha = a_alpha;
                    v_blur = a_blur;
                }
            `;
            const shadowFS = `#version 300 es
                precision mediump float;
                in vec2 v_uv;
                in float v_alpha;
                in float v_blur;
                out vec4 fragColor;
                void main() {
                    vec2 d = abs(v_uv - 0.5) * 2.0;
                    float dist = max(d.x, d.y);
                    float edge = 1.0 - smoothstep(1.0 - max(0.001, v_blur), 1.0, dist);
                    fragColor = vec4(0.0, 0.0, 0.0, v_alpha * edge);
                }
            `;
            this.shadowProgram = this._createProgram(shadowVS, shadowFS);
            // --- QUANTIZED LINE GFX SHADER ---
            const lineVS = `#version 300 es
                precision highp float;
                layout(location=0) in vec2 a_quad;
                out vec2 v_uv;
                void main() {
                    v_uv = a_quad;
                    gl_Position = vec4(a_quad * 2.0 - 1.0, 0.0, 1.0);
                }
            `;
            const lineFS = `#version 300 es
                precision highp float;
                in vec2 v_uv;
                uniform sampler2D u_characterBuffer;
                uniform sampler2D u_persistenceBuffer;
                uniform sampler2D u_sourceGrid;
                uniform sampler2D u_logicGrid;
                uniform vec2 u_logicGridSize; 
                uniform vec2 u_screenOrigin;
                uniform vec2 u_screenStep;
                uniform vec2 u_cellPitch;
                uniform vec2 u_blockOffset; 
                uniform vec2 u_userBlockOffset;
                uniform vec2 u_resolution;
                uniform vec2 u_offset;
                uniform int u_mode; // 0 = Generate, 1 = Composite, 2 = Pure Blit
                uniform ivec3 u_layerOrder; 
                uniform float u_thickness;
                uniform vec3 u_color;
                uniform float u_intensity;
                uniform float u_glow;
                out vec4 fragColor;
                vec3 getOccupancy(vec2 pos) {
                    if (pos.x < 0.0 || pos.x >= u_logicGridSize.x || pos.y < 0.0 || pos.y >= u_logicGridSize.y) return vec3(0.0);
                    return texture(u_logicGrid, (pos + 0.5) / u_logicGridSize).rgb;
                }
                float getLayerVal(vec3 occ, int layerIdx) {
                    if (layerIdx == 0) return occ.r;
                    if (layerIdx == 1) return occ.g;
                    if (layerIdx == 2) return occ.b;
                    return 0.0;
                }
                void main() {
                    if (u_mode == 2) {
                        fragColor = texture(u_characterBuffer, v_uv);
                        return;
                    }
                    if (u_mode == 1) {
                        vec4 base = texture(u_characterBuffer, v_uv);
                        float persist = texture(u_persistenceBuffer, v_uv).r;
                        // Sample Source Grid for illumination points
                        vec4 sourceChar = texture(u_sourceGrid, v_uv);
                        float charLuma = max(sourceChar.r, max(sourceChar.g, sourceChar.b));
                        // Additive highlight based on Source Grid characters
                        vec3 highlight = u_color * persist * charLuma;
                        fragColor = vec4(base.rgb + highlight, base.a);
                        return;
                    }
                    vec2 screenPos = v_uv * u_resolution - u_offset;
                    vec2 gridPos = (screenPos - u_screenOrigin) / u_screenStep;
                    vec2 logicPos = gridPos / u_cellPitch + u_blockOffset - u_userBlockOffset;
                    vec2 blockCoord = floor(logicPos);
                    vec2 cellLocal = fract(logicPos);
                    vec3 centerOcc = getOccupancy(blockCoord);
                    vec3 leftOcc = getOccupancy(blockCoord + vec2(-1.0, 0.0));
                    vec3 rightOcc = getOccupancy(blockCoord + vec2(1.0, 0.0));
                    vec3 upOcc = getOccupancy(blockCoord + vec2(0.0, -1.0));
                    vec3 downOcc = getOccupancy(blockCoord + vec2(0.0, 1.0));
                    float dist = 1e10;
                    bool isVisible = false;
                    for (int i = 0; i < 3; i++) {
                        int L = u_layerOrder[i];
                        float cL = getLayerVal(centerOcc, L);
                        bool hasEdge = false;
                        float layerDist = 1e10;
                        if ((cL > 0.5) != (getLayerVal(leftOcc, L) > 0.5)) { layerDist = min(layerDist, cellLocal.x * u_cellPitch.x); hasEdge = true; }
                        if ((cL > 0.5) != (getLayerVal(rightOcc, L) > 0.5)) { layerDist = min(layerDist, (1.0 - cellLocal.x) * u_cellPitch.x); hasEdge = true; }
                        if ((cL > 0.5) != (getLayerVal(upOcc, L) > 0.5)) { layerDist = min(layerDist, cellLocal.y * u_cellPitch.y); hasEdge = true; }
                        if ((cL > 0.5) != (getLayerVal(downOcc, L) > 0.5)) { layerDist = min(layerDist, (1.0 - cellLocal.y) * u_cellPitch.y); hasEdge = true; }
                        if (hasEdge) {
                            bool obscured = false;
                            for (int m = 0; m < i; m++) {
                                int M = u_layerOrder[m];
                                if (getLayerVal(centerOcc, M) > 0.5) { obscured = true; break; }
                            }
                            if (!obscured) {
                                dist = min(dist, layerDist);
                                isVisible = true;
                            }
                        }
                    }
                    float total = 0.0;
                    if (isVisible) {
                        float halfThick = (u_thickness / 10.0) * 0.5;
                        float line = 1.0 - smoothstep(halfThick - 0.05, halfThick + 0.05, dist);
                        float glow = exp(-dist * 2.0) * (u_glow * 0.5);
                        total = max(line, glow) * u_intensity;
                    }
                    fragColor = vec4(total, 0.0, 0.0, 1.0);
                }
            `;
            this.lineProgram = this._createProgram(lineVS, lineFS);
            // --- MATRIX SHADERS (SPLIT 2D/3D) ---
            const matrixVS_Common = `#version 300 es
                precision mediump float;
                layout(location=0) in vec2 a_quad;
                layout(location=1) in vec2 a_pos;
                layout(location=2) in float a_charIdx;
                layout(location=3) in vec4 a_color;
                layout(location=4) in float a_alpha;
                layout(location=5) in float a_decay;
                layout(location=6) in float a_glow;
                layout(location=7) in float a_mix;
                layout(location=8) in float a_nextChar;
                layout(location=9) in vec3 a_depth;
                layout(location=10) in float a_maxDecay;
                out vec2 v_uv;
                out vec2 v_uv2;
                out vec4 v_color;
                out float v_mix;
                out float v_glow;
                out float v_prog;
                out vec2 v_screenUV;
                out vec2 v_shadowUV;
                out vec2 v_cellUV;
            `;
            // 2D Vertex Shader
            const matrixVS2D = matrixVS_Common + `
                uniform vec2 u_resolution;
                uniform vec2 u_atlasSize;
                uniform vec2 u_gridSize;
                uniform vec2 u_gridOffset; 
                uniform float u_cellSize;
                uniform float u_cols;
                uniform float u_decayDur;
                uniform vec2 u_stretch;
                uniform float u_mirror;
                uniform float u_dissolveEnabled;
                uniform float u_dissolveScale;
                void main() {
                    // Decay Scale Logic
                    float scale = 1.0;
                    v_prog = 0.0;
                    v_cellUV = a_quad;
                    if (a_decay >= 2.0) {
                        float duration = (a_maxDecay > 0.0) ? a_maxDecay : u_decayDur;
                        v_prog = (a_decay - 2.0) / duration;
                        if (u_dissolveEnabled > 0.5) {
                            scale = mix(1.0, u_dissolveScale, v_prog);
                        } else {
                            scale = 1.0;
                        }
                    }
                    // Position Calculation (2D)
                    vec2 centerPos2D = (a_quad - 0.5) * u_cellSize * scale;
                    vec2 worldPos = a_pos + centerPos2D;
                    v_shadowUV = (worldPos + u_gridOffset) / u_gridSize;
                    // Mirror/Stretch
                    vec2 gridCenter = u_gridSize * 0.5;
                    worldPos.x = (worldPos.x - gridCenter.x) * u_stretch.x + (u_resolution.x * 0.5);
                    worldPos.y = (worldPos.y - gridCenter.y) * u_stretch.y + (u_resolution.y * 0.5);
                    if (u_mirror < 0.0) worldPos.x = u_resolution.x - worldPos.x;
                    // 2D Mode (Legacy Clip Space)
                    vec2 clip = (worldPos / u_resolution) * 2.0 - 1.0;
                    clip.y = -clip.y;
                    gl_Position = vec4(clip, 0.0, 1.0);
                    // Pass Attributes
                    vec3 ndc = gl_Position.xyz / gl_Position.w;
                    v_screenUV = ndc.xy * 0.5 + 0.5;
                    v_color = a_color;
                    v_color.a *= a_alpha;
                    v_mix = a_mix;
                    v_glow = a_glow;
                    // UV 1
                    float cIdx = a_charIdx;
                    float row = floor(cIdx / u_cols);
                    float col = mod(cIdx, u_cols);
                    vec2 uvBase = vec2(col, row) * u_cellSize;
                    v_uv = (uvBase + (a_quad * u_cellSize)) / u_atlasSize;
                    // UV 2
                    if (a_mix > 0.0) {
                        float cIdx2 = a_nextChar;
                        float row2 = floor(cIdx2 / u_cols);
                        float col2 = mod(cIdx2, u_cols);
                        vec2 uvBase2 = vec2(col2, row2) * u_cellSize;
                        v_uv2 = (uvBase2 + (a_quad * u_cellSize)) / u_atlasSize;
                    } else {
                        v_uv2 = v_uv;
                    }
                }
            `;
            // Optimized Fragment Shader (Shared)
            const matrixFS = `#version 300 es
                precision mediump float;
                in vec2 v_uv;
                in vec2 v_uv2;
                in vec4 v_color;
                in float v_mix;
                in float v_glow;
                in float v_prog;
                in vec2 v_screenUV;
                in vec2 v_shadowUV;
                in vec2 v_cellUV;
                uniform sampler2D u_texture;
                uniform sampler2D u_shadowMask; 
                uniform sampler2D u_glimmerNoise; // <-- Optimization Texture
                uniform float u_time;
                uniform float u_dissolveEnabled; 
                uniform float u_dissolveScale;
                uniform float u_dissolveSize;
                uniform float u_deteriorationEnabled;
                uniform float u_deteriorationStrength;
                uniform vec2 u_atlasSize;
                uniform vec2 u_gridSize; 
                uniform float u_cellSize; 
                uniform vec2 u_cellScale; 
                uniform vec4 u_overlapColor;
                uniform float u_glimmerSpeed;
                uniform float u_glimmerSize;
                uniform float u_glimmerFill; // Unused in optimized version (baked into texture density)
                uniform float u_glimmerIntensity;
                uniform float u_glimmerFlicker; // Controls spread of flicker
                // 0 = Base (Glyphs/Glow), 1 = Shadow
                uniform int u_passType;
                out vec4 fragColor;
                // Pseudo-random function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                vec2 random2(vec2 st) {
                    st = vec2( dot(st,vec2(127.1,311.7)),
                               dot(st,vec2(269.5,183.3)) );
                    return -1.0 + 2.0*fract(sin(st)*43758.5453123);
                }
                // Helper to apply all visual degradations (Dissolve + Ghosting) identically
                float getProcessedAlpha(vec2 uv) {
                    float a = texture(u_texture, uv).a;
                    float ghost1 = 0.0;
                    float ghost2 = 0.0;
                    // Trail Ghosting (Vertical Blur) - Sample first
                    if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                        float blurDist = (u_deteriorationStrength * v_prog) / u_atlasSize.y;
                        ghost1 = texture(u_texture, uv + vec2(0.0, blurDist)).a;
                        ghost2 = texture(u_texture, uv - vec2(0.0, blurDist)).a;
                    }
                    // Alpha Erosion Dissolve (Burn away from edges)
                    // Apply to MAIN char AND GHOSTS
                    if (u_dissolveEnabled > 0.5 && v_prog > 0.0) {
                        float erosion = v_prog * 1.2; 
                        a = min(a, smoothstep(erosion, erosion + 0.1, a));
                        if (ghost1 > 0.0) ghost1 = min(ghost1, smoothstep(erosion, erosion + 0.1, ghost1));
                        if (ghost2 > 0.0) ghost2 = min(ghost2, smoothstep(erosion, erosion + 0.1, ghost2));
                    }
                    // Combine
                    if (u_deteriorationEnabled > 0.5 && v_prog > 0.0) {
                        a = max(a, max(ghost1, ghost2) * 0.5);
                    }
                    return a;
                }
                void main() {
                    // Decode High Priority Signal
                    bool isHighPriority = (v_mix >= 9.5);
                    float useMix = isHighPriority ? v_mix - 10.0 : v_mix;
                    // Sample Shadow Mask
                    float shadow = texture(u_shadowMask, v_shadowUV).a;
                    // Sample Texture with Effects
                    float tex1 = getProcessedAlpha(v_uv);
                    vec4 baseColor = v_color;
                    // Default Standard Mode
                    float finalAlpha = tex1;
                    // GLIMMER LOGIC (State 30.0 -> useMix 20.0)
                    float glimmer = 0.0;
                    if (useMix >= 19.5) {
                        float gOpacity = clamp(useMix - 20.0, 0.0, 1.0);
                        useMix = 0.0; // Reset
                        float rawTex = texture(u_texture, v_uv).a;
                        if (rawTex > 0.3) {
                            // 1. Calculate Seed with Time Step (Pattern Switching)
                            // u_glimmerSpeed controls the frequency of pattern changes (Hz)
                            float switchFreq = max(0.01, u_glimmerSpeed);
                            float timeStep = floor(u_time * switchFreq);
                            vec2 renderSize = u_cellSize * u_cellScale; 
                            vec2 cellGridPos = floor((v_shadowUV * u_gridSize) / renderSize);
                            // Perturb seed with timeStep to switch patterns
                            vec2 seed = cellGridPos + vec2(timeStep * 37.0, timeStep * 11.0);
                            float cellRand = random(seed);
                            // 2. Determine Shape/Position
                            // "Lamp illuminating pattern from behind" - Shapes are geometric/tech
                            vec2 center = vec2(0.5);
                            vec2 sizeBounds = vec2(0.1, 0.1); // Default
                            float rotation = 0.0;
                            // Probability Distribution (Refactored for Balance):
                            // 0.00 - 0.40: Vertical Bars (40%) -> High priority per user request
                            // 0.40 - 0.60: Horizontal Bars (20%)
                            // 0.60 - 0.70: Small Rects (10%)
                            // 0.70 - 1.00: Diagonals (30%) -> Split evenly 15% each
                            if (cellRand < 0.20) {
                                // Vertical Left
                                center = vec2(0.2, 0.5);
                                sizeBounds = vec2(0.08, 0.45);
                            } else if (cellRand < 0.40) {
                                // Vertical Right
                                center = vec2(0.8, 0.5);
                                sizeBounds = vec2(0.08, 0.45);
                            } else if (cellRand < 0.47) {
                                // Horizontal Top
                                center = vec2(0.5, 0.8);
                                sizeBounds = vec2(0.45, 0.08);
                            } else if (cellRand < 0.54) {
                                // Horizontal Bottom
                                center = vec2(0.5, 0.2);
                                sizeBounds = vec2(0.45, 0.08);
                            } else if (cellRand < 0.60) {
                                // Horizontal Middle
                                center = vec2(0.5, 0.5);
                                sizeBounds = vec2(0.45, 0.06);
                            } else if (cellRand < 0.70) {
                                // Small Rect Center
                                center = vec2(0.5, 0.5);
                                sizeBounds = vec2(0.15, 0.15);
                            } else if (cellRand < 0.85) {
                                // Diagonal 1: Bottom-Left to Top-Right (/)
                                // Rotation +45 deg aligns local X with diagonal
                                rotation = 0.785398; 
                                sizeBounds = vec2(0.05, 0.55); 
                            } else {
                                // Diagonal 2: Top-Left to Bottom-Right (\)
                                // Rotation -45 deg
                                rotation = -0.785398; 
                                sizeBounds = vec2(0.05, 0.55);
                            }
                            // 3. Sample Noise Texture (Luminosity Modulator)
                            // Remove continuous scrolling. Pattern is static per timeStep.
                            // Map Cell Position to Texture Space
                            vec2 noiseUV = vec2(cellGridPos.x / 64.0, cellGridPos.y / 64.0);
                            // Apply random offset based on seed
                            noiseUV += vec2(cellRand * 123.0, cellRand * 456.0);
                            float activeVal = texture(u_glimmerNoise, noiseUV).r;
                            // 4. Draw Shape (Geometry is Constant per Cell)
                            vec2 p = v_cellUV - center;
                            // Apply Rotation if needed
                            if (rotation != 0.0) {
                                float s = sin(rotation);
                                float c = cos(rotation);
                                p = vec2(p.x * c - p.y * s, p.x * s + p.y * c);
                            }
                            p = abs(p);
                            float r = 0.01; // Sharp corners
                            float d = length(max(p - sizeBounds, 0.0)) + min(max(p.x - sizeBounds.x, p.y - sizeBounds.y), 0.0) - r;
                            float core = 1.0 - smoothstep(-0.01, 0.01, d);
                            float halo = 1.0 - smoothstep(0.0, 0.15, d);
                            float shape = core + (halo * 0.4);
                            // 5. Apply Luminosity & Flicker
                            // "Bad Connection / Fluorescent" Flicker
                            float flicker = 1.0;
                            // Flicker Spread Control:
                            // u_glimmerFlicker determines probability of a cell being "faulty"
                            if (cellRand < u_glimmerFlicker) {
                                // 1. Primary Flicker Cycle (Variable speed per cell)
                                float cycleSpeed = 10.0 + (cellRand * 20.0);
                                float flickerBase = sin(u_time * cycleSpeed + (cellRand * 100.0));
                                // 2. Hard Cutout (Thresholding)
                                // Occasional complete dropouts. If base wave is low, light cuts out.
                                float cutout = smoothstep(-0.4, -0.2, flickerBase);
                                // 3. High Frequency Jitter (When ON)
                                // Simulates the electrical noise
                                float jitter = 0.7 + 0.6 * fract(sin(dot(vec2(u_time, cellRand), vec2(12.9898,78.233))) * 43758.5453);
                                flicker = cutout * jitter;
                                // 4. Long Random Dropouts (The "Dead Cell" Effect)
                                // Sample noise at a very slow speed
                                vec2 dropoutUV = vec2(cellGridPos.x / 13.0, (u_time * 0.5) + cellRand * 50.0);
                                float dropoutVal = texture(u_glimmerNoise, dropoutUV).r;
                                // 20% chance to be completely dead at any moment for flickering cells
                                if (dropoutVal < 0.2) {
                                    flicker = 0.0;
                                }
                            }
                            // Combine: Shape * NoiseModulation * Flicker * Opacity
                            glimmer = shape * (0.4 + (0.6 * activeVal)) * flicker;
                            glimmer *= gOpacity;
                        }
                    }
                    if (useMix >= 4.0) {
                        // Overlay Mode (Tracers/Effects)
                        // Use baseColor so tracers follow Stream Color.
                        float originalBaseAlpha = baseColor.a;
                        float ovAlpha = useMix - 4.0;
                        float tex2 = getProcessedAlpha(v_uv2);
                        float effA = tex2 * ovAlpha;
                        float simA = tex1 * originalBaseAlpha;
                        // Mix towards White (Tracer-like) instead of just boosting brightness
                        vec3 targetColor = vec3(0.95, 0.95, 0.95); 
                        baseColor.rgb = mix(baseColor.rgb, targetColor, effA);
                        finalAlpha = max(simA, effA);
                        baseColor.a = 1.0; // Prevent base instance alpha (0 for empty) from killing the overlay
                    } else if (useMix >= 3.0) {
                        // Solid Mode
                        finalAlpha = 1.0;
                    } else if (useMix >= 2.0) {
                        // Overlap Mode
                        // Apply same effects to secondary character
                        float tex2 = getProcessedAlpha(v_uv2);
                        float intersection = tex1 * tex2;
                        // Primary visible, secondary invisible except intersection
                        finalAlpha = tex1; 
                        // If intersecting, use overlap color
                        if (intersection > 0.1) {
                                baseColor.rgb = u_overlapColor.rgb;
                        }
                    } else if (useMix > 0.0) {
                        // Rotator Mix
                        // For rotator, we might NOT want dissolve/ghosting on the incoming char yet?
                        // Usually rotator happens on active cells (decay=0).
                        // If decay=0, getProcessedAlpha just returns raw alpha. So it's safe.
                        float tex2 = getProcessedAlpha(v_uv2);
                        finalAlpha = mix(tex1, tex2, useMix);
                    }
                    if (finalAlpha < 0.01) discard;
                    // Apply Shadow Darkening
                    // shadow = 0..1 (0=No Shadow, 1=Black)
                    // LAYER PRECEDENCE:
                    // 1. Background Code & Tracers -> Affect by Shadow
                    // 2. High Priority Effects (Lightning) -> Ignore Shadow (v_mix >= 10.0)
                    if (!isHighPriority) {
                        baseColor.rgb *= (1.0 - shadow);
                    }
                    vec4 col = baseColor;
                    // Boost brightness for glow (Bloom trigger)
                    // Multiply by alpha to ensure it fades out with the character
                    if (v_glow > 0.0) {
                        // GLOW logic must also respect shadow for non-high-priority effects!
                        // If shadow is active, the baseColor is darkened.
                        // The GLOW should also be darkened/suppressed.
                        // Otherwise a black char will still emit light.
                        float glowFactor = v_glow;
                        if (!isHighPriority) {
                            glowFactor *= (1.0 - shadow);
                        }
                        col.rgb += (glowFactor * 0.3 * col.a);
                    }
                    // Base Alpha (Stream Fade)
                    float streamAlpha = col.a * finalAlpha;
                    if (glimmer > 0.0) {
                        // 1. Turn the block White (mix base color to white)
                        // Clamp mixing factor to 1.0 to stay within white range
                        col.rgb = mix(col.rgb, vec3(1.0), min(1.0, glimmer));
                        // 2. Add Bright Glow (Additively)
                        // Use u_glimmerIntensity (from slider) to boost brightness significantly
                        // We do NOT multiply by shadow here, allowing glimmer to pierce darkness
                        // Scale by 0.3 to match standard glow intensity curve
                        vec3 glowBoost = vec3(u_glimmerIntensity * 0.3) * glimmer;
                        col.rgb += glowBoost;
                        // Force alpha to be at least the glimmer opacity
                        streamAlpha = max(streamAlpha, glimmer);
                    }
                    fragColor = vec4(col.rgb, streamAlpha);
                }
            `;
            this.program2D = this._createProgram(matrixVS2D, matrixFS);
            this.program = this.program2D; // Default fallback
            // Keep existing Bloom/Color programs
            const bloomVS = `#version 300 es\nlayout(location=0) in vec2 a_position; out vec2 v_uv; void main(){ v_uv=a_position*0.5+0.5; gl_Position=vec4(a_position, 0.0, 1.0); }`;
            const bloomFS = `#version 300 es\nprecision mediump float; in vec2 v_uv; uniform sampler2D u_image; uniform bool u_horizontal; uniform float u_weight[5]; uniform float u_spread; uniform float u_opacity; out vec4 fragColor; void main(){ vec2 tex_offset=(1.0/vec2(textureSize(u_image, 0)))*u_spread; vec3 result=texture(u_image, v_uv).rgb*u_weight[0]; if(u_horizontal){ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(tex_offset.x*float(i), 0.0)).rgb*u_weight[i]; } }else{ for(int i=1; i<5; ++i){ result+=texture(u_image, v_uv+vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; result+=texture(u_image, v_uv-vec2(0.0, tex_offset.y*float(i))).rgb*u_weight[i]; } } fragColor=vec4(result*u_opacity, 1.0); }`;
            this.bloomProgram = this._createProgram(bloomVS, bloomFS);
            const colorVS = `#version 300 es\nlayout(location=0) in vec2 a_position; void main(){ gl_Position=vec4(a_position, 0.0, 1.0); }`;
            const colorFS = `#version 300 es\nprecision mediump float; uniform vec4 u_color; out vec4 fragColor; void main(){ fragColor=u_color; }`;
            this.colorProgram = this._createProgram(colorVS, colorFS);
        }
    _initBuffers() {
        const quadVerts = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);
        const screenQuadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
        this.quadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, quadVerts, this.gl.STATIC_DRAW);
        this.screenQuadBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, screenQuadVerts, this.gl.STATIC_DRAW);
        // Shadow Instance Buffer (Dynamic)
        this.shadowInstanceBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
        this.shadowInstanceCapacity = 1000;
        // Initial capacity: 1000 sheets * 20 bytes (x,y,w,h,a)
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * 20, this.gl.DYNAMIC_DRAW);
        // Instance buffers will be created in resize()
        this.posBuffer = null;
        this.charBuffer = null;
        this.colorBuffer = null;
        this.alphaBuffer = null;
        this.decayBuffer = null;
        this.glowBuffer = null;
        this.mixBuffer = null;
        this.nextCharBuffer = null;
        this.maxDecayBuffer = null;
        // Mapped Arrays (CPU side)
        this.mappedChars = null;
        this.mappedNextChars = null;
    }
    _initBloomBuffers() {
        this.fboA = this.gl.createFramebuffer(); this.texA = this.gl.createTexture();
        this.fboA2 = this.gl.createFramebuffer(); this.texA2 = this.gl.createTexture();
        this.fboB = this.gl.createFramebuffer(); this.texB = this.gl.createTexture();
        this.fboC = this.gl.createFramebuffer(); this.texC = this.gl.createTexture();
        // Line Persistence
        this.fboLinePersist = this.gl.createFramebuffer();
        this.texLinePersist = this.gl.createTexture();
        // Shadow Mask FBO
        this.shadowMaskFbo = this.gl.createFramebuffer(); 
        this.shadowMaskTex = this.gl.createTexture();
    }
    _initLineGfxBuffers() {
        this.logicGridTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.logicGridTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.lastLogicGridWidth = 0;
        this.lastLogicGridHeight = 0;
        this.sourceGridTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceGridTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.lastSourceGridSeed = -1;
    }
    _configureFramebuffer(fbo, tex, width, height) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fbo);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        let internalFormat = this.gl.RGBA;
        let type = this.gl.UNSIGNED_BYTE;
        if (this.canUseFloat) {
            internalFormat = this.gl.RGBA16F;
            type = this.gl.HALF_FLOAT;
        }
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, internalFormat, width, height, 0, this.gl.RGBA, type, null);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, tex, 0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
    handleFontChange() { this.glyphAtlases.clear(); this.needsAtlasUpdate = true; }
    handleAppearanceChange() { this.needsAtlasUpdate = true; }
    updateSmoothing() { 
        const s = this.config.state.smoothingEnabled ? this.config.state.smoothingAmount : 0; 
        this.cvs.style.filter = `blur(${s}px)`; 
    }
    resize() {
        const s = this.config.state;
        const d = this.config.derived;
        const scale = s.resolution;
        this.handleAppearanceChange();
        this.w = window.innerWidth;
        this.h = window.innerHeight;
        // Fix: Explicitly set CSS size to match window, independent of buffer resolution
        this.cvs.style.width = `${this.w}px`;
        this.cvs.style.height = `${this.h}px`;
        const pw = Math.floor(this.w * scale);
        const ph = Math.floor(this.h * scale);
        if (this.cvs.width !== pw || this.cvs.height !== ph) {
            this.cvs.width = pw; this.cvs.height = ph; this.gl.viewport(0, 0, pw, ph);
        }
        if (this.fboWidth !== pw || this.fboHeight !== ph) {
            this.fboWidth = pw; this.fboHeight = ph;
            this.bloomWidth = Math.floor(pw * 0.5); this.bloomHeight = Math.floor(ph * 0.5);
            if (pw > 0 && ph > 0) {
                this._configureFramebuffer(this.fboA, this.texA, this.fboWidth, this.fboHeight);
                this._configureFramebuffer(this.fboA2, this.texA2, this.fboWidth, this.fboHeight);
                this._configureFramebuffer(this.fboLinePersist, this.texLinePersist, this.fboWidth, this.fboHeight);
                this._configureFramebuffer(this.fboB, this.texB, this.bloomWidth, this.bloomHeight);
                this._configureFramebuffer(this.fboC, this.texC, this.bloomWidth, this.bloomHeight);
                // Shadow Mask (Matches Render Resolution)
                this._configureFramebuffer(this.shadowMaskFbo, this.shadowMaskTex, this.fboWidth, this.fboHeight);
            }
        }
        if (this.postProcessor) { this.postProcessor.resize(pw, ph); this.postProcessor.canvas.style.width = `${this.w}px`; this.postProcessor.canvas.style.height = `${this.h}px`; }
        // --- Resize Buffers ---
        const totalCells = this.grid.cols * this.grid.rows;
        // Helper to recreate buffer
        const ensureBuf = (buf, size, drawType = this.gl.DYNAMIC_DRAW) => {
             if (buf) this.gl.deleteBuffer(buf);
             const newBuf = this.gl.createBuffer();
             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, newBuf);
             this.gl.bufferData(this.gl.ARRAY_BUFFER, size, drawType);
             return newBuf;
        };
        // Static Position Buffer
        this.posBuffer = ensureBuf(this.posBuffer, totalCells * 8, this.gl.STATIC_DRAW); // 2 floats * 4 bytes
        const posData = new Float32Array(totalCells * 2);
        const cw = d.cellWidth; const ch = d.cellHeight;
        const xOff = 0; const yOff = 0;
        for (let i = 0; i < totalCells; i++) {
             const col = i % this.grid.cols;
             const row = Math.floor(i / this.grid.cols);
             posData[i*2] = col * cw + cw * 0.5 + xOff;
             posData[i*2+1] = row * ch + ch * 0.5 + yOff;
        }
        // Fix: Explicitly bind posBuffer before uploading posData
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, posData);
        // Dynamic Buffers
        this.charBuffer = ensureBuf(this.charBuffer, totalCells * 2); // Uint16
        this.colorBuffer = ensureBuf(this.colorBuffer, totalCells * 4); // Uint32 (RGBA)
        this.alphaBuffer = ensureBuf(this.alphaBuffer, totalCells * 4); // Float32
        this.decayBuffer = ensureBuf(this.decayBuffer, totalCells); // Uint8
        this.glowBuffer = ensureBuf(this.glowBuffer, totalCells * 4); // Float32
        this.mixBuffer = ensureBuf(this.mixBuffer, totalCells * 4); // Float32
        this.nextCharBuffer = ensureBuf(this.nextCharBuffer, totalCells * 2); // Uint16
        this.maxDecayBuffer = ensureBuf(this.maxDecayBuffer, totalCells * 2); // Uint16
        // Mapped Arrays
        this.mappedChars = new Uint16Array(totalCells);
        this.mappedNextChars = new Uint16Array(totalCells);
        // Upload Buffers (CPU merging for overrides/effects)
        this.uploadColors = new Uint32Array(totalCells);
        this.uploadAlphas = new Float32Array(totalCells);
        this.uploadDecays = new Uint8Array(totalCells); // Decays usually don't have overrides but safe to copy
        this.uploadMaxDecays = new Uint16Array(totalCells);
        this.uploadGlows = new Float32Array(totalCells);
        this.uploadMix = new Float32Array(totalCells);
        this._setupVAO();
    }
    _setupVAO() {
        if (this.vao) this.gl.deleteVertexArray(this.vao);
        this.vao = this.gl.createVertexArray();
        this.gl.bindVertexArray(this.vao);
        // 0: Quad (Vertex)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        // 1: Pos (Static Instance)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.enableVertexAttribArray(1);
        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(1, 1);
        // 2: CharIdx (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.enableVertexAttribArray(2);
        this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(2, 1);
        // 3: Color (Dynamic Instance, Uint32 -> Vec4 Normalized)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.enableVertexAttribArray(3);
        this.gl.vertexAttribPointer(3, 4, this.gl.UNSIGNED_BYTE, true, 0, 0);
        this.gl.vertexAttribDivisor(3, 1);
        // 4: Alpha (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.enableVertexAttribArray(4);
        this.gl.vertexAttribPointer(4, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(4, 1);
        // 5: Decay (Dynamic Instance, Uint8 -> Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.enableVertexAttribArray(5);
        this.gl.vertexAttribPointer(5, 1, this.gl.UNSIGNED_BYTE, false, 0, 0);
        this.gl.vertexAttribDivisor(5, 1);
        // 6: Glow (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.enableVertexAttribArray(6);
        this.gl.vertexAttribPointer(6, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(6, 1);
        // 7: Mix (Dynamic Instance, Float)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.enableVertexAttribArray(7);
        this.gl.vertexAttribPointer(7, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.vertexAttribDivisor(7, 1);
        // 8: NextChar (Dynamic Instance, Uint16 -> Float/Int)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.enableVertexAttribArray(8);
        this.gl.vertexAttribPointer(8, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(8, 1);
        // 10: MaxDecay (Dynamic Instance, Uint16 -> Float)
        // Location 9 is depth (unused in 2D but reserved), skipping to 10
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.maxDecayBuffer);
        this.gl.enableVertexAttribArray(10);
        this.gl.vertexAttribPointer(10, 1, this.gl.UNSIGNED_SHORT, false, 0, 0);
        this.gl.vertexAttribDivisor(10, 1);
        this.gl.bindVertexArray(null);
    }
    _drawFullscreenTexture(texture, opacity, blurAmt) {
        if (!this.bloomProgram) return;
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [1.0, 0.0, 0.0, 0.0, 0.0];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), 1);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    _renderQuantizedLineGfx(s, d, sourceTex) {
        let fx = null;
        if (this.effects && this.effects.effects) {
            const effectList = (Array.isArray(this.effects.effects)) 
                ? this.effects.effects 
                : (this.effects.effects instanceof Map) 
                    ? Array.from(this.effects.effects.values()) 
                    : [];
            fx = effectList.find(e => e.active && e.name.startsWith('Quantized'));
        }
        if (!fx || !fx.renderGrid) return false;
        const gw = fx.logicGridW;
        const gh = fx.logicGridH;
        if (gw <= 0 || gh <= 0) return false;
        if (gw !== this.lastLogicGridWidth || gh !== this.lastLogicGridHeight) {
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.logicGridTexture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGB, gw, gh, 0, this.gl.RGB, this.gl.UNSIGNED_BYTE, null);
            this.lastLogicGridWidth = gw;
            this.lastLogicGridHeight = gh;
        }
        const occupancy = new Uint8Array(gw * gh * 3);
        for (let i = 0; i < gw * gh; i++) {
            for (let L = 0; L < 3; L++) {
                const grid = fx.layerGrids[L];
                occupancy[i * 3 + L] = (grid && grid[i] !== -1) ? 255 : 0;
            }
        }
                this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.logicGridTexture);
                this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, gw, gh, this.gl.RGB, this.gl.UNSIGNED_BYTE, occupancy);
                // 2. Update Source Grid Texture (Characters)
                if (fx.gridCacheCanvas) {
                    if (fx.lastGridSeed !== this.lastSourceGridSeed) {
                        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceGridTexture);
                        // Canvas might be a different size than logic grid (it's full-screen)
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, fx.gridCacheCanvas);
                        this.lastSourceGridSeed = fx.lastGridSeed;
                    }
                }
                this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4);
                const prog = this.lineProgram;
                this.gl.useProgram(prog);
                const scale = s.resolution;
                const bs = fx.getBlockSize();
                const cellPitchX = Math.max(1, bs.w);
                const cellPitchY = Math.max(1, bs.h);
                const { offX, offY } = fx._computeCenteredOffset(gw, gh, cellPitchX, cellPitchY);
                const screenStepX = d.cellWidth * s.stretchX * scale;
                const screenStepY = d.cellHeight * s.stretchY * scale;
                const gridPixW = fx.g.cols * d.cellWidth * scale; 
                const gridPixH = fx.g.rows * d.cellHeight * scale;
                const screenOriginX = ((0 - (gridPixW * 0.5)) * s.stretchX) + (this.fboWidth * 0.5);
                const screenOriginY = ((0 - (gridPixH * 0.5)) * s.stretchY) + (this.fboHeight * 0.5);
                const uLoc = (n) => this.gl.getUniformLocation(prog, n);
                this.gl.uniform2f(uLoc('u_logicGridSize'), gw, gh);
                this.gl.uniform2f(uLoc('u_screenOrigin'), screenOriginX, screenOriginY);
                this.gl.uniform2f(uLoc('u_screenStep'), screenStepX, screenStepY);
                this.gl.uniform2f(uLoc('u_cellPitch'), cellPitchX, cellPitchY);
                this.gl.uniform2f(uLoc('u_blockOffset'), offX, offY);
                this.gl.uniform2f(uLoc('u_userBlockOffset'), fx.userBlockOffX || 0, fx.userBlockOffY || 0);
                this.gl.uniform2f(uLoc('u_resolution'), this.fboWidth, this.fboHeight);
                this.gl.uniform2f(uLoc('u_offset'), s.quantizedLineGfxOffsetX * scale, s.quantizedLineGfxOffsetY * scale);
                this.gl.uniform3iv(uLoc('u_layerOrder'), new Int32Array(fx.layerOrder || [0, 1, 2]));
                this.gl.uniform1f(uLoc('u_thickness'), s.quantizedLineGfxThickness);
                const col = Utils.hexToRgb(s.quantizedLineGfxColor || "#ffffff");
                this.gl.uniform3f(uLoc('u_color'), col.r/255, col.g/255, col.b/255);
                this.gl.uniform1f(uLoc('u_intensity'), s.quantizedLineGfxIntensity * fx.alpha); 
                this.gl.uniform1f(uLoc('u_glow'), s.quantizedLineGfxGlow);
                this.gl.activeTexture(this.gl.TEXTURE1);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.logicGridTexture);
                this.gl.uniform1i(uLoc('u_logicGrid'), 1);
                this.gl.activeTexture(this.gl.TEXTURE3);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceGridTexture);
                this.gl.uniform1i(uLoc('u_sourceGrid'), 3);
                // PASS 1: GENERATE
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboLinePersist);
                this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.ZERO, this.gl.SRC_COLOR); 
                const persistence = s.quantizedLineGfxPersistence;
                this.gl.useProgram(this.colorProgram);
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), persistence, persistence, persistence, 1.0);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
                this.gl.blendFunc(this.gl.ONE, this.gl.ONE); 
                this.gl.useProgram(prog);
                this.gl.uniform1i(uLoc('u_mode'), 0); 
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
                // PASS 2: COMPOSITE
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA2);
                this.gl.disable(this.gl.BLEND);
                // A. Pure blit (Mode 2) - Preserves original alpha
                this.gl.useProgram(prog);
                this.gl.uniform1i(uLoc('u_mode'), 2);
                this.gl.activeTexture(this.gl.TEXTURE0);
                this.gl.bindTexture(this.gl.TEXTURE_2D, sourceTex);
                this.gl.uniform1i(uLoc('u_characterBuffer'), 0);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
                // B. Apply highlights (Mode 1)
                this.gl.uniform1i(uLoc('u_mode'), 1);
                this.gl.activeTexture(this.gl.TEXTURE2);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texLinePersist);
                this.gl.uniform1i(uLoc('u_persistenceBuffer'), 2);
                // Ensure u_sourceGrid is also bound for mode 1 (already bound to unit 3 above)
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                return true;
            }
    _runBlur(sourceTex, horizontal, strength, width, height, opacity = 1.0) {
        if (!this.bloomProgram) return;
        this.gl.disable(this.gl.BLEND);
        this.gl.useProgram(this.bloomProgram);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
        this.gl.enableVertexAttribArray(0);
        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, sourceTex);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_image'), 0);
        const weights = [0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216];
        this.gl.uniform1fv(this.gl.getUniformLocation(this.bloomProgram, 'u_weight'), weights);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_spread'), strength);
        this.gl.uniform1f(this.gl.getUniformLocation(this.bloomProgram, 'u_opacity'), opacity);
        this.gl.uniform1i(this.gl.getUniformLocation(this.bloomProgram, 'u_horizontal'), horizontal ? 1 : 0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
    render(frame) {
        if (!this.posBuffer || this.fboWidth === 0) return; 
        const { state: s, derived: d } = this.config;
        const grid = this.grid;
        const activeFonts = d.activeFonts;
        const gl = this.gl;
        gl.enable(gl.BLEND);
        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        // --- ATLAS UPDATE ---
        const font = activeFonts[0];
        if (!font) return;
        let atlas = this.glyphAtlases.get(font.name);
        if (!atlas) {
            atlas = new GlyphAtlas(this.config, font.name, font.chars);
            this.glyphAtlases.set(font.name, atlas);
        } else {
            atlas.fontName = font.name; 
        }
        if (this.needsAtlasUpdate || atlas.needsUpdate) atlas.update();
        if (!atlas.glTexture || atlas.needsFullUpdate) {
            // Full Upload (Initial or Resize)
            if (!atlas.glTexture) atlas.glTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            // Re-apply parameters in case it's a new texture
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
            atlas.resetChanges();
        } else if (atlas.dirtyRects.length > 0) {
            // Incremental Update
            this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
            for (const rect of atlas.dirtyRects) {
                this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, rect.x, rect.y, this.gl.RGBA, this.gl.UNSIGNED_BYTE, rect.data);
            }
            atlas.resetChanges();
        }
        this.needsAtlasUpdate = false;
        // --- MERGE & MAP ---
        const totalCells = grid.cols * grid.rows;
        if (this.mappedChars.length !== totalCells) return;
        const gChars = grid.chars;
        const gNext = grid.nextChars;
        const gSecChars = grid.secondaryChars;
        const gColors = grid.colors;
        const gAlphas = grid.alphas;
        const gDecays = grid.decays;
        const gMaxDecays = grid.maxDecays;
        const gGlows = grid.glows;
        const gMix = grid.mix;
        const gMode = grid.renderMode;
        const gEnvGlows = grid.envGlows;
        const ovActive = grid.overrideActive;
        const ovChars = grid.overrideChars;
        const ovColors = grid.overrideColors;
        const ovAlphas = grid.overrideAlphas;
        const ovGlows = grid.overrideGlows;
        const ovNextChars = grid.overrideNextChars;
        const effActive = grid.effectActive;
        const effChars = grid.effectChars;
        const effColors = grid.effectColors;
        const effAlphas = grid.effectAlphas;
        const effGlows = grid.effectGlows;
        const lookup = atlas.codeToId;
        const mChars = this.mappedChars;
        const mNext = this.mappedNextChars;
        const uColors = this.uploadColors;
        const uAlphas = this.uploadAlphas;
        const uDecays = this.uploadDecays;
        const uMaxDecays = this.uploadMaxDecays;
        const uGlows = this.uploadGlows;
        const uMix = this.uploadMix;
        const mapChar = (c) => {
            if (c <= 32) return 0;
            let id = lookup[c];
            if (id === -1) {
                const rect = atlas.addChar(String.fromCharCode(c));
                id = rect ? rect.id : 0;
            }
            return id;
        };
        for (let i = 0; i < totalCells; i++) {
            // PRIORITY 1: PASSIVE EFFECT (Pulse, etc.)
            if (effActive && effActive[i]) {
                if (effActive[i] === 3) {
                    // SHADOW MODE
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = gColors[i];
                    uAlphas[i] = 1.0; // Force full alpha, let ovAlpha handle opacity
                    uDecays[i] = gDecays[i];
                    uMaxDecays[i] = 0; // Effects don't use variable decay
                    uGlows[i] = 0.0; // Disable glow for shadowboxes
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 5.0 + eAlpha; 
                    mNext[i] = 0;
                    continue;
                }
                if (effActive[i] === 2) {
                    // OVERLAY MODE: Draw Sim + White Effect
                    // 1. Load Simulation
                    const c = gChars[i];
                    mChars[i] = mapChar(c);
                    uColors[i] = effColors[i]; // Use effect-provided color (allows dimming)
                    uAlphas[i] = gAlphas[i];
                    uDecays[i] = gDecays[i];
                    uGlows[i] = gGlows[i] + effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    // 2. Load Effect
                    mNext[i] = mapChar(effChars[i]);
                    let eAlpha = effAlphas[i];
                    if (eAlpha > 0.99) eAlpha = 0.99;
                    uMix[i] = 4.0 + eAlpha; 
                    continue;
                }
                if (effActive[i] === 4) {
                    // HIGH PRIORITY OVERRIDE (Superman/Lightning)
                    // Behaves like Standard Override but sets Mix >= 10.0 to signal "Ignore Shadow"
                    mChars[i] = mapChar(effChars[i]);
                    uColors[i] = effColors[i];
                    uAlphas[i] = effAlphas[i];
                    uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    uDecays[i] = 0; 
                    uMix[i] = 10.0; // Signal Value
                    mNext[i] = 0;
                    continue;
                }
                // STANDARD OVERRIDE (Replace)
                mChars[i] = mapChar(effChars[i]);
                uColors[i] = effColors[i];
                uAlphas[i] = effAlphas[i];
                uGlows[i] = effGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                // Force "Solid" render behavior for effects to prevent simulation fading
                uDecays[i] = 0; 
                uMix[i] = 0.0; // Treat as solid/override in shader
                mNext[i] = 0;
                continue; 
            }
            // PRIORITY 2: HARD OVERRIDE (Deja Vu, etc.)
            // These usually indicate a logic change or interruption.
            const ov = ovActive[i];
            if (ov) {
                if (ov === 2) { // SOLID
                    mChars[i] = 0;
                    mNext[i] = 0;
                    uMix[i] = 3.0; // Trigger SOLID mode in shader
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = (gEnvGlows ? gEnvGlows[i] : 0);
                } else { // CHAR (Mode 1) or FULL (Mode 3)
                    mChars[i] = mapChar(ovChars[i]);
                    const mode = gMode[i];
                    if (mode === 1) { // OVERLAP
                        mNext[i] = mapChar(gSecChars[i]);
                        uMix[i] = 2.0; 
                    } else {
                        mNext[i] = 0;
                        uMix[i] = 0;
                    }
                    uColors[i] = ovColors[i];
                    uAlphas[i] = ovAlphas[i];
                    uDecays[i] = 0;
                    uGlows[i] = ovGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
                    if (ov === 3) {
                         // FULL OVERRIDE: Use Override Mix (New World state)
                         const mixVal = grid.overrideMix[i];
                         uMix[i] = mixVal;
                         if (mixVal > 0) {
                             mNext[i] = mapChar(ovNextChars[i]);
                         }
                    } else {
                         // CHAR OVERRIDE: Inherit Main Mix (Old World state)
                         if (gMix[i] > 0) {
                             uMix[i] = gMix[i];
                         }
                    }
                }
                continue;
            }
            // PRIORITY 3: STANDARD SIMULATION
            // Check for Glimmer (mix >= 30.0) which uses effectChars for non-destructive cycling
            const mix = gMix[i];
            let c = gChars[i];
            if (mix >= 30.0) {
                // Use visual override from effectChars if available
                const ec = effChars[i];
                if (ec > 0) c = ec;
            }
            mChars[i] = mapChar(c);
            uColors[i] = gColors[i];
            uAlphas[i] = gAlphas[i];
            uDecays[i] = gDecays[i];
            uMaxDecays[i] = gMaxDecays ? gMaxDecays[i] : 0;
            uGlows[i] = gGlows[i] + (gEnvGlows ? gEnvGlows[i] : 0);
            const mode = gMode[i];
            if (mode === 1) { // OVERLAP
                mNext[i] = mapChar(gSecChars[i]);
                uMix[i] = 2.0; 
            } else {
                uMix[i] = mix;
                if (mix > 0) {
                    mNext[i] = mapChar(gNext[i]);
                } else {
                    mNext[i] = 0;
                }
            }
        }
        if (atlas.hasChanges) {
             this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
             this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, atlas.canvas);
             atlas.resetChanges();
        }
        // --- UPLOAD ---
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.charBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mChars);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uColors);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uAlphas);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.decayBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uDecays);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.maxDecayBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uMaxDecays);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uGlows);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mixBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, uMix);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nextCharBuffer);
        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, mNext);
        // --- SHADOW MASK PASS ---
        // Render Shadow Masks from Effects (Generic)
        if (this.fboWidth > 0 && this.fboHeight > 0) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.shadowMaskFbo);
            this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
            this.gl.colorMask(true, true, true, true); // Ensure writes are enabled
            this.gl.clearColor(0, 0, 0, 0); 
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            // Collect Masks from All Active Effects
            let masks = [];
            if (this.effects) {
                 // Support both Array and Map structures for EffectRegistry
                 const effectList = (Array.isArray(this.effects.effects)) 
                    ? this.effects.effects 
                    : (this.effects.effects instanceof Map) 
                        ? Array.from(this.effects.effects.values()) 
                        : (typeof this.effects.get === 'function' && typeof this.effects.getAll === 'function') // Handle registry with getters
                            ? this.effects.getAll() // Assuming a getAll exists, or fallback to iterating specific known effects if not
                            : []; 
                 // If getAll doesn't exist, we might need to rely on the Map iterator if effects.effects is private.
                 // However, let's assume standard iteration is possible.
                 // Fallback: If effects.effects is a Map, use values().
                 const iterable = (this.effects.effects instanceof Map) ? this.effects.effects.values() : effectList;
                 for (const effect of iterable) {
                     if (effect.active) {
                         // Check for CrashEffect legacy support or new Generic Interface
                         if (effect.name === 'CrashSequence' && effect.blackSheets) {
                             // Legacy/Specific Support for CrashEffect
                             for (const s of effect.blackSheets) {
                                 masks.push({
                                     x: s.posX, y: s.posY, w: s.w, h: s.h,
                                     alpha: s.currentAlpha * s.maxAlpha,
                                     blur: (s.blur !== undefined) ? s.blur : 0.0 // Default to 0 for Crash
                                 });
                             }
                         }
                         // Future Generic Interface: getMasks()
                         if (typeof effect.getMasks === 'function') {
                             const effectMasks = effect.getMasks();
                             if (Array.isArray(effectMasks)) {
                                 masks.push(...effectMasks);
                             }
                         }
                     }
                 }
            }
            if (masks.length > 0 && this.shadowInstanceBuffer) {
                this.gl.useProgram(this.shadowProgram);
                // Upload Instance Data (x, y, w, h, alpha, blur) - 6 floats
                const count = masks.length;
                if (!this.shadowData || this.shadowData.length < count * 6) {
                    this.shadowData = new Float32Array(count * 6 * 2); 
                }
                const data = this.shadowData;
                for (let i=0; i<count; i++) {
                    const m = masks[i];
                    data[i*6+0] = m.x;
                    data[i*6+1] = m.y;
                    data[i*6+2] = m.w;
                    data[i*6+3] = m.h;
                    data[i*6+4] = m.alpha;
                    data[i*6+5] = (m.blur !== undefined) ? m.blur : 0.2; // Default blur if missing
                }
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // 6 floats * 4 bytes = 24 bytes per instance
                const stride = 24;
                if (count > this.shadowInstanceCapacity) {
                     this.shadowInstanceCapacity = Math.max(count, this.shadowInstanceCapacity * 2);
                     this.gl.bufferData(this.gl.ARRAY_BUFFER, this.shadowInstanceCapacity * stride, this.gl.DYNAMIC_DRAW);
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                } else {
                     this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, data.subarray(0, count*6));
                }
                // Setup Attributes
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowInstanceBuffer);
                // a_rect (vec4)
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, stride, 0);
                this.gl.vertexAttribDivisor(1, 1);
                // a_alpha (float)
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 1, this.gl.FLOAT, false, stride, 16);
                this.gl.vertexAttribDivisor(2, 1);
                // a_blur (float)
                this.gl.enableVertexAttribArray(3);
                this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, stride, 20);
                this.gl.vertexAttribDivisor(3, 1);
                this.gl.uniform2f(this.gl.getUniformLocation(this.shadowProgram, 'u_gridSize'), grid.cols, grid.rows);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, count);
                this.gl.vertexAttribDivisor(1, 0);
                this.gl.vertexAttribDivisor(2, 0);
                this.gl.vertexAttribDivisor(3, 0);
                this.gl.disableVertexAttribArray(1);
                this.gl.disableVertexAttribArray(2);
                this.gl.disableVertexAttribArray(3);
            }
            // --- REVEAL PUNCH-OUT PASS (Subtract Alpha) ---
            // Only necessary if we have drawn shadows
            if (typeof masks !== 'undefined' && masks && masks.length > 0 && this.effects) {
                let crash = null;
                // Locate CrashEffect
                if (Array.isArray(this.effects.effects)) {
                     crash = this.effects.effects.find(e => e.name === 'CrashSequence');
                } else if (this.effects.effects instanceof Map) {
                     crash = this.effects.effects.get('CrashSequence');
                } else if (typeof this.effects.get === 'function') {
                     crash = this.effects.get('CrashSequence');
                }
                if (crash && crash.active && typeof crash.getReveals === 'function') {
                    const reveals = crash.getReveals();
                    if (reveals.length > 0) {
                        // Use Color Program to draw fading triangles
                        this.gl.useProgram(this.colorProgram);
                        // Punch-out blend mode: DestAlpha = DestAlpha * (1 - SrcAlpha)
                        // Src = (0,0,0, RevealAlpha)
                        this.gl.blendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_ALPHA);
                        if (!this.revealBuffer) {
                            this.revealBuffer = this.gl.createBuffer();
                        }
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.revealBuffer);
                        // Enable Position Attribute (Location 0 in colorProgram)
                        this.gl.enableVertexAttribArray(0);
                        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                        const cols = grid.cols;
                        const rows = grid.rows;
                        // Buffer for batching vertices
                        // Estimate size: 50 reveals * 100 segments * 6 verts * 2 coords = ~60k floats
                        // Just allocate dynamically per frame or reuse a large buffer.
                        // For simplicity/safety in this refactor, let's process per reveal and use bufferData.
                        for (const r of reveals) {
                            const alpha = r.alpha;
                            if (alpha <= 0.01) continue;
                            this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), 0, 0, 0, alpha);
                            let vertices = null;
                            if (r.type === 'rects' && r.rects) {
                                const count = r.rects.length;
                                if (count > 0) {
                                    const data = new Float32Array(count * 6 * 2);
                                    let ptr = 0;
                                    for (const rect of r.rects) {
                                        const x1 = (rect.x / cols) * 2.0 - 1.0;
                                        const y1 = (rect.y / rows) * 2.0 - 1.0; 
                                        const x2 = ((rect.x + rect.w) / cols) * 2.0 - 1.0;
                                        const y2 = ((rect.y + rect.h) / rows) * 2.0 - 1.0;
                                        // Triangle 1
                                        data[ptr++] = x1; data[ptr++] = y1;
                                        data[ptr++] = x2; data[ptr++] = y1;
                                        data[ptr++] = x1; data[ptr++] = y2;
                                        // Triangle 2
                                        data[ptr++] = x2; data[ptr++] = y1;
                                        data[ptr++] = x2; data[ptr++] = y2;
                                        data[ptr++] = x1; data[ptr++] = y2;
                                    }
                                    vertices = data;
                                }
                            }
                            else if (r.type === 'strip' && r.trunk && r.branch) {
                                // Draw Triangle Strip between Trunk and Branch
                                const len = Math.min(r.trunk.length, r.branch.length);
                                if (len < 2) continue;
                                // 2 triangles per segment * (len-1) segments * 3 verts * 2 coords
                                const data = new Float32Array((len - 1) * 6 * 2);
                                let ptr = 0;
                                for (let i = 0; i < len - 1; i++) {
                                    // Points in Grid Space
                                    const t1 = r.trunk[i];
                                    const t2 = r.trunk[i+1];
                                    const b1 = r.branch[i];
                                    const b2 = r.branch[i+1];
                                    // Convert to Clip Space
                                    // X: 0..cols -> -1..1
                                    // Y: 0..rows -> -1..1
                                    const ax = (t1.x / cols) * 2.0 - 1.0; const ay = (t1.y / rows) * 2.0 - 1.0;
                                    const bx = (t2.x / cols) * 2.0 - 1.0; const by = (t2.y / rows) * 2.0 - 1.0;
                                    const cx = (b1.x / cols) * 2.0 - 1.0; const cy = (b1.y / rows) * 2.0 - 1.0;
                                    const dx = (b2.x / cols) * 2.0 - 1.0; const dy = (b2.y / rows) * 2.0 - 1.0;
                                    // Triangle 1: t1, t2, b1
                                    data[ptr++] = ax; data[ptr++] = ay;
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                    // Triangle 2: t2, b2, b1
                                    data[ptr++] = bx; data[ptr++] = by;
                                    data[ptr++] = dx; data[ptr++] = dy;
                                    data[ptr++] = cx; data[ptr++] = cy;
                                }
                                vertices = data;
                            } 
                            // Legacy/Fallback Triangle support (if needed, though we moved to strip)
                            else if (r.p1 && r.p2 && r.p3) {
                                const x1 = (r.p1.x / cols) * 2.0 - 1.0; const ay = (r.p1.y / rows) * 2.0 - 1.0;
                                const x2 = (r.p2.x / cols) * 2.0 - 1.0; const by = (r.p2.y / rows) * 2.0 - 1.0;
                                const x3 = (r.p3.x / cols) * 2.0 - 1.0; const cy = (r.p3.y / rows) * 2.0 - 1.0;
                                vertices = new Float32Array([x1, ay, x2, by, x3, cy]);
                            }
                            if (vertices) {
                                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
                                this.gl.drawArrays(this.gl.TRIANGLES, 0, vertices.length / 2);
                            }
                        }
                    }
                }
            }
        }
        // --- DRAW ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA);
        this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
        // 1. Trail Fade (Draw Black Quad)
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        if (this.colorProgram) {
            // Respect layerEnableBackground (Default: true)
            // If disabled, we don't clear/fade, which might look glitchy (hall of mirrors), but it's what was asked.
            // Actually, usually "disable background" means transparent background. 
            // But here we are drawing a full screen quad.
            // If layerEnableBackground is false, we skip this draw call.
            if (s.layerEnableBackground !== false) {
                this.gl.useProgram(this.colorProgram);
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.screenQuadBuffer);
                this.gl.enableVertexAttribArray(0); 
                this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 0, 0);
                // Apply Background Color for Fade
                const br = d.bgRgb ? d.bgRgb.r / 255.0 : 0.0;
                const bg = d.bgRgb ? d.bgRgb.g / 255.0 : 0.0;
                const bb = d.bgRgb ? d.bgRgb.b / 255.0 : 0.0;
                this.gl.uniform4f(this.gl.getUniformLocation(this.colorProgram, 'u_color'), br, bg, bb, s.clearAlpha);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            }
        }
        let finalMainTex = this.texA;
        // 2. Draw Cells
        // Respect layerEnablePrimaryCode
        if (s.layerEnablePrimaryCode !== false) {
            // Determine Program based on mode
            const activeProgram = this.program2D;
        this.gl.useProgram(activeProgram);
        // --- Shared Uniforms ---
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_resolution'), this.w, this.h);
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_atlasSize'), atlas.canvas.width, atlas.canvas.height);
        // Calculate Grid Size in Pixels for Centering
        const gridPixW = grid.cols * d.cellWidth;
        const gridPixH = grid.rows * d.cellHeight;
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_gridSize'), gridPixW, gridPixH);
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_gridOffset'), d.cellWidth, d.cellHeight);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_cellSize'), atlas.cellSize);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_cols'), atlas._lastCols);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_decayDur'), s.decayFadeDurationFrames);
        // Grid Layout Stretch
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_stretch'), s.stretchX, s.stretchY);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_mirror'), s.mirrorEnabled ? -1.0 : 1.0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, atlas.glTexture);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_texture'), 0);
        // Bind Shadow Mask
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.shadowMaskTex);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_shadowMask'), 1);
        // Bind Glimmer Optimization Texture
        this.gl.activeTexture(this.gl.TEXTURE2);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.glimmerTexture);
        this.gl.uniform1i(this.gl.getUniformLocation(activeProgram, 'u_glimmerNoise'), 2);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_time'), performance.now() / 1000.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveEnabled'), s.dissolveEnabled ? 1.0 : 0.0);
        // Decoupled: Shader blink speed is constant, Slider controls Char Cycle speed
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerSpeed'), s.upwardTracerGlimmerSpeed || 1.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerSize'), s.upwardTracerGlimmerSize || 3.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerFill'), s.upwardTracerGlimmerFill || 3.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerIntensity'), s.upwardTracerGlimmerGlow || 10.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_glimmerFlicker'), s.upwardTracerGlimmerFlicker !== undefined ? s.upwardTracerGlimmerFlicker : 0.5);
        // Calculate Cell Scale (Aspect Ratio Correction)
        const scaleMult = 1.0;
        const cellScaleX = (d.cellWidth / atlas.cellSize) * scaleMult;
        const cellScaleY = (d.cellHeight / atlas.cellSize) * scaleMult;
        this.gl.uniform2f(this.gl.getUniformLocation(activeProgram, 'u_cellScale'), cellScaleX, cellScaleY);
        // Target Scale: 1.0 + percent/100. e.g. -20% -> 0.8
        const percent = s.dissolveScalePercent !== undefined ? s.dissolveScalePercent : -20;
        const dissolveScale = s.dissolveEnabled ? (1.0 + (percent / 100.0)) : 1.0;
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveScale'), dissolveScale);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_dissolveSize'), s.dissolveMinSize || 1.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_deteriorationEnabled'), s.deteriorationEnabled ? 1.0 : 0.0);
        this.gl.uniform1f(this.gl.getUniformLocation(activeProgram, 'u_deteriorationStrength'), s.deteriorationStrength);
        // Pass Overlap Color
        const ovRgb = Utils.hexToRgb(s.overlapColor || "#FFD700");
        this.gl.uniform4f(this.gl.getUniformLocation(activeProgram, 'u_overlapColor'), ovRgb.r/255.0, ovRgb.g/255.0, ovRgb.b/255.0, 1.0);
        this.gl.bindVertexArray(this.vao);
        // Ensure blending is enabled for the main draw
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        // Draw Main Pass
        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, totalCells);
        this.gl.bindVertexArray(null);
        // --- 3rd Pass: Quantized Line GFX ---
        if (s.quantizedLineGfxEnabled && this.effects) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA2);
            this.gl.viewport(0, 0, this.fboWidth, this.fboHeight);
            this.gl.clearColor(0, 0, 0, 0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            if (this._renderQuantizedLineGfx(s, d, this.texA)) {
                finalMainTex = this.texA2;
            } else {
                // If GFX enabled but no active effect, we should probably clear persistence
                // so old lines don't get stuck.
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboLinePersist);
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                // Still need to blit texA to fboA2 if we want to use finalMainTex consistently
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboA2);
                this._drawFullscreenTexture(this.texA, 1.0, 0);
                finalMainTex = this.texA2;
            }
        }
        } // End layerEnablePrimaryCode check
        // --- POST PROCESS (Bloom) ---
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        const br = d.bgRgb ? d.bgRgb.r / 255.0 : 0.0;
        const bg = d.bgRgb ? d.bgRgb.g / 255.0 : 0.0;
        const bb = d.bgRgb ? d.bgRgb.b / 255.0 : 0.0;
        this.gl.clearColor(br, bg, bb, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        const blurAmt = s.smoothingEnabled ? s.smoothingAmount : 0;
        this._drawFullscreenTexture(finalMainTex, 1.0, blurAmt);
        if (s.enableBloom) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
            this.gl.viewport(0, 0, this.bloomWidth, this.bloomHeight);
            let spread = s.bloomStrength * 1.0; 
            this._runBlur(finalMainTex, true, spread, this.fboWidth, this.fboHeight); 
            const iterations = 3;
            for (let i = 0; i < iterations; i++) {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboC);
                this._runBlur(this.texB, false, spread, this.bloomWidth, this.bloomHeight);
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fboB);
                this._runBlur(this.texC, true, spread, this.bloomWidth, this.bloomHeight);
            }
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE); 
            this._drawFullscreenTexture(this.texB, s.bloomOpacity, 0);
        }
        if (this.postProcessor) {
            const customSource = s.shaderEnabled ? s.customShader : null;
            const effectSource = s.effectShader;
            // Compile Custom Shader if changed
            if (customSource !== this.lastShaderSource) {
                this.postProcessor.compileShader(customSource);
                this.lastShaderSource = customSource;
            }
            // Compile Effect Shader if changed
            if (effectSource !== this.lastEffectSource) {
                this.postProcessor.compileEffectShader(effectSource);
                this.lastEffectSource = effectSource;
            }
            const isActive = (s.shaderEnabled && customSource) || effectSource;
            if (isActive) {
                const param = s.shaderParameter !== undefined ? s.shaderParameter : 0.5;
                const effectParam = s.effectParameter !== undefined ? s.effectParameter : 0.0;
                this.postProcessor.render(this.cvs, performance.now() / 1000, this.mouseX, this.mouseY, param, effectParam);
                if (this.postProcessor.canvas.style.display === 'none') {
                    this.postProcessor.canvas.style.display = 'block';
                    this.cvs.style.opacity = '0'; 
                }
            } else {
                if (this.postProcessor.canvas.style.display !== 'none') {
                    this.postProcessor.canvas.style.display = 'none';
                    this.cvs.style.opacity = '1';
                }
            }
        }
    }
}
// --- SimulationSystem.js ---
// =========================================================================
// SIMULATION SYSTEM 
// =========================================================================
class SimulationSystem {
    constructor(grid, config, enableWorker = true) {
        this.grid = grid;
        this.config = config;
        // --- Web Worker Support ---
        this.worker = null;
        this.useWorker = false;
        this.workerBuffers = null; // Store current SABs
        this.rotatorSpeedMap = new Float32Array(60);
        for (let i = 0; i < 60; i++) {
            this.rotatorSpeedMap[i] = 0.5 + Math.random() * 2.5; 
        }
        if (enableWorker) {
            // Check for SharedArrayBuffer support
            // Note: functionality requires secure context (HTTPS/localhost) and cross-origin isolation headers.
            if (typeof SharedArrayBuffer !== 'undefined') {
                try {
                    // Test creation
                    new SharedArrayBuffer(10);
                    this.useWorker = true;
                    if (this.config.state.logErrors) console.log("[SimulationSystem] SharedArrayBuffer supported. Initializing Simulation Worker.");
                } catch (e) {
                    if (this.config.state.logErrors) console.warn("[SimulationSystem] SharedArrayBuffer defined but creation failed. Fallback to main thread.", e);
                }
            } else {
                 if (this.config.state.logErrors) console.warn("[SimulationSystem] SharedArrayBuffer not supported. Fallback to main thread.");
            }
        }
        if (this.useWorker) {
            this._initWorker();
            // Intercept Grid Resize to manage Shared Memory
            // This ensures MatrixKernel calls to grid.resize() trigger our memory management
            const originalResize = this.grid.resize.bind(this.grid);
            this.grid.resize = (width, height) => {
                // 1. Calculate Dimensions (Copied logic from CellGrid to know size)
                const d = this.config.derived;
                if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return;
                // Matched to CellGrid.js (Snap to Fit)
                const cols = Math.round(width / d.cellWidth);
                const rows = Math.ceil(height / d.cellHeight);
                const total = cols * rows;
                // 2. Allocate Shared Buffers
                this.workerBuffers = this._createSharedBuffers(total);
                // 3. Resize Grid using Shared Buffers
                originalResize(width, height, this.workerBuffers);
                // 4. Update Worker
                this.worker.postMessage({
                    type: 'resize',
                    width: width,
                    height: height,
                    buffers: this.workerBuffers,
                    config: {
                        state: JSON.parse(JSON.stringify(this.config.state)),
                        derived: this.config.derived // Derived often has getters, ensure it's serializable or plain object?
                        // ConfigurationManager.derived is usually a proxy or object. 
                        // We might need to extract values if it's a Proxy.
                        // Assuming standard object for now or that structuredClone handles it.
                    }
                });
            };
        }
        this.streamManager = new StreamManager(grid, config);
        this.glowSystem = new GlowSystem(grid);
        this.grid.glowSystem = this.glowSystem; 
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.timeScale = 1.0;
        // Subscribe to config changes to keep worker in sync
        if (this.useWorker) {
            this.config.subscribe((key) => {
                // Simple sync: send entire state on change. Optimized? No. Robust? Yes.
                // We avoid sending on 'resolution' changes here because 'resize' handles that.
                if (key !== 'resolution' && key !== 'stretchX' && key !== 'stretchY') {
                    this.worker.postMessage({
                        type: 'config',
                        config: {
                            state: JSON.parse(JSON.stringify(this.config.state)),
                            derived: this.config.derived
                        }
                    });
                }
            });
        }
    }
    _initWorker() {
        const embeddedWorker = document.getElementById('simulation-worker-source');
        if (embeddedWorker) {
            if (this.config.state.logErrors) console.log("[SimulationSystem] Using embedded worker source.");
            const blob = new Blob([embeddedWorker.textContent], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            this.worker = new Worker(workerUrl);
        } else {
            if (this.config.state.logErrors) console.log("[SimulationSystem] Using external worker file.");
            this.worker = new Worker('js/simulation/SimulationWorker.js');
        }
        this.worker.onmessage = (e) => {
            // Handle messages from worker (e.g., debug logs, sync ticks)
            if (e.data.type === 'log' && this.config.state.logErrors) console.log('[Worker]', e.data.message);
        };
        // Initial setup message will be sent by the first resize() call 
        // which happens immediately in MatrixKernel.initAsync()
    }
    _createSharedBuffers(total) {
        // Helper to create a specific typed array view on a SAB
        const createSAB = (bytes) => new SharedArrayBuffer(bytes);
        // Align to 4 bytes for safety/performance
        const uint8Size = total;
        const uint16Size = total * 2;
        const uint32Size = total * 4;
        const float32Size = total * 4;
        const int32Size = total * 4;
        const buffers = {
            state: new Uint8Array(createSAB(uint8Size)),
            chars: new Uint16Array(createSAB(uint16Size)),
            colors: new Uint32Array(createSAB(uint32Size)),
            baseColors: new Uint32Array(createSAB(uint32Size)),
            alphas: new Float32Array(createSAB(float32Size)),
            glows: new Float32Array(createSAB(float32Size)),
            fontIndices: new Uint8Array(createSAB(uint8Size)),
            secondaryChars: new Uint16Array(createSAB(uint16Size)),
            secondaryColors: new Uint32Array(createSAB(uint32Size)),
            secondaryAlphas: new Float32Array(createSAB(float32Size)),
            secondaryGlows: new Float32Array(createSAB(float32Size)),
            secondaryFontIndices: new Uint8Array(createSAB(uint8Size)),
            mix: new Float32Array(createSAB(float32Size)),
            renderMode: new Uint8Array(createSAB(uint8Size)),
            overrideActive: new Uint8Array(createSAB(uint8Size)),
            overrideChars: new Uint16Array(createSAB(uint16Size)),
            overrideColors: new Uint32Array(createSAB(uint32Size)),
            overrideAlphas: new Float32Array(createSAB(float32Size)),
            overrideGlows: new Float32Array(createSAB(float32Size)),
            overrideMix: new Float32Array(createSAB(float32Size)),
            overrideNextChars: new Uint16Array(createSAB(uint16Size)),
            overrideFontIndices: new Uint8Array(createSAB(uint8Size)),
            effectActive: new Uint8Array(createSAB(uint8Size)),
            effectChars: new Uint16Array(createSAB(uint16Size)),
            effectColors: new Uint32Array(createSAB(uint32Size)),
            effectAlphas: new Float32Array(createSAB(float32Size)),
            effectFontIndices: new Uint8Array(createSAB(uint8Size)),
            effectGlows: new Float32Array(createSAB(float32Size)),
            types: new Uint8Array(createSAB(uint8Size)),
            decays: new Uint16Array(createSAB(uint16Size)),
            maxDecays: new Uint16Array(createSAB(uint16Size)),
            ages: new Int32Array(createSAB(int32Size)),
            brightness: new Float32Array(createSAB(float32Size)),
            rotatorOffsets: new Uint8Array(createSAB(uint8Size)),
            cellLocks: new Uint8Array(createSAB(uint8Size)),
            nextChars: new Uint16Array(createSAB(uint16Size)),
            nextOverlapChars: new Uint16Array(createSAB(uint16Size)),
            envGlows: new Float32Array(createSAB(float32Size))
        };
        return buffers;
    }
    update(frame) {
        if (this.config.state.simulationPaused) return;
        if (this.useWorker && this.worker) {
            // Offload to Worker
            this.worker.postMessage({
                type: 'update',
                frame: frame
            });
            // Main thread does NOTHING for simulation logic
            // It just renders whatever is in the SharedBuffers
        } else {
            // Fallback: Local Logic
            this.streamManager.update(frame, this.timeScale);
            this._manageOverlapGrid(frame);
            this._updateCells(frame, this.timeScale);
            // Local Glimmer Lifecycle (Copy-paste logic from Worker/Original)
            this._updateGlimmerLifecycle();
            if (this.grid.envGlows) this.grid.envGlows.fill(0);
            this.glowSystem.update();
            this.glowSystem.apply();
            if (this.grid.cellLocks) this.grid.cellLocks.fill(0);
        }
    }
    _updateGlimmerLifecycle() {
        const s = this.config.state;
        const d = this.config.derived;
        // We iterate over a copy of keys to safely mutate the map during iteration (for movement)
        const indices = Array.from(this.grid.complexStyles.keys());
        for (const idx of indices) {
            const style = this.grid.complexStyles.get(idx);
            if (!style) continue;
            // Pause Glimmer updates if cell is frozen by an effect (e.g. Pulse Pause)
            if (this.grid.effectActive[idx] !== 0 || this.grid.overrideActive[idx] !== 0) continue;
            // --- TYPE 1: STANDARD GLIMMER (Upward Tracers) ---
            if (style.type === 'glimmer') {
                // Initialize Mobility (One-time)
                if (style.mobile === undefined) {
                    // 20% chance to be a "Moving" glimmer
                    if (Math.random() < 0.2) {
                        style.mobile = true;
                        // Move every 4-8 frames
                        style.moveInterval = Utils.randomInt(4, 8);
                        style.nextMove = style.age + style.moveInterval;
                        // Direction: Strictly Up (-1)
                        style.moveDir = -1; 
                    } else {
                        style.mobile = false;
                    }
                }
                const attack = s.upwardTracerAttackFrames;
                const hold = s.upwardTracerHoldFrames;
                const release = s.upwardTracerReleaseFrames;
                const totalDuration = attack + hold + release;
                style.age++;
                const activeAge = style.age - 1;
                // --- Vertical Movement Logic ---
                let currentIdx = idx;
                if (style.mobile && activeAge >= style.nextMove && activeAge < totalDuration) {
                    const col = currentIdx % this.grid.cols;
                    const row = Math.floor(currentIdx / this.grid.cols);
                    const nextRow = row + style.moveDir;
                    if (nextRow >= 0 && nextRow < this.grid.rows) {
                        const nextIdx = currentIdx + (style.moveDir * this.grid.cols);
                        // Only move if target is not already a glimmer or locked
                        if (!this.grid.complexStyles.has(nextIdx)) {
                            // Move State
                            this.grid.complexStyles.set(nextIdx, style);
                            this.grid.complexStyles.delete(currentIdx);
                            // Move Mix Value
                            this.grid.mix[nextIdx] = this.grid.mix[currentIdx];
                            this.grid.mix[currentIdx] = 0;
                            // Move Effect Char (if any, though we forced 0 below, but good practice)
                            this.grid.effectChars[nextIdx] = this.grid.effectChars[currentIdx];
                            this.grid.effectChars[currentIdx] = 0;
                            currentIdx = nextIdx;
                            style.nextMove = activeAge + style.moveInterval;
                        }
                    }
                }
                // Ensure we use the underlying character (Visual Highlight Only)
                this.grid.effectChars[currentIdx] = 0;
                // --- Lifecycle / Fade Logic ---
                let alpha = 0.0;
                if (activeAge <= attack) {
                    alpha = (attack > 0) ? (activeAge / attack) : 1.0;
                } else if (activeAge <= attack + hold) {
                    alpha = 1.0;
                } else if (activeAge <= totalDuration) {
                    const releaseAge = activeAge - (attack + hold);
                    alpha = (release > 0) ? (1.0 - (releaseAge / release)) : 0.0;
                }
                if (activeAge <= totalDuration) {
                    // Keep alive even if alpha is 0 (start of attack)
                    this.grid.mix[currentIdx] = 30.0 + alpha;
                } else {
                    this.grid.mix[currentIdx] = 0;
                    this.grid.complexStyles.delete(currentIdx);
                }
            }
            // --- TYPE 2: STAR POWER GLIMMER ---
            else if (style.type === 'star_glimmer') {
                // Static glimmer effect for Star Power streams.
                // Just force the shader signal (30.0) while the cell is active.
                // The stream lifecycle handles the cell death/cleanup.
                this.grid.mix[idx] = 30.0;
            }
        }
    }
    _manageOverlapGrid(frame) {
        const s = this.config.state;
        if (!s.overlapEnabled) {
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                if (this.grid.secondaryChars && typeof this.grid.secondaryChars.fill === 'function') {
                    this.grid.secondaryChars.fill(32); 
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = s.overlapDensity;
        const ovRgb = Utils.hexToRgb(s.overlapColor);
        const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
        const setOverlapChar = (i) => {
            let fIdx;
            if ((this.grid.types[i] & CELL_TYPE_MASK) === CELL_TYPE.EMPTY) {
                fIdx = Math.floor(Math.random() * numFonts);
            } else {
                fIdx = this.grid.fontIndices[i];
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            let code = 32;
            if (chars && chars.length > 0) {
                const r = Math.floor(Math.random() * chars.length);
                code = chars[r].charCodeAt(0);
            }
            this.grid.secondaryChars[i] = code;
            this.grid.secondaryColors[i] = ovColor;
        };
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            const N = this.grid.secondaryChars.length;
            for (let i = 0; i < N; i++) {
                // If cell is overridden (e.g. Pulse Freeze), do not change secondary char
                if (this.grid.overrideActive[i] !== 0) continue;
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.secondaryChars[i] = 32; 
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _updateCells(frame, timeScale = 1.0) {
        // Pause simulation updates if time is stopped or reversed
        if (timeScale <= 0) return;
        // Slow Motion: Probabilistic update for integer-based counters
        if (timeScale < 1.0) {
            if (Math.random() > timeScale) return;
        }
        const s = this.config.state;
        const d = this.config.derived;
        const grid = this.grid;
        for (const idx of grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const grid = this.grid;
        if (grid.cellLocks && grid.cellLocks[idx] === 1) return;
        // If an effect is overriding this cell, pause simulation updates (Freeze)
        // EXCEPTION: Mode 3 (FULL) is used by Quantized Effects for "Masking" (Replacement),
        // so we allow the underlying simulation to run underneath.
        if (grid.overrideActive[idx] !== 0 && grid.overrideActive[idx] !== 3) return;
        const decay = grid.decays[idx];
        if (decay === 0) return;
        let age = grid.ages[idx];
        if (age > 0) {
            age = this._incrementAge(age, d.maxState);
            grid.ages[idx] = age;
        }
        // --- TRACER COLOR FADE ---
        // Transitions from Tracer Color -> Stream Color based on Age
        // Only apply if NOT decaying (Erasers trigger decay)
        const type = grid.types[idx];
        const baseType = type & CELL_TYPE_MASK;
        const isGradual = (type & CELL_FLAGS.GRADUAL) !== 0;
        const isTracer = (baseType === CELL_TYPE.TRACER || baseType === CELL_TYPE.ROTATOR);
        const isUpward = (baseType === CELL_TYPE.UPWARD_TRACER);
        if (decay < 2 && isTracer) {
            const attack = s.tracerAttackFrames;
            const hold = s.tracerHoldFrames;
            const release = s.tracerReleaseFrames;
            const targetGlow = s.tracerGlow;
            const tracerColor = d.tracerColorUint32;
            const baseColor = grid.baseColors[idx];
            let ratio = 0; // 0 = Tracer, 1 = Base
            // Age 1..Attack: Fade In (Alpha handles this, color stays Tracer)
            // Attack..Attack+Hold: Hold Tracer Color
            // Attack+Hold..End: Fade to Stream Color
            const activeAge = age - 1;
            if (isGradual && !isUpward) {
                // Gradual Fade: Linearly interpolate over a long distance (e.g. 45 chars/frames)
                // Starts fading immediately after attack+hold
                const fadeStart = attack + hold;
                const fadeLen = 45.0; 
                if (activeAge > fadeStart) {
                    ratio = Math.min(1.0, (activeAge - fadeStart) / fadeLen);
                }
            } else {
                // Standard Logic
                if (activeAge > attack + hold) {
                    if (release > 0) {
                        ratio = Math.min(1.0, (activeAge - (attack + hold)) / release);
                    } else {
                        ratio = 1.0;
                    }
                }
            }
            if (ratio >= 1.0) {
                grid.colors[idx] = baseColor;
                grid.glows[idx] = 0; // Remove glow after transition
                // Only clear Glimmer (high mix values)
                // Rotators use mix 0..1, so preserve values < 2.0
                if (grid.mix[idx] >= 2.0) grid.mix[idx] = 0; 
            } else if (ratio > 0) {
                // Blend
                const tR = tracerColor & 0xFF;
                const tG = (tracerColor >> 8) & 0xFF;
                const tB = (tracerColor >> 16) & 0xFF;
                const bR = baseColor & 0xFF;
                const bG = (baseColor >> 8) & 0xFF;
                const bB = (baseColor >> 16) & 0xFF;
                const mR = Math.floor(tR + (bR - tR) * ratio);
                const mG = Math.floor(tG + (bG - tG) * ratio);
                const mB = Math.floor(tB + (bB - tB) * ratio);
                grid.colors[idx] = Utils.packAbgr(mR, mG, mB);
                if (isGradual && !isUpward) {
                    grid.glows[idx] = 0;
                } else {
                    grid.glows[idx] = targetGlow * (1.0 - ratio);
                }
            } else {
                // Hold Tracer
                grid.colors[idx] = tracerColor;
                grid.glows[idx] = targetGlow;
            }
        }
        // Handle Rotator
        // Allow rotator to finish its transition (mix > 0) even if subsequently disabled
        if ((s.rotatorEnabled || grid.mix[idx] > 0) && baseType === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        // Handle Dynamic Colors (Effects)
        if (grid.complexStyles.has(idx)) {
            const style = grid.complexStyles.get(idx);
            if (style.cycle) {
                const newHue = (style.h + style.speed) % 360;
                style.h = newHue; 
                const rgb = Utils.hslToRgb(newHue, style.s, style.l);
                grid.colors[idx] = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
            }
        }
        // Handle Decay / Alpha
        if (decay >= 2) {
            // Ensure trails are Stream Color, not Tracer Color
            let useBase = true;
            if (grid.complexStyles.has(idx)) {
                const style = grid.complexStyles.get(idx);
                if (style.cycle) useBase = false;
            }
            if (useBase) {
                if (decay === 2) { // First frame of decay
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                } else {
                    // Also enforce it in case we missed frame 2 (unlikely but safe)
                    grid.colors[idx] = grid.baseColors[idx];
                    grid.glows[idx] = 0;
                }
            } else {
                // For cycling effects, just kill the glow
                grid.glows[idx] = 0;
            }
            grid.decays[idx]++;
            const newDecay = grid.decays[idx];
            // Use per-cell max decay if set (non-zero), otherwise use global config
            const maxFade = (grid.maxDecays && grid.maxDecays[idx] > 0) ? grid.maxDecays[idx] : s.decayFadeDurationFrames;
            if (this._shouldDecay(idx, newDecay, maxFade)) {
                grid.clearCell(idx);
                return;
            }
            grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, maxFade);
        } else {
            const maxFade = (grid.maxDecays && grid.maxDecays[idx] > 0) ? grid.maxDecays[idx] : s.decayFadeDurationFrames;
            grid.alphas[idx] = this._calculateAlpha(idx, age, decay, maxFade);
        }
    }
    _incrementAge(age, maxState) {
        return age + 1;
    }
    _handleRotator(idx, frame, s, d) {
        const grid = this.grid;
        const mix = grid.mix[idx]; 
        const decay = grid.decays[idx];
        if (mix > 0) {
            this._progressRotator(idx, mix, s.rotatorCrossfadeFrames);
        } else if (s.rotatorEnabled && (decay === 1 || (s.rotateDuringFade && decay > 1))) {
            this._cycleRotator(idx, frame, s.rotatorCrossfadeFrames, d.rotatorCycleFrames, s);
        }
    }
    _progressRotator(idx, currentMix, crossfadeFrames) {
        const grid = this.grid;
        const step = 1.0 / Math.max(1, crossfadeFrames);
        const newMix = currentMix + step;
        if (newMix >= 1.0) {
            const target = grid.getRotatorTarget(idx, false); 
            if (target) {
                grid.chars[idx] = target.charCodeAt(0);
                if (this.config.state.overlapEnabled) {
                    const ovTarget = grid.getRotatorTarget(idx, true);
                    if (ovTarget) {
                        grid.secondaryChars[idx] = ovTarget.charCodeAt(0);
                    }
                }
            }
            grid.mix[idx] = 0;
            // Clear rotator targets
            grid.nextChars[idx] = 0;
            grid.nextOverlapChars[idx] = 0;
        } else {
            grid.mix[idx] = newMix;
        }
    }
    _cycleRotator(idx, frame, crossfadeFrames, cycleFrames, s) {
        const grid = this.grid;
        let effectiveCycle = cycleFrames;
        if (s.rotatorRandomSpeedEnabled) {
            // Pick a multiplier from the pre-generated map
            // Use frame and rotatorOffsets to pick a stable index that evolves
            const approxRotationCount = Math.floor(frame / (cycleFrames * 1.5));
            const speedIdx = (approxRotationCount + grid.rotatorOffsets[idx]) % 60;
            effectiveCycle = Math.round(cycleFrames * this.rotatorSpeedMap[speedIdx]);
        } else if (s.rotatorDesyncEnabled) {
            const variancePercent = s.rotatorDesyncVariance / 100;
            const maxVariance = cycleFrames * variancePercent;
            const offsetNorm = (grid.rotatorOffsets[idx] / 127.5) - 1.0;
            effectiveCycle = Math.max(1, Math.round(cycleFrames + (offsetNorm * maxVariance)));
        }
        effectiveCycle = Math.max(1, effectiveCycle);
        if (frame % effectiveCycle === 0) {
            const fontIdx = grid.fontIndices[idx];
            const activeFonts = this.config.derived.activeFonts;
            const fontData = activeFonts[fontIdx] || activeFonts[0];
            const charSet = fontData.chars;
            const nextChar = this._getUniqueChar(grid.getChar(idx), charSet);
            const nextCode = nextChar.charCodeAt(0);
            let nextOvCode = 0;
            if (this.config.state.overlapEnabled) {
                const curOv = String.fromCharCode(grid.secondaryChars[idx]);
                const nextOv = this._getUniqueChar(curOv, charSet);
                nextOvCode = nextOv.charCodeAt(0);
            }
            if (crossfadeFrames <= 1) {
                grid.chars[idx] = nextCode;
                if (nextOvCode) grid.secondaryChars[idx] = nextOvCode;
            } else {
                grid.mix[idx] = 0.01; 
                grid.setRotatorTarget(idx, nextChar, false);
                if (nextOvCode) {
                    grid.setRotatorTarget(idx, String.fromCharCode(nextOvCode), true);
                }
            }
        }
    }
    _getUniqueChar(exclude, charSet) {
        if (!charSet) charSet = Utils.CHARS;
        if (charSet.length <= 1) return charSet[0];
        let char;
        let attempts = 0;
        do {
            char = charSet[Math.floor(Math.random() * charSet.length)];
            attempts++;
        } while (char === exclude && attempts < 10);
        return char;
    }
    _shouldDecay(idx, decay, fadeDurationFrames) {
        return decay > fadeDurationFrames + 2;
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        const s = this.config.state;
        const b = this.grid.brightness[idx];
        // Fading OUT
        if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            // Use power curve for smoother perceived fade (starts fading sooner)
            const fade = Math.pow(Math.max(0, 1.0 - ratio), 2.0);
            return 0.95 * fade * b;
        }
        // Fading IN
        let attack = s.tracerAttackFrames;
        if ((this.grid.types[idx] & CELL_TYPE_MASK) === CELL_TYPE.UPWARD_TRACER) {
            attack = s.upwardTracerAttackFrames;
        }
        if (age <= attack && attack > 0) {
            return 0.95 * (age / attack) * b;
        }
        // Standard State
        return 0.95 * b;
    }
}
// --- StreamManager.js ---
// =========================================================================
// STREAM MANAGER
// =========================================================================
class StreamManager {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this._activeStreams = []; // Backing field
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(grid.cols).fill(null);
        this.columnSpeeds = new Float32Array(grid.cols);
        this.streamsPerColumn = new Int16Array(grid.cols); // Track active streams count
        this.modes = this._initializeModes(config);
        this.nextSpawnFrame = 0;
        // Reusable columns pool to avoid per-spawn allocation
        this._columnsPool = new Array(this.grid.cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    get activeStreams() {
        return this._activeStreams;
    }
    set activeStreams(val) {
        const oldLen = this._activeStreams ? this._activeStreams.length : 0;
        const newLen = val ? val.length : 0;
        // Critical Log: Catch assignment-based wipe
        if (oldLen > 20 && newLen === 0 && this.config.state.logErrors) {
            console.error(`[StreamManager] ActiveStreams REPLACED! Count dropped from ${oldLen} to ${newLen}.`);
            console.trace();
        }
        this._activeStreams = val;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    resize(cols) {
        // Critical Log: Catch resize-based wipe
        if (this._activeStreams && this._activeStreams.length > 0 && this.config.state.logErrors) {
            console.warn(`[StreamManager] Resize triggered (cols: ${cols}). Clearing ${this._activeStreams.length} streams.`);
            console.trace();
        }
        this.lastStreamInColumn = new Array(cols).fill(null);
        this.lastEraserInColumn = new Array(cols).fill(null);
        this.lastUpwardTracerInColumn = new Array(cols).fill(null);
        this.columnSpeeds = new Float32Array(cols);
        this.streamsPerColumn = new Int16Array(cols);
        this.activeStreams = []; // Triggers setter
        // Rebuild columns pool
        this._columnsPool = new Array(cols);
        for (let i = 0; i < this._columnsPool.length; i++) this._columnsPool[i] = i;
    }
    update(frame, timeScale) {
        // Only resize if grid dimensions have actually changed
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            if (this.config.state.logErrors) console.warn(`[StreamManager] Auto-resize triggered. Old: ${this.lastStreamInColumn.length}, New: ${this.grid.cols}`);
            this.resize(this.grid.cols);
        }
        if (timeScale > 0) {
            this._manageStreams(frame, timeScale);
        } else if (timeScale < 0) {
            this._processActiveStreams(frame, timeScale);
        }
        // If timeScale == 0, pause
    }
    _manageStreams(frame, timeScale) {
        const { state: s, derived: d } = this.config;
        // Independent Glimmer Management (Runs every frame)
        this._manageGlimmer(s);
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2;
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        this._processActiveStreams(frame, timeScale);
    }
    _manageGlimmer(s) {
        if (!s.upwardTracerEnabled || s.upwardTracerChance <= 0) return;
        // 1. Calculate Active Density per Column
        const colCounts = new Uint8Array(this.grid.cols);
        for (let i = 0; i < this.activeStreams.length; i++) {
            const stream = this.activeStreams[i];
            if (stream.isUpward && stream.active) {
                colCounts[stream.x]++;
            }
        }
        // 2. Determine Density Limit (1, 2, or 3)
        const limit = Math.ceil(s.upwardTracerChance * 3.0);
        // 3. Spawn Logic
        // Since this runs every frame, we use a low probability to fill gaps organically.
        const spawnChance = 0.05; 
        const columns = this._columnsPool;
        // Shuffle for random distribution
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (colCounts[col] < limit) {
                if (Math.random() < spawnChance) {
                    this._spawnUpwardTracerAt(col);
                    return; // Prevent clustering: Max 1 spawn per frame
                }
            }
        }
    }
    _spawnStreams(s, d) {
        const columns = this._columnsPool;
        // Fisher-Yates Shuffle
        for (let i = columns.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = columns[i]; columns[i] = columns[j]; columns[j] = tmp;
        }
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (let k = 0; k < columns.length; k++) {
            const col = columns[k];
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
            }
            const lastStream = this.lastStreamInColumn[col];
            // Resolve Speed for this column (Chain Consistency)
            let colSpeed = this.columnSpeeds[col];
            // Only generate a new speed if the column is completely empty of active streams
            if (this.streamsPerColumn[col] === 0) {
                // New chain, new random speed
                colSpeed = this._generateSpeed(s);
                this.columnSpeeds[col] = colSpeed;
            }
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true, colSpeed);
                eraserCount--;
                continue; 
            } 
            if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false, colSpeed);
                streamCount--;
                // Cluster Logic: 10-20% chance to spawn a neighbor
                if (s.preferClusters && streamCount > 0 && Math.random() < 0.15) {
                    // Try Right Neighbor (wrapping handled by modulo if needed, but here we just clamp)
                    const neighbor = col + 1;
                    if (neighbor < this.grid.cols) {
                        const idxN = this.grid.getIndex(neighbor, 0);
                        let blockedN = false;
                        if (idxN !== -1 && this.grid.decays[idxN] > 0) blockedN = true;
                        const lastStreamN = this.lastStreamInColumn[neighbor];
                        // Resolve Neighbor Speed
                        let neighborSpeed = this.columnSpeeds[neighbor];
                        if (!lastStreamN || !lastStreamN.active) {
                            neighborSpeed = this._generateSpeed(s);
                            this.columnSpeeds[neighbor] = neighborSpeed;
                        }
                        if (!blockedN && this._canSpawnTracer(lastStreamN, s.minStreamGap, s.minGapTypes)) {
                            this._spawnStreamAt(neighbor, false, neighborSpeed);
                            streamCount--;
                        }
                    }
                }
                continue; 
            }
        }
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        if (!lastStream || !lastStream.active) return true;
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastStream = this.lastStreamInColumn[col];
        // Prevent spawning an eraser if the column is empty or the last spawn was already an eraser.
        if (!lastStream || lastStream.isEraser) return false;
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        if (lastStream.active) {
            if (this.config.state.allowTinyStreams) {
                const s = this.config.state;
                const tinyGap = s.tracerAttackFrames + s.tracerHoldFrames + s.tracerReleaseFrames + 3;
                if (lastStream.y <= tinyGap) return false;
            } else {
                if (lastStream.y <= minGapTypes) return false;
            }
        }
        return true;
    }
    _processActiveStreams(frame, timeScale) {
        const grid = this.grid;
        const rows = grid.rows;
        const cellLocks = grid.cellLocks;
        const decays = grid.decays;
        // --- MASS EXTINCTION WATCHDOG ---
        if (this.activeStreams.length > 50) {
            this._lastHighCount = this.activeStreams.length;
        }
        const prevCount = this.activeStreams.length;
        // --------------------------------
        if (Math.abs(timeScale) < 0.01) return;
        const isReverse = timeScale < 0;
        const speedMult = Math.abs(timeScale);
                for (let i = this.activeStreams.length - 1; i >= 0; i--) {
                    const stream = this.activeStreams[i];
                    if (!stream.active) {
                        if (this.streamsPerColumn[stream.x] > 0) this.streamsPerColumn[stream.x]--;
                        this.activeStreams.splice(i, 1);
                        continue;
                    }
            const headIdx = grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && cellLocks && cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.tickTimer -= speedMult;
            if (stream.tickTimer > 0) {
                continue; 
            }
            stream.tickTimer = stream.tickInterval;
            // Handle Upward Tracers (Scanners)
            if (stream.isUpward) {
                if (isReverse) {
                    stream.y++; // Move down in reverse
                    if (stream.y > rows + 5) {
                        stream.active = false;
                        continue;
                    }
                } else {
                    stream.y--; // Move up in forward
                    if (stream.y < -5) {
                        stream.active = false;
                        continue;
                    }
                }
                this._writeHead(stream, frame);
                continue; 
            }
            if (isReverse) {
                stream.y--;
                // REWIND LOGIC: Clear the "future" (the cell we just left, which was stream.y + 1)
                // This creates the effect of the stream being sucked back up.
                const oldHeadY = stream.y + 1;
                if (oldHeadY < rows) {
                    const oldIdx = grid.getIndex(stream.x, oldHeadY);
                    if (oldIdx !== -1) {
                         grid.clearCell(oldIdx);
                    }
                }
                if (stream.y < -5) {
                    stream.active = false;
                    continue;
                }
                this._writeHead(stream, frame);
            } else {
                // Drop-off logic
                if (stream.isEraser) {
                    const stopChance = this.config.state.eraserStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                } else {                    
                    const stopChance = this.config.state.tracerStopChance;
                    if (stopChance > 0 && Math.random() < (stopChance / 100)) {
                        stream.active = false;
                        continue;
                    }
                    // In 3D mode, ignore collision with existing trails to allow high density
                    // 3D mode is gone, but we keep this check for future modes
                    const nextY = stream.y + 1;
                    if (nextY < rows) {
                        const nextIdx = grid.getIndex(stream.x, nextY);
                        if (nextIdx !== -1 && decays[nextIdx] > 0) {
                            stream.active = false;
                            continue; 
                        }
                    }
                } 
                stream.age++;
                if (stream.age >= stream.visibleLen) {
                    this._handleStreamCompletion(stream);
                    continue;
                }
                if (stream.y < stream.len) {
                    // Debug: Clean up previous eraser position to prevent trails
                    if (stream.isEraser && this.config.state.highlightErasers) {
                        const prevIdx = grid.getIndex(stream.x, stream.y);
                        if (prevIdx !== -1) grid.clearEffectOverride(prevIdx);
                    }
                    stream.y++;
                    this._writeHead(stream, frame);
                }
            }
        }
        // --- WATCHDOG CHECK ---
        // If count dropped to 0 from a healthy state in one frame (or close to it)
        if (prevCount > 20 && this.activeStreams.length === 0 && this.config.state.logErrors) {
            console.error(`[StreamManager] MASS EXTINCTION DETECTED! Streams dropped from ${prevCount} to 0 in one frame.`);
            console.trace(); // Log stack to see who called update() or if this logic caused it
            // Log Config State to see if a kill-switch was hit
            console.log("Config State at Extinction:", JSON.parse(JSON.stringify(this.config.state)));
            // Attempt to diagnose "Natural" vs "Forced"
            // If they died in the loop above, it's natural (age/collision).
            // But ALL of them?
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        const autoErase = this.config.state.autoEraserEnabled !== false;
        // Prevent auto-eraser if an eraser is already running in this column
        const last = this.lastStreamInColumn[stream.x];
        const isBlocked = last && last !== stream && last.active && last.isEraser;
        if (!stream.isEraser && autoErase && !isBlocked) {
            this._spawnStreamAt(stream.x, true, stream.tickInterval);
        }
    }
    _spawnStreamAt(x, forceEraser, forcedSpeed) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s, forcedSpeed);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _generateSpeed(s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        if (s.desyncIntensity > 0) {
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            return Math.max(1, baseTick + offset);
        }
        return baseTick;
    }
    recalculateSpeeds() {
        const s = this.config.state;
        for (let col = 0; col < this.grid.cols; col++) {
            const newSpeed = this._generateSpeed(s);
            this.columnSpeeds[col] = newSpeed;
        }
        // Update active streams to match new column speeds immediately
        for (const stream of this.activeStreams) {
            if (stream.x >= 0 && stream.x < this.columnSpeeds.length) {
                stream.tickInterval = this.columnSpeeds[stream.x];
            }
        }
    }
    _initializeStream(x, forceEraser, s, forcedSpeed) {
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        let tickInterval = forcedSpeed;
        // Enforce Column Speed Consistency
        // If the column has an assigned speed, strictly use it to ensure Tracers and Erasers remain synchronized
        if (this.columnSpeeds[x] > 0) {
            tickInterval = this.columnSpeeds[x];
        }
        if (!tickInterval) {
            tickInterval = this._generateSpeed(s);
            // Ensure this new speed is recorded for the column
            this.columnSpeeds[x] = tickInterval;
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsUint32?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval,
            tickTimer: 0
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        // Erasers should always finish their job of clearing the column.
        // We ignore scale here to ensure they reach the bottom regardless of tracer settings.
        stream.visibleLen = (stream.len + 2) * stream.tickInterval; 
        return stream;
    }
    _initializeTracerStream(stream, s) {
        stream.len = this.grid.rows; 
        // Variable Fade Duration Logic
        stream.maxDecay = 0; 
        if (s.trailLengthVarianceEnabled) {
            const baseFade = s.decayFadeDurationFrames || 24;
            const varianceVal = s.trailLengthVariance || 0;
            // The additional length is random between [FadeSpeed, Variance]
            // Ensure bounds are valid (min <= max)
            const minAdd = baseFade;
            const maxAdd = Math.max(baseFade, varianceVal);
            const additional = Utils.randomInt(minAdd, maxAdd);
            stream.maxDecay = baseFade + additional;
        }
        const travelDuration = stream.len * stream.tickInterval;
        const scale = (s.streamVisibleLengthScale !== undefined) ? s.streamVisibleLengthScale : 1.0;
        // visibleLen = Travel Time + small buffer (5 frames)
        stream.visibleLen = (travelDuration + (5 * stream.tickInterval)) * scale;
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        stream.isGradual = s.gradualColorStreams && (Math.random() * 100 < s.gradualColorStreamsFrequency);
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    injectStream(x, y, forceEraser) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s);
        stream.y = y;
        // Approximate age based on Y
        stream.age = Math.floor(Math.max(0, y * stream.tickInterval));
        stream.tickTimer = Math.random() * stream.tickInterval;
        this.modes[stream.mode].spawn(stream);
        this.addActiveStream(stream);
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isUpward) {
            this._handleUpwardHead(idx, this.config.state);
            return;
        }
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        const decays = this.grid.decays;
        if (decays[idx] >= 2) return;
        if (decays[idx] > 0 && (this.grid.types[idx] & CELL_TYPE_MASK) !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            decays[idx] = 2;
        } else {
            this.grid.clearCell(idx);
        }
        if (this.config.state.highlightErasers) {
            // Debug: Show Eraser as Red 'W' using High Priority Effect layer (0xFF0000FF = Red)
            // This overlays the 'W' without destroying the underlying simulation state (decay/clear)
            this.grid.setHighPriorityEffect(idx, 'W', 0xFF0000FF, 1.0, 0, 0);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const s = this.config.state;
            const d = this.config.derived;
            const grid = this.grid;
            let cellType = s.rotatorEnabled && Math.random() < (s.rotatorChance / 100)
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            if (stream.isGradual) {
                cellType |= CELL_FLAGS.GRADUAL;
            }
            grid.types[idx] = cellType;
            grid.ages[idx] = 1;
            grid.decays[idx] = 1;
            // Store per-stream max decay (fade duration)
            if (grid.maxDecays) {
                grid.maxDecays[idx] = stream.maxDecay || 0; 
            }
            grid.mix[idx] = 0; // Reset Rotator/Mix Progress
            grid.renderMode[idx] = RENDER_MODE.STANDARD;
            grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = d.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const charStr = charSet[Math.floor(Math.random() * charSet.length)];
            // Resolve Color
            let colorUint32;
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                // Complex Style (Effect)
                grid.complexStyles.set(idx, style);
                // Convert style to color immediately
                if (style.h !== undefined) {
                    const rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    colorUint32 = Utils.packAbgr(rgb.r, rgb.g, rgb.b);
                } else {
                     // Fallback
                     colorUint32 = d.tracerColorUint32;
                }
            } else {
                grid.complexStyles.delete(idx);
                // Standard Color
                // colorMixType: 0 = Stream, 1 = Character
                const isPerChar = Math.random() < s.colorMixType;
                if (isPerChar || Math.random() < s.paletteBias) {
                    const pLen = d.paletteColorsUint32?.length || 1;
                    colorUint32 = d.paletteColorsUint32[Math.floor(Math.random() * pLen)];
                } else {
                    colorUint32 = d.paletteColorsUint32[stream.pIdx] || d.paletteColorsUint32[0];
                }
            }
            // Brightness / Alpha
            const b = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            grid.brightness[idx] = b;
            // Set Primary (Visual = Tracer Color initially)
            const tracerColor = d.tracerColorUint32;
            grid.setPrimary(idx, charStr, tracerColor, b, stream.fontIndex, s.tracerGlow);
            grid.baseColors[idx] = colorUint32; // Store Stream Color for fade target
            // Handle Overlap (Secondary)
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                const overlapChar = charSet[Math.floor(Math.random() * charSet.length)];
                const ovRgb = Utils.hexToRgb(s.overlapColor);
                const ovColor = Utils.packAbgr(ovRgb.r, ovRgb.g, ovRgb.b);
                grid.setSecondary(idx, overlapChar, ovColor, b, stream.fontIndex, s.tracerGlow);
                grid.renderMode[idx] = RENDER_MODE.OVERLAP;
            }
        } else {
            this.grid.clearCell(idx);
        }
    }
    _spawnUpwardTracerAt(x) {
        const s = this.config.state;
        const stream = this._initializeUpwardTracerStream(x, s);
        this.activeStreams.push(stream);
        this.streamsPerColumn[x]++;
        this.lastUpwardTracerInColumn[x] = stream;
    }
    _initializeUpwardTracerStream(x, s) {
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        // Apply speed multiplier (faster scanners look better)
        const speedMult = s.upwardTracerSpeedMult || 1.5; 
        const tickInterval = Math.max(1, baseTick / speedMult);
        return {
            x,
            // Random start position: throughout screen or delayed from bottom
            y: Utils.randomInt(0, this.grid.rows + 15), 
            active: true,
            delay: 0, // Remove delay for immediate feedback
            age: 0,
            len: 1, // Conceptually length 1 head
            isUpward: true,
            visibleLen: 1000, // Long life
            mode: 'STANDARD',
            tickInterval: tickInterval,
            tickTimer: 0
        };
    }
    addActiveStream(stream) {
        if (!stream) return;
        this.activeStreams.push(stream);
        this.streamsPerColumn[stream.x]++;
        this.lastStreamInColumn[stream.x] = stream;
        if (stream.isEraser) {
            this.lastEraserInColumn[stream.x] = stream;
        } else if (stream.isUpward) {
            this.lastUpwardTracerInColumn[stream.x] = stream;
        }
    }
    _handleUpwardHead(idx, s) {
        // Only interact if the cell is ACTIVE (has a character) AND visible
        // Prevents "resurrecting" fully faded characters which looks like spawning new ones
        if (this.grid.state[idx] === CELL_STATE.ACTIVE && this.grid.alphas[idx] > 0.1) {
            // 25% chance to leave a "blank" (gap) in the glimmer trail
            if (Math.random() < 0.25) return;
            // Mark as Glimmering immediately and store lifecycle state in complexStyles
            this.grid.mix[idx] = 30.0; 
            this.grid.complexStyles.set(idx, { type: 'glimmer', age: 1 });
        }
    }
}
// --- StreamModes.js ---
// =========================================================================
// STREAM MODE
// =========================================================================
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        let hue;
        if (state.starPowerRainbowMode === 'char') {
            hue = (frame + (stream.x * 10)) % 360; // Character-based hue
        } else {
            // Full Stream Mode: Sync hue start time so they cycle together
            // If cycling is enabled, offset the base hue by the current frame * speed
            hue = stream.baseHue;
            if (state.starPowerColorCycle) {
                 hue = (hue + (frame * state.starPowerCycleSpeed)) % 360;
            }
        }
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed);
    }
    _createStyle(hue, saturation, lightness, cycle, speed) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, isEffect: true, type: 'star_glimmer' };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, isEffect: true };
    }
}
// --- CharacterSelectorModal.js ---
// =========================================================================
// CHARACTER SELECTOR MODAL
// =========================================================================
class CharacterSelectorModal {
    constructor(config, fontManager, notificationMgr) {
        this.config = config;
        this.fonts = fontManager;
        this.notifications = notificationMgr;
        this.dom = null;
        this.currentFont = null;
        // Canvas for glyph detection
        this.scanCanvas = document.createElement('canvas');
        this.scanCanvas.width = 20;
        this.scanCanvas.height = 20;
        this.scanCtx = this.scanCanvas.getContext('2d', { willReadFrequently: true });
        // Subscribe to config changes for fontSettings
        this.config.subscribe((key) => this._handleConfigChange(key));
    }
    show() {
        if (!this.dom) {
            this._createDOM();
        }
        this._refreshFontList();
        const currentFamily = this.config.get('fontFamily');
        const isKnown = this.fonts.loadedFonts.some(f => f.name === currentFamily) || currentFamily === 'MatrixEmbedded';
        this.currentFont = isKnown ? currentFamily : 'MatrixEmbedded';
        if (this.dom.fontSelect.querySelector(`option[value="${this.currentFont}"]`)) {
            this.dom.fontSelect.value = this.currentFont;
        } else {
             this.currentFont = 'MatrixEmbedded';
             this.dom.fontSelect.value = 'MatrixEmbedded';
        }
        this._loadFontSettings(this.currentFont);
        this.dom.overlay.classList.add('visible');
    }
    hide() {
        if (this.dom) {
            this.dom.overlay.classList.remove('visible');
        }
    }
    _handleConfigChange(key) {
        if (key === 'fontSettings' && this.dom && this.dom.overlay.classList.contains('visible')) {
            // If font settings changed while modal is open, reload current font settings to refresh UI
            this._loadFontSettings(this.currentFont);
        }
    }
    _createDOM() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        const content = document.createElement('div');
        content.className = 'modal-content';
        // Header
        const header = document.createElement('div');
        header.className = 'modal-header';
        header.innerHTML = '<h3 class="modal-title">Manage Characters</h3><div class="modal-close"></div>';
        header.querySelector('.modal-close').onclick = () => this.hide();
        // Body
        const body = document.createElement('div');
        body.className = 'modal-body';
        // 1. Font Selector
        const fontRow = document.createElement('div');
        fontRow.innerHTML = '<label class="modal-label">Select Font to Edit</label>';
        this.fontSelect = document.createElement('select');
        this.fontSelect.onchange = (e) => this._loadFontSettings(e.target.value);
        fontRow.appendChild(this.fontSelect);
        body.appendChild(fontRow);
        // 2. Active Toggle
        const activeRow = document.createElement('div');
        activeRow.className = 'checkbox-row';
        activeRow.innerHTML = '<span>Include in Rain</span><input type="checkbox" id="fontActiveToggle">';
        activeRow.querySelector('input').onchange = (e) => this._updateSetting('active', e.target.checked);
        this.activeToggle = activeRow.querySelector('input');
        body.appendChild(activeRow);
        // 3. Custom Chars Toggle
        const customToggleRow = document.createElement('div');
        customToggleRow.className = 'checkbox-row';
        customToggleRow.innerHTML = '<span>Use Custom Characters</span><input type="checkbox" id="fontCustomToggle">';
        customToggleRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useCustomChars', e.target.checked);
            this._toggleInputs(e.target.checked);
        };
        this.customToggle = customToggleRow.querySelector('input');
        body.appendChild(customToggleRow);
        // 4. Use All Characters Toggle
        const useAllRow = document.createElement('div');
        useAllRow.className = 'checkbox-row';
        useAllRow.innerHTML = '<span>Auto-Detect All Characters</span><input type="checkbox" id="fontUseAllToggle">';
        useAllRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useAllChars', e.target.checked);
            this._handleUseAll(e.target.checked);
        };
        this.useAllToggle = useAllRow.querySelector('input');
        body.appendChild(useAllRow);
        this.scanStatus = document.createElement('div');
        this.scanStatus.className = 'scan-status';
        body.appendChild(this.scanStatus);
        // 5. Visual Picker
        const pickerGroup = document.createElement('div');
        pickerGroup.innerHTML = '<label class="modal-label">Visual Selector</label><div class="modal-desc">Click characters to add/remove them. Empty boxes are unsupported by this font.</div>';
        this.charGrid = document.createElement('div');
        this.charGrid.className = 'char-grid-container';
        pickerGroup.appendChild(this.charGrid);
        body.appendChild(pickerGroup);
        // 6. Manual Input (Fallback)
        const inputGroup = document.createElement('div');
        inputGroup.innerHTML = '<label class="modal-label">Manual Input</label>';
        this.charInput = document.createElement('textarea');
        this.charInput.className = 'char-input';
        this.charInput.placeholder = 'Or paste characters here...';
        this.charInput.oninput = (e) => {
            this._updateSetting('customCharacters', e.target.value);
            this._updateGridSelection();
        };
        inputGroup.appendChild(this.charInput);
        body.appendChild(inputGroup);
        // Footer
        const footer = document.createElement('div');
        footer.className = 'modal-footer';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'action-btn btn-info';
        saveBtn.textContent = 'Done';
        saveBtn.style.width = 'auto';
        saveBtn.onclick = () => this.hide();
        footer.appendChild(saveBtn);
        content.append(header, body, footer);
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        this.dom = { overlay, fontSelect: this.fontSelect };
    }
    _refreshFontList() {
        this.fontSelect.innerHTML = '';
        const fonts = [
            { name: 'MatrixEmbedded', display: 'Matrix Custom Code (Default)' },
            ...this.fonts.loadedFonts.filter(f => !f.isEmbedded)
        ];
        fonts.forEach(f => {
            const opt = document.createElement('option');
            opt.value = f.name;
            opt.textContent = f.display || f.name;
            this.fontSelect.appendChild(opt);
        });
    }
    _loadFontSettings(fontName) {
        this.currentFont = fontName;
        const allSettings = this.config.get('fontSettings') || {};
        if (!allSettings[fontName]) {
             allSettings[fontName] = { active: false, useCustomChars: false, useAllChars: false, customCharacters: "" };
        }
        const settings = allSettings[fontName];
        this.activeToggle.checked = settings.active;
        this.customToggle.checked = settings.useCustomChars;
        this.useAllToggle.checked = settings.useAllChars;
        this.charInput.value = settings.customCharacters || "";
        this._toggleInputs(settings.useCustomChars);
        // If Use All is checked, run the scan logic visually but don't overwrite if not needed
        // Ideally we only run scan if useAllChars is TRUE.
        if (settings.useCustomChars) {
            if (settings.useAllChars) {
                this._handleUseAll(true); // Will re-scan and disable inputs
            } else {
                this._renderGrid(); // Just render grid for manual selection
            }
        }
    }
    _toggleInputs(enabled) {
        const opacity = enabled ? 1 : 0.5;
        this.useAllToggle.disabled = !enabled;
        this.useAllToggle.parentElement.style.opacity = opacity;
        // If "Use All" is checked, specific inputs are disabled regardless of "Use Custom"
        const allChecked = this.useAllToggle.checked;
        const manualEnabled = enabled && !allChecked;
        this.charInput.disabled = !manualEnabled;
        this.charInput.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.pointerEvents = manualEnabled ? 'auto' : 'none';
        if (enabled && !allChecked) {
            this._renderGrid();
        }
    }
    async _handleUseAll(checked) {
        if (!checked) {
            this._toggleInputs(true); // Re-enable manual inputs
            this.scanStatus.textContent = '';
            return;
        }
        this.charInput.disabled = true;
        this.charInput.style.opacity = 0.5;
        this.charGrid.style.opacity = 0.5;
        this.charGrid.style.pointerEvents = 'none';
        this.scanStatus.textContent = 'Scanning font for all valid glyphs...';
        // Yield to UI render
        await new Promise(r => setTimeout(r, 50));
        const validChars = this._scanForChars(this.currentFont);
        this.charInput.value = validChars;
        this._updateSetting('customCharacters', validChars);
        this.scanStatus.textContent = `Scan complete. Found ${validChars.length} characters.`;
        this._renderGrid(); // Visual confirmation
    }
    _scanForChars(fontName) {
        const ranges = [
            [33, 126], // Basic Latin
            [161, 255], // Latin-1
            [1024, 1279], // Cyrillic
            [913, 969], // Greek
            [5792, 5887], // Runic
            [12353, 12447], // Hiragana
            [12448, 12543], // Katakana
            [65377, 65439] // Halfwidth Katakana
        ];
        let valid = "";
        // Get "tofu" or empty signature
        const emptySig = this._getCharSignature(fontName, '\uFFFF');
        const spaceSig = this._getCharSignature(fontName, ' ');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(fontName, char);
                // If distinct from empty/tofu, it's valid
                if (sig && sig !== emptySig && sig !== spaceSig) {
                    valid += char;
                }
            }
        }
        return valid;
    }
    _getCharSignature(fontName, char) {
        this.scanCtx.clearRect(0, 0, 20, 20);
        this.scanCtx.font = `16px "${fontName}"`;
        this.scanCtx.textBaseline = 'middle';
        this.scanCtx.textAlign = 'center';
        this.scanCtx.fillStyle = '#fff';
        this.scanCtx.fillText(char, 10, 10);
        // Get pixel data hash-ish
        const data = this.scanCtx.getImageData(5, 5, 10, 10).data; // Sample center 10x10
        let sum = 0;
        for(let i=3; i<data.length; i+=4) { // check alpha only
            sum += data[i];
        }
        return sum; // simple sum signature
    }
    _renderGrid() {
        this.charGrid.innerHTML = '';
        // Define grid ranges (subset of scan ranges for visual sanity)
        const ranges = [
            [33, 126], // ASCII
            [12448, 12543] // Katakana
        ];
        const currentSet = new Set(this.charInput.value.split(''));
        const emptySig = this._getCharSignature(this.currentFont, '\uFFFF');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(this.currentFont, char);
                // If valid glyph
                if (sig && sig !== emptySig) {
                    const el = document.createElement('div');
                    el.className = 'char-grid-item';
                    el.textContent = char;
                    el.style.fontFamily = this.currentFont;
                    if (currentSet.has(char)) el.classList.add('selected');
                    el.onclick = () => {
                        if (this.useAllToggle.checked) return; // Locked
                        this._toggleChar(char);
                        el.classList.toggle('selected');
                    };
                    this.charGrid.appendChild(el);
                }
            }
        }
    }
    _toggleChar(char) {
        let val = this.charInput.value;
        if (val.includes(char)) {
            val = val.replace(char, '');
        } else {
            val += char;
        }
        this.charInput.value = val;
        this._updateSetting('customCharacters', val);
    }
    _updateGridSelection() {
        const currentSet = new Set(this.charInput.value.split(''));
        Array.from(this.charGrid.children).forEach(el => {
            if (currentSet.has(el.textContent)) el.classList.add('selected');
            else el.classList.remove('selected');
        });
    }
    _updateSetting(key, value) {
        if (!this.currentFont) return;
        const allSettings = { ...this.config.get('fontSettings') };
        if (!allSettings[this.currentFont]) {
            allSettings[this.currentFont] = {};
        }
        allSettings[this.currentFont][key] = value;
        this.config.set('fontSettings', allSettings);
    }
}
// --- FontManager.js ---
// =========================================================================
// FONT MANAGER
// =========================================================================
class FontManager {
  constructor(config, notificationMgr) {
    this.config = config;
    this.notifications = notificationMgr;
    // IndexedDB
    this.dbName = 'MatrixFontDB';
    this.storeName = 'fonts';
    this.db = null;
    // Runtime font bookkeeping
    this.loadedFonts = [];     // { name, display, isEmbedded, mimeType?, data? }
    this.subscribers = [];
    this.embeddedFontName = 'MatrixEmbedded';
    // Internal: promises to prevent duplicate loads per face
    this._facePromises = new Map(); // key: fontName -> Promise<void>
    this._defaultCanvasPx = 20;     // used for document.fonts.load exact-size readiness
    this._loadTimeoutMs = 8000;     // defensive timeout for font loads
    // Listen for config resets to re-inject custom font entries
    this.config.subscribe((key) => this._onConfigChange(key));
  }
  _onConfigChange(key) {
    if (key === 'ALL' || key === 'fontSettings') {
        // Re-ensure all loaded fonts exist in the new settings
        this.loadedFonts.forEach(f => {
            this._ensureFontConfig(f.name);
        });
    }
    // Check if the current font family is actually available
    if (key === 'fontFamily' || key === 'ALL') {
        const currentFont = this.config.get('fontFamily');
        const isDefault = currentFont === 'MatrixEmbedded';
        const isLoaded = this.loadedFonts.some(f => f.name === currentFont);
        if (!isDefault && !isLoaded) {
            this.notifications.show(`Font "${currentFont}" not found. Using fallback.`, 'warning');
        }
    }
  }
  /** Initialize: inject embedded font (if present) + open DB + load stored fonts. */
  async init() {
    if (typeof DEFAULT_FONT_DATA === 'string' && DEFAULT_FONT_DATA.length > 50) {
      await this.injectEmbeddedFont();
    }
    try {
      await this._openDB();
      await this._loadFontsFromDB();
    } catch (error) {
      console.warn('Font DB Error:', error);
      this.notifications.show('Failed to initialize Font Database', 'error');
    }
  }
  /** Subscribe to changes in loadedFonts. */
  subscribe(callback) {
    this.subscribers.push(callback);
  }
  /** Notify subscribers. */
  _notify() {
    this.subscribers.forEach(cb => cb(this.loadedFonts));
  }
  /** Ensure config entry exists for a font. */
  _ensureFontConfig(fontName) {
    const settings = { ...this.config.get('fontSettings') };
    if (!settings[fontName]) {
      settings[fontName] = {
        active: false,
        useCustomChars: false,
        customCharacters: ""
      };
      this.config.set('fontSettings', settings);
    }
  }
  /**
   * Inject embedded default Matrix font (data: URI or base64) if not yet loaded.
   * Uses FontFace + document.fonts to ensure readiness.
   */
  async injectEmbeddedFont() {
    const isFontInjected = this.loadedFonts.some(f => f.name === this.embeddedFontName);
    if (isFontInjected) return;
    const ok = await this._registerFontFace({
      name: this.embeddedFontName,
      // DEFAULT_FONT_DATA is expected to be a data: URL (e.g., data:font/woff2;base64,...)
      // If it's raw base64, wrap as data:font/woff2;base64,<data>
      // Otherwise, provide a normal URL to a woff2 file.
      sourceUrl: DEFAULT_FONT_DATA,
      // Hint the format since data URLs dont carry a MIME header you can inspect easily.
      formatHint: "format('woff2')",
      canvasPx: this._defaultCanvasPx
    });
    if (ok) {
      this.loadedFonts.push({
        name: this.embeddedFontName,
        display: 'The Matrix Custom Code',
        isEmbedded: true
      });
      // Ensure default font is active/configured
      const settings = { ...this.config.get('fontSettings') };
      if (!settings[this.embeddedFontName]) {
        settings[this.embeddedFontName] = {
          active: true,
          useCustomChars: false,
          customCharacters: ""
        };
        this.config.set('fontSettings', settings);
      }
    } else {
        this.notifications.show('Failed to load embedded font', 'error');
    }
  }
  /**
   * Programmatic font registration using FontFace.
   * Replaces the old <style>@font-face</style> injection.
   *
   * @param {Object} opts
   *  - name: string (family)
   *  - sourceUrl: string (Blob URL, data: URL, or http(s) URL)
   *  - formatHint: string e.g. "format('woff2')" (optional but recommended)
   *  - weight/style/stretch/unicodeRange: CSS descriptors (optional)
   *  - canvasPx: number (exact size youll use for canvas metrics readiness)
   *  - preload: boolean (inject <link rel="preload"> if sourceUrl is http(s))
   */
  async _registerFontFace(opts) {
    const {
      name,
      sourceUrl,
      formatHint,
      weight = '400',
      style = 'normal',
      stretch = 'normal',
      unicodeRange,
      canvasPx = this._defaultCanvasPx,
      preload = false
    } = opts;
    // De-dupe: once per family
    if (this._facePromises.has(name)) {
      return this._facePromises.get(name);
    }
    const task = (async () => {
      // (Optional) preload for http(s) sources
      if (preload && /^https?:/.test(sourceUrl)) {
        this._injectPreload(sourceUrl);
      }
      // src string (programmatic FontFace supports url()+format())
      const src = formatHint ? `url("${sourceUrl}") ${formatHint}` : `url("${sourceUrl}")`;
      const descriptors = { weight, style, stretch };
      if (unicodeRange) descriptors.unicodeRange = unicodeRange;
      const face = new FontFace(name, src, descriptors);
      // Defensive timeout so we never hang the animation pipeline.
      const timeout = new Promise((_, rej) =>
        setTimeout(() => rej(new Error(`Font load timeout: ${name}`)), this._loadTimeoutMs)
      );
      // Load the font bytes & parse the face
      await Promise.race([face.load(), timeout]);
      // Register with the document
      document.fonts.add(face);
      // Ensure exact face+size is available for canvas metrics
      await document.fonts.load(`${canvasPx}px "${name}"`);
      await document.fonts.ready;
      return true;
    })().catch(err => {
      console.warn(`[FontManager] Failed to load "${name}"`, err);
      return false;
    });
    this._facePromises.set(name, task);
    return task;
  }
  /** Preload helper to avoid late discovery & double fetch. */
  _injectPreload(href) {
    const existing = document.querySelector(`link[rel="preload"][as="font"][href="${href}"]`);
    if (existing) return;
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'font';
    link.href = href;
    link.type = 'font/woff2';
    link.crossOrigin = 'anonymous'; // critical for font preloads to be reusable from cache
    document.head.appendChild(link);
  }
  /**
   * Legacy wrapper: Keep method name for compatibility.
   * Internally routes to FontFace registration.
   *
   * @param {string} name    - family name
   * @param {string} url     - Blob URL / data URL / http(s)
   * @param {string} format  - e.g., "format('woff2')"
   */
  async _injectCSS(name, url, format) {
    return this._registerFontFace({ name, sourceUrl: url, formatHint: format, canvasPx: this._defaultCanvasPx });
  }
  /** Open/create IndexedDB store. */
  async _openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onupgradeneeded = event => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'name' });
        }
      };
      request.onsuccess = event => {
        this.db = event.target.result;
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /** Load stored fonts: register faces + ensure readiness, then notify. */
  async _loadFontsFromDB() {
    return new Promise(resolve => {
      if (!this.db) return resolve();
      const txn = this.db.transaction(this.storeName, 'readonly');
      const store = txn.objectStore(this.storeName);
      store.getAll().onsuccess = async event => {
        const storedFonts = event.target.result || [];
        // Keep only embedded font in runtime list; reload DB fonts fresh
        this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
        await Promise.all(storedFonts.map(async (font) => {
          this.loadedFonts.push(font);
          this._ensureFontConfig(font.name);
          const type = font.mimeType || (font.data && font.data.type) || 'font/woff2';
          const format = this._getFormatFromType(type);
          const blobUrl = URL.createObjectURL(font.data);
          const ok = await this._registerFontFace({
            name: font.name,
            sourceUrl: blobUrl,
            formatHint: format,
            canvasPx: this._defaultCanvasPx
          });
          // Once registered and ready, we can revoke the blob URL to free memory
          // (the face is now owned by document.fonts).
          try { URL.revokeObjectURL(blobUrl); } catch (_) {}
          if (!ok) {
            console.warn(`Font "${font.name}" failed to register from DB`);
          }
        }));
        this._notify();
        resolve();
      };
    });
  }
  /** Map MIME -> format() hint for @font-face / FontFace src. */
  _getFormatFromType(mimeType = '') {
    const mt = mimeType.toLowerCase();
    if (mt.includes('woff2')) return "format('woff2')";
    if (mt.includes('woff'))  return "format('woff')";
    if (mt.includes('opentype') || mt.includes('otf')) return "format('opentype')";
    return "format('truetype')";
  }
  /**
   * Import a custom font file: hash, persist in DB, register via FontFace, notify.
   * Keeps your existing external behavior but ensures readiness & object URL cleanup.
   */
  importFont(file) {
    const reader = new FileReader();
    reader.onload = async event => {
      const arrayBuffer = event.target.result;
      const blob = new Blob([arrayBuffer], { type: file.type });
      let fontName;
      try {
        const hash = await Utils.computeSHA256(arrayBuffer);
        fontName = `CustomFont_${hash.substring(0, 16)}`;
      } catch (e) {
        console.warn("Hashing failed, falling back to timestamp", e);
        fontName = `CustomFont_${Date.now()}`;
      }
      const record = {
        name: fontName,
        display: file.name,
        data: blob,
        mimeType: file.type
      };
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.put(record).onsuccess = async () => {
        const format = this._getFormatFromType(file.type);
        // Register via FontFace & ensure ready
        const blobUrl = URL.createObjectURL(blob);
        const ok = await this._registerFontFace({
          name: fontName,
          sourceUrl: blobUrl,
          formatHint: format,
          canvasPx: this._defaultCanvasPx
        });
        try { URL.revokeObjectURL(blobUrl); } catch (_) {}
        this.loadedFonts.push(record);
        this._ensureFontConfig(fontName);
        // If desired, auto-activate imported font (kept as comment to preserve your behavior)
        const settings = { ...this.config.get('fontSettings') };
        settings[fontName].active = true;
        this.config.set('fontSettings', settings);
        if (ok) {
          this.config.set('fontFamily', fontName);
          this._notify();
          this.notifications.show(`Imported: ${file.name}`, 'success');
        } else {
          this.notifications.show(`Import failed: ${file.name}`, 'error');
        }
      };
      txn.onerror = () => {
        this.notifications.show('Database Write Failed', 'error');
      };
    };
    reader.readAsArrayBuffer(file);
  }
  /**
   * Delete by font id/name.
   * Note: FontFace entries registered in document.fonts cant be explicitly removed,
   * but removing config, style tags (legacy), and revoking Blob URLs (handled above)
   * prevents leaks and stops future use.
   */
  deleteFont(id) {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.delete(id).onsuccess = () => {
        // Remove legacy style tag (if any)
        document.getElementById(`style-${id}`)?.remove();
        const deletedFont = this.loadedFonts.find(font => font.name === id);
        this.loadedFonts = this.loadedFonts.filter(font => font.name !== id);
        // Deactivate in config to prevent rendering issues
        const settings = { ...this.config.get('fontSettings') };
        if (settings[id]) {
          settings[id].active = false;
          this.config.set('fontSettings', settings);
        }
        if (this.config.state.fontFamily === id) {
          this.config.set('fontFamily', this.config.defaults.fontFamily);
          this.notifications.show(`Deleted font was active. Reverted to default.`, 'warning');
        } else {
             this.notifications.show(`Deleted font: ${deletedFont ? deletedFont.display : id}`, 'success');
        }
        this._notify();
        resolve();
      };
      store.delete(id).onerror = () => {
          this.notifications.show('Failed to delete font', 'error');
          resolve();
      };
    });
  }
  /** Clear DB + keep only embedded runtime fonts. */
  deleteAllFonts() {
    return new Promise(resolve => {
      const txn = this.db.transaction(this.storeName, 'readwrite');
      const store = txn.objectStore(this.storeName);
      store.clear().onsuccess = () => {
        // Remove any legacy <style> tags
        this.loadedFonts
          .filter(font => !font.isEmbedded)
          .forEach(font => document.getElementById(`style-${font.name}`)?.remove());
        // Keep only embedded fonts
        this.loadedFonts = this.loadedFonts.filter(font => font.isEmbedded);
        this._notify();
        this.notifications.show('All custom fonts deleted', 'success');
        resolve();
      };
      store.clear().onerror = () => {
          this.notifications.show('Failed to clear fonts', 'error');
          resolve();
      };
    });
  }
  // ---------- Canvas helpers (optional but handy) ----------
  /**
   * Build a safe canvas font shorthand string for metrics & drawing.
   * @param {string} family
   * @param {number} sizePx
   * @param {string} weight
   * @param {string} style
   * @param {string} fallbackStack
   */
  buildCanvasFont({ family, sizePx = this._defaultCanvasPx, weight = '400', style = 'normal', fallbackStack = 'monospace' } = {}) {
    // e.g. "normal 400 20px 'MatrixEmbedded', monospace"
    return `${style} ${weight} ${sizePx}px '${family}', ${fallbackStack}`;
  }
  /**
   * Ensure a specific family is ready for the given canvas size before drawing.
   * (Useful if you change sizes dynamically.)
   */
  async ensureReadyForCanvasSize(family, sizePx = this._defaultCanvasPx) {
    await document.fonts.load(`${sizePx}px "${family}"`);
       await document.fonts.ready;
  }
}
// --- NotificationManager.js ---
// =========================================================================
// NOTIFICATION SYSTEM 
// =========================================================================
class NotificationManager {
    constructor(config) {
        this.config = config;
        this.container = document.getElementById('toast-container') || this._createContainer();
    }
    /**
     * Creates and initializes the toast container if it doesn't exist.
     * @returns {HTMLElement} The toast container DOM element.
     */
    _createContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.setAttribute('aria-live', 'polite'); // Accessibility: Announce updates to screen readers.
        container.setAttribute('role', 'status'); // Accessibility: Define the type of content the container holds.
        document.body.appendChild(container);
        return container;
    }
    /**
     * Displays a notification with the specified message and type.
     * @param {string} message - The message to display in the notification.
     * @param {string} [type='info'] - The type of the notification ('info', 'success', 'error', etc.).
     * @param {number} [duration=3000] - The duration (in milliseconds) for the notification to be visible.
     */
    show(message, type = 'info', duration = 3000) {
        if (this.config && this.config.state && this.config.state.suppressToasts) return;
        // Create the notification element.
        const toast = this._createToast(message, type);
        // Ensure the container is attached.
        if (!document.body.contains(this.container)) {
            document.body.appendChild(this.container);
        }
        // Add the notification to the container and apply the "visible" class for animation.
        this.container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        // Set timers for hiding and removing the notification.
        this._scheduleToastRemoval(toast, duration);
    }
    /**
     * Creates an individual toast element.
     * @private
     * @param {string} message - The message to display.
     * @param {string} type - The type of the notification.
     * @returns {HTMLElement} The toast DOM element.
     */
    _createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast-msg toast-${type}`;
        toast.textContent = message;
        toast.setAttribute('role', 'alert'); // Accessibility: Specify that this is an alert message.
        return toast;
    }
    /**
     * Schedules the removal of the notification after the specified duration.
     * Handles smooth animation states before removing the DOM element.
     * @private
     * @param {HTMLElement} toast - The toast element to remove.
     * @param {number} duration - How long the toast remains visible.
     */
    _scheduleToastRemoval(toast, duration) {
        setTimeout(() => {
            // Trigger fade-out animation by removing the "visible" class.
            toast.classList.remove('visible');
            // Remove the toast element from the DOM after the animation completes.
            setTimeout(() => toast.remove(), 300); // Matches CSS animation transition time.
        }, duration);
    }
}
// --- QuantizedEffectEditor.js ---
class QuantizedEffectEditor {
    constructor(registry, uimanager) {
        this.registry = registry;
        this.ui = uimanager;
        // Default to Pulse if available
        this.effect = this.registry ? this.registry.get('QuantizedPulse') : null;
        this.active = false;
        this.dom = null;
        this.currentTool = 'select'; 
        this.currentFace = 'N'; 
        this.currentLayer = 0; // 0, 1, 2
        this.visibleLayers = [true, true, true];
        this.layerColors = ['#0f0', '#0af', '#f0c']; // Green, Blue, Magenta
        this.hoverBlock = null;
        this._boundMouseDown = this._onMouseDown.bind(this);
        this._boundMouseMove = this._onMouseMove.bind(this);
        this._boundMouseUp = this._onMouseUp.bind(this);
        this._boundKeyDown = this._onKeyDown.bind(this);
        this._boundWheel = this._onWheel.bind(this);
        this._boundRender = this._renderLoop.bind(this);
        this.dragStart = null;
        this.showGrid = false; 
        this.highlightChanges = true; 
        this.canvas = null;
        this.ctx = null;
        this.selectionRect = null;
        this.selectedBlocks = new Set(); // Set of "x,y" strings
        this.clipboard = null;
        this.redoStack = [];
        // Optimization: Dirty Flags
        this.isDirty = true;
        this.lastHoverHash = "";
        // Communication
        const params = new URLSearchParams(window.location.search);
        this.isStandalone = params.get('mode') === 'editor'; 
        this.channel = new BroadcastChannel('matrix-quant-editor');
        this.isPoppedOut = false; // Set to true on main window if standalone is open
        this.channel.onmessage = (e) => this._onRemoteMessage(e.data);
        if (this.isStandalone) {
            this._log("QuantizedEffectEditor: Running in Standalone Mode");
            // Delay initial sync slightly to ensure MatrixKernel has finished async registry init
            setTimeout(() => this._sendRemote({ type: 'requestSync' }), 100);
        } else {
            // Main window: check if an editor is already open
            this._sendRemote({ type: 'ping' });
        }
    }
    _onRemoteMessage(msg) {
        if (this.isStandalone) {
             if (msg.type === 'ping') {
                 this._sendRemote({ type: 'hello' });
                 this._sendRemote({ type: 'requestSync' });
                 return;
             }
             if (msg.type === 'sync') {
                 this._log(`[Editor-Remote] Sync Received. Tool: ${msg.tool}, Phase: ${msg.phase}, Ops: ${msg.currentStepOps ? msg.currentStepOps.length : 0}`);
                 if (msg.effectName) {
                     // Only switch if different to avoid reset
                     if (!this.effect || this.effect.name !== msg.effectName) {
                         this._switchEffect(msg.effectName);
                     }
                     // Force sequence decoding if we have global data but the effect hasn't loaded it yet
                     if (this.effect && (!this.effect.sequence || this.effect.sequence.length <= 1) && window.matrixPatterns && window.matrixPatterns[this.effect.name]) {
                         this.effect.sequence = this._decodeSequence(window.matrixPatterns[this.effect.name]);
                     }
                 }
                 if (this.effect && msg.phase !== undefined) {
                     this.effect.expansionPhase = msg.phase;
                     this.effect.jumpToStep(msg.phase);
                 }
                 if (msg.tool) this.currentTool = msg.tool;
                 if (msg.face) this.currentFace = msg.face;
                 if (msg.layer !== undefined) this.currentLayer = msg.layer;
                 if (msg.visibleLayers) {
                     this.visibleLayers = [...msg.visibleLayers];
                     if (this.effect) this.effect.visibleLayers = [...msg.visibleLayers];
                 }
                 if (msg.selectionRect) {
                     this.selectionRect = msg.selectionRect;
                 } else if (msg.selectionRect === null) {
                     this.selectionRect = null;
                 }
                 if (msg.selectedBlocks) {
                     this.selectedBlocks = new Set(msg.selectedBlocks);
                 } else if (msg.selectedBlocks === null) {
                     this.selectedBlocks.clear();
                 }
                 // Sync sequence data for current step if provided
                 if (msg.currentStepOps && this.effect) {
                     const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
                     this.effect.sequence[targetIdx] = msg.currentStepOps;
                     this.effect.refreshStep();
                 }
                 this._updateUI();
                 this.isDirty = true;
             }
             return; 
        }
        // Main Window receives messages
        if (msg.type === 'ping') {
            this.isPoppedOut = true;
            this._removeUI();
            this._sendRemote({ 
                type: 'sync', 
                effectName: this.effect ? this.effect.name : null,
                phase: this.effect ? this.effect.expansionPhase : 0,
                tool: this.currentTool,
                face: this.currentFace,
                layer: this.currentLayer,
                visibleLayers: this.visibleLayers,
                selectionRect: this.selectionRect,
                selectedBlocks: this.selectedBlocks.size > 0 ? Array.from(this.selectedBlocks) : null
            });
            return;
        }
        if (msg.type === 'requestSync') {
            this.isPoppedOut = true;
            this._removeUI();
            this._sendRemote({ 
                type: 'sync', 
                effectName: this.effect ? this.effect.name : null,
                phase: this.effect ? this.effect.expansionPhase : 0,
                tool: this.currentTool,
                face: this.currentFace,
                layer: this.currentLayer,
                visibleLayers: this.visibleLayers,
                selectionRect: this.selectionRect,
                selectedBlocks: this.selectedBlocks.size > 0 ? Array.from(this.selectedBlocks) : null
            });
            return;
        }
        if (msg.type === 'hello') {
            this.isPoppedOut = true;
            this._removeUI(); // Hide local if remote opens
            return;
        }
        if (msg.type === 'bye') {
            this.isPoppedOut = false;
            if (this.active) this._createUI(); // Show local if remote closes
            return;
        }
        if (msg.type === 'sync') {
            if (msg.phase !== undefined && this.effect) {
                if (this.effect.expansionPhase !== msg.phase) {
                    this._log(`[Editor-Main] Syncing Phase: ${this.effect.expansionPhase} -> ${msg.phase}`);
                    this.effect.expansionPhase = msg.phase;
                    this.effect.refreshStep();
                }
            }
            if (msg.tool) this.currentTool = msg.tool;
            if (msg.face) this.currentFace = msg.face;
            if (msg.layer !== undefined) this.currentLayer = msg.layer;
            if (msg.visibleLayers) {
                this.visibleLayers = [...msg.visibleLayers];
                if (this.effect) this.effect.visibleLayers = [...msg.visibleLayers];
            }
            if (msg.selectionRect) {
                this.selectionRect = msg.selectionRect;
            } else if (msg.selectionRect === null) {
                this.selectionRect = null;
            }
            if (msg.selectedBlocks) {
                this.selectedBlocks = new Set(msg.selectedBlocks);
            } else if (msg.selectedBlocks === null) {
                this.selectedBlocks.clear();
            }
            // Sync sequence data for current step if provided
            if (msg.currentStepOps && this.effect) {
                const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
                // console.log(`[Editor-Main] Syncing currentStepOps for step ${targetIdx}`);
                this.effect.sequence[targetIdx] = msg.currentStepOps;
                this.effect.refreshStep();
            }
            this.isDirty = true;
            return;
        }
        switch (msg.type) {
            case 'switchEffect': 
                this._log(`[Editor-Main] switchEffect: ${msg.effectName}`);
                this._switchEffect(msg.effectName); 
                break;
            case 'changeStep': this._changeStep(msg.delta); break;
            case 'addStep': this._addStep(); break;
            case 'delStep': this._delStep(); break;
            case 'resetSteps': this._resetSteps(); break;
            case 'selectTool': this._selectTool(msg.tool); break;
            case 'selectFace': this._selectFace(msg.face); break;
            case 'changeBlockSize': this._changeBlockSize(msg.w, msg.h); break;
            case 'setSpeed': 
                if (this.effect) {
                    this.effect.c.set(this.effect.configPrefix + 'Speed', msg.val);
                    this._updateUI();
                }
                break;
            case 'setDuration':
                if (this.effect) {
                    this.effect.c.set(this.effect.configPrefix + 'DurationSeconds', msg.val);
                    this._updateUI();
                }
                break;
            case 'setLayer': this.currentLayer = msg.layer; this.isDirty = true; this._updateUI(); break;
            case 'toggleHighlight': this.highlightChanges = msg.val; this.isDirty = true; break;
            case 'toggleLayerVisibility':
                this.visibleLayers[msg.layer] = msg.val;
                if (this.effect) this.effect.visibleLayers[msg.layer] = msg.val;
                this.isDirty = true;
                this._updateUI(); // Refresh checkboxes if local
                break;
            case 'toggleGrid': this.showGrid = msg.val; this.isDirty = true; break;
            case 'toggleShadow': 
                if (this.effect) this.effect.c.set('layerEnableShadowWorld', msg.val); 
                this.isDirty = true; 
                break;
            case 'toggleRemovals':
                if (this.effect) this.effect.c.set('layerEnableEditorRemovals', msg.val); 
                this.isDirty = true; 
                break;
            case 'export': this._exportData(); break;
            case 'save': this._savePattern(); break;
            case 'undo': this._undo(); break;
            case 'redo': this._redo(); break;
            case 'merge':
                if (this.effect) {
                    this._log(`[Editor-Main] Merge Command Received. MultiSelect: ${!!msg.multiSelect}, HasSelection: ${!!msg.selection}`);
                    this.redoStack = [];
                    // Ensure logic state is fully updated for this step before merge
                    if (typeof this.effect._updateRenderGridLogic === 'function') {
                        this.effect._updateRenderGridLogic();
                    }
                    const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
                    const step = this.effect.sequence[targetIdx];
                    if (!step) {
                        this._error(`[Editor-Main] Merge failed: No step data found at targetIdx ${targetIdx}`);
                        break;
                    }
                    const originalOps = JSON.parse(JSON.stringify(step));
                    let count = 0;
                    if (msg.multiSelect && msg.selection) {
                        this._log(`[Editor-Main] Performing mergeBlocksAtStep with ${msg.selection.length} blocks at index ${targetIdx}`);
                        count = this.effect.mergeBlocksAtStep(msg.selection, targetIdx);
                    } else if (msg.selection) {
                        this._log(`[Editor-Main] Performing mergeSelectionAtStep with rect at index ${targetIdx}`);
                        count = this.effect.mergeSelectionAtStep(msg.selection, targetIdx);
                    } else {
                        this._log(`[Editor-Main] Performing flattenLayers at index ${targetIdx}`);
                        const layersToMerge = [1, 2]; // Default
                        count = this.effect.flattenLayers(layersToMerge, null, targetIdx);
                    }
                    this._log(`[Editor-Main] Merge complete. Blocks modified: ${count}`);
                    if (count > 0) {
                        const mergedOps = step.splice(0, step.length);
                        step.push({ 
                            op: 'group', 
                            ops: mergedOps, 
                            replacesStep: true, 
                            originalOps: originalOps,
                            label: 'Merge Layers (Remote)' 
                        });
                        this.ui.notifications.show(`${count} blocks merged into Layer 0 (Remote)`, 'success');
                    }
                    this.effect.refreshStep();
                    this.isDirty = true;
                    this._updateUI(); // Added to refresh step counter
                    this._broadcastSync(); // Notify remote of updated sequence
                }
                break;
        }
    }
    _sendRemote(msg) {
        this.channel.postMessage(msg);
    }
    _log(...args) {
        if (this.ui.c.get('logErrors')) {
            console.log(...args);
        }
    }
    _warn(...args) {
        if (this.ui.c.get('logErrors')) {
            console.warn(...args);
        }
    }
    _error(...args) {
        if (this.ui.c.get('logErrors')) {
            console.error(...args);
        }
    }
    _broadcastSync() {
        if (!this.isStandalone && !this.isPoppedOut) return;
        const phase = this.effect ? this.effect.expansionPhase : 0;
        const targetIdx = Math.max(0, phase - 1);
        const currentStepOps = (this.effect && this.effect.sequence[targetIdx]) ? this.effect.sequence[targetIdx] : null;
        this._sendRemote({ 
            type: 'sync', 
            effectName: this.effect ? this.effect.name : null,
            phase: phase,
            tool: this.currentTool,
            face: this.currentFace,
            layer: this.currentLayer,
            selectionRect: this.selectionRect,
            selectedBlocks: this.selectedBlocks.size > 0 ? Array.from(this.selectedBlocks) : null,
            visibleLayers: this.visibleLayers,
            currentStepOps: currentStepOps
        });
    }
    _decodeSequence(sequence) {
        if (!sequence || sequence.length === 0) return [[]];
        const OPS_INV = { 1: 'add', 2: 'rem', 3: 'addRect', 6: 'addSmart', 7: 'removeBlock' };
        const decodedSeq = [];
        for (const step of sequence) {
            const decodedStep = [];
            if (Array.isArray(step) && step.length > 0 && typeof step[0] === 'number') {
                let i = 0;
                while (i < step.length) {
                    const opCode = step[i++];
                    const opName = OPS_INV[opCode];
                    let args = [];
                    if (opCode === 1 || opCode === 6 || opCode === 7) {
                        args = [step[i++], step[i++]];
                    } else if (opCode === 3) {
                        args = [step[i++], step[i++], step[i++], step[i++]];
                    } else if (opCode === 8) { // addLayered
                        const x = step[i++];
                        const y = step[i++];
                        const l = step[i++];
                        decodedStep.push({ op: 'add', args: [x, y], layer: l });
                        continue;
                    } else if (opCode === 9) { // addRectLayered
                        const x1 = step[i++];
                        const y1 = step[i++];
                        const x2 = step[i++];
                        const y2 = step[i++];
                        const l = step[i++];
                        decodedStep.push({ op: 'addRect', args: [x1, y1, x2, y2], layer: l });
                        continue;
                    } else if (opCode === 10) { // addSmartLayered
                        const x = step[i++];
                        const y = step[i++];
                        const l = step[i++];
                        decodedStep.push({ op: 'addSmart', args: [x, y], layer: l });
                        continue;
                    } else if (opCode === 11) { // removeBlockLayered
                        const x = step[i++];
                        const y = step[i++];
                        const l = step[i++];
                        decodedStep.push({ op: 'removeBlock', args: [x, y], layer: l });
                        continue;
                    } else if (opCode === 12) { // nudge
                        const x = step[i++];
                        const y = step[i++];
                        const w = step[i++];
                        const h = step[i++];
                        const l = step[i++];
                        const fMask = step[i++];
                        const FACES_INV = { 1: 'N', 2: 'S', 4: 'E', 8: 'W' };
                        const face = FACES_INV[fMask] || 'N';
                        decodedStep.push({ op: 'nudge', args: [x, y, w, h, face], layer: l });
                        continue;
                    } else if (opCode === 2) {
                        const x = step[i++];
                        const y = step[i++];
                        let mask = step[i++];
                        // Unpack Layer
                        const l = (mask >> 4) & 0x7; 
                        decodedStep.push({ op: 'rem', args: [x, y], layer: l });
                        continue; 
                    }
                    decodedStep.push({ op: opName, args: args });
                }
            } else {
                for (const opObj of step) {
                    if (Array.isArray(opObj)) {
                        decodedStep.push({ op: opObj[0], args: opObj.slice(1) });
                    } else if (opObj && opObj.op === 'group' && opObj.ops) {
                        // Recursively decode group ops
                        const decodedGroup = { op: 'group', ops: [] };
                        // We wrap ops in a temporary step to reuse decode logic (shallow)
                        const tempResult = this._decodeSequence([opObj.ops]);
                        decodedGroup.ops = tempResult[0];
                        decodedStep.push(decodedGroup);
                    } else {
                        decodedStep.push(opObj);
                    }
                }
            }
            decodedSeq.push(decodedStep);
        }
        return decodedSeq;
    }
    _switchEffect(effectName) {
        if (this.isStandalone) {
            this._sendRemote({ type: 'switchEffect', effectName });
        }
        const newEffect = this.registry.get(effectName);
        if (!newEffect) return;
        if (this.effect === newEffect) return;
        // Deactivate old effect logic
        if (this.active && this.effect) {
             this.effect.active = false;
             this.effect.editorPreviewOp = null;
             if (this.effect.g) this.effect.g.clearAllOverrides();
        }
        // Disable all quantized effects to ensure a clean slate for the new one
        const qEffects = ['QuantizedPulse', 'QuantizedClimb', 'QuantizedRetract', 'QuantizedAdd', 'QuantizedZoom', 'QuantizedBlockGenerator'];
        if (this.registry) {
            qEffects.forEach(name => {
                const eff = this.registry.get(name);
                if (eff) {
                    eff.active = false;
                    if (eff.state) eff.state = 'IDLE'; 
                    if (eff.g) eff.g.clearAllOverrides();
                }
            });
        }
        this.redoStack = [];
        this.selectionRect = null;
        this.selectedBlocks.clear();
        this.effect = newEffect;
        // Activate new effect logic
        if (this.active) {
            this.effect.trigger(true); 
            // Robust loading: Ensure sequence is loaded from global Patterns if trigger didn't
            if ((!this.effect.sequence || this.effect.sequence.length <= 1) && window.matrixPatterns && window.matrixPatterns[this.effect.name]) {
                this.effect.sequence = window.matrixPatterns[this.effect.name];
            }
            // DECODE ON LOAD
            this.effect.sequence = this._decodeSequence(this.effect.sequence);
            this.effect.debugMode = true;
            this.effect.manualStep = false; 
            // Start at Step 1 if available
            this.effect.expansionPhase = Math.min(1, this.effect.sequence.length);
            this.effect.refreshStep();
            this._updateUI(); 
            this.isDirty = true;
            this._broadcastSync();
        }
    }
    toggle(isActive) {
        this._log("QuantizedEffectEditor: toggle", isActive);
        this.active = isActive;
        if (this.isStandalone) {
            if (this.active) {
                this._sendRemote({ type: 'hello' });
                this._createUI();
                this._updateUI();
            } else {
                this._sendRemote({ type: 'bye' });
                this._removeUI();
            }
            return;
        }
        if (this.isPoppedOut && this.active) {
            // Standalone is active, don't show local UI
            return;
        }
        if (this.active) {
            this.redoStack = []; 
            this._createUI();
            this._createCanvas();
            this._attachListeners();
            if (this.effect) {
                this.effect.manualStep = false; 
                this.effect.debugMode = true;
                // Force re-trigger to ensure init logic runs (e.g. Shadow World)
                this.effect.active = false;
                const triggered = this.effect.trigger(true); 
                if (!triggered) {
                    this._warn("QuantizedEffectEditor: Forced trigger failed for", this.effect.name, "- Activating manually.");
                    this.effect.active = true;
                    if (typeof this.effect._initLogicGrid === 'function') this.effect._initLogicGrid();
                    if (typeof this.effect._initShadowWorld === 'function') {
                        this.effect._initShadowWorld();
                    } else if (typeof this.effect._initShadowWorldBase === 'function') {
                        this.effect._initShadowWorldBase(false);
                    }
                }
                if ((!this.effect.sequence || this.effect.sequence.length <= 1) && window.matrixPatterns && window.matrixPatterns[this.effect.name]) {
                    this.effect.sequence = window.matrixPatterns[this.effect.name];
                }
                this.effect.sequence = this._decodeSequence(this.effect.sequence);
                // Start at Step 1 if available
                this.effect.expansionPhase = Math.min(1, this.effect.sequence.length);
                this.effect.refreshStep();
                this._updateUI(); 
                this.isDirty = true;
                this._renderLoop();
                this._broadcastSync();
            }
        } else {
            this._removeUI();
            this._removeCanvas();
            this._detachListeners();
            if (this.effect) {
                this.effect.active = false; 
                this.effect.debugMode = false; 
                this.effect.manualStep = false; 
                this.effect.editorPreviewOp = null; 
                if (this.effect.g) this.effect.g.clearAllOverrides();
            }
            this.selectionRect = null;
            this.redoStack = [];
        }
    }
    _createCanvas() {
        if (this.canvas) return;
        this.canvas = document.createElement('canvas');
        this.canvas.id = 'quant-editor-canvas';
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.zIndex = '10'; 
        this.canvas.style.pointerEvents = 'none'; 
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
    }
    _removeCanvas() {
        if (this.canvas) {
            document.body.removeChild(this.canvas);
            this.canvas = null;
            this.ctx = null;
        }
    }
    _renderLoop() {
        if (!this.active || this.isStandalone) return;
        // Override: Ensure effect stays alive and visible while editing
        if (this.effect) {
             this.effect.active = true;
             if (this.effect.state === 'FADE_OUT' || this.effect.state === 'IDLE') {
                 this.effect.state = 'SUSTAIN';
                 this.effect.alpha = 1.0;
             }
             // Increment frame to support line fading in editor
             this.effect.animFrame++;
             // console.log("QuantizedEffectEditor: loop frame", this.effect.animFrame);
        }
        this._render();
        requestAnimationFrame(this._boundRender);
    }
    _render() {
        if (!this.canvas || !this.ctx) return;
        // Remove Throttling to ensure live updates from configuration changes
        // This ensures the canvas is cleared and redrawn every frame when the editor is active.
        const width = window.innerWidth;
        const height = window.innerHeight;
        if (this.canvas.width !== width || this.canvas.height !== height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.isDirty = true; // Resize forces redraw
        }
        const ctx = this.ctx;
        ctx.clearRect(0, 0, width, height);
        // 1. Render actual effect components (Fades, Source Grid etc)
        // This also triggers _updateMask which is essential for line fade logic.
        this.effect.renderEditorPreview(ctx, this.effect.c.derived, this.effect.editorPreviewOp);
        // Ensure layout exists for schematic rendering
        if (!this.effect.layout) {
            // Force a mask update to generate layout if missing
            if (typeof this.effect._ensureCanvases === 'function') {
                this.effect._ensureCanvases(width, height);
            }
            if (typeof this.effect._updateMask === 'function') {
                this.effect._updateMask(width, height, this.effect.c.state, this.effect.c.derived);
            }
            if (!this.effect.layout) return; // Still missing? Bail.
        }
        const l = this.effect.layout;
        const grid = this.effect.g;
        // Calculate Grid Metrics
        // Note: effect.layout might use different scaling than simple blocks, but we trust it.
        const blocksX = this.effect.logicGridW;
        const blocksY = this.effect.logicGridH;
        const cx = Math.floor(blocksX / 2);
        const cy = Math.floor(blocksY / 2);
        // User Editor Offsets
        const gridOffX = 0;
        const gridOffY = 0;
        const changesOffX = 0;
        const changesOffY = 0;
        // 2. Render Background Grid (Overlay)
        if (this.showGrid) {
            this.effect.renderEditorGrid(ctx);
        }
        // 3. Render Schematic Layer (Blocks & Ops)
        if (this.highlightChanges) {
            this.effect.renderEditorOverlay(ctx);
        }
        // 3b. Render Editor Preview Op (Schematic)
        if (this.effect.editorPreviewOp) {
            const op = this.effect.editorPreviewOp;
            const layerColor = this.layerColors[this.currentLayer] || '#0f0';
            // Adjust opacity for fill, keep stroke solid/opaque
            // Simple hex to rgba parser or just use the color directly if it's hex and rely on globalAlpha?
            // layerColors are hex (e.g. #0f0, #0af). 
            // Let's use canvas globalAlpha for fill.
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = layerColor;
            ctx.strokeStyle = layerColor;
            // We want stroke to be more opaque, but we set globalAlpha.
            // Let's manually set strokeStyle with high alpha if possible, or reset globalAlpha for stroke.
            const drawBlock = (bx, by) => {
                 // Absolute Logic Coordinates
                 const absX = cx + bx;
                 const absY = cy + by;
                 // Snapped Cell Coordinates
                 const cellX = Math.round((absX - l.offX + l.userBlockOffX) * l.cellPitchX);
                 const cellY = Math.round((absY - l.offY + l.userBlockOffY) * l.cellPitchY);
                 const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                 const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                 const nextCellX = Math.round((absX + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                 const nextCellY = Math.round((absY + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                 const w = (nextCellX - cellX) * l.screenStepX;
                 const h = (nextCellY - cellY) * l.screenStepY;
                 ctx.globalAlpha = 0.3;
                 ctx.fillRect(x, y, w, h);
                 ctx.globalAlpha = 0.8;
                 ctx.strokeRect(x, y, w, h);
            };
            if (op.op === 'addRect') {
                const [x1, y1, x2, y2] = op.args;
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        drawBlock(x, y);
                    }
                }
            } else if (op.op === 'add' || op.op === 'addSmart') {
                const [x, y] = op.args;
                drawBlock(x, y);
            }
            // Add other tool previews here if needed
            ctx.restore();
        }
        // Define shared variables needed for selection rendering
        if (this.selectionRect) {
            ctx.save();
            // selectionRect is now in ABSOLUTE Logic Coords (0..W)
            const minX = this.selectionRect.x;
            const minY = this.selectionRect.y;
            const maxX = minX + this.selectionRect.w + 1; 
            const maxY = minY + this.selectionRect.h + 1;
            // Calculate Snapped Bounds (min and max corners)
            // Note: offX is relative to center? No, logicGrid coordinates 0..W.
            // l.offX is used to align Logic Grid to Screen Grid.
            // Formula: ScreenX = Origin + ( (LogicX - offX + userOff) * Pitch ) * Step
            const cellX1 = Math.round((minX - l.offX + l.userBlockOffX) * l.cellPitchX);
            const cellY1 = Math.round((minY - l.offY + l.userBlockOffY) * l.cellPitchY);
            const cellX2 = Math.round((maxX - l.offX + l.userBlockOffX) * l.cellPitchX);
            const cellY2 = Math.round((maxY - l.offY + l.userBlockOffY) * l.cellPitchY);
            const selX = l.screenOriginX + (cellX1 * l.screenStepX) + l.pixelOffX + changesOffX;
            const selY = l.screenOriginY + (cellY1 * l.screenStepY) + l.pixelOffY + changesOffY;
            const selW = (cellX2 - cellX1) * l.screenStepX;
            const selH = (cellY2 - cellY1) * l.screenStepY;
            ctx.strokeStyle = '#0088FF';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.strokeRect(selX, selY, selW, selH);
            ctx.fillStyle = 'rgba(0, 136, 255, 0.1)';
            ctx.fillRect(selX, selY, selW, selH);
            ctx.restore();
        }
        // Define shared variables needed for multi-block selection rendering
        if (this.selectedBlocks.size > 0) {
            ctx.save();
            ctx.strokeStyle = '#0088FF';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.fillStyle = 'rgba(0, 136, 255, 0.1)';
            for (const key of this.selectedBlocks) {
                const [absX, absY] = key.split(',').map(Number);
                const cellX = Math.round((absX - l.offX + l.userBlockOffX) * l.cellPitchX);
                const cellY = Math.round((absY - l.offY + l.userBlockOffY) * l.cellPitchY);
                const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                const nextCellX = Math.round((absX + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                const nextCellY = Math.round((absY + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                const w = (nextCellX - cellX) * l.screenStepX;
                const h = (nextCellY - cellY) * l.screenStepY;
                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
            }
            ctx.restore();
        }
        // 5. Render Tool Preview (Drag/Hover)
        // If we have an editorPreviewOp, visual feedback is handled by renderEditorPreview.
        // But for Paste, we draw manually.
        if (this.currentTool === 'paste' && this.clipboard && this.hoverBlock) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            const ox = this.hoverBlock.x + cx;
            const oy = this.hoverBlock.y + cy;
            for (const pt of this.clipboard.data) {
                const absX = ox + pt.x;
                const absY = oy + pt.y;
                const cellX = Math.round((absX - l.offX + l.userBlockOffX) * l.cellPitchX);
                const cellY = Math.round((absY - l.offY + l.userBlockOffY) * l.cellPitchY);
                const x = l.screenOriginX + (cellX * l.screenStepX) + l.pixelOffX + changesOffX;
                const y = l.screenOriginY + (cellY * l.screenStepY) + l.pixelOffY + changesOffY;
                const nextCellX = Math.round((absX + 1 - l.offX + l.userBlockOffX) * l.cellPitchX);
                const nextCellY = Math.round((absY + 1 - l.offY + l.userBlockOffY) * l.cellPitchY);
                const w = (nextCellX - cellX) * l.screenStepX;
                const h = (nextCellY - cellY) * l.screenStepY;
                ctx.fillRect(x, y, w, h);
            }
            ctx.restore();
        }
        // Reset dirty flag after render
        this.isDirty = false;
    }
    _createUI() {
        if (this.dom) return;
        const container = document.createElement('div');
        container.id = 'quant-editor-ui';
        container.style.position = 'fixed';
        container.style.top = '10px';
        container.style.left = '10px';
        container.style.zIndex = '11';
        container.style.background = 'rgba(0, 0, 0, 0.8)';
        container.style.border = '1px solid #0f0';
        container.style.padding = '10px';
        container.style.color = '#0f0';
        container.style.fontFamily = 'monospace';
        container.style.userSelect = 'none';
        container.style.cursor = 'default';
        const header = document.createElement('div');
        header.textContent = 'Quantized Effect Editor';
        header.style.marginBottom = '10px';
        header.style.fontWeight = 'bold';
        header.style.cursor = 'move';
        header.style.background = '#222';
        header.style.padding = '5px';
        header.style.borderBottom = '1px solid #0f0';
        container.appendChild(header);
        // Pop Out / External Button
        const btnPopOut = this._createBtn(this.isStandalone ? 'Dock (Close)' : 'Pop Out', () => {
            if (this.isStandalone) {
                window.close();
            } else {
                if (typeof window.require !== 'undefined') {
                    try {
                        const { ipcRenderer } = window.require('elec' + 'tron');
                        ipcRenderer.send('open-editor');
                    } catch (e) {
                        this._error("Electron Pop Out failed:", e);
                    }
                } else {
                    window.open(window.location.href + (window.location.href.includes('?') ? '&' : '?') + 'mode=editor', '_blank', 'width=400,height=800');
                }
            }
        });
        btnPopOut.style.width = '100%';
        btnPopOut.style.marginBottom = '10px';
        btnPopOut.style.background = '#040';
        btnPopOut.style.borderColor = '#0f0';
        container.appendChild(btnPopOut);
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        header.onmousedown = (e) => {
            if (this.isStandalone) return;
            isDragging = true;
            dragOffsetX = e.clientX - container.offsetLeft;
            dragOffsetY = e.clientY - container.offsetTop;
            e.preventDefault(); 
        };
        const onGlobalMouseMove = (e) => {
            if (isDragging) {
                container.style.left = (e.clientX - dragOffsetX) + 'px';
                container.style.top = (e.clientY - dragOffsetY) + 'px';
            }
        };
        const onGlobalMouseUp = () => { isDragging = false; };
        window.addEventListener('mousemove', onGlobalMouseMove);
        window.addEventListener('mouseup', onGlobalMouseUp);
        this._cleanupDrag = () => {
            window.removeEventListener('mousemove', onGlobalMouseMove);
            window.removeEventListener('mouseup', onGlobalMouseUp);
        };
        // Effect Selector
        if (this.registry) {
            const effectSelect = document.createElement('select');
            effectSelect.style.width = '100%';
            effectSelect.style.marginBottom = '10px';
            effectSelect.style.background = '#333';
            effectSelect.style.color = '#0f0';
            effectSelect.style.border = '1px solid #0f0';
            effectSelect.title = "Select the Quantized effect to edit";
            const effects = ['QuantizedPulse', 'QuantizedClimb', 'QuantizedRetract', 'QuantizedAdd', 'QuantizedZoom', 'QuantizedBlockGenerator'];
            effects.forEach(effName => {
                if (this.registry.get(effName)) {
                    const opt = document.createElement('option');
                    opt.value = effName;
                    opt.textContent = effName;
                    if (this.effect && this.effect.name === effName) opt.selected = true;
                    effectSelect.appendChild(opt);
                }
            });
            effectSelect.onchange = (e) => this._switchEffect(e.target.value);
            container.appendChild(effectSelect);
            const selectorSeparator = document.createElement('div');
            selectorSeparator.style.marginBottom = '10px';
            selectorSeparator.style.borderBottom = '1px solid #0f0';
            container.appendChild(selectorSeparator);
        }
        // Block Size Controls
        const sizeControls = document.createElement('div');
        sizeControls.style.marginBottom = '10px';
        sizeControls.style.paddingBottom = '10px';
        sizeControls.style.borderBottom = '1px dashed #444';
        sizeControls.style.display = 'flex';
        sizeControls.style.alignItems = 'center';
        sizeControls.style.justifyContent = 'space-between';
        const lblSize = document.createElement('span');
        lblSize.textContent = 'Block Size:';
        const inpW = document.createElement('input');
        inpW.type = 'number';
        inpW.min = '1';
        inpW.max = '8';
        inpW.style.width = '40px';
        inpW.style.background = '#333';
        inpW.style.color = '#fff';
        inpW.style.border = '1px solid #555';
        const lblX = document.createElement('span');
        lblX.textContent = 'x';
        const inpH = document.createElement('input');
        inpH.type = 'number';
        inpH.min = '1';
        inpH.max = '8';
        inpH.style.width = '40px';
        inpH.style.background = '#333';
        inpH.style.color = '#fff';
        inpH.style.border = '1px solid #555';
        const btnSetSize = this._createBtn('Set', () => {
            this._changeBlockSize(parseInt(inpW.value), parseInt(inpH.value));
        });
        btnSetSize.title = "Update logic grid resolution";
        sizeControls.append(lblSize, inpW, lblX, inpH, btnSetSize);
        container.appendChild(sizeControls);
        this.inpBlockW = inpW;
        this.inpBlockH = inpH;
        // Speed Control
        const speedControls = document.createElement('div');
        speedControls.style.marginBottom = '10px';
        speedControls.style.paddingBottom = '10px';
        speedControls.style.borderBottom = '1px dashed #444';
        speedControls.style.display = 'flex';
        speedControls.style.alignItems = 'center';
        const lblSpeed = document.createElement('span');
        lblSpeed.textContent = 'Speed:';
        lblSpeed.style.marginRight = '10px';
        const inpSpeed = document.createElement('input');
        inpSpeed.type = 'number';
        inpSpeed.min = '0.1';
        inpSpeed.step = '0.1';
        inpSpeed.style.width = '50px';
        inpSpeed.style.background = '#333';
        inpSpeed.style.color = '#fff';
        inpSpeed.style.border = '1px solid #555';
        inpSpeed.style.marginRight = '10px';
        const btnSetSpeed = this._createBtn('Set', () => {
            const val = parseFloat(inpSpeed.value);
            const finalVal = isNaN(val) ? 1.0 : val;
            if (this.isStandalone) {
                this._sendRemote({ type: 'setSpeed', val: finalVal });
            } else if (this.effect) {
                this.effect.c.set(this.effect.configPrefix + 'Speed', finalVal);
                alert(`Speed set to ${finalVal}`);
            }
        });
        btnSetSpeed.title = "Set animation step interval";
        speedControls.append(lblSpeed, inpSpeed, btnSetSpeed);
        // Duration Control
        const lblDur = document.createElement('span');
        lblDur.textContent = 'Duration (s):';
        lblDur.style.marginLeft = '15px';
        lblDur.style.marginRight = '10px';
        const inpDur = document.createElement('input');
        inpDur.type = 'number';
        inpDur.min = '0.5';
        inpDur.step = '0.5';
        inpDur.style.width = '50px';
        inpDur.style.background = '#333';
        inpDur.style.color = '#fff';
        inpDur.style.border = '1px solid #555';
        inpDur.style.marginRight = '10px';
        const btnSetDur = this._createBtn('Set', () => {
            const val = parseFloat(inpDur.value);
            const finalVal = isNaN(val) ? 5.0 : val;
            if (this.isStandalone) {
                this._sendRemote({ type: 'setDuration', val: finalVal });
            } else if (this.effect) {
                this.effect.c.set(this.effect.configPrefix + 'DurationSeconds', finalVal);
                alert(`Duration set to ${finalVal}s`);
            }
        });
        btnSetDur.title = "Set total effect lifetime";
        speedControls.append(lblDur, inpDur, btnSetDur);
        this.inpDuration = inpDur;
        container.appendChild(speedControls);
        this.inpSpeed = inpSpeed;
        const stepControls = document.createElement('div');
        stepControls.style.marginBottom = '10px';
        stepControls.style.paddingBottom = '10px';
        stepControls.style.borderBottom = '1px dashed #444';
        const btnPrev = this._createBtn('<', () => this._changeStep(-1));
        btnPrev.title = "Previous Step";
        const btnNext = this._createBtn('>', () => this._changeStep(1));
        btnNext.title = "Next Step";
        const btnAddStep = this._createBtn('+', () => this._addStep());
        btnAddStep.title = "Insert New Step";
        const btnDelStep = this._createBtn('-', () => this._delStep());
        btnDelStep.title = "Delete Current Step";
        this.stepLabel = document.createElement('span');
        this.stepLabel.style.margin = '0 10px';
        this.stepLabel.textContent = `Step: 0`;
        stepControls.append(btnPrev, this.stepLabel, btnNext, document.createTextNode(' '), btnAddStep, btnDelStep);
        container.appendChild(stepControls);
        const btnReset = this._createBtn('Reset All Steps', () => this._resetSteps());
        btnReset.title = "Clear all steps and reset sequence to empty";
        btnReset.style.width = '100%';
        btnReset.style.marginBottom = '10px';
        btnReset.style.color = '#ff4444';
        btnReset.style.borderColor = '#ff4444';
        container.appendChild(btnReset);
        // Edit Actions (Copy/Paste)
        const editControls = document.createElement('div');
        editControls.style.marginBottom = '10px';
        editControls.style.paddingBottom = '10px';
        editControls.style.borderBottom = '1px dashed #444';
        editControls.style.display = 'grid';
        editControls.style.gridTemplateColumns = '1fr 1fr 1fr 1fr';
        editControls.style.gap = '5px';
        const btnCopy = this._createBtn('Copy', () => this._copySelection());
        btnCopy.title = "Copy selected blocks to clipboard";
        const btnCut = this._createBtn('Cut', () => this._cutSelection());
        btnCut.title = "Cut selected blocks to clipboard";
        const btnPaste = this._createBtn('Paste', () => this._startPaste());
        btnPaste.title = "Enter Paste mode";
        const btnDelSel = this._createBtn('Del', () => this._deleteSelection());
        btnDelSel.title = "Delete selected blocks";
        editControls.append(btnCopy, btnCut, btnPaste, btnDelSel);
        container.appendChild(editControls);
        const toolControls = document.createElement('div');
        toolControls.style.marginBottom = '10px';
        toolControls.style.display = 'grid';
        toolControls.style.gridTemplateColumns = '1fr 1fr';
        toolControls.style.gap = '5px';
        this.tools = {};
        const addTool = (id, label, title) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.title = title || "";
            btn.style.background = '#333';
            btn.style.color = '#fff';
            btn.style.border = '1px solid #555';
            btn.style.cursor = 'pointer';
            btn.style.padding = '2px 5px';
            btn.onclick = () => this._selectTool(id);
            toolControls.appendChild(btn);
            this.tools[id] = btn;
        };
        addTool('select', 'Select', "Drag to select blocks");
        addTool('add', 'Add Block', "Click to toggle block existence");
        addTool('nudge', 'Nudge Block', "Drag to shift existing blocks");
        addTool('removeBlock', 'Rem Block', "Click to force remove block");
        addTool('addRect', 'Add Rect', "Drag to add multiple blocks");
        container.appendChild(toolControls);
        const faceControls = document.createElement('div');
        faceControls.id = 'face-controls';
        faceControls.style.marginBottom = '10px';
        faceControls.style.paddingBottom = '10px';
        faceControls.style.borderBottom = '1px dashed #444';
        ['N', 'S', 'E', 'W'].forEach(f => {
            const btn = this._createBtn(f, () => this._selectFace(f));
            btn.title = `Select ${f} face for line tools`;
            faceControls.appendChild(btn);
            if (!this.faceBtns) this.faceBtns = {};
            this.faceBtns[f] = btn;
        });
        container.appendChild(faceControls);
        this.faceControls = faceControls;
        const colorToggle = document.createElement('label');
        colorToggle.style.display = 'block';
        colorToggle.style.marginTop = '10px';
        colorToggle.title = "Visual feedback for operation changes";
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = this.highlightChanges;
        checkbox.onchange = (e) => { 
            if (this.isStandalone) {
                this._sendRemote({ type: 'toggleHighlight', val: e.target.checked });
            }
            this.highlightChanges = e.target.checked; 
            this.isDirty = true; 
        };
        colorToggle.append(checkbox, document.createTextNode(' Highlight Changes'));
        container.appendChild(colorToggle);
        // Layer Controls
        const layerControls = document.createElement('div');
        layerControls.style.marginTop = '10px';
        layerControls.style.paddingTop = '10px';
        layerControls.style.borderTop = '1px solid #555';
        const lblLayer = document.createElement('div');
        lblLayer.textContent = 'Active Layer:';
        lblLayer.style.marginBottom = '5px';
        layerControls.appendChild(lblLayer);
        const layerBtnGroup = document.createElement('div');
        layerBtnGroup.style.display = 'flex';
        layerBtnGroup.style.gap = '5px';
        layerBtnGroup.style.marginBottom = '10px';
        this.layerBtns = [];
        [0, 1, 2].forEach(l => {
            const btn = this._createBtn(`L${l}`, () => {
                this.currentLayer = l;
                this._updateUI();
                if (this.isStandalone) this._sendRemote({ type: 'setLayer', layer: l });
            });
            btn.style.flex = '1';
            btn.title = `Select Layer ${l} for drawing. L0 is base, L1-L2 are overlays.`;
            layerBtnGroup.appendChild(btn);
            this.layerBtns[l] = btn;
        });
        layerControls.appendChild(layerBtnGroup);
        const btnMergeSel = this._createBtn('Merge Selection to L0', () => {
            if (!this.effect) return;
            this._log(`[Editor] Merge Selection Button Clicked. Standalone: ${this.isStandalone}`);
            this.redoStack = [];
            const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
            if (this.isStandalone) {
                // In standalone mode, we DON'T check local state (which may be inaccurate/incomplete)
                // We just send the selection to the main window and let IT perform the merge.
                if (this.selectedBlocks.size > 0) {
                    const blocks = Array.from(this.selectedBlocks).map(key => {
                        const [x, y] = key.split(',').map(Number);
                        return { x, y };
                    });
                    this._log(`[Editor] Sending Remote Merge (Multi-Select: ${blocks.length} blocks)`);
                    this._sendRemote({ type: 'merge', selection: blocks, multiSelect: true });
                    this.selectedBlocks.clear();
                    this.isDirty = true;
                } else if (this.selectionRect) {
                    this._log(`[Editor] Sending Remote Merge (Rect: ${JSON.stringify(this.selectionRect)})`);
                    this._sendRemote({ type: 'merge', selection: this.selectionRect });
                } else {
                    this.ui.notifications.show("No selection to merge", "info");
                }
                return;
            }
            // --- LOCAL EXECUTION (Main Window) ---
            // Ensure logic state is fully updated for this step before merge
            if (typeof this.effect._updateRenderGridLogic === 'function') {
                this.effect._updateRenderGridLogic();
            }
            const step = this.effect.sequence[targetIdx];
            if (!step) return;
            // Snapshot before merge for undo support
            const originalOps = JSON.parse(JSON.stringify(step));
            let count = 0;
            if (this.selectedBlocks.size > 0) {
                const blocks = Array.from(this.selectedBlocks).map(key => {
                    const [x, y] = key.split(',').map(Number);
                    return { x, y };
                });
                count = this.effect.mergeBlocksAtStep(blocks, targetIdx);
                this.selectedBlocks.clear();
            } else if (this.selectionRect) {
                count = this.effect.mergeSelectionAtStep(this.selectionRect, targetIdx);
            } else {
                this.ui.notifications.show("No selection to merge", "info");
                return;
            }
            if (count > 0) {
                // Wrap the entire new state in a transformative group
                const mergedOps = step.splice(0, step.length);
                step.push({ 
                    op: 'group', 
                    ops: mergedOps, 
                    replacesStep: true, 
                    originalOps: originalOps,
                    label: 'Merge Selected Blocks'
                });
                this.effect.refreshStep();
                this.isDirty = true;
                this.ui.notifications.show(`${count} blocks merged to Layer 0`, 'success');
                this._broadcastSync();
            } else {
                this.ui.notifications.show("No blocks found in selection on Layers 1 or 2", "info");
            }
        });
        btnMergeSel.style.width = '100%';
        btnMergeSel.title = "Move only selected blocks from L1/L2 to L0.";
        layerControls.appendChild(btnMergeSel);
        // Show layer toggles
        const showLayerTitle = document.createElement('div');
        showLayerTitle.textContent = 'Show layer:';
        showLayerTitle.style.marginTop = '10px';
        showLayerTitle.style.marginBottom = '5px';
        showLayerTitle.style.fontSize = '12px';
        layerControls.appendChild(showLayerTitle);
        const showLayerGroup = document.createElement('div');
        showLayerGroup.style.display = 'flex';
        showLayerGroup.style.flexDirection = 'column';
        showLayerGroup.style.gap = '2px';
        [0, 1, 2].forEach(l => {
            const lbl = document.createElement('label');
            lbl.style.display = 'flex';
            lbl.style.alignItems = 'center';
            lbl.style.fontSize = '12px';
            lbl.style.cursor = 'pointer';
            const chk = document.createElement('input');
            chk.type = 'checkbox';
            chk.checked = this.visibleLayers[l];
            chk.style.marginRight = '5px';
            chk.onchange = (e) => {
                this.visibleLayers[l] = e.target.checked;
                if (this.effect) this.effect.visibleLayers[l] = e.target.checked;
                this.isDirty = true;
                if (this.isStandalone) this._sendRemote({ type: 'toggleLayerVisibility', layer: l, val: e.target.checked });
            };
            lbl.append(chk, `Layer ${l}`);
            showLayerGroup.appendChild(lbl);
        });
        layerControls.appendChild(showLayerGroup);
        container.appendChild(layerControls);
        const gridToggle = document.createElement('label');
        gridToggle.style.display = 'block';
        gridToggle.style.marginTop = '10px';
        gridToggle.style.paddingTop = '10px';
        gridToggle.style.borderTop = '1px solid #555';
        gridToggle.title = "Show logic grid block boundaries";
        const gridCheck = document.createElement('input');
        gridCheck.type = 'checkbox';
        gridCheck.checked = this.showGrid;
        gridCheck.onchange = (e) => { 
            if (this.isStandalone) {
                this._sendRemote({ type: 'toggleGrid', val: e.target.checked });
            }
            this.showGrid = e.target.checked; 
            this.isDirty = true; 
        };
        gridToggle.append(gridCheck, document.createTextNode(' Show Grid Overlay'));
        container.appendChild(gridToggle);
        const shadowToggle = document.createElement('label');
        shadowToggle.style.display = 'block';
        shadowToggle.style.marginTop = '5px';
        shadowToggle.title = "Enable background simulation reveal";
        const shadowCheck = document.createElement('input');
        shadowCheck.type = 'checkbox';
        shadowCheck.checked = (this.effect && this.effect.c.state.layerEnableShadowWorld !== false);
        shadowCheck.onchange = (e) => { 
            if (this.isStandalone) {
                this._sendRemote({ type: 'toggleShadow', val: e.target.checked });
            }
            if (this.effect) this.effect.c.set('layerEnableShadowWorld', e.target.checked); 
            this.isDirty = true; 
        };
        shadowToggle.append(shadowCheck, document.createTextNode(' Use Shadow World'));
        container.appendChild(shadowToggle);
        const removalsToggle = document.createElement('label');
        removalsToggle.style.display = 'block';
        removalsToggle.style.marginTop = '5px';
        removalsToggle.style.marginBottom = '10px';
        removalsToggle.title = "Show blocks that are being explicitly removed";
        const removalsCheck = document.createElement('input');
        removalsCheck.type = 'checkbox';
        removalsCheck.checked = (this.effect && this.effect.c.state.layerEnableEditorRemovals !== false);
        removalsCheck.onchange = (e) => { 
            if (this.isStandalone) {
                this._sendRemote({ type: 'toggleRemovals', val: e.target.checked });
            }
            if (this.effect) this.effect.c.set('layerEnableEditorRemovals', e.target.checked); 
            this.isDirty = true; 
        };
        removalsToggle.append(removalsCheck, document.createTextNode(' Show Removals'));
        container.appendChild(removalsToggle);
        const exportControls = document.createElement('div');
        exportControls.style.display = 'flex';
        exportControls.style.justifyContent = 'space-between';
        exportControls.style.marginTop = '10px';
        exportControls.style.paddingTop = '10px';
        exportControls.style.borderTop = '1px solid #555';
        const btnExport = this._createBtn('Copy Data', () => this._exportData());
        btnExport.title = "Copy the compressed sequence data to clipboard";
        btnExport.style.width = '32%';
        btnExport.style.marginRight = '0';
        const btnSave = this._createBtn('Save Pattern', () => this._savePattern());
        btnSave.title = "Save all patterns to QuantizedPatterns.js";
        btnSave.style.width = '48%';
        btnSave.style.marginRight = '0';
        exportControls.appendChild(btnExport);
        exportControls.appendChild(btnSave);
        container.appendChild(exportControls);
        const legend = document.createElement('div');
        legend.style.marginTop = '10px';
        legend.style.fontSize = '12px';
        legend.style.background = 'rgba(0,0,0,0.5)';
        legend.style.padding = '5px';
        legend.innerHTML = `
            <div style="display:flex;align-items:center;margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:rgba(0,255,0,0.5);margin-right:5px;border:1px solid #0f0;"></span>Add (L0)</div>
            <div style="display:flex;align-items:center;margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:rgba(0,200,255,0.5);margin-right:5px;border:1px solid #0af;"></span>Add (L1)</div>
            <div style="display:flex;align-items:center;margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:rgba(255,0,200,0.5);margin-right:5px;border:1px solid #f0c;"></span>Add (L2)</div>
            <div style="display:flex;align-items:center;margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:rgba(255,0,0,0.5);margin-right:5px;border:1px solid #f00;"></span>Remove</div>
            <div style="display:flex;align-items:center;"><span style="display:inline-block;width:10px;height:10px;background:none;border:1px dashed #0088FF;margin-right:5px;"></span>Selection</div>
        `;
        container.appendChild(legend);
        document.body.appendChild(container);
        this.dom = container;
        this._updateUI();
    }
    _removeUI() {
        if (this.dom) { document.body.removeChild(this.dom); this.dom = null; }
        if (this._cleanupDrag) { this._cleanupDrag(); this._cleanupDrag = null; }
    }
    _createBtn(text, onClick) {
        const btn = document.createElement('button');
        btn.textContent = text;
        btn.style.marginRight = '5px';
        btn.style.background = '#333';
        btn.style.color = '#fff';
        btn.style.border = '1px solid #555';
        btn.style.cursor = 'pointer';
        btn.onclick = onClick;
        return btn;
    }
    _attachListeners() {
        window.addEventListener('mousedown', this._boundMouseDown);
        window.addEventListener('mousemove', this._boundMouseMove);
        window.addEventListener('mouseup', this._boundMouseUp);
        window.addEventListener('keydown', this._boundKeyDown);
        window.addEventListener('wheel', this._boundWheel, { passive: false });
    }
    _detachListeners() {
        window.removeEventListener('mousedown', this._boundMouseDown);
        window.removeEventListener('mousemove', this._boundMouseMove);
        window.removeEventListener('mouseup', this._boundMouseUp);
        window.removeEventListener('keydown', this._boundKeyDown);
        window.removeEventListener('wheel', this._boundWheel);
    }
    _selectTool(tool) {
        if (this.isStandalone) {
            this._sendRemote({ type: 'selectTool', tool });
        }
        this.currentTool = tool;
        this.selectionRect = null; 
        this.selectedBlocks.clear();
        if (tool !== 'paste') this.clipboard = null; 
        this._updateUI();
        this.isDirty = true;
        this._broadcastSync();
    }
    _selectFace(face) { 
        if (this.isStandalone) {
            this._sendRemote({ type: 'selectFace', face });
        }
        this.currentFace = face; this._updateUI(); 
        this._broadcastSync();
    }
    _changeBlockSize(w, h) {
        if (this.isStandalone) {
            this._sendRemote({ type: 'changeBlockSize', w, h });
            return;
        }
        if (!this.effect) return;
        if (isNaN(w) || w < 1) w = 4;
        if (isNaN(h) || h < 1) h = 4;
        const prefix = this.effect.configPrefix;
        // Use set() to trigger auto-alignment logic in ConfigurationManager
        this.effect.c.set(prefix + 'BlockWidthCells', w);
        this.effect.c.set(prefix + 'BlockHeightCells', h);
        // Re-init logic grid with new size
        const currentStep = this.effect.expansionPhase;
        this.effect._initLogicGrid(); 
        this.effect.jumpToStep(currentStep); 
        this.isDirty = true;
        this._broadcastSync();
    }
    _updateUI() {
        if (!this.dom) return;
        if (this.effect && this.inpBlockW && this.inpBlockH) {
            const bs = this.effect.getBlockSize();
            this.inpBlockW.value = bs.w;
            this.inpBlockH.value = bs.h;
            if (this.inpSpeed) {
                const spd = this.effect.c.state[this.effect.configPrefix + 'Speed'];
                this.inpSpeed.value = (spd !== undefined) ? spd : 1.0;
            }
            if (this.inpDuration) {
                const dur = this.effect.c.state[this.effect.configPrefix + 'DurationSeconds'];
                this.inpDuration.value = (dur !== undefined) ? dur : 5.0;
            }
        }
        if (this.effect && this.stepLabel) {
            this.stepLabel.textContent = `Step: ${this.effect.expansionPhase} / ${this.effect.sequence.length}`;
        }
        for (const t in this.tools) {
            this.tools[t].style.background = (t === this.currentTool) ? '#00aa00' : '#333';
        }
        // Update layer buttons
        if (this.layerBtns) {
            this.layerBtns.forEach((btn, l) => {
                btn.style.background = (this.currentLayer === l) ? '#00aa00' : '#333';
            });
        }
        const showFaces = (this.currentTool === 'nudge');
        if (this.faceControls) {
            this.faceControls.style.display = showFaces ? 'block' : 'none';
            if (showFaces) {
                for (const f in this.faceBtns) {
                    this.faceBtns[f].style.background = (f === this.currentFace) ? '#00aa00' : '#333';
                }
            }
        }
    }
    _changeStep(delta) {
        if (this.isStandalone) {
            this._sendRemote({ type: 'changeStep', delta });
            return;
        }
        this.redoStack = [];
        const oldStep = this.effect.expansionPhase;
        let newStep = oldStep + delta;
        // Clamp to minimum Step 1
        if (newStep < 1) newStep = 1;
        // Procedural Generation Support (Only if attempting to go past the end)
        if (delta > 0 && newStep > this.effect.sequence.length) {
            if (this.effect.name === 'QuantizedBlockGenerator' || (this.effect.state === 'GENERATING' && typeof this.effect._attemptGrowth === 'function')) {
                // Ensure we have an entry for the NEW step
                if (!this.effect.sequence[newStep - 1]) {
                    this.effect.sequence[newStep - 1] = [];
                }
                // Force manual recording for this growth attempt
                this.effect.manualStep = true;
                // Keep expansionPhase at oldStep so _attemptGrowth writes to sequence[oldStep]
                this.effect.expansionPhase = oldStep;
                this.effect._attemptGrowth();
                // Now advance to the new step
                this.effect.expansionPhase = newStep;
                this._updateUI();
                this.isDirty = true;
                this._broadcastSync();
                return;
            }
        }
        // Limit to sequence length
        if (newStep > this.effect.sequence.length) newStep = this.effect.sequence.length;
        this._log(`[Editor] ChangeStep: ${oldStep} -> ${newStep} (Delta: ${delta}, Len: ${this.effect.sequence.length})`);
        // Force jumpToStep for all changes to ensure immediate visibility (skip fades) and state parity
        this.effect.expansionPhase = newStep;
        this.effect.jumpToStep(newStep);
        this._updateUI();
        this.isDirty = true;
        this._broadcastSync();
    }
    _addStep() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'addStep' });
            return;
        }
        this.redoStack = [];
        // Insert at the current phase index (between current state and next step)
        const insertIdx = this.effect.expansionPhase;
        this._log(`[Editor] Inserting new empty step at index ${insertIdx} (Current Phase: ${this.effect.expansionPhase})`);
        this.effect.sequence.splice(insertIdx, 0, []); 
        // Move into the new step
        this._changeStep(1);
    }
    _delStep() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'delStep' });
            return;
        }
        // Foundation Bypass: Cannot delete if at Step 1 or Step 0, or if it's the last remaining step
        if (this.effect.expansionPhase <= 1 || this.effect.sequence.length <= 1) {
            this._warn("[Editor] Deletion blocked: Step 1 is a foundational step and cannot be removed.");
            this.ui.notifications.show("Step 1 is foundational and cannot be deleted", "info");
            return;
        }
        this.redoStack = [];
        // The current step being viewed is at index (expansionPhase - 1)
        const targetIdx = this.effect.expansionPhase - 1;
        this._log(`[Editor] Deleting step at index ${targetIdx} (Phase was ${this.effect.expansionPhase})`);
        this.effect.sequence.splice(targetIdx, 1);
        // Step back so we are looking at the previous valid state
        this._changeStep(-1);
    }
    _resetSteps() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'resetSteps' });
            return;
        }
        if (!this.effect) return;
        if (!confirm("Are you sure you want to RESET ALL STEPS for this effect? This will clear the entire animation sequence.")) return;
        this.redoStack = [];
        this.effect.sequence = [[]]; // Reset to single empty step
        this.effect.expansionPhase = 1; // Default to Step 1
        // Clear transient mask operations
        if (this.effect.maskOps) this.effect.maskOps = [];
        // Reset the logic grid
        if (typeof this.effect._initLogicGrid === 'function') {
            this.effect._initLogicGrid();
        }
        this.effect.refreshStep();
        this._updateUI();
        this.isDirty = true;
        this._log("QuantizedEffectEditor: Steps reset for", this.effect.name);
        this._broadcastSync();
    }
    _exportData() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'export' });
            return;
        }
        const encoded = this._encodeSequence(this.effect.sequence);
        const json = JSON.stringify(encoded);
        navigator.clipboard.writeText(json).then(() => { alert('Sequence data copied to clipboard (Compressed)!'); });
    }
    _savePattern() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'save' });
            return;
        }
        const effectsToSave = ['QuantizedPulse', 'QuantizedClimb', 'QuantizedRetract', 'QuantizedAdd', 'QuantizedZoom'];
        const fullPatterns = window.matrixPatterns || {};
        effectsToSave.forEach(effName => {
            const eff = this.registry.get(effName);
            if (!eff) return;
            let sequenceToSave = eff.sequence;
            const isInstanceEmpty = (!sequenceToSave || sequenceToSave.length === 0 || (sequenceToSave.length === 1 && sequenceToSave[0].length === 0));
            const globalData = (window.matrixPatterns && window.matrixPatterns[effName]);
            const hasGlobalData = globalData && globalData.length > 0;
            if (isInstanceEmpty && hasGlobalData) {
                return;
            }
            if (!sequenceToSave) return;
            let isDecoded = false;
            for (const step of sequenceToSave) {
                if (step && step.length > 0) {
                    if (typeof step[0] === 'object') {
                        isDecoded = true;
                    }
                    break;
                }
            }
            if (isDecoded) {
                sequenceToSave = this._encodeSequence(sequenceToSave);
            }
            fullPatterns[effName] = sequenceToSave;
        });
        if (typeof window.require !== 'undefined') {
            try {
                const { ipcRenderer } = window.require('elec' + 'tron');
                ipcRenderer.send('save-patterns', fullPatterns);
                alert('Patterns saved to disk successfully!');
                return;
            } catch (e) {
                this._warn("IPC Save failed, falling back to download:", e);
            }
        }
        const jsonContent = JSON.stringify(fullPatterns, null, 4); 
        const jsContent = `window.matrixPatterns = ${jsonContent};`;
        const blob = new Blob([jsContent], {type: 'application/javascript'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'QuantizedPatterns.js';
        a.click();
        URL.revokeObjectURL(url);
    }
    _encodeSequence(sequence) {
        const OPS = { 'add': 1, 'rem': 2, 'addRect': 3, 'addSmart': 6, 'removeBlock': 7, 'nudge': 12 };
        const FACES = { 'N': 1, 'n': 1, 'S': 2, 's': 2, 'E': 4, 'e': 4, 'W': 8, 'w': 8 };
        const packedSequence = [];
        for (const step of sequence) {
            const stepData = [];
            for (const opObj of step) {
                let opName, args, layer = 0;
                if (Array.isArray(opObj)) {
                    if (typeof opObj[0] === 'number') {
                        stepData.push(...opObj);
                        continue;
                    }
                    opName = opObj[0];
                    args = opObj.slice(1);
                } else {
                    opName = opObj.op;
                    args = opObj.args;
                    layer = opObj.layer || 0;
                }
                const opCode = OPS[opName];
                if (!opCode) {
                    if (opName === 'group' && opObj.ops) {
                        const encodedGroup = { op: 'group', ops: [] };
                        const tempResult = this._encodeSequence([opObj.ops]);
                        encodedGroup.ops = tempResult[0];
                        stepData.push(encodedGroup);
                    }
                    continue;
                }
                if (opCode === 1) { // add
                    if (layer > 0) {
                        stepData.push(8, args[0], args[1], layer); 
                    } else {
                        stepData.push(1, args[0], args[1]);
                    }
                } else if (opCode === 3) { // addRect
                    if (layer > 0) {
                        stepData.push(9, args[0], args[1], args[2], args[3], layer); 
                    } else {
                        stepData.push(3, args[0], args[1], args[2], args[3]);
                    }
                } else if (opCode === 6) { // addSmart
                    if (layer > 0) {
                         stepData.push(10, args[0], args[1], layer); 
                    } else {
                         stepData.push(6, args[0], args[1]);
                    }
                } else if (opCode === 7) { // removeBlock
                    if (layer > 0) {
                         stepData.push(11, args[0], args[1], layer); 
                    } else {
                         stepData.push(7, args[0], args[1]);
                    }
                } else if (opCode === 12) { // nudge
                    const dx = args[0];
                    const dy = args[1];
                    let face = args[4];
                    if (!face) {
                         if (dx === 0 && dy === 0) face = 'N'; 
                         else if (Math.abs(dy) > Math.abs(dx)) face = (dy > 0) ? 'S' : 'N';
                         else face = (dx > 0) ? 'E' : 'W';
                    }
                    const fMask = FACES[face.toUpperCase()] || 0;
                    stepData.push(12, args[0], args[1], args[2], args[3], layer, fMask);
                } else if (opCode === 2) { // rem
                    stepData.push(2, args[0], args[1]);
                    let mask = 0;
                    if (layer > 0) {
                        mask = (layer << 4);
                    }
                    stepData.push(mask);
                }
            }
            packedSequence.push(stepData);
        }
        return packedSequence;
    }
    _undo() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'undo' });
            return;
        }
        const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
        const step = this.effect.sequence[targetIdx];
        if (step && step.length > 0) { 
            const action = step.pop(); 
            // Support for transformative operations (like merge) that snapshot the state
            if (action.replacesStep && action.originalOps) {
                step.splice(0, step.length, ...action.originalOps);
            }
            this.redoStack.push(action);
            this.effect.refreshStep(); 
            this.isDirty = true;
            this._broadcastSync();
        }
    }
    _redo() {
        if (this.isStandalone) {
            this._sendRemote({ type: 'redo' });
            return;
        }
        const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
        const step = this.effect.sequence[targetIdx];
        if (this.redoStack.length > 0) {
            const action = this.redoStack.pop();
            step.push(action);
            this.effect.refreshStep();
            this.isDirty = true;
            this._broadcastSync();
        }
    }
    // CLIPBOARD OPERATIONS
    _copySelection() {
        if (!this.selectionRect) return;
        const grid = this.effect.logicGrid;
        const w = this.effect.logicGridW;
        const r = this.selectionRect; // Absolute coords now
        const data = [];
        for (let y = r.y; y <= r.y + r.h; y++) {
            for (let x = r.x; x <= r.x + r.w; x++) {
                const idx = y * w + x;
                if (grid[idx] === 1) {
                    data.push({ x: x - r.x, y: y - r.y });
                }
            }
        }
        this.clipboard = { w: r.w, h: r.h, data: data };
        this._log("Copied", data.length, "blocks");
        alert(`Copied ${data.length} blocks!`);
    }
    _deleteSelection() {
        if (!this.selectionRect) return;
        this.redoStack = [];
        const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
        const step = this.effect.sequence[targetIdx];
        const w = this.effect.logicGridW;
        const cx = Math.floor(w / 2);
        const cy = Math.floor(this.effect.logicGridH / 2);
        const r = this.selectionRect; // Absolute
        // Push a single rectangular removal op for efficiency
        step.push({ 
            op: 'removeBlock', 
            args: [r.x - cx, r.y - cy, r.x + r.w - cx, r.y + r.h - cy], 
            layer: this.currentLayer 
        });
        if (this.effect.expansionPhase === 0) this.effect.expansionPhase = 1;
        this.effect.refreshStep();
        this.isDirty = true;
        this._broadcastSync();
    }
    _cutSelection() {
        this._copySelection();
        this._deleteSelection();
    }
    _startPaste() {
        if (!this.clipboard || this.clipboard.data.length === 0) { alert("Clipboard empty"); return; }
        this.currentTool = 'paste';
        this._updateUI();
        this._broadcastSync();
    }
    _commitPaste(targetX, targetY) {
        if (!this.clipboard) return;
        this.redoStack = [];
        const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
        const step = this.effect.sequence[targetIdx];
        for (const pt of this.clipboard.data) {
            step.push({ op: 'add', args: [targetX + pt.x, targetY + pt.y] });
        }
        if (this.effect.expansionPhase === 0) this.effect.expansionPhase = 1;
        this.effect.refreshStep();
        this.isDirty = true;
        this._broadcastSync();
    }
    _onKeyDown(e) {
        if (!this.active) return;
        // Ignore if typing in an input field or text area
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        // Shortcuts
        if (e.key === 'Escape') {
            if (this.selectedBlocks.size > 0 || this.selectionRect) {
                this.selectedBlocks.clear();
                this.selectionRect = null;
                this.isDirty = true;
                e.preventDefault();
                return;
            }
        }
        if ((e.ctrlKey || e.metaKey)) {
            if (e.key === 'c') { e.preventDefault(); this._copySelection(); return; }
            if (e.key === 'x') { e.preventDefault(); this._cutSelection(); return; }
            if (e.key === 'v') { e.preventDefault(); this._startPaste(); return; }
            if (e.key === 'z') { e.preventDefault(); this._undo(); return; }
            if (e.key === 'y') { e.preventDefault(); this._redo(); return; }
        }
        if (e.key === 'Delete' || e.key === 'Backspace') {
            e.preventDefault(); this._deleteSelection(); return; 
        }
        if (e.key === 'ArrowRight' || e.key === '.' || e.key === '>') this._changeStep(1);
        if (e.key === 'ArrowLeft') this._changeStep(-1);
    }
    _getHitTest(clientX, clientY) {
        if (!this.effect) return null;
        // We use changesOff because that's where the visual blocks are drawn.
        // gridOff should ideally match but changesOff is primary for 'hitting' things.
        const options = {
            editorOffX: this.effect.c.state.quantizedEditorChangesOffsetX || 0,
            editorOffY: this.effect.c.state.quantizedEditorChangesOffsetY || 0
        };
        return this.effect.hitTest(clientX, clientY, options);
    }
    _onMouseMove(e) {
        if (!this.active) return;
        const hit = this._getHitTest(e.clientX, e.clientY);
        // Optimize: Check if hover changed
        const hoverHash = hit ? `${hit.x},${hit.y}` : "null";
        if (this.currentTool === 'addRect' || this.currentTool === 'select' || this.currentTool === 'nudge') {
            if (this.dragStart && hit) {
                // Update Preview op for drawing
                if (this.currentTool === 'nudge') {
                    // Nudge preview: Just the block itself, or the shift?
                    // Just showing the block being added is enough for now.
                    // Nudge op args: x, y, w, h
                    // We need to calculate top-left and size from drag
                    const x1 = Math.min(this.dragStart.x, hit.x);
                    const y1 = Math.min(this.dragStart.y, hit.y);
                    const x2 = Math.max(this.dragStart.x, hit.x);
                    const y2 = Math.max(this.dragStart.y, hit.y);
                    const w = x2 - x1 + 1;
                    const h = y2 - y1 + 1;
                    // We render it as an 'addRect' preview visually
                    this.effect.editorPreviewOp = {
                        op: 'addRect',
                        args: [x1, y1, x2, y2]
                    };
                } else {
                    this.effect.editorPreviewOp = {
                        op: 'addRect',
                        args: [this.dragStart.x, this.dragStart.y, hit.x, hit.y]
                    };
                }
                this.isDirty = true; // Dragging requires redraw
            } else {
                if (this.effect.editorPreviewOp) {
                    this.effect.editorPreviewOp = null;
                    this.isDirty = true;
                }
            }
        }
        if (hoverHash !== this.lastHoverHash) {
            this.lastHoverHash = hoverHash;
            if (hit) {
                this.hoverBlock = hit;
            } else {
                this.hoverBlock = null;
            }
            // If dragging, we already set dirty. If not dragging, we might need dirty for cursor highlight?
            // Editor doesn't draw cursor highlight unless pasting.
            if (this.currentTool === 'paste') this.isDirty = true;
        }
    }
    _onMouseDown(e) {
        if (!this.active) return;
        const settingsPanel = document.getElementById('settingsPanel');
        const menuToggle = document.getElementById('menuToggle');
        if ((this.dom && this.dom.contains(e.target)) || 
            (settingsPanel && settingsPanel.contains(e.target)) ||
            (menuToggle && menuToggle.contains(e.target))) {
            return;
        }
        const hit = this._getHitTest(e.clientX, e.clientY);
        // Deselect previous on new select click (unless CTRL is held)
        if (this.currentTool === 'select' && !e.ctrlKey) {
            if (this.selectedBlocks.size > 0 || this.selectionRect) {
                this.selectedBlocks.clear();
                this.selectionRect = null;
                this.isDirty = true;
            }
        }
        if (hit) {
            // Multi-Select Toggle with CTRL
            if (e.ctrlKey) {
                // If we have a selectionRect, bake it into selectedBlocks first
                if (this.selectionRect) {
                    const r = this.selectionRect;
                    for (let ry = r.y; ry <= r.y + r.h; ry++) {
                        for (let rx = r.x; rx <= r.x + r.w; rx++) {
                            this.selectedBlocks.add(`${rx},${ry}`);
                        }
                    }
                    this.selectionRect = null;
                }
                const key = `${hit.absX},${hit.absY}`;
                if (this.selectedBlocks.has(key)) {
                    this.selectedBlocks.delete(key);
                } else {
                    this.selectedBlocks.add(key);
                }
                this.isDirty = true;
                this._broadcastSync();
                return;
            }
            if (this.currentTool === 'paste') {
                this._commitPaste(hit.x, hit.y);
                return;
            }
            if (this.currentTool === 'addRect' || this.currentTool === 'select' || this.currentTool === 'nudge') {
                this.dragStart = hit;
                this._broadcastSync();
                return; // Wait for mouse up
            }
            // Basic Block Tools
            let opName = null;
            let args = null;
            if (this.currentTool === 'add') { opName = 'add'; args = [hit.x, hit.y]; } 
            else if (this.currentTool === 'removeBlock') { opName = 'removeBlock'; args = [hit.x, hit.y]; } 
            if (opName) {
                this.redoStack = [];
                const argsMatch = (o, op, a) => {
                    let oOp, oArgs;
                    if (Array.isArray(o)) {
                        oOp = o[0]; oArgs = o.slice(1);
                    } else {
                        oOp = o.op; oArgs = o.args;
                    }
                    return oOp === op && oArgs.length === a.length && oArgs.every((v, i) => v === a[i]);
                };
                const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
                const step = this.effect.sequence[targetIdx];
                const existingIdx = step.findIndex(o => argsMatch(o, opName, args));
                if (existingIdx !== -1) { 
                    step.splice(existingIdx, 1); 
                } else { 
                    if (opName === 'add') {
                        // Use _spawnBlock to trigger procedural behaviors (Balancing, Rules)
                        const oldManual = this.effect.manualStep;
                        this.effect.manualStep = true;
                        this.effect._spawnBlock(hit.x, hit.y, 1, 1, this.currentLayer);
                        this.effect.manualStep = oldManual;
                    } else {
                        const newOp = { op: opName, args: args };
                        if (opName === 'nudge') newOp.layer = this.currentLayer;
                        if (opName === 'removeBlock') newOp.layer = this.currentLayer;
                        step.push(newOp); 
                    }
                }
                if (this.effect.expansionPhase === 0) this.effect.expansionPhase = 1;
                this.effect.refreshStep();
                this.isDirty = true;
                this._broadcastSync();
            }        }
    }
    _onMouseUp(e) {
        if (!this.active) return;
        if (this.dragStart) {
            const hit = this._getHitTest(e.clientX, e.clientY);
            if (hit) {
                const targetIdx = Math.max(0, this.effect.expansionPhase - 1);
                const step = this.effect.sequence[targetIdx];
                if (this.currentTool === 'addRect') {
                    this.redoStack = [];
                    const x1 = this.dragStart.x;
                    const y1 = this.dragStart.y;
                    const x2 = hit.x;
                    const y2 = hit.y;
                    const minX = Math.min(x1, x2);
                    const maxX = Math.max(x1, x2);
                    const minY = Math.min(y1, y2);
                    const maxY = Math.max(y1, y2);
                    const w = maxX - minX + 1;
                    const h = maxY - minY + 1;
                    // Use _spawnBlock to trigger procedural behaviors (Balancing, Rules)
                    const oldManual = this.effect.manualStep;
                    this.effect.manualStep = true;
                    this.effect._spawnBlock(minX, minY, w, h, this.currentLayer);
                    this.effect.manualStep = oldManual;
                    if (this.effect.expansionPhase === 0) this.effect.expansionPhase = 1;
                    this.effect.refreshStep();
                    this.isDirty = true;
                } else if (this.currentTool === 'nudge') {
                    this.redoStack = [];
                    let targetX, targetY, targetW, targetH;
                    if (this.dragStart.x === hit.x && this.dragStart.y === hit.y) {
                        // Click nudge. Check if we have an active selection.
                        if (this.selectedBlocks.size > 0) {
                            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                            const cx = Math.floor(this.effect.logicGridW / 2);
                            const cy = Math.floor(this.effect.logicGridH / 2);
                            for (const key of this.selectedBlocks) {
                                const [absX, absY] = key.split(',').map(Number);
                                const rx = absX - cx;
                                const ry = absY - cy;
                                minX = Math.min(minX, rx);
                                maxX = Math.max(maxX, rx);
                                minY = Math.min(minY, ry);
                                maxY = Math.max(maxY, ry);
                            }
                            targetX = minX; targetY = minY;
                            targetW = maxX - minX + 1; targetH = maxY - minY + 1;
                        } else if (this.selectionRect) {
                            const cx = Math.floor(this.effect.logicGridW / 2);
                            const cy = Math.floor(this.effect.logicGridH / 2);
                            targetX = this.selectionRect.x - cx;
                            targetY = this.selectionRect.y - cy;
                            targetW = this.selectionRect.w + 1;
                            targetH = this.selectionRect.h + 1;
                        } else {
                            // Single block nudge
                            targetX = hit.x; targetY = hit.y;
                            targetW = 1; targetH = 1;
                        }
                    } else {
                        // Drag nudge
                        targetX = Math.min(this.dragStart.x, hit.x);
                        targetY = Math.min(this.dragStart.y, hit.y);
                        const x2 = Math.max(this.dragStart.x, hit.x);
                        const y2 = Math.max(this.dragStart.y, hit.y);
                        targetW = x2 - targetX + 1;
                        targetH = y2 - targetY + 1;
                    }
                    step.push({ 
                        op: 'nudge', 
                        args: [targetX, targetY, targetW, targetH, this.currentFace],
                        layer: this.currentLayer
                    });
                    if (this.effect.expansionPhase === 0) this.effect.expansionPhase = 1;
                    this.effect.refreshStep();
                    this.isDirty = true;
                } else if (this.currentTool === 'select') {
                    // Define Selection Rect
                    // dragStart and hit are in block coordinates relative to CENTER (from hitTest)
                    // hitTest returns { x: bx - cx, y: by - cy, absX: bx, absY: by }
                    // We want ABSOLUTE logic coordinates (0..W) for simpler bounds checking in flattenLayers?
                    // flattenLayers converts ops (relative) to absolute (0..W). 
                    // So let's store Absolute coords in selectionRect.
                    const absStart = this.dragStart.absX !== undefined ? this.dragStart : { absX: this.dragStart.x, absY: this.dragStart.y }; // Fallback
                    const x1 = Math.min(this.dragStart.absX, hit.absX);
                    const y1 = Math.min(this.dragStart.absY, hit.absY);
                    const x2 = Math.max(this.dragStart.absX, hit.absX);
                    const y2 = Math.max(this.dragStart.absY, hit.absY);
                    this.selectionRect = { x: x1, y: y1, w: x2-x1, h: y2-y1 };
                    this.isDirty = true;
                }
            }
            this.dragStart = null;
            this.effect.editorPreviewOp = null;
            this.isDirty = true; // Ensure preview cleared
            this._broadcastSync();
        }
    }
    _onWheel(e) {
        if (!this.active) return;
        // Prevent interfering with UI scrolling
        const settingsPanel = document.getElementById('settingsPanel');
        if (this.dom && this.dom.contains(e.target)) return;
        if (settingsPanel && settingsPanel.contains(e.target)) return;
        e.preventDefault();
        if (e.deltaY < 0) {
            this._changeStep(-1);
        } else if (e.deltaY > 0) {
            this._changeStep(1);
        }
    }
}
// --- UIManager.js ---
// =========================================================================
// UI MANAGER
// =========================================================================
class UIManager {
    constructor(c, effects, fonts, notificationMgr, charSelector) {
        // Core dependencies and state
        this.c = c;
        this.effects = effects; // Renamed from this.eff for clarity, consistency
        this.fonts = fonts;
        this.notifications = notificationMgr;
        this.charSelector = charSelector;
        this.dom = this._initializeDOM();
        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 };
        this.ignoreNextClick = false; // Retain existing logic for drag/click distinction
        this.isKeyBindingActive = false; // Flag to suspend global key inputs
        this.defs = this._generateDefinitions();
        // Event subscriptions
        this.c.subscribe((key, state) => this.refresh(key));
        this.fonts.subscribe(() => this.refresh('fontFamily'));
        // Initialization
        this.init();
    }
    /**
     * Establish initial DOM structure using expected selectors and IDs.
     * @private
     */
    _initializeDOM() {
        return {
            panel: document.getElementById('settingsPanel'),
            toggle: document.getElementById('menuToggle'),
            tabs: document.getElementById('navTabs'),
            content: document.getElementById('contentArea'),
            tooltip: document.getElementById('ui-tooltip') || this._createTooltip(),
            keyTrap: document.getElementById('ui-key-trap') || this._createKeyTrap(),
            track: null, // Initialized later in init
        };
    }
    /**
     * Create invisible input trap for key binding.
     * @private
     */
    _createKeyTrap() {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'ui-key-trap';
        // Ensure element is rendered but invisible/unobtrusive
        input.style.position = 'fixed';
        input.style.top = '0';
        input.style.left = '0';
        input.style.width = '1px';
        input.style.height = '1px';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        input.style.zIndex = '-1';
        input.setAttribute('aria-hidden', 'true');
        document.body.appendChild(input);
        return input;
    }
    /**
     * Create the tooltip element and attach to the DOM.
     * @private
     */
    _createTooltip() {
        const tooltip = document.createElement('div');
        tooltip.id = 'ui-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
    }
    /**
     * Generate all UI component definitions for settings dynamically.
     * This method orchestrates the gathering of definitions from category-specific methods.
     * @private
     */
    _generateDefinitions() {
        return [
            ...this._generateGlobalSettings(),
            // APPEARANCE TAB
            ...this._generateAppearanceSettings(),
            // BEHAVIOR TAB
            ...this._generateBehaviorSettings(),
            // FX TAB
            ...this._generateFXSettings(),
            // DEBUG TAB
            ...this._generateDebugTab(),
            // SYSTEM TAB
            ...this._generateSystemTab()
        ];
    }
    /**
     * Generates definitions for the 'Global' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateGlobalSettings() {
        return [
            { cat: 'Global', type: 'accordion_header', label: 'Code Basics' },
            { cat: 'Global', id: 'backgroundColor', type: 'color', label: 'Background Color' },
            { cat: 'Global', id: 'streamPalette', type: 'color_list', label: 'Code Colors', max: 3 },
            { cat: 'Global', id: 'paletteBias', type: 'range', label: 'Color Mix', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'% Mix', description: "Left: Solid Streams. Right: Random Characters. Middle: Blend." },
            { cat: 'Global', id: 'colorMixType', type: 'range', label: 'Mix Type', min: 0, max: 1, step: 0.05, transform: v => v < 0.3 ? 'Stream Colors' : (v > 0.7 ? 'Character Colors' : 'Mixed'), description: "Controls whether colors are assigned per-stream or per-character." },
            { cat: 'Global', id: 'tracerColor', type: 'color', label: 'Tracer Color', description: "The head of the stream that writes the code to the screen" },
            { cat: 'Global', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, step: 1, unit: 'px' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20, step: 1 },
            { cat: 'Global', id: 'performanceMode', type: 'checkbox', label: 'Performance Mode', description: "Optimizes settings for older hardware: Font 24px (min), No Bloom/Post-Process, 0.75x Res, No Smoothing." },
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing', dep: '!shaderEnabled', description: 'Anti-aliasing is automatically disabled when a custom shader is in use.' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: ['smoothingEnabled', '!shaderEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'Appearance' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateAppearanceSettings() {
        return [
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Fonts' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Manage Character Sets', action: 'manageCharacters', class: 'btn-info' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' }, // Main Accordion Header
            { cat: 'Appearance', type: 'accordion_subheader', label: 'General' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Allows for brightness variance when characters are written' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
            { cat: 'Appearance', id: 'gradualColorStreams', type: 'checkbox', label: 'Gradual Color Streams', description: "Immediately blends tracer color to stream color behind the head, removing tracer glow." },
            { cat: 'Appearance', id: 'gradualColorStreamsFrequency', type: 'range', label: 'Frequency', min: 1, max: 100, step: 1, unit: '%', dep: 'gradualColorStreams', description: "Probability that a tracer will use the gradual color effect." },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Tracers' },
            { cat: 'Appearance', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 150, unit: 'fr' },
            { cat: 'Appearance', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 150, unit: 'fr' },
            { cat: 'Appearance', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 150, unit: 'fr' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Stream Trails' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolving Stream Trails' }, 
            { cat: 'Appearance', id: 'dissolveScalePercent', type: 'range', label: 'Dissolve Scale', min: -100, max: 100, unit: '%', dep: 'dissolveEnabled', description: 'Percentage size change during dissolve. Negative values shrink, positive values grow.' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Trail Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghosting Offset', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Character Overlap' },
            { cat: 'Appearance', id: 'overlapEnabled', type: 'checkbox', label: 'Enable Overlap' },
            { cat: 'Appearance', id: 'overlapColor', type: 'color', label: 'Overlap Color', dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapDensity', type: 'range', label: 'Overlap Density', min: 0.1, max: 1.0, step: 0.1, dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapTarget', type: 'select', label: 'Overlap Target', options: [{label:'Streams Only',value:'stream'},{label:'All Characters',value:'all'}], dep: 'overlapEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glimmer Tracers'},
            { cat: 'Appearance', id: 'upwardTracerEnabled', type: 'checkbox', label: 'Glimmer Tracers', description: 'Invisible scanners that light up existing code' },
            { cat: 'Appearance', id: 'upwardTracerChance', type: 'range', label: 'Frequency', min: 0, max: 1.0, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 180, unit: 'fr', dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerSpeedMult', type: 'range', label: 'Vertical Climb Speed', min: 0.5, max: 4.0, step: 0.1, transform: v=>v+'x', dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerGlimmerSpeed', type: 'range', label: 'Glimmer Blink Speed', min: 0.01, max: 10.0, step: 0.01, dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerGlimmerSize', type: 'range', label: 'Glimmer Grid Size', min: 2, max: 6, step: 1, dep: 'upwardTracerEnabled', description: "The number of mini blocks that determine the shape of the Glimmer highlighting." },
            { cat: 'Appearance', id: 'upwardTracerGlimmerFill', type: 'range', label: 'Glimmer Fill', min: 2, max: 12, step: 1, dep: 'upwardTracerEnabled', description: "The amount of mini blocks that are lit within the Glimmer Grid." },
            { cat: 'Appearance', id: 'upwardTracerGlimmerGlow', type: 'range', label: 'Glimmer Glow', min: 0, max: 50, step: 1, dep: 'upwardTracerEnabled' },
            { cat: 'Appearance', id: 'upwardTracerGlimmerFlicker', type: 'range', label: 'Glimmer Flicker', min: 0.0, max: 1.0, step: 0.05, dep: 'upwardTracerEnabled', transform: v=>(v*100).toFixed(0)+'%', description: "How often Glimmer highlights will flicker on/off, adding to the randomness of the highlighting." },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.0, max: 1.0, step: 0.01, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            // View Window Controls
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        ];
    }
    /**
     * Generates definitions for the 'Behavior' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateBehaviorSettings() {
        return [
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'releaseInterval', type: 'range', label: 'Event Timer', description: "For synchronized events (like tracer release) this is the interval between events.", min: 1, max: 10, step: 1 },
            { cat: 'Behavior', id: 'desyncIntensity', type: 'range', label: 'Tracer Desync', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', description: "Varies the speed and release timing of tracers. 0% is uniform sync." },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Between Erasers', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minGapTypes', type: 'range', label: 'Min Gap Between Types', min: 1, max: 100, unit: 'px', description: "Minimum space between tracer types, preventing short streams" },
            { cat: 'Behavior', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 180, unit:'fr' },
            { cat: 'Behavior', id: 'trailLengthVarianceEnabled', type: 'checkbox', label: 'Variable Trail Length' },
            { cat: 'Behavior', id: 'trailLengthVariance', type: 'range', label: 'Length Variance', min: 0, max: 600, unit: 'fr', dep: 'trailLengthVarianceEnabled', description: "Randomizes the length of the trail. Range is between Fade Speed and this value." },
            { cat: 'Behavior', id: 'streamVisibleLengthScale', type: 'range', label: 'Stream Length Scale', min: 0.8, max: 2.0, step: 0.1, transform: v => v + 'x', description: "Scales the visible length of all code streams." },
            { cat: 'Behavior', id: 'allowTinyStreams', type: 'checkbox', label: 'Allow Tiny Streams', description: "Increases the probability of very short streams spawning." },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps in Code Stream', min: 0, max: 0.5, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Tracers'},
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1, description: "Max number of tracers released per cycle. A tracer is the leading character that 'writes' the stream to the screen." },
            { cat: 'Behavior', id: 'preferClusters', type: 'checkbox', label: 'Prefer Clusters', description: "Slightly increases the chance of tracers spawning side-by-side." },
            { cat: 'Behavior', id: 'tracerStopChance', type: 'range', label: 'Tracer Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for a tracer to randomly stop, leaving a hanging stream.'},
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Erasers'},
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, description: "Invisible tracers that erase code streams instead of writing it." },
            { cat: 'Behavior', id: 'eraserStopChance', type: 'range', label: 'Eraser Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for an eraser to randomly stop, leaving a hanging stream.' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Inverted Tracers'},
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Tracers that only write occassional characters" },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Frequency', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%'},
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Symbol Rotator' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 100, step: 1, unit: '%', dep: 'rotatorEnabled', description: "Rotators are characters that change over time. This is the likelyhood that a rotator will be spawned." },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: "Lock the rotator change to the cycles that move the tracers" },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotateDuringFade', type: 'checkbox', label: 'Rotate during fade', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncEnabled', type: 'checkbox', label: 'Desynchronize Rotators', dep: 'rotatorEnabled', description: "Allow rotators to rotate at different speeds" },
            { cat: 'Behavior', id: 'rotatorDesyncVariance', type: 'range', label: 'Desync Variance', min: 0, max: 100, unit: '%', dep: ['rotatorEnabled', 'rotatorDesyncEnabled'] },
            { cat: 'Behavior', id: 'rotatorRandomSpeedEnabled', type: 'checkbox', label: 'Randomize Rotation Speed', dep: 'rotatorEnabled', description: "Vary the rotation speed randomly throughout the rotator's life cycle." },
        ];
    }
    /**
     * Generates definitions for the 'FX' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateFXSettings() {
        return [
            { cat: 'Effects', type: 'header', label: 'Movie Effects' }, // Using header for main section
            { cat: 'Effects', type: 'header', label: 'Trilogy' }, // Sub-header
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'Effects', id: 'pulseMovieAccurate', type: 'checkbox', label: 'Movie Accurate', dep: 'pulseEnabled', description: "Enables movie-accurate timing and visuals, disabling custom controls." },
            { cat: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDelaySeconds', type: 'range', label: 'Delay', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Honor blank spaces within the code streams." },
            { cat: 'Effects', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Preserve Tracer Glow', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseDimming', type: 'range', label: 'Initial Dim Amount', min: 0.0, max: 1.0, step: 0.05, dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: ['pulseEnabled', '!pulseMovieAccurate'], description: "Start at a full square" },
            { cat: 'Effects', id: 'pulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: ['pulseEnabled', '!pulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_header', label: 'Clear Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Clear Pulse Now', action: 'clearpulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'clearPulseEnabled', type: 'checkbox', label: 'Enable Clear Pulse' },
            { cat: 'Effects', id: 'clearPulseMovieAccurate', type: 'checkbox', label: 'Movie Accurate', dep: 'clearPulseEnabled', description: "Enables movie-accurate visual artifacts (tearing/lag) without dimming the screen." },
            { cat: 'Effects', id: 'clearPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'], description: "Honor blank spaces within the code streams." },
            { cat: 'Effects', id: 'clearPulseBlend', type: 'checkbox', label: 'Color Blend', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'], description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', id: 'clearPulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'], description: "Start at a full square" },
            { cat: 'Effects', id: 'clearPulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: ['clearPulseEnabled', '!clearPulseMovieAccurate'] },
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse Storm' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Storm Now', action: 'minipulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'Effects', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseUseTracerGlow', type: 'checkbox', label: 'Use Tracer Glow', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'miniPulseEnabled', description: "Honor blank spaces within the code streams." },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseThickness', type: 'range', label: 'Wave Width', min: 10, max: 150, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSize', type: 'range', label: 'Blast Size Max', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Deja Vu' },
            { cat: 'Effects', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'Effects', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'Effects', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMinRectHeight', type: 'range', label: 'Minimum Thickness', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Maximum Thickness', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuHoleBrightness', type: 'range', label: 'Intensity', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Enable Color Writing', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuIntensity', type: 'range', label: 'Flash Frequency', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Length', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Length Variance', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Superman' },
            { cat: 'Effects', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'Effects', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman Effects' },
            { cat: 'Effects', id: 'supermanFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanGlow', type: 'range', label: 'Glow amount', min: 1, max: 10, dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFadeSpeed', type: 'range', label: 'Fade Duration', min: 5, max: 60, dep: 'supermanEnabled', description: 'Higher values mean trails last longer.' },
            { cat: 'Effects', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 10, step: 1, dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'Effects', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 10, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'Effects', id: 'supermanSpawnSpeed', type: 'range', label: 'Bolt Speed', min: 10, max: 100, dep: 'supermanEnabled', description: 'Speed from left to right' },
            { cat: 'Effects', type: 'accordion_header', label: 'Boot/Crash' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Boot Sequence' },
            { cat: 'Effects', id: 'bootSequenceEnabled', type: 'checkbox', label: 'Start Code with Boot' },
            { cat: 'Effects', type: 'button', label: 'Trigger Boot Now', action: 'boot', class: 'btn-warn' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Sequence' },
            { cat: 'Effects', id: 'crashEnabled', type: 'checkbox', label: 'Enable Crash' },
            { cat: 'Effects', id: 'crashFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashDurationSeconds', type: 'range', label: 'Duration', min: 5, max: 120, step: 5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Visuals', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetCount', type: 'range', label: 'Shadowbox Density', min: 0, max: 200, step: 1, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashSheetSpeed', type: 'range', label: 'Shadowbox Speed', min: 0.1, max: 3.0, step: 0.1, dep: 'crashEnabled', transform: v=>v+'x' },
            { cat: 'Effects', id: 'crashSheetOpacity', type: 'range', label: 'Shadowbox Opacity', min: 0.0, max: 1.0, step: 0.01, dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashStationaryChance', type: 'range', label: 'Shadowbox Movement Level', min: 0, max: 100, unit: '%', invert: true, dep: 'crashEnabled', description: "How likely a shadow box is to move when spawned." },
            { cat: 'Effects', id: 'crashFlashDelayMin', type: 'range', label: 'Flash Delay Min', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashFlashDelayMax', type: 'range', label: 'Flash Delay Max', min: 1, max: 10, step: 0.5, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Features', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashMovieFps', type: 'checkbox', label: 'Movie FPS', dep: 'crashEnabled', description: "When enabled, locks the rendering to 30 fps for most effects." },
            { cat: 'Effects', id: 'crashEnableSmith', type: 'checkbox', label: 'Enable Agent Smith', description: "Randomly introduces agent Smith within the crash. Subtle.", dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableSuperman', type: 'checkbox', label: 'Enable Code Bolts', dep: 'crashEnabled' },
            { cat: 'Effects', id: 'crashEnableFlash', type: 'checkbox', label: 'Enable Flash/Fade', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'button', label: 'Trigger Crash Now', action: 'crash', class: 'btn-warn', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Macros' },
            { cat: 'Effects', id: 'runBothInOrder', type: 'checkbox', label: 'Run Both in Order', description: 'Automatically triggers the Crash sequence after the Boot sequence completes.' },
            { cat: 'Effects', type: 'button', label: 'Trigger Sequence Now', action: 'boot_crash_sequence', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Resurrections' }, // Sub-header
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Pulse', action: 'quantizedPulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedPulseEnabled', type: 'checkbox', label: 'Enable Quantized Pulse' },
            { cat: 'Effects', id: 'quantizedPulseAutoGenerateRemaining', type: 'checkbox', label: 'Auto generate remaining animation', dep: 'quantizedPulseEnabled', description: "When the manual animation is complete but does not fill the screen, allow the Block Generator to take over and finish the animation" },
            { cat: 'Effects', id: 'quantizedPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseDurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseSpeed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedPulseEnabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedPulseFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedBlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedPulseEnabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedBlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedPulseEnabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedPulseBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulsePerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulsePerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', id: 'quantizedPulseInnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Add' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Add', action: 'quantizedAdd', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedAddEnabled', type: 'checkbox', label: 'Enable Quantized Add' },
            { cat: 'Effects', id: 'quantizedAddAutoGenerateRemaining', type: 'checkbox', label: 'Auto generate remaining animation', dep: 'quantizedAddEnabled', description: "When the manual animation is complete but does not fill the screen, allow the Block Generator to take over and finish the animation" },
            { cat: 'Effects', id: 'quantizedAddFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddDurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddSpeed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedAddEnabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedAddBlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedAddEnabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedAddBlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedAddEnabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedAddFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddPerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddPerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', id: 'quantizedAddInnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedAddEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Retract' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Retract', action: 'quantizedRetract', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedRetractEnabled', type: 'checkbox', label: 'Enable Quantized Retract' },
            { cat: 'Effects', id: 'quantizedRetractAutoGenerateRemaining', type: 'checkbox', label: 'Auto generate remaining animation', dep: 'quantizedRetractEnabled', description: "When the manual animation is complete but does not fill the screen, allow the Block Generator to take over and finish the animation" },
            { cat: 'Effects', id: 'quantizedRetractFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractDurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractSpeed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedRetractEnabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedRetractBlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedRetractEnabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedRetractBlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedRetractEnabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedRetractFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractPerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractPerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', id: 'quantizedRetractInnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedRetractEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Climb' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Climb', action: 'quantizedClimb', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedClimbEnabled', type: 'checkbox', label: 'Enable Quantized Climb' },
            { cat: 'Effects', id: 'quantizedClimbAutoGenerateRemaining', type: 'checkbox', label: 'Auto generate remaining animation', dep: 'quantizedClimbEnabled', description: "When the manual animation is complete but does not fill the screen, allow the Block Generator to take over and finish the animation" },
            { cat: 'Effects', id: 'quantizedClimbFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbDurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbSpeed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedClimbEnabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedClimbBlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedClimbEnabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedClimbBlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedClimbEnabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedClimbFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbPerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbPerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', id: 'quantizedClimbInnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedClimbEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Zoom' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Zoom', action: 'quantizedZoom', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedZoomEnabled', type: 'checkbox', label: 'Enable Quantized Zoom' },
            { cat: 'Effects', id: 'quantizedZoomAutoGenerateRemaining', type: 'checkbox', label: 'Auto generate remaining animation', dep: 'quantizedZoomEnabled', description: "When the manual animation is complete but does not fill the screen, allow the Block Generator to take over and finish the animation" },
            { cat: 'Effects', id: 'quantizedZoomFrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomDurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomSpeed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedZoomEnabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedZoomZoomRate', type: 'range', label: 'Zoom Rate', min: 0.1, max: 5, step: 0.1, dep: 'quantizedZoomEnabled', description: "Controls how fast the inner content zooms in." },
            { cat: 'Effects', id: 'quantizedZoomDelay', type: 'range', label: 'Zoom Start Delay', min: 0, max: 5, step: 0.1, unit: 's', dep: 'quantizedZoomEnabled', description: "Time to wait before starting the zoom effect." },
            { cat: 'Effects', id: 'quantizedZoomHoldSeconds', type: 'range', label: 'Hold Time', min: 0, max: 10, step: 0.1, unit: 's', dep: 'quantizedZoomEnabled', description: "How long the effect stays on screen after expansion completes." },
            { cat: 'Effects', id: 'quantizedZoomBlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedZoomEnabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedZoomBlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedZoomEnabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedZoomFadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomFadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomBorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomPerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomPerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', id: 'quantizedZoomInnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedZoomEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Quantized Block Generator' },
            { cat: 'Effects', type: 'button', label: 'Trigger Quantized Block Generator', action: 'QuantizedBlockGenerator', class: 'btn-warn' },
            { cat: 'Effects', id: 'quantizedGenerateV2Enabled', type: 'checkbox', label: 'Enable Quantized Block Generator' },
            
            { cat: 'Effects', type: 'accordion_subheader', label: 'General', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2FrequencySeconds', type: 'range', label: 'Frequency', min: 50, max: 500, step: 1, unit: 's', transform: v => v === 500 ? 'Random' : v + 's', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2DurationSeconds', type: 'range', label: 'Max Duration', min: 1, max: 30, step: 0.1, unit: 's', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2Speed', type: 'range', label: 'Speed', min: 1, max: 10, step: 0.1, dep: 'quantizedGenerateV2Enabled', description: "Controls the animation update rate. 1 = Slowest, 10 = Fastest." },
            { cat: 'Effects', id: 'quantizedGenerateV2SimultaneousSpawns', type: 'range', label: 'Max Actions', min: 1, max: 10, step: 1, dep: 'quantizedGenerateV2Enabled', description: "The maximum number of growth actions to attempt in a single step." },

            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2LayerCount', type: 'range', label: 'Layer Count', min: 1, max: 2, step: 1, dep: 'quantizedGenerateV2Enabled', description: "Number of additional layers to generate (Layer 0 is always base, max 2 additional = 3 total)." },
            { cat: 'Effects', id: 'quantizedGenerateV2BlockWidthCells', type: 'range', label: 'Grid Width', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled', description: "Width of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedGenerateV2BlockHeightCells', type: 'range', label: 'Grid Height', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled', description: "Height of each grid block in character cells." },
            { cat: 'Effects', id: 'quantizedGenerateV2MinBlockWidth', type: 'range', label: 'Min Block Width', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2MaxBlockWidth', type: 'range', label: 'Max Block Width', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2MinBlockHeight', type: 'range', label: 'Min Block Height', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2MaxBlockHeight', type: 'range', label: 'Max Block Height', min: 1, max: 8, step: 1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2FadeInFrames', type: 'range', label: 'Fade In', min: 0, max: 60, unit: 'fr', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2FadeFrames', type: 'range', label: 'Fade Out', min: 0, max: 60, unit: 'fr', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2BorderIllumination', type: 'range', label: 'Border Illumination', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2PerimeterThickness', type: 'range', label: 'Perimeter Thickness', min: 0.1, max: 4.0, step: 0.1, dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2PerimeterColor', type: 'color', label: 'Perimeter Color', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2InnerColor', type: 'color', label: 'Perimeter Fade Color', dep: 'quantizedGenerateV2Enabled' },

            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxOverride', type: 'checkbox', label: 'Override Line Defaults', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxThickness', type: 'range', label: 'Line Size', min: 0.1, max: 10.0, step: 0.1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxColor', type: 'color', label: 'Line Tint', dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxFadeColor', type: 'color', label: 'Line Fade Color', dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxIntensity', type: 'range', label: 'Intensity', min: 0.01, max: 1.0, step: 0.01, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxGlow', type: 'range', label: 'Glow Intensity', min: 0.01, max: 1.0, step: 0.01, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxSaturation', type: 'range', label: 'Saturation', min: 0.0, max: 2.0, step: 0.05, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxBrightness', type: 'range', label: 'Brightness', min: 0.0, max: 2.0, step: 0.05, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxAdditiveStrength', type: 'range', label: 'Additive Strength', min: 0.0, max: 2.0, step: 0.05, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxSharpness', type: 'range', label: 'Line Sharpness', min: 0.01, max: 0.2, step: 0.01, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxRoundness', type: 'range', label: 'Line Roundness', min: 0.0, max: 1.0, step: 0.05, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxGlowFalloff', type: 'range', label: 'Glow Falloff', min: 0.5, max: 10.0, step: 0.1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxSampleOffsetX', type: 'range', label: 'Char Sample X Offset', min: -50, max: 50, step: 1, unit: 'px', dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxSampleOffsetY', type: 'range', label: 'Char Sample Y Offset', min: -50, max: 50, step: 1, unit: 'px', dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxMaskSoftness', type: 'range', label: 'Char Mask Softness', min: 0.0, max: 5.0, step: 0.1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'] },
            { cat: 'Effects', id: 'quantizedGenerateV2LineGfxPersistence', type: 'range', label: 'Fade Duration', min: 0.0, max: 1.0, step: 0.01, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2LineGfxOverride'], description: "Overrides global line persistence for this effect." },

            { cat: 'Effects', type: 'accordion_subheader', label: 'Behavior', dep: 'quantizedGenerateV2Enabled' },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableUnfold', type: 'checkbox', label: 'Enable Unfold Growth', dep: 'quantizedGenerateV2Enabled', description: "Enables the unfolding behavior (Copy/Paste frontier)." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableNudge', type: 'checkbox', label: 'Enable Nudge Growth', dep: 'quantizedGenerateV2Enabled', description: "Enables multi-layer nudge behaviors." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableCluster', type: 'checkbox', label: 'Enable Cluster Growth', dep: 'quantizedGenerateV2Enabled', description: "Enables shifting clusters of 2-3 blocks." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableCentered', type: 'checkbox', label: 'Enable Centered Growth', dep: 'quantizedGenerateV2Enabled', description: "Starts at the center and grows outward on all layers." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableOverlap', type: 'checkbox', label: 'Enable Layer Overlap', dep: 'quantizedGenerateV2Enabled', description: "Enables overlapping layer generation (Cloud effect)." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableShift', type: 'checkbox', label: 'Enable Block Shift', dep: 'quantizedGenerateV2Enabled', description: "Selects a contiguous block group on a sub-layer and shifts it away from the central axis, filling the wake to prevent holes." },
            { cat: 'Effects', id: 'quantizedGenerateV2ShiftFrequency', type: 'range', label: 'Shift Frequency', min: 1, max: 10, step: 1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableShift'], description: "Controls how often block shifting is attempted. 1 = Rarely, 10 = Every step." },
            { cat: 'Effects', id: 'quantizedGenerateV2ShiftMaxThickness', type: 'range', label: 'Max Shift Thickness', min: 1, max: 10, step: 1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableShift'], description: "The behavior stops shifting a quadrant once the code mass in that region exceeds this thickness." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableRearrange', type: 'checkbox', label: 'Enable Block Rearranging', dep: 'quantizedGenerateV2Enabled', description: "Scans for L-shaped block configurations, deletes the arm that extends away from its closest central axis, and redistributes it to a viable location near the axes in the next step." },
            { cat: 'Effects', id: 'quantizedGenerateV2RearrangeFrequency', type: 'range', label: 'Deletions per Step', min: 1, max: 5, step: 1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableRearrange'], description: "Controls the maximum number of blocks pruned, rotated, or rearranged per step." },
            { cat: 'Effects', id: 'quantizedGenerateV2RearrangeSubLayersOnly', type: 'checkbox', label: 'Sub-Layers Only', dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableRearrange'], description: "Forces rearranging and deletions to only affect sub-layers (L1, L2), preserving the integrity of the primary layer (L0)." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableThicken', type: 'checkbox', label: 'Enable Thicken Growth', dep: 'quantizedGenerateV2Enabled', description: "Adds a layer of thickness to existing blocks within random quadrants." },
            { cat: 'Effects', id: 'quantizedGenerateV2ThickenQuadrantCount', type: 'range', label: 'Thicken Quadrant Count', min: 0, max: 4, step: 1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableThicken'], description: "Number of quadrants to thicken per step (0-4)." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableAutoFillHoles', type: 'checkbox', label: 'Auto Fill Holes', dep: 'quantizedGenerateV2Enabled', description: "Automatically fills 1x1 internal gaps within logic blocks." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableAutoConnectIslands', type: 'checkbox', label: 'Auto Connect Islands', dep: 'quantizedGenerateV2Enabled', description: "Attempts to bridge gaps between detached clusters of blocks." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableSyncSubLayers', type: 'checkbox', label: 'Sync Sub-Layers', dep: 'quantizedGenerateV2Enabled', description: "Ensures Layer 0 blocks are always duplicated to sub-layers." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableLayerShoving', type: 'checkbox', label: 'Enable Layer Shoving', dep: 'quantizedGenerateV2Enabled', description: "Pushes overlapping sub-layer blocks outwards when the base layer expands." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableLayerCycling', type: 'checkbox', label: 'Layer Cycle (1-2-0)', dep: 'quantizedGenerateV2Enabled', description: "Cycles through Layer 1, 2, and 0 sequentially for each action in a step." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableAxisBalancing', type: 'checkbox', label: 'Enable Axis Balancing', dep: 'quantizedGenerateV2Enabled', description: "Ensures symmetrical growth by spawning a mirrored block on an opposite axis whenever a new block is added." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableScaledGrowth', type: 'checkbox', label: 'Enable Scaled Growth', dep: 'quantizedGenerateV2Enabled', description: "Starts with small blocks (1x1, 1x2) and increases block size as the total mass grows." },
            { cat: 'Effects', id: 'quantizedGenerateV2EnableEventScaling', type: 'checkbox', label: 'Enable Event Scaling', dep: 'quantizedGenerateV2Enabled', description: "Starts with few actions per step and increases frequency as total mass grows." },
            { cat: 'Effects', id: 'quantizedGenerateV2EventScalingMin', type: 'range', label: 'Min Actions', min: 1, max: 10, step: 1, dep: ['quantizedGenerateV2Enabled', 'quantizedGenerateV2EnableEventScaling'], description: "The starting number of actions per step when event scaling is enabled." },
            { cat: 'Effects', type: 'header', label: 'Special Effects' }, // Header for Special Effects
            { cat: 'Effects', type: 'accordion_header', label: 'Star Power' },
            { cat: 'Effects', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'Effects', id: 'starPowerFreq', type: 'range', label: 'Frequency', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamChance', type: 'range', label: 'Frequency', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Effects', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
            { cat: 'Effects', type: 'header', label: 'Post Processing' },
            { cat: 'Effects', type: 'accordion_header', label: 'Shader' },
            { cat: 'Effects', type: 'info_description', id: 'currentShaderNameDisplay', text: 'Loaded: No shader.' },
            { cat: 'Effects', id: 'shaderEnabled', type: 'checkbox', label: 'Enable Custom Shader' },
            { cat: 'Effects', id: 'shaderParameter', type: 'range', label: 'Shader Parameter', min: 0.0, max: 1.0, step: 0.01, dep: 'shaderEnabled', description: "A generic 0.0-1.0 value passed to the shader as 'uParameter'." },
            { cat: 'Effects', type: 'button', label: 'Import Fragment Shader (.glsl)', action: 'importShader', class: 'btn-info', dep: 'shaderEnabled' },
            { cat: 'Effects', type: 'info_description', text: 'Uniforms provided: uTexture (sampler2D), uTime (float), uResolution (vec2), uMouse (vec2), uParameter (float). Output to gl_FragColor.', dep: 'shaderEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'Debug' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateDebugTab() {
        return [
            { cat: 'Debug', type: 'accordion_header', label: 'General' },
            { cat: 'Debug', id: 'showFpsCounter', type: 'checkbox', label: 'Show FPS Counter', description: "Displays the current frames-per-second in the top-left corner." },
            { cat: 'Debug', id: 'debugEnabled', type: 'checkbox', label: 'Detailed Performance Stats', dep: 'showFpsCounter', description: "Shows detailed performance logs." },
            { cat: 'Debug', id: 'simulationPaused', type: 'checkbox', label: 'Pause Code Flow', description: "Freezes the falling code animation." },
            { cat: 'Debug', id: 'logErrors', type: 'checkbox', label: 'Log Errors to Console', description: "Allows application errors to be logged to the browser console." },
            { cat: 'Debug', id: 'quantEditorEnabled', type: 'checkbox', label: 'QuantEditor', description: "Enable the visual editor for Quantized Pulse Effect." },
            { cat: 'Debug', type: 'accordion_header', label: 'Layers' },
            { cat: 'Debug', id: 'layerEnableBackground', type: 'checkbox', label: 'Enable Background Color', description: 'Draws the black background to clear the previous frame.' },
            { cat: 'Debug', id: 'layerEnablePrimaryCode', type: 'checkbox', label: 'Show Primary Code', description: 'The main Matrix rain simulation.' },
            { cat: 'Debug', id: 'layerEnableShadowWorld', type: 'checkbox', label: 'Show Shadow World', description: 'The alternate reality revealed by effects.' },
            { cat: 'Debug', id: 'layerEnableQuantizedLines', type: 'checkbox', label: 'Show Quantized Lines', description: 'The yellow/green grid lines from quantized effects.' },
            { cat: 'Debug', id: 'layerEnableQuantizedGridCache', type: 'checkbox', label: 'Show Quantized Source Grid', description: 'The raw character grid used to generate lines (Sparse Optimization).' },
            { cat: 'Debug', id: 'quantizedSourceGridOffsetX', type: 'range', label: 'Source Grid X Offset', min: -100, max: 100, step: 1, dep: 'layerEnableQuantizedGridCache' },
            { cat: 'Debug', id: 'quantizedSourceGridOffsetY', type: 'range', label: 'Source Grid Y Offset', min: -100, max: 100, step: 1, dep: 'layerEnableQuantizedGridCache' },
            { cat: 'Debug', id: 'layerEnableEditorGrid', type: 'checkbox', label: 'Show Editor Grid', description: 'The alignment grid in the Quantized Editor.' },
            { cat: 'Debug', id: 'layerEnableEditorOverlay', type: 'checkbox', label: 'Show Editor Changes', description: 'The green schematic blocks in the Quantized Editor.' },
            { cat: 'Debug', id: 'highlightErasers', type: 'checkbox', label: 'Highlight Erasers', description: "Draws a red border around invisible eraser tracers." },
            { cat: 'Debug', id: 'quantizedSolidPerimeter', type: 'checkbox', label: 'Solid Perimeter Lines', description: 'Renders grid lines as solid blocks instead of character-based masks.' },
            { cat: 'Debug', type: 'accordion_header', label: 'Quantized Line GFX' },
            { cat: 'Debug', id: 'quantizedLineGfxEnabled', type: 'checkbox', label: 'Enable GPU Lines', description: 'Replaces standard perimeter lines with GPU-accelerated ones.' },
            { cat: 'Debug', id: 'quantizedLineGfxThickness', type: 'range', label: 'Line Size', min: 0.1, max: 10.0, step: 0.1, dep: 'quantizedLineGfxEnabled', description: "10.0 = 1 Character width. 0.1 = ~1 Pixel." },
            { cat: 'Debug', id: 'quantizedLineGfxColor', type: 'color', label: 'Line Tint', dep: 'quantizedLineGfxEnabled' },
            { cat: 'Debug', id: 'quantizedLineGfxIntensity', type: 'range', label: 'Intensity', min: 0.01, max: 1.0, step: 0.01, dep: 'quantizedLineGfxEnabled' },
            { cat: 'Debug', id: 'quantizedLineGfxGlow', type: 'range', label: 'Glow Intensity', min: 0.01, max: 1.0, step: 0.01, dep: 'quantizedLineGfxEnabled' },
            { cat: 'Debug', id: 'quantizedLineGfxOffsetX', type: 'range', label: 'X Offset', min: -50, max: 50, step: 1, unit: 'px', dep: 'quantizedLineGfxEnabled' },
            { cat: 'Debug', id: 'quantizedLineGfxOffsetY', type: 'range', label: 'Y Offset', min: -50, max: 50, step: 1, unit: 'px', dep: 'quantizedLineGfxEnabled' },
            { cat: 'Debug', id: 'quantizedLineGfxPersistence', type: 'range', label: 'Fade Duration', min: 0.0, max: 1.0, step: 0.01, dep: 'quantizedLineGfxEnabled', description: "Similar to burn-in, controls how long lines linger." },
        ];
    }
    /**
     * Generates definitions for the 'System' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateSystemTab() {
        return [
            { cat: 'System', type: 'accordion_header', label: 'Configuration' },
            { cat: 'System', type: 'slot', idx: 0, id: 'slot_0' },
            { cat: 'System', type: 'slot', idx: 1, id: 'slot_1' },
            { cat: 'System', type: 'slot', idx: 2, id: 'slot_2' },
            { cat: 'System', type: 'slot', idx: 3, id: 'slot_3' },
            { cat: 'System', type: 'slot', idx: 4, id: 'slot_4' },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
            { cat: 'System', id: 'hideMenuIcon', type: 'checkbox', label: 'Hide Settings Icon', description: 'Hover your mouse over the top right or press the Toggle UI Panel keybind to show' },
            { cat: 'System', id: 'doubleClickToReset', type: 'checkbox', label: 'Double Click to Reset', description: 'Double click/tap sliders to reset them to default values.' },
            { cat: 'System', id: 'suppressToasts', type: 'checkbox', label: 'Suppress Toast Messages', description: 'Disable pop-up notifications at the bottom of the screen.' },
            { cat: 'System', id: 'debugTabEnabled', type: 'checkbox', label: 'Enable Debug Mode', description: "Shows the hidden Debug tab for advanced settings and alignment tools." },
            { cat: 'System', type: 'accordion_header', label: 'Key Bindings' },
            { cat: 'System', id: 'enableKeybinds', type: 'checkbox', label: 'Enable Keybinds', description: 'Master switch for key bindings. When enabled, keybinds will force effects to run even if the effect is disabled in settings.' },
            { cat: 'System', type: 'info_description', text: 'Click a button to assign a new key. Press Backspace or Delete to clear.' },
            { cat: 'System', type: 'keybinder', id: 'BootSequence', label: 'Boot Animation' },
            { cat: 'System', type: 'keybinder', id: 'CrashSequence', label: 'Crash Animation' },
            { cat: 'System', type: 'keybinder', id: 'BootCrashSequence', label: 'Boot to Crash' },
            { cat: 'System', type: 'keybinder', id: 'Pulse', label: 'Pulse' },
            { cat: 'System', type: 'keybinder', id: 'ClearPulse', label: 'Clear Pulse' },
            { cat: 'System', type: 'keybinder', id: 'MiniPulse', label: 'Pulse Storm' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedPulse', label: 'Quantized Pulse' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedAdd', label: 'Quantized Add' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedRetract', label: 'Quantized Retract' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedClimb', label: 'Quantized Climb' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedZoom', label: 'Quantized Zoom' },
            { cat: 'System', type: 'keybinder', id: 'QuantizedBlockGenerator', label: 'Quantized Block Generator' },
            { cat: 'System', type: 'keybinder', id: 'DejaVu', label: 'Deja Vu' },
            { cat: 'System', type: 'keybinder', id: 'Superman', label: 'Superman' },
            { cat: 'System', type: 'keybinder', id: 'ToggleUI', label: 'Toggle UI Panel' },
            { cat: 'System', type: 'accordion_header', label: 'System Reset' },
            { cat: 'System', type: 'info_description', text: 'Clears the current font cache, and resets all font entries to default' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' },
            { cat: 'System', type: 'accordion_subheader', label: 'Frequently Asked Questions' },
            { cat: 'System', type: 'faq_item', question: 'What is this?', answer: 'This is a highly customizable Matrix Digital Rain simulation built with HTML5 Canvas and JavaScript.' },
            { cat: 'System', type: 'faq_item', question: 'How do I change the code?', answer: 'Use the settings panel on the right side of the screen to customize various aspects like colors, speeds, and effects.' },
            { cat: 'System', type: 'faq_item', question: 'Can I use my own font?', answer: 'Yes, go to the "Appearance" tab, under "Character Fonts" you can import your own TTF or OTF font file.' },
            { cat: 'System', type: 'faq_item', question: 'Why is it sometimes slow?', answer: 'Performance depends on your device and settings. Try reducing "Resolution Scale" or disabling some effects under the "Effects" tab.' },
            { cat: 'System', type: 'faq_item', question: 'Is this more AI slop?', answer: 'Yes and no. LLM\'s were definitely used to make this, but the person who programmed it is a real person, and much of the code was hand-written, not just \'vibe coded\'. It\'s not perfect, but it\'s being slowly improved.' },
            { cat: 'System', type: 'faq_item', question: 'How do I leave feedback or suggestions on your app?', answer: 'Feel free to reach out via github! I\'m definitely open to ideas and suggestions.' }
        ];
    }
    /**
     * Initialize the events, tabs, and UI components.
     */
    init() {
        // Toggle button for the settings panel
        this.dom.toggle.onclick = () => this.togglePanel();
        // Create and populate tabs and content containers
        this._setupTabs();
        // Update footer version
        document.getElementById('globalStatus').textContent = `Matrix Code v${APP_VERSION}`;
        // Initialize File Input Handlers
        this._setupFileHandlers();
        // Handle tab dragging and horizontal scrolling
        this._setupTabScroll();
        // Refresh UI
        this.refresh('ALL');
    }
    /**
     * Toggles the settings panel visibility.
     */
    togglePanel() {
        const isOpen = this.dom.panel.classList.toggle('open');
        this.dom.panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
        this.dom.toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
    /**
     * Sets up the tabs and their corresponding content containers.
     * Creates category tabs and assigns content containers to each.
     * @private
     */
    _setupTabs() {
        if (!this.dom.track) {
            this.dom.track = document.createElement('div');
            this.dom.track.id = 'tabTrack';
            this.dom.tabs.appendChild(this.dom.track);
        } else {
            this.dom.track.innerHTML = '';
        }
        const showDebug = this.c.get('debugTabEnabled');
        const categories = [...new Set(this.defs.map(def => def.cat))].filter(cat => {
            if (cat === 'Debug' && !showDebug) return false;
            return true;
        });
        const tabContentContainers = {}; // Mapping of category -> content container div
        this.dom.content.innerHTML = '';
        // Create tabs and attach event handlers
        categories.forEach((category, index) => {
            const tabButton = this._createTabButton(category, index === 0);
            this.dom.track.appendChild(tabButton);
            // Create corresponding content container for the tab
            const contentContainer = this._createTabContentContainer(category, index === 0);
            this.dom.content.appendChild(contentContainer);
            tabContentContainers[category] = contentContainer;
        });
        // Populate tab content
        this._populateTabContent(tabContentContainers);
    }
    /**
     * Creates a tab button element for a category.
     * @private
     * @param {string} category - The category name for the tab.
     * @param {boolean} isActive - Whether the tab should be active by default.
     * @returns {HTMLElement} The created tab button element.
     */
    _createTabButton(category, isActive) {
        const button = document.createElement('button');
        button.className = `tab-btn ${isActive ? 'active' : ''}`;
        button.textContent = category;
        button.onclick = () => this._handleTabClick(category, button);
        return button;
    }
    /**
     * Handles when a tab is clicked and activates the corresponding tab content.
     * @private
     * @param {string} category - The category associated with the clicked tab.
     * @param {HTMLElement} button - The clicked tab button element.
     */
    _handleTabClick(category, button) {
        // Use this.scrollState.dragDistance for distinguishing drag from click
        if (this.scrollState.dragDistance > 3) {
            this.scrollState.dragDistance = 0; // Reset for next interaction
            return; 
        }
        // Deactivate all tabs and their content
        this.dom.tabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.dom.content.querySelectorAll('.tab-content-group').forEach(content => content.classList.remove('active'));
        // Activate selected tab and content
        button.classList.add('active');
        document.getElementById(`tab-content-${category}`).classList.add('active');
    }
    /**
     * Creates a tab content container for a given category.
     * @private
     * @param {string} category - The category name for the content container.
     * @param {boolean} isActive - Whether the content container should be active by default.
     * @returns {HTMLElement} The created tab content container element.
     */
    _createTabContentContainer(category, isActive) {
        const container = document.createElement('div');
        container.className = `tab-content-group ${isActive ? 'active' : ''}`;
        container.id = `tab-content-${category}`;
        return container;
    }
    /**
     * Populates tabs with content, including accordions and controls.
     * @private
     * @param {Object} tabContentContainers - A map of category names to their content container elements.
     */
    _populateTabContent(tabContentContainers) {
        let currentAccordionBody = null;
        let lastCat = null;
        this.defs.forEach(def => {
            const container = tabContentContainers[def.cat];
            if (!container) return;
            // Reset accordion context when switching tabs/categories
            if (def.cat !== lastCat) {
                currentAccordionBody = null;
                lastCat = def.cat;
            }
            // Handle Accordion Headers (Start new accordion)
            if (def.type === 'accordion_header') {
                currentAccordionBody = this._createAccordion(container, def.label);
                return;
            } 
            // Handle Accordion Subheaders
            else if (def.type === 'accordion_subheader') {
                if (currentAccordionBody) {
                    const el = this.renderControl(def);
                    if (el) currentAccordionBody.appendChild(el);
                }
                return;
            }
            // Handle Section Headers (Break out of accordion)
            // Exception: CAUTION ZONE remains inside for special handling below
            if (def.type === 'header' && def.label !== 'CAUTION ZONE') {
                currentAccordionBody = null;
                const el = this.renderControl(def);
                if (el) container.appendChild(el);
                return;
            }
            // Handle Controls
            if (currentAccordionBody) {
                // Special handling for CAUTION ZONE inside an accordion
                if (def.cat === 'System' && def.label === 'CAUTION ZONE' && def.type === 'header') {
                    const cautionZoneDiv = document.createElement('div');
                    cautionZoneDiv.className = 'caution-zone';
                    const headerEl = this.renderControl(def);
                    cautionZoneDiv.appendChild(headerEl);
                    currentAccordionBody.appendChild(cautionZoneDiv);
                } else {
                    if (def.caution) return; // Skip caution items here, handled separately
                    const controlElement = this.renderControl(def);
                    if (controlElement) currentAccordionBody.appendChild(controlElement);
                }
            } else {
                // Orphan controls (outside any accordion) - e.g. top level buttons or headers
                const controlElement = this.renderControl(def);
                if (controlElement) container.appendChild(controlElement);
            }
        });
        // Post-process: Insert Factory Reset into the created Caution Zone
        const factoryResetDef = this.defs.find(d => d.action === 'reset' && d.caution);
        if (factoryResetDef) {
            const cautionZoneDiv = this.dom.content.querySelector('.caution-zone');
            if (cautionZoneDiv) {
                const controlElement = this.renderControl(factoryResetDef);
                if (controlElement) cautionZoneDiv.appendChild(controlElement);
            }
        }
    }
    /**
     * Creates an accordion section with a header and a container for controls.
     * @private
     * @param {HTMLElement} tabContentGroup - The parent container for the accordion.
     * @param {string} label - The label for the accordion header.
     * @returns {HTMLElement} The body element of the created accordion where controls can be appended.
     */
    _createAccordion(tabContentGroup, label) {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.innerHTML = `
            ${label}
            <span class="accordion-icon">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </span>
        `;
        const body = document.createElement('div');
        body.className = 'accordion-content';
        header.onclick = () => this._toggleAccordion(header, body, tabContentGroup);
        accordionItem.appendChild(header);
        accordionItem.appendChild(body);
        tabContentGroup.appendChild(accordionItem);
        // Default open logic: REMOVED per user request
        // const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
        // if (accordionsInTab.length === 1) { 
        //     body.classList.add('open');
        //     header.classList.add('active');
        //     header.querySelector('.accordion-icon').classList.add('rotated');
        // }
        return body;
    }
    /**
     * Toggles the visibility of an accordion section and manages sibling accordions.
     * @private
     * @param {HTMLElement} header - The header element of the accordion.
     * @param {HTMLElement} body - The body element of the accordion.
     * @param {HTMLElement} group - The parent group containing all accordions (tabContentGroup).
     */
    _toggleAccordion(header, body, group) {
        const isOpen = body.classList.contains('open');
        // Close other accordions in the group
        group.querySelectorAll('.accordion-content').forEach(siblingBody => {
            siblingBody.classList.remove('open');
            siblingBody.previousElementSibling?.classList.remove('active');
            siblingBody.previousElementSibling?.querySelector('.accordion-icon')?.classList.remove('rotated');
        });
        // Toggle the current accordion
        if (isOpen) {
            body.classList.remove('open');
            header.classList.remove('active');
            header.querySelector('.accordion-icon')?.classList.remove('rotated');
        } else {
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon')?.classList.add('rotated');
        }
    }
    /**
     * Setup input handlers for font and config import.
     * @private
     */
    _setupFileHandlers() {
        document.getElementById('importFile').onchange = e => this._handleConfigImport(e);
        document.getElementById('importFontFile').onchange = e => this._handleFontImport(e);
        // Add shader input
        const shaderInput = document.createElement('input');
        shaderInput.type = 'file';
        shaderInput.id = 'importShaderFile';
        shaderInput.accept = '.glsl,.frag,.txt';
        shaderInput.style.display = 'none';
        document.body.appendChild(shaderInput);
        shaderInput.onchange = e => this._handleShaderImport(e);
    }
    /**
     * Handles the import of a shader file.
     * @private
     */
    _handleShaderImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const source = ev.target.result;
            this.c.set('customShader', source);
            this.notifications.show('Shader Imported', 'success');
            event.target.value = '';
        };
        reader.readAsText(file);
    }
    /**
     * Updates the slot name inputs from the current configuration.
     */
    updateSlotNames() {
        if (this.c.slots) {
            this.c.slots.forEach((slot, i) => {
                const slotInput = document.getElementById(`slot-input-${i}`);
                if (slotInput) {
                    slotInput.value = slot.name;
                }
            });
        }
    }
    /**
     * Handles the import of a JSON configuration file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleConfigImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                // Merge loaded config with defaults to ensure all properties exist
                this.c.state = { ...this.c.defaults, ...data.state };
                // Handle Saved Presets
                if (data.savedPresets) {
                    this.c.slots = data.savedPresets;
                    this.c.saveSlots();
                    this.updateSlotNames(); // Force update immediately
                }
                this.c.updateDerivedValues();
                this.c.save();
                this.c.notify('ALL');
                this.notifications.show('Configuration Loaded', 'success');
            } catch (error) {
                console.error("Error loading config:", error);
                this.notifications.show('Invalid Configuration File', 'error');
            }
            event.target.value = ''; // Reset input value to allow re-importing the same file
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a custom font file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleFontImport(event) {
        const file = event.target.files[0];
        if (file) this.fonts.importFont(file);
        event.target.value = ''; // Reset input value
    }
    /**
     * Set up drag and scroll functionality for tabs.
     * @private
     */
    _setupTabScroll() {
        const tabs = this.dom.tabs;
        tabs.addEventListener('mousedown', e => this._startDrag(e));
        tabs.addEventListener('mouseleave', () => this._stopDrag());
        tabs.addEventListener('mouseup', () => this._stopDrag());
        tabs.addEventListener('mousemove', e => this._doDrag(e));
        // Ensure overflow handling matches standard behavior for wheel support
        tabs.style.overflowX = 'auto'; 
        tabs.style.overscrollBehaviorX = 'contain';
        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
        tabs.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaX) >= Math.abs(e.deltaY)) {
                return;
            }
            if (e.deltaY !== 0) {
                // preventDefault stops the browser "back" gesture or vertical page scroll
                e.preventDefault(); 
                tabs.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }
    /**
     * Initiates the drag operation for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse down event.
     */
    _startDrag(e) {
        if (e.button !== 0) return; // Only respond to primary click (left mouse button)
        this.scrollState.isDown = true;
        this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft;
        this.scrollState.scrollLeft = this.dom.tabs.scrollLeft;
        this.scrollState.dragDistance = 0;
        this.ignoreNextClick = false; // Reset flag
        this.dom.tabs.style.cursor = 'grabbing';
    }
    /**
     * Stops the drag operation for tab scrolling.
     * @private
     */
    _stopDrag() {
        this.scrollState.isDown = false;
        this.dom.tabs.style.cursor = 'grab';
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Handles the drag movement for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse move event.
     */
    _doDrag(e) {
        if (!this.scrollState.isDown) return;
        e.preventDefault(); // Prevent text highlighting during drag
        const x = e.pageX - this.dom.tabs.offsetLeft;
        const walk = (x - this.scrollState.startX) * 1.5; // Multiplier for faster scrolling
        this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk;
        this.scrollState.dragDistance = Math.abs(x - this.scrollState.startX); // Update based on actual movement
        if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; // Set flag if dragged enough to be considered a drag
    }
    /**
     * Retrieves the list of available fonts, including embedded and custom fonts.
     * @private
     * @returns {Array<Object>} An array of font objects suitable for select options.
     */
    _getFonts() {
        return [
            ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true}))
        ];
    }
    /**
     * Updates the UI list of custom fonts (used in the font manager section).
     * @param {HTMLElement} el - The DOM element to populate with the font list.
     */
    updateFontList(el) {
        el.innerHTML = '';
        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
            const div = document.createElement('div');
            div.className = 'font-item';
            div.innerHTML = `<span class="font-name">${f.display}</span>`;
            const btn = document.createElement('div');
            btn.className = 'font-delete-btn';
            btn.innerHTML = '';
            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
            div.appendChild(btn);
            el.appendChild(div);
        });
    }
    /**
     * Displays a tooltip with a given text near a target element.
     * @param {string} text - The text to display in the tooltip.
     * @param {HTMLElement} target - The element relative to which the tooltip should be positioned.
     */
    showTooltip(text, target) {
        this.dom.tooltip.textContent = text;
        this.dom.tooltip.classList.add('visible');
        const rect = target.getBoundingClientRect();
        const tipRect = this.dom.tooltip.getBoundingClientRect();
        let top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        let left = rect.left - tipRect.width - 12; // Default to left of target
        // Adjust position if it goes off-screen
        if (top < 10) top = 10;
        if (left < 10) left = rect.right + 12; // Move to right if it's too far left
        this.dom.tooltip.style.top = `${top}px`;
        this.dom.tooltip.style.left = `${left}px`;
    }
    /**
     * Hides the currently displayed tooltip.
     */
    hideTooltip() {
        this.dom.tooltip.classList.remove('visible');
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Updates the text/state of a specific keybinder button.
     * @param {string} id - The ID of the keybinding action (e.g., 'Pulse').
     */
    updateKeyBinderVisuals(id) {
        const btn = document.getElementById(`btn-key-${id}`);
        if (!btn) return;
        const def = this.defs.find(d => d.id === id);
        if (!def) return;
        const bindings = this.c.get('keyBindings') || {};
        const rawKey = bindings[id] || 'None';
        const displayKey = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
        btn.textContent = `${def.label}: [ ${displayKey} ]`;
        btn.className = 'action-btn btn-info'; // Reset class
    }
    /**
     * Creates a styled label group for a UI control, optionally including an info icon with a tooltip.
     * @param {Object} def - The definition object for the UI control.
     * @returns {HTMLElement} The created label group DOM element.
     */
    createLabelGroup(def) {
        const group = document.createElement('div');
        group.className = 'control-label-group';
        const text = document.createElement('span');
        text.textContent = def.label;
        group.appendChild(text);
        if (def.description) {
            const icon = document.createElement('span');
            icon.className = 'info-icon';
            icon.textContent = '?';
            const show = (e) => this.showTooltip(def.description, e.target);
            icon.onmouseenter = show;
            icon.onmouseleave = () => this.hideTooltip();
            // Handle touch events for mobile tooltips
            icon.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                if (this.dom.tooltip.classList.contains('visible')) { 
                    this.hideTooltip(); 
                } else { 
                    show(e); 
                    // Automatically hide tooltip after a short delay on touch devices
                    setTimeout(() => this.hideTooltip(), 3000); 
                } 
            });
            group.appendChild(icon);
        }
        return group;
    }
    /**
     * Renders the content of a color list control into the provided wrapper.
     * @private
     * @param {HTMLElement} wrapper - The container element.
     * @param {Object} def - The control definition.
     */
    _renderColorList(wrapper, def) {
        wrapper.innerHTML = '';
        const palette = this.c.get(def.id) || ["#00FF00"];
        palette.forEach((color, idx) => {
            const item = document.createElement('div');
            item.className = 'color-list-item';
            const cInput = document.createElement('input');
            cInput.type = 'color';
            cInput.value = color;
            // Optimisation: Update state directly on input to allow dragging without re-render
            cInput.oninput = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.state[def.id] = newP; // Direct state mutation
                this.c.updateDerivedValues(); // Force derived update for live preview
            };
            // Commit change on release
            cInput.onchange = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.set(def.id, newP); // Triggers save and refresh
            };
            item.appendChild(cInput);
            if (palette.length > 1 && idx > 0) {
                const delBtn = document.createElement('div');
                delBtn.className = 'btn-icon-remove';
                delBtn.textContent = '';
                delBtn.onclick = () => {
                    const newP = this.c.get(def.id).filter((_, i) => i !== idx);
                    this.c.set(def.id, newP);
                    this._renderColorList(wrapper, def);
                    this.refresh('streamPalette');
                };
                item.appendChild(delBtn);
            }
            wrapper.appendChild(item);
        });
        if (palette.length < (def.max || 3)) {
            const addBtn = document.createElement('div');
            addBtn.className = 'btn-icon-add';
            addBtn.textContent = '+';
            addBtn.onclick = () => {
                const newP = [...this.c.get(def.id), "#ffffff"];
                this.c.set(def.id, newP);
                this._renderColorList(wrapper, def);
                this.refresh('streamPalette');
            };
            wrapper.appendChild(addBtn);
        }
    }
    /**
     * Dynamically renders a UI control element based on its definition.
     * @param {Object} def - The definition object for the control.
     * @returns {HTMLElement|null} The created control element, or null if it's an accordion header.
     */
    renderControl(def) {
        if (def.type === 'accordion_header') { return null; }
        if (def.type === 'accordion_subheader') {
            const el = document.createElement('div');
            el.className = 'accordion-subheader';
            el.textContent = def.label;
            if(def.dep) el.setAttribute('data-dep', JSON.stringify(def.dep));
            return el;
        }
        if (def.type === 'header') {
            const el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; return el;
        }
        if (def.type === 'about_content') {
            const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
            const logoChar = Utils.getRandomKatakanaChar();
            const initialColor = this.c.get('streamColor');
            const initialSvgDataUrl = Utils.generateGlyphSVG(logoChar, initialColor, 48, this.c.get('fontFamily'));
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <img id="matrixLogo" src="${initialSvgDataUrl}" alt="Matrix Logo" style="height: 48px; width: 48px; margin-right: 10px;"/>
                    <h3 style="margin:0; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                </div>
                <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
            return div;
        }
        if (def.type === 'info_description') {
            const div = document.createElement('div');
            div.className = 'info-description';
            div.textContent = def.text;
            if (def.id) div.id = `in-${def.id}`;
            return div;
        }
        if (def.type === 'faq_item') {
            const container = document.createElement('div');
            container.className = 'faq-item';
            const question = document.createElement('div');
            question.className = 'faq-question';
            question.textContent = def.question;
            const answer = document.createElement('div');
            answer.className = 'faq-answer';
            answer.textContent = def.answer;
            container.appendChild(question);
            container.appendChild(answer);
            return container;
        }
        const row = document.createElement('div');
        if (def.type === 'button') {
            const btn = document.createElement('button'); btn.className = `action-btn ${def.class||'btn-info'}`; btn.textContent = def.label; btn.id = `btn-${def.action}`; btn.name = def.action; btn.onclick = () => this.handleAction(def.action); row.appendChild(btn);
        } else if (def.type === 'slot') {
            row.className = 'slot-container';
            const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[def.idx].name; inp.id = `slot-input-${def.idx}`; inp.name = `slot_name_${def.idx}`; inp.onchange = e => this.c.renameSlot(def.idx, e.target.value);
            inp.onfocus = e => e.target.select();
            const grp = document.createElement('div'); grp.className = 'slot-btn-group';
            const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${def.idx}`; save.onclick = () => { this.c.saveToSlot(def.idx); };
            const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${def.idx}`; load.onclick = () => { this.c.loadFromSlot(def.idx); };
            grp.append(save, load); row.append(inp, grp);
        } else if (def.type === 'font_list') {
            row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
        } else {
            row.className = def.type === 'checkbox' ? 'checkbox-row' : 'control-row';
            const labelGroup = this.createLabelGroup(def);
            if(def.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
            if(!def.hideValue && def.type === 'range') { 
                const valDisp = document.createElement('span'); 
                valDisp.id = `val-${def.id}`;
                valDisp.title = "Click to manual input";
                valDisp.style.cursor = "pointer";
                // Set initial value
                const initialVal = this.c.get(def.id);
                let displayVal = initialVal;
                if (!def.transform && typeof initialVal === 'number') {
                    const step = def.step || 1;
                    const decimals = (step.toString().split('.')[1] || '').length;
                    displayVal = parseFloat(initialVal.toFixed(decimals));
                }
                valDisp.textContent = def.transform ? def.transform(initialVal) : displayVal + (def.unit || '');
                valDisp.onclick = () => {
                    if (valDisp.querySelector('input')) return;
                    const currentVal = this.c.get(def.id);
                    const savedText = valDisp.textContent;
                    valDisp.textContent = '';
                    const numInput = document.createElement('input');
                    numInput.type = 'number';
                    numInput.value = currentVal;
                    numInput.className = 'manual-input'; 
                    // basic inline styles to make it fit
                    numInput.style.width = '60px';
                    numInput.style.background = '#222';
                    numInput.style.color = '#fff';
                    numInput.style.border = '1px solid #444';
                    numInput.style.borderRadius = '3px';
                    numInput.style.padding = '0 2px';
                    if (def.min !== undefined) numInput.min = def.min;
                    if (def.max !== undefined) numInput.max = def.max;
                    if (def.step !== undefined) numInput.step = def.step;
                    let committed = false;
                    const commit = () => {
                        if (committed) return;
                        let newVal = parseFloat(numInput.value);
                        if (isNaN(newVal)) {
                             this.refresh(def.id);
                             return;
                        }
                        // Clamp
                        if (def.min !== undefined && newVal < def.min) newVal = def.min;
                        if (def.max !== undefined && newVal > def.max) newVal = def.max;
                        // Step precision
                        if (def.step) {
                            const step = parseFloat(def.step);
                            newVal = Math.round(newVal / step) * step;
                        }
                        committed = true;
                        this.c.set(def.id, newVal);
                    };
                    numInput.onblur = () => {
                        if (!committed) this.refresh(def.id);
                    };
                    numInput.onkeydown = (e) => {
                         e.stopPropagation(); // Ensure keys like Backspace reach the input
                         if(e.key === 'Enter') commit();
                         if(e.key === 'Escape') this.refresh(def.id);
                    };
                    valDisp.appendChild(numInput);
                    numInput.focus();
                    numInput.select();
                };
                hdr.appendChild(valDisp); 
            } row.appendChild(hdr); } 
                else { row.appendChild(labelGroup); }
            let inp;
            if(def.type === 'range') { 
                inp = document.createElement('input'); 
                inp.type = 'range'; 
                inp.min=def.min; 
                inp.max=def.max; 
                if(def.step) inp.step=def.step; 
                const resetToDefault = () => {
                     if (this.c.get('doubleClickToReset')) {
                        const defaultVal = this.c.defaults[def.id];
                        if (defaultVal !== undefined) {
                            this.c.set(def.id, defaultVal);
                            this.notifications.show(`Reset ${def.label}`, 'info');
                            return true;
                        }
                    }
                    return false;
                };
                inp.ondblclick = resetToDefault;
                let isTouching = false;
                let lastTapTime = 0;
                inp.value = def.invert ? (def.max+def.min)-this.c.get(def.id) : this.c.get(def.id);                            
                inp.oninput = e => { 
                    if (isTouching) return; // Block native updates during touch interaction
                    const v = parseFloat(e.target.value); 
                    let actual = def.invert ? (def.max+def.min)-v : v; 
                    // Dynamic precision based on step
                    const step = def.step || 1;
                    const decimals = (step.toString().split('.')[1] || '').length;
                    if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                    this.c.set(def.id, actual); 
                    const disp = document.getElementById(`val-${def.id}`); 
                    if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                }; 
                let startX = 0;
                let startY = 0;
                let startValue = 0;
                let isHorizontalDrag = false;
                inp.addEventListener('touchstart', e => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTapTime;
                    if (tapLength < 300 && tapLength > 0) {
                        if (resetToDefault()) {
                            e.preventDefault();
                            return;
                        }
                    }
                    lastTapTime = currentTime;
                    isTouching = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(e.target.value);
                    isHorizontalDrag = false;
                    // Prevent "jump to tap" visually
                    requestAnimationFrame(() => {
                        inp.value = startValue;
                    });
                }, { passive: false });
                inp.addEventListener('touchmove', e => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    const dx = x - startX;
                    const dy = y - startY;
                    if (!isHorizontalDrag && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 5) {
                        isHorizontalDrag = true;
                    }
                    if (isHorizontalDrag) {
                        e.preventDefault(); 
                        const rect = inp.getBoundingClientRect();
                        const relativeX = Math.min(Math.max(0, x - rect.left), rect.width);
                        const percent = relativeX / rect.width;
                        const min = parseFloat(def.min);
                        const max = parseFloat(def.max);
                        let newVal = min + (percent * (max - min));
                        // Dynamic precision based on step
                        const step = parseFloat(def.step || 1);
                        newVal = Math.round(newVal / step) * step;
                        if (newVal < min) newVal = min;
                        if (newVal > max) newVal = max;
                        inp.value = newVal;
                        let actual = def.invert ? (max+min)-newVal : newVal; 
                        const decimals = (step.toString().split('.')[1] || '').length;
                        if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                        this.c.set(def.id, actual); 
                        const disp = document.getElementById(`val-${def.id}`); 
                        if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                    }
                }, { passive: false });
                inp.addEventListener('touchend', () => {
                    isTouching = false;
                    isHorizontalDrag = false;
                });
            }
            else if(def.type === 'color') { 
                const w = document.createElement('div'); 
                w.className = 'color-wrapper'; 
                inp = document.createElement('input'); 
                inp.type = 'color'; 
                inp.value = this.c.get(def.id); 
                inp.id = `in-${def.id}`; 
                inp.name = def.id; 
                inp.oninput = e => { 
                    this.c.state[def.id] = e.target.value; 
                    this.c.updateDerivedValues(); // Force derived update for live preview
                }; 
                inp.onchange = e => { this.c.set(def.id, e.target.value); }; // Commit and refresh
                w.appendChild(inp); row.appendChild(w); 
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`; 
                return row; 
            }
            else if(def.type === 'color_list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'color-list-wrapper';
                wrapper.id = `in-${def.id}`;
                this._renderColorList(wrapper, def);
                row.appendChild(wrapper);
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`;
                return row;
            }
            else if(def.type === 'keybinder') {
                const btn = document.createElement('button');
                // Initial text setup
                const rawKey = (this.c.get('keyBindings') || {})[def.id] || 'None';
                const initialDisplay = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
                btn.className = 'action-btn btn-info';
                btn.id = `btn-key-${def.id}`;
                btn.textContent = `${def.label}: [ ${initialDisplay} ]`;
                btn.onclick = () => {
                    this.isKeyBindingActive = true; 
                    btn.textContent = `${def.label}: [ Press Key... ]`;
                    btn.classList.remove('btn-info');
                    btn.classList.add('btn-warn');
                    // Focus trap to isolate input from global listeners
                    this.dom.keyTrap.focus();
                    const handler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        let newKey = e.key;
                        // Handle special keys
                        if (newKey === 'Backspace' || newKey === 'Delete') {
                            newKey = null;
                        } else if (newKey.length === 1) {
                            newKey = newKey.toLowerCase();
                        }
                        // Save config
                        try {
                            const bindings = { ...this.c.get('keyBindings') };
                            if (newKey) {
                                bindings[def.id] = newKey;
                            } else {
                                delete bindings[def.id];
                            }
                            this.c.set('keyBindings', bindings); // Triggers refresh() -> updateKeyBinderVisuals()
                        } catch (err) {
                            console.error("Failed to save keybinding:", err);
                            btn.textContent = "Error Saving";
                        }
                        // Cleanup
                        this.dom.keyTrap.blur();
                        this.isKeyBindingActive = false;
                        // Force immediate visual update just in case refresh is delayed
                        this.updateKeyBinderVisuals(def.id);
                    };
                    this.dom.keyTrap.addEventListener('keydown', handler, { once: true });
                };
                row.appendChild(btn);
                return row;
            }
            else if(def.type === 'checkbox') { 
                inp = document.createElement('input'); 
                inp.type = 'checkbox'; 
                inp.checked = this.c.get(def.id); 
                inp.onchange = e => { 
                    if(e.target.checked && def.warning) alert(def.warning);
                    this.c.set(def.id, e.target.checked); 
                }; 
                row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; 
            }
            else if(def.type === 'select') { inp = document.createElement('select'); (typeof def.options === 'function' ? def.options() : def.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(def.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(def.id, e.target.value); }
            else if(def.type === 'text') {
                inp = document.createElement('input');
                inp.type = 'text';
                const val = this.c.get(def.id);
                inp.value = def.transform ? def.transform(val) : (val || "");
                inp.onchange = e => {
                    const finalVal = def.parse ? def.parse(e.target.value) : e.target.value;
                    this.c.set(def.id, finalVal);
                };
            }
            row.appendChild(inp);
            if(def.id) { inp.id = `in-${def.id}`; inp.name = def.id; }
            if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`;
        }
        return row;
    }
    /**
     * Handles UI actions triggered by buttons or other interactive elements.
     * @param {string} action - The action identifier.
     */
    handleAction(action) {
        if(action === 'reset' && confirm('Reset all settings?')) this.c.reset();
        if(action === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts();
        if(action === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state, savedPresets:this.c.slots}, `matrix_conf_v${APP_VERSION}.json`);
        if(action === 'import') document.getElementById('importFile').click();
        if(action === 'importFont') document.getElementById('importFontFile').click();
        if(action === 'importShader') document.getElementById('importShaderFile').click();
        if(action === 'manageCharacters') this.charSelector.show();
        if(action === 'boot') { if(this.effects.trigger('BootSequence')) this.notifications.show('Boot Sequence Initiated', 'success'); else this.notifications.show('Boot Sequence Active...', 'info'); }
        if(action === 'crash') { if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger'); else this.notifications.show('Crash Sequence Active...', 'info'); }
        if(action === 'boot_crash_sequence') {
            if(this.effects.trigger('BootSequence')) {
                this.notifications.show('Boot Sequence Initiated', 'success');
                setTimeout(() => {
                    if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger');
                }, 4000);
            } else {
                this.notifications.show('Sequence Active...', 'info');
            }
        }
        if(action === 'pulse') { if(this.effects.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
        if(action === 'clearpulse') { if(this.effects.trigger('ClearPulse')) this.notifications.show('Clear Pulse Triggered', 'success'); else this.notifications.show('Clear Pulse active...', 'info'); }
        if(action === 'minipulse') { if(this.effects.trigger('MiniPulse')) this.notifications.show('Pulse Storm Triggered', 'success'); else this.notifications.show('Pulse Storm active...', 'info'); }
        if(action === 'quantizedPulse') { if(this.effects.trigger('QuantizedPulse')) this.notifications.show('Quantized Pulse Triggered', 'success'); else this.notifications.show('Quantized Pulse active...', 'info'); }
        if(action === 'quantizedAdd') { if(this.effects.trigger('QuantizedAdd')) this.notifications.show('Quantized Add Triggered', 'success'); else this.notifications.show('Quantized Add active...', 'info'); }
        if(action === 'quantizedRetract') { if(this.effects.trigger('QuantizedRetract')) this.notifications.show('Quantized Retract Triggered', 'success'); else this.notifications.show('Quantized Retract active...', 'info'); }
        if(action === 'quantizedClimb') { if(this.effects.trigger('QuantizedClimb')) this.notifications.show('Quantized Climb Triggered', 'success'); else this.notifications.show('Quantized Climb active...', 'info'); }
                if(action === 'quantizedZoom') { if(this.effects.trigger('QuantizedZoom')) this.notifications.show('Quantized Zoom Triggered', 'success'); else this.notifications.show('Quantized Zoom active...', 'info'); }
                if(action === 'QuantizedBlockGenerator') { if(this.effects.trigger('QuantizedBlockGenerator')) this.notifications.show('Quantized Block Generator Triggered', 'success'); else this.notifications.show('Quantized Block Generator already active...', 'info'); }
                if(action === 'dejavu') { if(this.effects.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
        if(action === 'superman') { if(this.effects.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
    }
    /**
     * Refreshes the UI to reflect current configuration settings.
     * @param {string} key - The specific configuration key to refresh, or 'ALL' to refresh all controls.
     */
    refresh(key, isRecursive = false) {
        try {
            if(key === 'ALL') { 
                this.defs.forEach(d => { if(d.id) this.refresh(d.id, true); }); 
                // Refresh Slot Names
                this.updateSlotNames();
                this.refresh('fontFamily', true); // Special refresh for font list
                this.dom.content.querySelectorAll('[data-dep]').forEach(row => {
                    try {
                        const depRule = JSON.parse(row.getAttribute('data-dep')); 
                        const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                        let conditionsMet = true;
                        for (let rule of rules) { 
                            let target = rule; 
                            let expected = true; 
                            if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                            let actualVal = this.c.get(target);
                            if (actualVal === 'true') actualVal = true;
                            if (actualVal === 'false') actualVal = false;
                            const actual = !!actualVal; 
                            if (actual !== expected) { conditionsMet = false; break; } 
                        }
                        if(conditionsMet) row.classList.remove('control-disabled'); 
                        else row.classList.add('control-disabled');
                    } catch(e) { console.warn("Error processing dependency row:", e); }
                });
                return; 
            }
            if (key === 'keyBindings') {
                this.defs.filter(d => d.type === 'keybinder').forEach(d => this.refresh(d.id));
                return;
            }
            if (key === 'debugTabEnabled') {
                this._setupTabs();
                return;
            }
                        if (key === 'fontFamily' || key === 'fontSettings') { // Now also refreshes on fontSettings changes
                            const sel = document.getElementById('in-fontFamily');
                            if(sel) { 
                                sel.innerHTML = ''; 
                                this._getFonts().forEach(o => { 
                                    const opt = document.createElement('option'); 
                                    opt.value = o.value; 
                                    opt.textContent = o.label; 
                                    if(o.custom) opt.className = 'custom-font-opt'; 
                                    if(this.c.get('fontFamily') === o.value) opt.selected = true; 
                                    sel.appendChild(opt); 
                                }); 
                            }
                            const list = document.getElementById('fontListUI'); 
                            if (list) this.updateFontList(list); 
                            // Update logo and favicon when font family or settings change, re-randomize char
                            const currentPrimaryColor = this.c.get('streamPalette')[0]; // Use primary palette color
                            const logo = document.getElementById('matrixLogo');
                            if (logo) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                logo.src = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 48, this.c.get('fontFamily'));
                            }
                            const favicon = document.getElementById('favicon');
                            if (favicon) {
                                const randomChar = Utils.getRandomKatakanaChar();
                                favicon.href = Utils.generateGlyphSVG(randomChar, currentPrimaryColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                            }
                            return;
                        }
                        // Removed the separate `if (key === 'streamColor')` block as its functionality
                        // is now handled by the 'streamPalette' block, and this 'fontFamily'/'fontSettings' block.
                        // ... the rest of the refresh method ...
                        if (key === 'customShader' || key === 'shaderEnabled' || key === 'ALL') {
                            const shaderNameDisplay = document.getElementById('in-currentShaderNameDisplay');
                if (shaderNameDisplay) {
                    let name = 'No shader loaded.';
                    const customShaderSource = this.c.get('customShader');
                    const shaderEnabled = this.c.get('shaderEnabled');
                    if (shaderEnabled && customShaderSource) {
                        // 1. Try to find a name metadata tag in the first 500 chars
                        // Matches "// Name: My Shader" or "// Shader: My Shader" case-insensitive
                        const nameMatch = customShaderSource.substring(0, 500).match(/^\s*\/\/\s*(?:Name|Shader|Title):\s*(.+)$/im);
                        if (nameMatch && nameMatch[1]) {
                            name = nameMatch[1].trim();
                        } 
                        // 2. Fallback: Check if it's standard code
                        else if (customShaderSource.trim().startsWith('precision')) {
                            name = 'Custom Shader (No Name)';
                        }
                        // 3. Fallback: If it doesn't look like code (maybe it really is a path?)
                        else if (customShaderSource.length < 200 && (customShaderSource.includes('/') || customShaderSource.includes('\\'))) {
                             const parts = customShaderSource.split(/[\/\\]/);
                             name = parts[parts.length - 1];
                        }
                        else {
                             name = 'Custom Shader';
                        }
                    } else if (shaderEnabled) {
                         name = 'Unnamed/Default Shader'; 
                    }
                    shaderNameDisplay.textContent = `Loaded: ${name}`;
                }
            }
            if (key === 'streamPalette') {
                 const palette = this.c.get('streamPalette');
                 const biasRow = document.getElementById('row-paletteBias');
                 if (biasRow) {
                     if (palette && palette.length > 1) {
                         biasRow.classList.remove('control-disabled');
                     } else {
                         biasRow.classList.add('control-disabled');
                     }
                 }
                 // Update UI Elements based on primary color
                 if (palette && palette.length > 0) {
                     const color = palette[0];
                     // Update Settings Wheel
                     const toggle = this.dom.toggle;
                     if (toggle) {
                         toggle.style.setProperty('--accent', color);
                         toggle.style.borderColor = color;
                         // toggle.style.color = color; // Removed to allow CSS hover override
                         toggle.style.boxShadow = `0 0 5px ${color}40`; // Subtle glow using hex alpha
                     }
                     // Update Logo & Favicon
                     const logo = document.getElementById('matrixLogo');
                     if (logo) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        logo.src = Utils.generateGlyphSVG(randomChar, color, 48, this.c.get('fontFamily'));
                     }
                     const favicon = document.getElementById('favicon');
                     if (favicon) {
                        const randomChar = Utils.getRandomKatakanaChar();
                        favicon.href = Utils.generateGlyphSVG(randomChar, color, 32, this.c.get('fontFamily'));
                     }
                 }
            }
            if (key === 'quantEditorEnabled' || key === 'ALL') {
                const enabled = this.c.get('quantEditorEnabled');
                console.log("UIManager: quantEditorEnabled refresh", enabled);
                // Force reload on user toggle to ensure clean state
                if (key === 'quantEditorEnabled' && !isRecursive) {
                     location.reload(); 
                     return; 
                }
                if (typeof QuantizedEffectEditor !== 'undefined') {
                    if (!this.quantEditor) {
                        this.quantEditor = new QuantizedEffectEditor(this.effects, this);
                    }
                    this.quantEditor.toggle(enabled);
                }
            }
            if (key === 'hideMenuIcon' || key === 'ALL') {
                const shouldHide = this.c.get('hideMenuIcon');
                const toggleBtn = this.dom.toggle;
                // Clear any existing listeners/timeouts
                if (this._menuIconTimeout) clearTimeout(this._menuIconTimeout);
                if (this._menuMouseMoveHandler) {
                    document.removeEventListener('mousemove', this._menuMouseMoveHandler);
                    this._menuMouseMoveHandler = null;
                }
                if (shouldHide) {
                    toggleBtn.style.transition = 'opacity 0.5s ease-in-out, transform 0.3s ease';
                    const showIcon = () => {
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.pointerEvents = 'auto';
                        clearTimeout(this._menuIconTimeout);
                        // Hide again after 1s of no activity near it? 
                        // Or just 1s after showing? The prompt says "hide itself after one second".
                        this._menuIconTimeout = setTimeout(() => {
                            // Only hide if panel is CLOSED
                            if (!this.dom.panel.classList.contains('open')) {
                                toggleBtn.style.opacity = '0';
                                toggleBtn.style.pointerEvents = 'none';
                            }
                        }, 1000);
                    };
                    // Initial hide after delay
                    showIcon(); 
                    // Hot-zone detection
                    this._menuMouseMoveHandler = (e) => {
                        // Top right corner hot-zone (100x100px)
                        const isHotZone = (e.clientX > window.innerWidth - 100) && (e.clientY < 100);
                        if (isHotZone || this.dom.panel.classList.contains('open')) {
                            showIcon();
                        }
                    };
                    document.addEventListener('mousemove', this._menuMouseMoveHandler);
                } else {
                    // Reset to always visible
                    toggleBtn.style.opacity = '1';
                    toggleBtn.style.pointerEvents = 'auto';
                }
            }
            if(key) {
                // Keybinder Refresh Logic
                if (document.getElementById(`btn-key-${key}`)) {
                    this.updateKeyBinderVisuals(key);
                }
                const inp = document.getElementById(`in-${key}`);
                if(inp) { 
                    const def = this.defs.find(d=>d.id===key); 
                    if(def) { 
                        const val = this.c.get(key); 
                        if(def.type === 'checkbox') inp.checked = val; 
                        else if(def.type === 'color_list') this._renderColorList(inp, def);
                        else if(def.type === 'range') { 
                            inp.value = def.invert ? (def.max+def.min)-val : val; 
                            const disp = document.getElementById(`val-${key}`); 
                            if(disp) {
                                let displayVal = val;
                                if (!def.transform && typeof val === 'number') {
                                    const step = def.step || 1;
                                    const decimals = (step.toString().split('.')[1] || '').length;
                                    displayVal = parseFloat(val.toFixed(decimals));
                                }
                                disp.textContent = def.transform ? def.transform(val) : displayVal + (def.unit || ''); 
                            }
                        } else if (def.type === 'text') {
                            inp.value = def.transform ? def.transform(val) : (val || "");
                        } else {
                            // Handle boolean values in select dropdowns correctly
                            inp.value = String(val);
                        }
                    } 
                }
            }
            // Update dependents
            this.dom.content.querySelectorAll(`[data-dep*="${key}"]`).forEach(row => {
                try {
                    const depRule = JSON.parse(row.getAttribute('data-dep')); 
                    const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                    let conditionsMet = true;
                    for (let rule of rules) { 
                        let target = rule; 
                        let expected = true; 
                        if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                        // Handle boolean vs string "true"/"false" mismatch
                        let actualVal = this.c.get(target);
                        if (actualVal === 'true') actualVal = true;
                        if (actualVal === 'false') actualVal = false;
                        const actual = !!actualVal; 
                        if (actual !== expected) { conditionsMet = false; break; } 
                    }
                    if(conditionsMet) row.classList.remove('control-disabled'); 
                    else row.classList.add('control-disabled');
                } catch(e) { console.warn("Error processing dependency row:", e); }
            });
        } catch(e) { console.warn("UI Refresh Error:", e); }
    }
}
// --- MatrixKernel.js ---
// =======================================================================
// MATRIX KERNEL
// =========================================================================
class MatrixKernel {
    constructor() {
        // Initialize core components
        this._initializeManagers();
        this._initializeEffects();
        // Frame handling and rendering variables
        this.frame = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.timestep = 1000 / 60;
        this._effectTimers = {}; // Initialize map for effect timers
        this._supermanTimer = 0; // Initialize Superman effect timer (will be managed in _effectTimers)
        this._lastResetReason = "Startup"; // Track last reset
        this._setupResizeListener();
        this._setupInputListener();
        // FPS tracking variables
        this.lastFrameTime = 0; // Tracks time of the previous frame
        this.fpsHistory = []; // Used for simple FPS smoothing
        this.fpsDisplayElement = null; // Holds reference to the HTML element
        // Configuration subscription for dynamic updates
        this._setupConfigSubscriptions();
        // Override console.error based on logErrors setting
        const originalError = console.error;
        console.error = (...args) => {
            if (this.config.state.logErrors) {
                originalError.apply(console, args);
            }
        };
    }
    async initAsync() {
        // Asynchronous initialization steps (Patterns are needed for editor too)
        await this._loadPatterns();
        // Detect Editor-Only Mode
        const params = new URLSearchParams(window.location.search);
        this.isEditorWindow = params.get('mode') === 'editor';
        if (this.isEditorWindow) {
            document.body.classList.add('editor-window-mode');
            // Hide simulation canvases
            const canvases = ['matrixCanvas', 'overlayCanvas'];
            canvases.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            // Minimal UI Init
            this.fontMgr = new FontManager(this.config, this.notifications);
            this.charSelector = new CharacterSelectorModal(this.config, this.fontMgr, this.notifications);
            this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications, this.charSelector);
            await this.fontMgr.init();
            // Force open Quantized Editor in standalone mode
            if (this.ui && typeof QuantizedEffectEditor !== 'undefined') {
                this.ui.quantEditor = new QuantizedEffectEditor(this.effectRegistry, this.ui);
                this.ui.quantEditor.isStandalone = true;
                this.ui.quantEditor.toggle(true);
            }
            window.addEventListener('beforeunload', () => {
                if (this.ui && this.ui.quantEditor) {
                    this.ui.quantEditor.channel.postMessage({ type: 'bye' });
                }
            });
            return;
        }
        // Standard Application initialization
        await this._initializeRendererAndUI();
        // Perform the initial resize setup and start the loop
        this._resize();
        requestAnimationFrame((time) => this._loop(time));
        this.fpsDisplayElement = document.getElementById('fps-counter');
        // Trigger Boot Sequence on startup if enabled
        if (this.config.get('bootSequenceEnabled')) {
            // Short delay to ensure everything is ready
            setTimeout(() => {
                this.effectRegistry.trigger('BootSequence');
            }, 100);
        }
    }
    /**
     * Loads external pattern data for effects.
     * @private
     */
    async _loadPatterns() {
        if (window.matrixPatterns) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = 'js/effects/QuantizedPatterns.js';
            script.onload = () => {
                if (this.config.state.logErrors) console.log("Patterns loaded successfully.");
                resolve();
            };
            script.onerror = () => {
                if (this.config.state.logErrors) console.warn("Failed to load patterns from js/effects/QuantizedPatterns.js");
                resolve(); // Resolve anyway to allow app to start
            };
            document.head.appendChild(script);
        });
    }
    /**
     * Initializes core managers (Notification, Config, Grid, Simulation, EffectRegistry).
     * @private
     */
    _initializeManagers() {
        this.config = new ConfigurationManager();
        this.config.clearShaderState(); // Ensure clean shader state on every load
        this.notifications = new NotificationManager(this.config);
        this.config.setNotificationManager(this.notifications);
        this.grid = new CellGrid(this.config);
        this.simulation = new SimulationSystem(this.grid, this.config);
        this.effectRegistry = new EffectRegistry(this.grid, this.config);
    }
    /**
     * Registers all active visual effects with the EffectRegistry.
     * @private
     */
    _initializeEffects() {
        const effects = [
            PulseEffect,
            ClearPulseEffect,
            MiniPulseEffect,
            DejaVuEffect,
            SupermanEffect,
            BootEffect,
            CrashEffect,
            QuantizedPulseEffect,
            QuantizedAddEffect,
            QuantizedRetractEffect,
            QuantizedClimbEffect,
            QuantizedZoomEffect,
            QuantizedBlockGeneration
        ];
        effects.forEach((EffectClass) => {
            if (EffectClass === CrashEffect || EffectClass === BootEffect) {
                this.effectRegistry.register(new EffectClass(this.grid, this.config, this.effectRegistry));
            } else {
                this.effectRegistry.register(new EffectClass(this.grid, this.config));
            }
        });
    }
    /**
     * Initializes the CanvasRenderer, FontManager, and UIManager.
     * @private
     */
    async _initializeRendererAndUI() {
        if (typeof WebGLRenderer !== 'undefined') {
             this.renderer = new WebGLRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
        } else {
             if (this.config.state.logErrors) console.error("WebGLRenderer not found. Application cannot start.");
             this.notifications.show("Critical Error: WebGL Renderer missing.", "error");
             return;
        }
        this.fontMgr = new FontManager(this.config, this.notifications);
        this.charSelector = new CharacterSelectorModal(this.config, this.fontMgr, this.notifications);
        this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications, this.charSelector);
        // Overlay Canvas Setup
        this.overlayCanvas = document.getElementById('overlayCanvas');
        if (this.overlayCanvas) {
            this.overlayCtx = this.overlayCanvas.getContext('2d');
        }
        // Subscribe to font changes to invalidate rendering caches
        this.fontMgr.subscribe(() => {
            if (this.renderer) {
                this.renderer.handleFontChange();
            }
        });
        // Initialize font manager and await its completion
        await this.fontMgr.init();
    }
    /**
     * Sets up a debounced window resize listener.
     * @private
     */
    _setupResizeListener() {
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this._resize(), 100); // Debounce resize events
        });
    }
    /**
     * Sets up the global input listener for key bindings.
     * @private
     */
    _setupInputListener() {
        window.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field or text area
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Ignore if in key binding mode (Double check flag)
            if (this.ui && this.ui.isKeyBindingActive) return;
            // Ignore if modifier keys are pressed (unless we want to support them later)
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            const bindings = this.config.state.keyBindings || {};
            const key = e.key.toLowerCase();
            // Master Switch for Keybinds
            if (!this.config.state.enableKeybinds) return;
            let matched = false;
            for (const [action, boundKey] of Object.entries(bindings)) {
                if (boundKey && boundKey.toLowerCase() === key) {
                    matched = true;
                    if (action === 'ToggleUI') {
                        this.ui.togglePanel();
                    } else if (action === 'BootSequence' || action === 'CrashSequence') { 
                        this.effectRegistry.trigger(action, true);
                        this.notifications.show(`${action} Triggered`, 'success');
                    }
                    else {
                        // Compatibility for renamed effect
                        let targetAction = action;
                        if (action === 'QuantizedGenerateV2' || action === 'quantizedGenerateV2') {
                            targetAction = 'QuantizedBlockGenerator';
                        }
                        // Block quantized effects if editor is active
                        const isQuantized = targetAction.startsWith('Quantized');
                        const editorActive = this.ui && this.ui.quantEditor && this.ui.quantEditor.active;
                        if (!(isQuantized && editorActive)) {
                            // Always force execution via keybind, overriding "Automatic Enabled" toggles
                            if (this.effectRegistry.trigger(targetAction, true)) {
                                const label = targetAction.replace(/([A-Z])/g, ' $1').trim();
                                this.notifications.show(`${label} Triggered`, 'success');
                            }
                        }
                    }
                }
            }
            if (matched) e.preventDefault();
        });
    }
    /**
     * Sets up subscriptions to configuration changes that trigger UI or rendering updates.
     * @private
     */
    _setupConfigSubscriptions() {
        const resizeTriggers = new Set([
            'resolution',
            'stretchX',
            'stretchY',
            'fontSize',
            'horizontalSpacingFactor',
            'verticalSpacingFactor'
        ]);
        const smoothingTriggers = new Set([
            'smoothingEnabled',
            'smoothingAmount'
        ]);
        const atlasTriggers = new Set([
            'fontWeight',
            'italicEnabled',
            'tracerSizeIncrease',
            'tracerGlow',
            'overlapColor',
            'streamPalette',
            'tracerColor'
        ]);
        const speedTriggers = new Set([
            'streamSpeed',
            'desyncIntensity'
        ]);
        this.config.subscribe((key) => {
            // Resize the canvas and grid on resolution-related changes
            if (resizeTriggers.has(key) || key === 'ALL') {
                this._resize();
            }
            // Recalculate stream speeds when timing settings change
            if ((speedTriggers.has(key) || key === 'ALL') && this.simulation && this.simulation.streamManager) {
                this.simulation.streamManager.recalculateSpeeds();
            }
            // Update renderer when smoothing settings change
            if (smoothingTriggers.has(key)) {
                this.renderer.updateSmoothing();
            }
            // Update Atlas if appearance changes (WebGL optimization)
            if ((atlasTriggers.has(key) || key === 'ALL') && this.renderer && this.renderer.handleAppearanceChange) {
                this.renderer.handleAppearanceChange();
            }
            const autoEffects = [
                { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
                { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
                { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
                { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
                { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
                { enabledKey: 'quantizedPulseEnabled', frequencyKey: 'quantizedPulseFrequencySeconds', effectName: 'QuantizedPulse' },
                { enabledKey: 'quantizedAddEnabled', frequencyKey: 'quantizedAddFrequencySeconds', effectName: 'QuantizedAdd' },
                { enabledKey: 'quantizedRetractEnabled', frequencyKey: 'quantizedRetractFrequencySeconds', effectName: 'QuantizedRetract' },
                { enabledKey: 'quantizedClimbEnabled', frequencyKey: 'quantizedClimbFrequencySeconds', effectName: 'QuantizedClimb' },
                { enabledKey: 'quantizedZoomEnabled', frequencyKey: 'quantizedZoomFrequencySeconds', effectName: 'QuantizedZoom' },
                { enabledKey: 'quantizedGenerateV2Enabled', frequencyKey: 'quantizedGenerateV2FrequencySeconds', effectName: 'QuantizedBlockGenerator' },
                { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
            ];
            autoEffects.forEach(effect => {
                if ((key === effect.enabledKey && this.config.state[effect.enabledKey]) || key === 'ALL') {
                    const minFrequencyFrames = this._getMinFrequencyFrames(effect.effectName, effect.frequencyKey);
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                } else if (key === effect.enabledKey && !this.config.state[effect.enabledKey]) {
                    // If an effect is specifically disabled, remove its timer
                    delete this._effectTimers[effect.effectName];
                }
            });
        });
    }
    /**
     * Calculates the minimum frequency in frames, handling the "Random" (500s) special case for Quantized effects.
     * @private
     * @param {string} effectName - The name of the effect.
     * @param {string} frequencyKey - The configuration key for the frequency.
     * @returns {number} The calculated frequency in frames.
     */
    _getMinFrequencyFrames(effectName, frequencyKey) {
        let seconds = this.config.state[frequencyKey];
        if (seconds === 500) {
            seconds = Utils.randomInt(50, 500);
        }
        return seconds * 60;
    }
    /**
     * Resizes the grid and renderer dimensions based on current window size and configuration.
     * @private
     */
    _resize() {
        if (this.config.state.logErrors) console.log("[MatrixKernel] Resize Event Triggered.");
        this._lastResetReason = "Resize: " + new Date().toLocaleTimeString();
        const s = this.config.state;
        const d = this.config.derived;
        // 1. Calculate Logical Dimensions (accounting for Stretch)
        const logicalW = window.innerWidth / s.stretchX;
        const logicalH = window.innerHeight / s.stretchY;
        // 2. Snap Logic: Adjust Derived Cell Size to fit Width perfectly
        // Calculate target Cell Width based on User Settings
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const targetCellW = s.fontSize * hFactor;
        // Calculate number of columns that fit closest to logical width
        // Ensure at least 1 column
        const cols = Math.max(1, Math.round(logicalW / targetCellW));
        // Calculate Exact Snapped Cell Width (This ensures Width / CellWidth = Integer)
        const snappedCellW = logicalW / cols;
        // Calculate Scale Ratio to maintain Aspect Ratio
        const ratio = snappedCellW / targetCellW;
        // Update Derived Config (Runtime Override)
        // This ensures Grid and Renderer use the snapped values
        d.cellWidth = snappedCellW;
        // Adjust Cell Height to maintain Font Aspect Ratio
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const targetCellH = s.fontSize * vFactor;
        d.cellHeight = targetCellH * ratio;
        // 3. Resize Grid
        this.grid.resize(logicalW, logicalH);
        this.renderer.resize();
        if (this.overlayCanvas) {
            this.overlayCanvas.width = window.innerWidth;
            this.overlayCanvas.height = window.innerHeight;
        }
    }
    /**
     * The main animation loop, handling updates and rendering.
     * Uses a fixed timestep for consistent simulation speed.
     * @private
     * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
     */
    _loop(time) {
    // 1. Calculate Delta and FPS
    const now = performance.now();
    const deltaFPS = now - this.lastFrameTime;
    this.lastFrameTime = now;
    if (deltaFPS > 0 && this.config.state.showFpsCounter) {
        const fps = 1000 / deltaFPS;
        // Simple 30-frame smoothing
        this.fpsHistory.push(fps);
        if (this.fpsHistory.length > 30) {
            this.fpsHistory.shift();
        }
        const smoothedFps = this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            // 2. Update Display
            if (this.fpsDisplayElement) {
                let text = `FPS: ${Math.round(smoothedFps)}`;
                if (this.config.state.debugEnabled) {
                     if (performance.memory) {
                         const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                         text += ` | Mem: ${used}MB`;
                     }
                     if (this.grid && this.grid.activeIndices) {
                         const cellCount = this.grid.activeIndices.size;
                         const sm = this.simulation.streamManager;
                         // Safety check for streamManager
                         const streams = sm ? sm.activeStreams : [];
                         const tracers = streams.filter(s => !s.isEraser && !s.isUpward).length;
                         const erasers = streams.filter(s => s.isEraser).length;
                         let rotators = 0;
                         for (const idx of this.grid.activeIndices) {
                             if ((this.grid.types[idx] & CELL_TYPE_MASK) === CELL_TYPE.ROTATOR) rotators++;
                         }
                         const shimmers = this.grid.complexStyles.size;
                         text += ` | Cells: ${cellCount}`;
                         text += ` | Tracers: ${tracers}`;
                         text += ` | Erasers: ${erasers}`;
                         text += ` | Rotators: ${rotators}`;
                         text += ` | Shimmers: ${shimmers}`;
                         // Debug: QuantizedBlockGenerator Internal Lines
                         const qGenV2 = this.effectRegistry.get('QuantizedBlockGenerator');
                         if (qGenV2 && qGenV2.active && qGenV2.debugInternalCount !== undefined) {
                             text += ` | IntLines: ${qGenV2.debugInternalCount}`;
                         }
                         text += ` | Reset: ${this._lastResetReason}`;
                     }
                }
                this.fpsDisplayElement.textContent = text;
                this.fpsDisplayElement.style.display = 'block';
            }
        } else if (this.fpsDisplayElement) {
            // Hide the counter if the setting is disabled
            this.fpsDisplayElement.style.display = 'none';
        }
        // Start main rendering loop
        if (!this.lastTime) this.lastTime = time;
        const delta = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += delta;
        while (this.accumulator >= this.timestep) {
            this._updateFrame();
            this.accumulator -= this.timestep;
        }
        this.renderer.render(this.frame);
        // Render Overlay Effects
        if (this.overlayCtx) {
            this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
            this.effectRegistry.render(this.overlayCtx, this.config.derived);
        }
        requestAnimationFrame((nextTime) => this._loop(nextTime));
    }
    /**
     * Updates the simulation logic for a single frame.
     * @private
     */
    _updateFrame() {
        this.frame++;
        this.effectRegistry.update();
        this.simulation.update(this.frame);
        const autoEffects = [
            { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
            { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
            { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
            { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
            { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
            { enabledKey: 'quantizedPulseEnabled', frequencyKey: 'quantizedPulseFrequencySeconds', effectName: 'QuantizedPulse' },
            { enabledKey: 'quantizedAddEnabled', frequencyKey: 'quantizedAddFrequencySeconds', effectName: 'QuantizedAdd' },
            { enabledKey: 'quantizedRetractEnabled', frequencyKey: 'quantizedRetractFrequencySeconds', effectName: 'QuantizedRetract' },
            { enabledKey: 'quantizedClimbEnabled', frequencyKey: 'quantizedClimbFrequencySeconds', effectName: 'QuantizedClimb' },
            { enabledKey: 'quantizedZoomEnabled', frequencyKey: 'quantizedZoomFrequencySeconds', effectName: 'QuantizedZoom' },
            { enabledKey: 'quantizedGenerateV2Enabled', frequencyKey: 'quantizedGenerateV2FrequencySeconds', effectName: 'QuantizedBlockGenerator' },
            { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
        ];
        const isEditorActive = this.config.get('quantEditorEnabled') === true;
        autoEffects.forEach(effect => {
            if (this.config.state[effect.enabledKey]) {
                if (!this._effectTimers[effect.effectName]) {
                    // Initialize timer with randomization if not already set
                    const minFrequencyFrames = this._getMinFrequencyFrames(effect.effectName, effect.frequencyKey);
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
                if (!isEditorActive) {
                    this._effectTimers[effect.effectName]--;
                    if (this._effectTimers[effect.effectName] <= 0) {
                        this.effectRegistry.trigger(effect.effectName);
                        // Reset timer with randomization
                        const minFrequencyFrames = this._getMinFrequencyFrames(effect.effectName, effect.frequencyKey);
                        const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5);
                        this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                    }
                }
            } else {
                // If effect is disabled, ensure its timer is reset or cleared
                if (this._effectTimers[effect.effectName]) {
                    delete this._effectTimers[effect.effectName];
                }
            }
        });
    }
}
// Initialize the MatrixKernel on DOMContentLoaded
window.addEventListener('DOMContentLoaded', async () => {
    const kernel = new MatrixKernel();
    // Expose kernel and config globally for debugging/console access
    window.matrix = kernel;
    window.config = kernel.config;
    await kernel.initAsync();
    kernel.lastFrameTime = performance.now(); // Set initial time
});
// --- Patch: Integrate Embedded Assets ---
(function() {
    if (typeof ConfigurationManager !== 'undefined') {
        const orig = ConfigurationManager.prototype._loadSlots;
        ConfigurationManager.prototype._loadSlots = function() {
            let local = null; try { local = orig.call(this); } catch(e) {}
            if (local && local.length > 0 && local[0].name) return local;
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.presets) {
                for (const k in __EMBEDDED_ASSETS__.presets) {
                    const p = __EMBEDDED_ASSETS__.presets[k];
                    if (p && p.savedPresets) return p.savedPresets;
                }
            }
            return local || [];
        };
    }
    if (typeof FontManager !== 'undefined') {
        const orig = FontManager.prototype.init;
        FontManager.prototype.init = async function() {
            await orig.call(this);
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.fonts) {
                for (const [n, d] of Object.entries(__EMBEDDED_ASSETS__.fonts)) {
                    const fam = n.split('.')[0].replace(/-/g, ' ');
                    if (this.loadedFonts.some(f => f.name === fam)) continue;
                    const ok = await this._registerFontFace({ name: fam, sourceUrl: d, formatHint: n.endsWith('woff2')?"format('woff2')":"format('truetype')", canvasPx: 20 });
                    if (ok) this.loadedFonts.push({ name: fam, display: fam, isEmbedded: true });
                }
                this._notify();
            }
        };
    }
    if (typeof PostProcessor !== 'undefined') {
        const orig = PostProcessor.prototype.compileShader;
        PostProcessor.prototype.compileShader = function(src) {
            if (typeof __EMBEDDED_ASSETS__ !== 'undefined' && __EMBEDDED_ASSETS__.shaders && __EMBEDDED_ASSETS__.shaders[src]) {
                src = __EMBEDDED_ASSETS__.shaders[src];
            }
            return orig.call(this, src);
        };
    }
})();
</script>
    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>