<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
:root {
    --bg-color: #000;
    --panel-bg: rgba(10, 12, 16, 0.96);
    --panel-border: rgba(34, 197, 94, 0.3);
    --text-main: #4ade80;
    --text-muted: #86efac;
    --accent: #22c55e;
    --accent-glow: rgba(34, 197, 94, 0.4);
    --danger: #ef4444;
    --info: #3b82f6; /* Preserved from existing */
    --warn: #f59e0b; /* Preserved from existing */
    --safe-top: env(safe-area-inset-top, 20px);
    --safe-right: env(safe-area-inset-right, 20px);
}
        * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        html, body {
    height: 100%;
    font-family: 'Segoe UI', 'Roboto', monospace;
    background-color: var(--bg-color);
    overscroll-behavior: none;
    overflow: hidden; /* Retained from existing style */
}
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; transform: translateZ(0); -webkit-transform: translateZ(0); }
        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }
        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }
        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }
        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }
        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        #tabTrack { display: inline-flex; width: max-content; }
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }
        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }
        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }
        .accordion-subheader {
            margin-top: 0.75rem; margin-bottom: 0.2rem;
            font-size: 0.85rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 3px;
            padding-left: 0.25rem;
        }
        .info-description {
            font-size: 1.0rem;
            color: var(--text-muted);
            padding: 0.5rem 0.25rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .faq-item {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        .faq-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .faq-question {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }
        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}
/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1.5rem;
    border-radius: 6px;
    margin-top: 1.5rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
    text-align: center;
    margin-bottom: 0.5rem;
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; margin-right: 10px; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: 25%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px; margin-right: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }
        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 10000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }
        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }
        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
        input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }
        /* Color List Styling */
        .color-list-wrapper { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; width: 100%; margin-top: 8px; }
        .color-list-item { position: relative; display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; }
        .color-list-item input[type="color"] { width: 48px; height: 48px; border-width: 2px; }
        .btn-icon-remove {
            position: absolute; top: -6px; right: -6px;
            width: 20px; height: 20px; border-radius: 50%;
            background: #ef4444; color: white; border: 1px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; cursor: pointer; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            line-height: 1; padding-bottom: 2px;
        }
        .btn-icon-add {
            width: 48px; height: 48px; border-radius: 50%;
            border: 2px dashed var(--accent);
            background: rgba(34, 197, 94, 0.1);
            color: var(--accent);
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            line-height: 1; padding-bottom: 3px;
        }
        .btn-icon-add:hover { background: rgba(34, 197, 94, 0.3); transform: scale(1.05); }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }
        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }
        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }
        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        #menuToggle {
    position: fixed;
    top: max(0.75em, var(--safe-top));
    right: max(1.2em, var(--safe-right));
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--panel-border);
    background: rgba(10, 12, 16, 0.6);
    color: var(--text-main);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 30;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px); /* Retained from existing style */
    cursor: pointer; /* Retained from existing style */
}
#menuToggle:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 20px var(--accent);
    transform: rotate(90deg);
}
        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
</style>
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E">
</head>
<body>
    <!-- Primary Canvas for Matrix Animation -->
    <canvas id="matrixCanvas" aria-label="Matrix Digital Rain Animation"></canvas>
    <!-- Hidden Bloom Canvas for Layer Effects -->
    <canvas id="bloomCanvas" hidden aria-hidden="true"></canvas>
    <!-- Toggle Button for Opening Settings Menu -->
    <button id="menuToggle" aria-controls="settingsPanel" aria-expanded="false" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03 .66.07 .98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"></path>
        </svg>
    </button>
    <!-- Input for Importing Files -->
    <input type="file" id="importFile" accept=".json" hidden aria-label="Import JSON Configuration" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" hidden aria-label="Import Font Files" />
    <!-- Settings Panel -->
    <aside id="settingsPanel" role="dialog" aria-hidden="true">
        <header id="panelHeader" role="banner">
            <h2 class="panel-title">Settings</h2>
        </header>
        <!-- Navigation Tabs -->
        <nav id="navTabs" role="tablist" aria-label="Settings Navigation"></nav>
        <!-- Content Area -->
        <main id="contentArea">
            <!-- Dynamic content will populate through scripts -->
        </main>
        <!-- Panel Footer -->
        <footer id="panelFooter">
            <p id="globalStatus" class="status-msg"></p>
        </footer>
    </aside>
    <script>
// --- Utils.js ---
const APP_VERSION = "7.4"; // Retained current version
// =========================================================================
// 1. CORE UTILITIES / CONSTANTS
// =========================================================================
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a 6-character hex color code (e.g., "#RRGGBB") to an { r, g, b } object format.
     * @param {string} hex - The hex color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (hex) => {
        if (typeof hex !== "string" || !/^#?([A-Fa-f0-9]{6})$/.test(hex)) {
            // Default to a valid fallback RGB value
            return { r: 0, g: 255, b: 0 }; // Default green
        }
        const value = parseInt(hex.replace(/^#/, ''), 16);
        return {
            r: (value >> 16) & 0xFF,
            g: (value >> 8) & 0xFF,
            b: value & 0xFF
        };
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    /**
     * Converts RGB {r, g, b} to HSL {h, s, l}.
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @returns {{h: number, s: number, l: number}} HSL values.
     */
    rgbToHsl: (r, g, b) => {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h *= 60;
        }
        return { h, s: s * 100, l: l * 100 };
    },
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|⽇゠ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲンワヲン',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: 'ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲン',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Returns a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3
};
    // =========================================================================
    // 1.1 NOTIFICATION SYSTEM 
    // =========================================================================
// --- ConfigurationManager.js ---
class ConfigurationManager {
    constructor() {
        this.storageKey = 'matrix_config_v7.4';
        this.slotsKey = 'matrix_slots_v7.4';
        this.defaults = this._initializeDefaults();
        this.state = { ...this.defaults };
        this.derived = {};
        this.slots = this._loadSlots();
        this.subscribers = [];
        this._loadState();
        this.updateDerivedValues();
    }
    // ====================
    // Initialization Helpers
    // ====================
    /**
     * Initializes the default configuration settings.
     * @private
     * @returns {Object} An object containing all default configuration properties.
     */
    _initializeDefaults() {
        return {
            // --- GLOBAL ---
            streamColor: "#65d778",
            streamPalette: ["#65d778"],
            paletteBias: 0.0,
            tracerColor: "#d9f2f2",
            fontSize: 24,
            streamSpeed: 16,
            releaseInterval: 4,
            resolution: 1,
            enableGlyphAtlas: true,
            smoothingEnabled: true,
            smoothingAmount: 0.5,
            // --- APPEARANCE ---
            fontFamily: "MatrixEmbedded",
            fontWeight: "normal",
            italicEnabled: false,
            mirrorEnabled: false,
            variableBrightnessEnabled: true,
            brightnessVariance: 20,
            // Overlap / Imposition Layer
            overlapEnabled: false,
            overlapColor: "#FFD700",
            overlapDensity: 0.5,
            overlapTarget: "stream",
            dissolveEnabled: true,
            dissolveMinSize: 18,
            deteriorationEnabled: true,
            deteriorationStrength: 4,
            enableBloom: true,
            bloomStrength: 4,
            bloomOpacity: 0.45,
            tracerGlow: 6,
            clearAlpha: 0.8,
            horizontalSpacingFactor: 0.7,
            verticalSpacingFactor: 1,
            fontOffsetX: 0,
            fontOffsetY: 0,
            stretchX: 1,
            stretchY: 1.2,
            // --- BEHAVIOR ---
            ttlMinSeconds: 1,
            ttlMaxSeconds: 8,
            decayFadeDurationFrames: 13,
            streamSpawnCount: 5,
            eraserSpawnCount: 5,
            minStreamGap: 10,
            minEraserGap: 15,
            holeRate: 0.1,
            tracerAttackFrames: 3,
            tracerHoldFrames: 0,
            tracerReleaseFrames: 5,
            invertedTracerEnabled: true,
            invertedTracerChance: 0.1,
            rotatorEnabled: true,
            rotatorChance: 0.13,
            rotatorSyncToTracer: true,
            rotatorSyncMultiplier: 0.5,
            rotatorCycleFactor: 11,
            rotatorCrossfadeFrames: 6,
            // --- FX ---
            pulseEnabled: true,
            pulseFrequencySeconds: 220,
            pulseDurationSeconds: 1.8,
            pulsePreserveSpaces: true,
            pulseIgnoreTracers: true,
            pulseDimming: 0.2,
            pulseBlend: false,
            pulseWidth: 130,
            pulseRandomPosition: true,
            pulseInstantStart: false,
            pulseCircular: false,
            clearPulseEnabled: true,
            clearPulseFrequencySeconds: 195,
            clearPulseDurationSeconds: 1,
            clearPulsePreserveSpaces: true,
            clearPulseBlend: false,
            clearPulseWidth: 280,
            clearPulseRandomPosition: true,
            clearPulseInstantStart: false,
            clearPulseCircular: false,
            miniPulseEnabled: true,
            miniPulseFrequencySeconds: 450,
            miniPulseDurationSeconds: 5,
            miniPulsePreserveSpaces: true,
            miniPulseThickness: 100,
            miniPulseSpawnChance: 0.06,
            miniPulseSpeed: 16,
            miniPulseSize: 360,
            dejaVuEnabled: true,
            dejaVuFrequencySeconds: 350,
            dejaVuDurationSeconds: 5,
            dejaVuMinRectHeight: 1,
            dejaVuMaxRectHeight: 10,
            dejaVuHoleBrightness: 0.02,
            dejaVuRandomizeColors: false,
            dejaVuIntensity: 0.1,
            dejaVuBarDurationFrames: 28,
            dejaVuVarianceFrames: 43,
            supermanEnabled: true,
            supermanFrequencySeconds: 240,
            supermanDurationSeconds: 6,
            supermanIncludeColors: true,
            supermanFadeSpeed: 6,
            supermanGlow: 4,
            supermanBoltThickness: 5,
            supermanFlickerRate: 2,
            supermanWidth: 4,
            supermanSpawnSpeed: 69,
            starPowerEnabled: false,
            starPowerFreq: 100,
            starPowerRainbowMode: "char",
            starPowerSaturation: 100,
            starPowerIntensity: 51,
            starPowerGlitter: false,
            starPowerColorCycle: true,
            starPowerCycleSpeed: 5,
            rainbowStreamEnabled: false,
            rainbowStreamChance: 1,
            rainbowStreamIntensity: 50,
            firewallEnabled: true,
            firewallFrequencySeconds: 150,
            firewallRandomColorEnabled: true,
            firewallColor: "#00ff00",
            firewallReverseDurationFrames: 20,
            firewallEraseDurationFrames: 50,
            // Properties not directly exposed in UI but used in defaults.json or internally
            deteriorationType: "ghost",
            tracerSizeIncrease: 1,
            supermanProb: 4,
            dejaVuAutoMode: true,
            pulseDelayFrames: 60,
            clearPulseIgnoreTracers: true, // Not exposed in UI
            clearPulseCircular: false,
            clearPulseBlend: false,
            clearPulseInstantStart: false
        };
    }
    /**
     * Loads configuration slots from local storage.
     * @private
     * @returns {Array<Object>} An array of slot data.
     */
    _loadSlots() {
        try {
            const storedSlots = localStorage.getItem(this.slotsKey);
            if (storedSlots) {
                return JSON.parse(storedSlots);
            }
        } catch (e) {
            console.warn('Failed to load slots:', e);
        }
        // Default slots if not found or error occurs
        return Array(3).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null }));
    }
    /**
     * Saves configuration slots to local storage.
     */
    saveSlots() {
        try {
            localStorage.setItem(this.slotsKey, JSON.stringify(this.slots));
        } catch (e) {
            console.warn('Failed to save slots:', e);
        }
    }
    /**
     * Loads the application state from local storage.
     * @private
     */
    _loadState() {
        try {
            const storedState = localStorage.getItem(this.storageKey);
            if (storedState) {
                const parsed = JSON.parse(storedState);
                delete parsed.customFonts; // Remove unsupported keys if present
                this.state = { ...this.defaults, ...parsed };
                // Migration: Ensure streamPalette exists
                if (!this.state.streamPalette) {
                    this.state.streamPalette = [this.state.streamColor];
                }
            }
        } catch (e) {
            console.warn('Failed to load configuration:', e);
        }
    }
    /**
     * Saves the current application state to local storage.
     */
    save() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.state));
        } catch (e) {
            console.warn('Failed to save configuration:', e);
        }
    }
    /**
     * Retrieves the value of a specific configuration key.
     * @param {string} key - The key of the configuration setting.
     * @returns {*} The value of the configuration setting.
     */
    get(key) {
        return this.state[key];
    }
    /**
     * Sets the value of a configuration key and triggers updates.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The new value for the setting.
     */
    set(key, value) {
        if (this.state[key] === value) return; // Skip if no change in value
        this.state[key] = value;
        // Maintain consistency between related properties
        if (key === 'streamMinLength') {
            this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
        } else if (key === 'streamMaxLength') {
            this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
        }
        this.updateDerivedValues();
        this.save();
        this.notify(key);
    }
    /**
     * Resets the application state to its default values.
     */
    reset() {
        this.state = { ...this.defaults };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
    }
    /**
     * Saves the current application state to a specific slot.
     * @param {number} index - The index of the slot (0-2).
     */
    saveToSlot(index) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index] = {
                name: this.slots[index].name,
                data: JSON.parse(JSON.stringify(this.state)) // Deep clone state
            };
            this.saveSlots();
        } else {
            console.warn(`Attempted to save to non-existent slot index: ${index}`);
        }
    }
    /**
     * Loads the application state from a specific slot.
     * @param {number} index - The index of the slot (0-2).
     * @returns {boolean} True if the state was loaded successfully, false otherwise.
     */
    loadFromSlot(index) {
        if (!this.slots[index]?.data) return false; // Use optional chaining for safety
        this.state = { ...this.defaults, ...this.slots[index].data };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
        return true;
    }
    /**
     * Renames a specific configuration slot.
     * @param {number} index - The index of the slot (0-2).
     * @param {string} name - The new name for the slot.
     */
    renameSlot(index, name) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index].name = name;
            this.saveSlots();
        } else {
            console.warn(`Attempted to rename non-existent slot index: ${index}`);
        }
    }
    /**
     * Subscribes a callback function to configuration changes.
     * @param {Function} callback - The function to call when configuration changes.
     */
    subscribe(callback) {
        if (typeof callback === "function") {
            this.subscribers.push(callback);
        }
    }
    /**
     * Notifies all subscribed listeners about a configuration change.
     * @param {string} key - The key of the changed configuration setting.
     */
    notify(key) {
        this.subscribers.forEach((callback) => callback(key, this.state));
    }
    /**
     * Updates all derived configuration values based on the current state.
     * These are values calculated from base settings for performance or convenience.
     */
    updateDerivedValues() {
        const s = this.state;
        const cycleDuration = 21 - s.streamSpeed;
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const rotatorCycleFrames = s.rotatorSyncToTracer
            ? Math.max(1, Math.floor(cycleDuration / s.rotatorSyncMultiplier))
            : Math.max(10, Math.round(60 - s.rotatorCycleFactor * 2.5));
        this.derived = {
            cycleDuration,
            safeAttack: Math.min(Math.max(1, s.tracerAttackFrames), cycleDuration),
            safeRelease: Math.min(s.tracerReleaseFrames, cycleDuration),
            holdFrames: Math.max(0, s.tracerHoldFrames),
            maxState: cycleDuration + Math.max(0, s.tracerHoldFrames) + cycleDuration,
            rotatorCycleFrames,
            cellWidth: s.fontSize * hFactor,
            cellHeight: s.fontSize * vFactor,
            varianceMin: 1.0 - s.brightnessVariance / 100,
            streamRgb: Utils.hexToRgb(s.streamColor),
            tracerRgb: Utils.hexToRgb(s.tracerColor),
            streamColorStr: Utils.createRGBString(Utils.hexToRgb(s.streamColor)),
            paletteRgbs: (s.streamPalette || [s.streamColor]).map(c => Utils.hexToRgb(c)),
            paletteColorsStr: (s.streamPalette || [s.streamColor]).map(c => Utils.createRGBString(Utils.hexToRgb(c))),
            tracerColorStr: Utils.createRGBString(Utils.hexToRgb(s.tracerColor)),
            fontBaseStr: `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
        };
    }
}
    // =========================================================================
    // 3.0 MATRIX GRID
    // =========================================================================
// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=";
    // =========================================================================
    // 4.0 STREAM MODE
    // =========================================================================
// --- MatrixGrid.js ---
class MatrixGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // Grid storage and state tracking
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.chars = null;
        this.types = null;
        this.alphas = null;
        this.decays = null;
        this.ages = null;
        this.brightness = null;
        this.rotatorProg = null;
        // Auxiliary storage
        this.complexStyles = new Map(); // Tracks complex character styling
        this.nextChars = new Map(); // Tracks characters for transitions
        this.noiseDirty = true;
    }
    /**
     * Resizes the grid based on new width and height, reallocating arrays only if dimensions change.
     * @param {number} width - The new width of the grid area.
     * @param {number} height - The new height of the grid area.
     */
    resize(width, height) {
        const d = this.config.derived;
        const newCols = Math.max(1, Math.floor(width / d.cellWidth));
        const newRows = Math.max(1, Math.floor(height / d.cellHeight));
        if (newCols !== this.cols || newRows !== this.rows) {
            this._resizeGrid(newCols, newRows);
        }
    }
    /**
     * Gets the 1D array index from 2D coordinates (x, y).
     * @param {number} x - The column index.
     * @param {number} y - The row index.
     * @returns {number} The 1D index, or -1 if out of bounds.
     */
    getIndex(x, y) {
        if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) {
            return -1; // Out of bounds
        }
        return y * this.cols + x;
    }
    /**
     * Sets a character at the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @param {string} charStr - The character string to set.
     */
    setChar(idx, charStr) {
        if (typeof charStr === "string" && charStr.length > 0) {
            this.chars[idx] = charStr.charCodeAt(0);
        }
    }
    /**
     * Gets the character from the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @returns {string} The character at the index.
     */
    getChar(idx) {
        // Ensure chars array is not null before accessing
        if (!this.chars || idx < 0 || idx >= this.chars.length) return '';
        return String.fromCharCode(this.chars[idx]);
    }
    /**
     * Reinitializes all grid arrays and dimensions.
     * @private
     * @param {number} newCols - The new number of columns.
     * @param {number} newRows - The new number of rows.
     */
    _resizeGrid(newCols, newRows) {
        const totalCells = newCols * newRows;
        // Reinitialize arrays with new size
        this.chars = new Uint16Array(totalCells);
        this.types = new Uint8Array(totalCells);
        this.alphas = new Float32Array(totalCells);
        this.decays = new Uint8Array(totalCells);
        this.ages = new Int32Array(totalCells);
        this.brightness = new Float32Array(totalCells);
        this.rotatorProg = new Float32Array(totalCells);
        // Color Palette Index (0-2)
        this.paletteIndices = new Uint8Array(totalCells);
        // Imposition Layer (Overlap)
        this.overlapChars = new Uint16Array(totalCells);
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.nextChars = new Map();
        this.nextOverlapChars = new Map();
        this.noiseDirty = true;
        // Update grid dimensions
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- FontData.js ---
// --- EffectRegistry.js ---
class EffectRegistry {
            constructor(grid, config) { this.grid = grid; this.config = config; this.effects = []; }
            register(effect) { this.effects.push(effect); }
            trigger(name) { const fx = this.effects.find(e => e.name === name); if(fx) return fx.trigger(); return false; }
            update() { this.effects.forEach(e => e.update()); }
            getOverride(i) { for(const fx of this.effects) { const o = fx.getOverride(i); if(o) return o; } return null; }
            hasActiveEffects() { return this.effects.some(e => e.active); }
        }
        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; }
            trigger() { return false; }
            update() {}
            getOverride(i) { return null; }
        }
// --- ClearPulseEffect.js ---
class ClearPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "ClearPulse";
        this.active = false;
        this.origin = { x: 0, y: 0 };
        this.radius = 0;
        this.snap = null;
        this.autoTimer = c.state.clearPulseFrequencySeconds * 60;
        this.renderData = null;
    }
    trigger() {
        if (this.active) return false;
        const total = this.g.cols * this.g.rows;
        const s = this.c.state;
        const d = this.c.derived;
        // Snapshot colors and fill chars to avoid per-frame calculations
        this.snap = { 
            fillChars: new Uint16Array(total),
            colors: new Uint32Array(total)
        };
        for (let i = 0; i < total; i++) {
            // Snapshot Fill Char
            this.snap.fillChars[i] = Utils.getRandomChar().charCodeAt(0);
            // Snapshot Color (Simulating the logic that was previously in getOverride)
            let rgb;
            const style = this.g.complexStyles.get(i);
            if(style) {
                rgb = Utils.hslToRgb(style.h, style.s, style.l);
            } else {
                rgb = d.streamRgb;
            }
            this.snap.colors[i] = Utils.packRgb(rgb.r, rgb.g, rgb.b);
        }
        let ox, oy;
        if (s.clearPulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols * 0.2, this.g.cols * 0.8);
            oy = Utils.randomInt(this.g.rows * 0.2, this.g.rows * 0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.clearPulseWidth && pxDistY < s.clearPulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols / 2);
            oy = Math.floor(this.g.rows / 2);
        }
        this.origin = { x: ox, y: oy };
        this.active = true;
        this.radius = s.clearPulseInstantStart ? s.clearPulseWidth * 2 : 0;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * 60);
        return true;
    }
    update() {
        const s = this.c.state;
        if (!this.active && s.clearPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.clearPulseFrequencySeconds * 60;
        }
        if (!this.active) { this.renderData = null; return; }
        this.radius += this.speed;
        const d = this.c.derived;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        if (this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
        // --- Optimization Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX);
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        const width = s.clearPulseWidth * 2;
        const innerEdge = this.radius - width;
        let ratio = 1;
        if (!s.clearPulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        let minX, maxX, minY, maxY;
        if (s.clearPulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = {
            ox, oy,
            radius: this.radius,
            radiusSq: this.radius * this.radius,
            innerEdge,
            innerEdgeSq: innerEdge * innerEdge,
            width,
            ratio,
            minX, maxX, minY, maxY
        };
    }
    getOverride(i) {
        if (!this.active || !this.snap || !this.renderData) return null;
        const s = this.c.state;
        const d = this.c.derived;
        const rd = this.renderData;
        const x = i % this.g.cols; 
        const y = Math.floor(i / this.g.cols);
        const cx = Math.floor(x * d.cellWidth * s.stretchX);
        const cy = Math.floor(y * d.cellHeight * s.stretchY);
        // 1. Outer AABB (Optimization)
        if (cx < rd.minX || cx > rd.maxX || cy < rd.minY || cy > rd.maxY) return null;
        // 2. Inner Hole Check (Optimization)
        if (rd.innerEdge > 0) {
            if (s.clearPulseCircular) {
                if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                    cy > rd.oy - rd.innerEdge && cy < rd.oy + rd.innerEdge) {
                    const dx = cx - rd.ox; const dy = cy - rd.oy;
                    if ((dx * dx + dy * dy) < rd.innerEdgeSq) return null;
                }
            } else {
                const rY = rd.innerEdge / rd.ratio;
                if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                    cy > rd.oy - rY && cy < rd.oy + rY) {
                    return null;
                }
            }
        }
        // 3. Distance Calculation
        let dist;
        if (s.clearPulseCircular) {
            const dx = cx - rd.ox; const dy = cy - rd.oy;
            dist = Math.sqrt(dx * dx + dy * dy);
        } else {
            const dx = Math.abs(cx - rd.ox);
            const dy = Math.abs(cy - rd.oy);
            dist = Math.max(dx, dy * rd.ratio);
        }
        // 4. Wave Bounds Check
        if (dist < rd.innerEdge || dist > rd.radius) return null;
        // Check Live Alpha to determine if cell is empty
        const alpha = this.g.alphas[i];
        const isGap = (alpha <= 0.01);
        if (s.clearPulsePreserveSpaces && isGap) return null;
        let char;
        if (isGap) {
            // Fill the gap (Reveal effect) using snapshot
            char = String.fromCharCode(this.snap.fillChars[i]);
        } else {
            // Use LIVE character (Flow continues)
            char = this.g.getChar(i);
        }
        // Color Calculation
        const tRgb = d.tracerRgb;
        const rel = Math.max(0, Math.min(1, (rd.radius - dist) / rd.width));
        let finalColor = `rgb(${tRgb.r},${tRgb.g},${tRgb.b})`; 
        if (s.clearPulseBlend) { 
            // Use snapshot color which is pre-calculated for all cells (Stream or Style)
            const baseInt = this.snap.colors[i];
            const bR = (baseInt >> 16) & 0xFF;
            const bG = (baseInt >> 8) & 0xFF;
            const bB = baseInt & 0xFF;
            const mR = Math.floor(tRgb.r + (bR - tRgb.r) * rel);
            const mG = Math.floor(tRgb.g + (bG - tRgb.g) * rel);
            const mB = Math.floor(tRgb.b + (bB - tRgb.b) * rel);
            finalColor = `rgb(${mR},${mG},${mB})`;
        }
        const useSolid = isGap; 
        const useBlend = !isGap && s.clearPulseBlend;
        return { 
            char, 
            color: finalColor, 
            alpha: 1.0, 
            glow: Math.max(s.tracerGlow, 30 * (1.0 - rel)), 
            size: s.tracerSizeIncrease, 
            solid: useSolid, 
            blend: useBlend, 
            bgColor: '#000000' 
        };
    }
}
// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "DejaVu"; 
                this.active = false; 
                this.autoTimer = c.state.dejaVuFrequencySeconds * 60; 
                this.map = null; 
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.dejaVuDurationSeconds * 60; 
                this.bars = []; 
                this.map = new Uint8Array(this.g.rows); 
                return true; 
            }
            update() {
                const s = this.c.state;
                if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
                if(!this.active) return;
                if(this.timer-- <= 0) { this.active = false; this.bars = []; this.map = null; return; }
                this.map.fill(0);
                // Generate new bars
                if(Math.random() < s.dejaVuIntensity) {
                    const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); 
                    const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
                    this.bars.push({ y, h, age: 0, maxAge: s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10) });
                }
                // Update bars and populate row map
                for(let i=this.bars.length-1; i>=0; i--) {
                    const b = this.bars[i]; b.age++;
                    if(b.age > b.maxAge) {
                        this.bars.splice(i, 1); 
                    } else { 
                        const limit = Math.min(this.g.rows, b.y + b.h);
                        for(let r=b.y; r < limit; r++) this.map[r] = 1; 
                    }
                }
                // Apply glitches to active rows (Mutation logic)
                for (const b of this.bars) {
                    const limit = Math.min(this.g.rows, b.y + b.h);
                    for(let y=b.y; y < limit; y++) {
                        const glitchCount = Math.floor(this.g.cols * 0.1);
                        for(let k=0; k<glitchCount; k++) {
                            const x = Utils.randomInt(0, this.g.cols);
                            const i = this.g.getIndex(x, y);
                            // Apply glitch
                            this.g.rotatorProg[i] = 0; 
                            const c = Utils.getRandomChar(); 
                            this.g.setChar(i, c);
                            if(s.dejaVuRandomizeColors) {
                                this.g.complexStyles.set(i, { h: Utils.randomInt(0,360), s: 90, l: 70, glitched: true });
                            }
                        }
                    }
                }
            }
            getOverride(i) {
                if(!this.active || !this.map) return null;
                // Optimization: Map lookup is O(1) array access.
                const y = Math.floor(i / this.g.cols);
                // Fast rejection
                if(this.map[y] === 0) return null;
                const s = this.c.state; 
                // Fix: Preserve existing alpha for active cells to maintain trail gradients
                const baseAlpha = this.g.alphas[i];
                const alpha = baseAlpha < 0.1 ? s.dejaVuHoleBrightness : baseAlpha; 
                if(alpha < 0.01) return null;
                return { 
                    char: this.g.getChar(i), 
                    color: this.c.derived.tracerColorStr, 
                    alpha, 
                    glow: 20 * alpha, 
                    size: 2 
                };
            }
        }
// --- FirewallEffect.js ---
class FirewallEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "Firewall";
        this.active = false;
        this.autoTimer = c.state.firewallFrequencySeconds * 60;
        this.column = -1;
        this.state = 'IDLE'; 
        this.reverseTimer = 0;
        this.eraseTimer = 0;
        this.snapChars = null;
        this.cleanupFrames = 2; // Add a final cleanup buffer frame
        this.shiftCounter = 0;
        this.shiftInterval = 2; // Shift every 2 frames during reversing
        this._firewallRandomColor = null; // Store the random color for a given trigger
    } // Added missing closing brace
    trigger() {
        if (this.active) return false;
        // 1. Pick Random Column
        this.column = Utils.randomInt(1, this.g.cols - 2); 
        this.reverseTimer = this.c.state.firewallReverseDurationFrames; 
        this.eraseTimer = this.c.state.firewallEraseDurationFrames + this.cleanupFrames; // Add buffer
        this.active = true;
        this.state = 'REVERSING';
        // 2. Snapshot the existing code
        this.snapChars = new Uint16Array(this.g.rows);
        for (let y = 0; y < this.g.rows; y++) {
            const idx = this.g.getIndex(this.column, y);
            this.snapChars[y] = this.g.chars[idx];
        }
        // Generate random color once per trigger if enabled
        if (this.c.state.firewallRandomColorEnabled) {
            const randomHue = Utils.randomInt(0, 359);
            this._firewallRandomColor = Utils.hslToRgb(randomHue, 100, 70);
        } else {
            this._firewallRandomColor = null; // Clear if not using random color
        }
        return true;
    }
    update() {
        const s = this.c.state;
        // Auto-trigger logic
        if (!this.active && s.firewallEnabled && this.autoTimer-- <= 0) { 
            this.trigger(); 
            this.autoTimer = s.firewallFrequencySeconds * 60; 
        }
        if (!this.active) { return; }
        if (this.state === 'REVERSING') {
            if (this.reverseTimer-- <= 0) {
                this.state = 'ERASING';
            } else {
                this.shiftCounter++;
                if (this.shiftCounter >= this.shiftInterval) {
                    this._shiftColumnCharsUpwards();
                    this.shiftCounter = 0;
                }
            }
        } else if (this.state === 'ERASING') {
            this.eraseTimer--;
            // If we are in the last two frames (cleanup buffer), ensure the column is empty
            if (this.eraseTimer <= this.cleanupFrames) {
                // Deep clean the column so it is totally empty
                for (let y = 0; y < this.g.rows; y++) {
                    const idx = this.g.getIndex(this.column, y);
                    this.g.types[idx] = CELL_TYPE.EMPTY;
                    this.g.alphas[idx] = 0;
                    this.g.ages[idx] = 0;
                    this.g.decays[idx] = 0;
                    this.g.rotatorProg[idx] = 0;
                    this.g.complexStyles.delete(idx);
                }
            }
            if (this.eraseTimer <= 0) {
                this.active = false;
                this.snapChars = null;
            }
        }
    }
    _shiftColumnCharsUpwards() {
        if (!this.snapChars) return;
        const topChar = this.snapChars[0];
        for (let y = 0; y < this.g.rows - 1; y++) {
            this.snapChars[y] = this.snapChars[y + 1];
        }
        this.snapChars[this.g.rows - 1] = topChar;
    }
    getOverride(i) {
        if (!this.active || this.snapChars === null) return null;
        const x = i % this.g.cols; 
        if (x !== this.column) return null; 
        const y = Math.floor(i / this.g.cols);
        const s = this.c.state;
        const d = this.c.derived;
        const originalChar = String.fromCharCode(this.snapChars[y]);
        // Fix for residual flash: If timer is in cleanup phase, return a transparent block.
        if (this.state === 'ERASING' && this.eraseTimer <= this.cleanupFrames) {
             return { char: '', color: '#000000', alpha: 0.0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
        }
        // --- PHASE 1: REVERSE FLOW ---
        if (this.state === 'REVERSING') {
            const charCode = this.snapChars[y];
            return {
                char: String.fromCharCode(charCode),
                color: d.streamColorStr, // Use stream color
                alpha: 1.0,
                glow: 20,
                size: 2,
                solid: false,
                blend: false
            };
        } 
        // --- PHASE 2: ERASE & FADE ---
        else if (this.state === 'ERASING') {
            const maxT = s.firewallEraseDurationFrames - this.cleanupFrames; // Base duration for fade
            const progress = 1.0 - (this.eraseTimer / maxT);
            // Calculate Alpha for the Fade
            const alpha = Math.max(0, 1.0 - progress);
            if (alpha <= 0.01) return null;
            let finalRgb;
            if (s.firewallRandomColorEnabled) {
                finalRgb = this._firewallRandomColor;
            } else {
                // Use the configured firewall color
                finalRgb = Utils.hexToRgb(s.firewallColor);
            }
            // Create RGBA string so the BLOCK fades
            const rgbaColor = `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${alpha})`;
            return {
                char: originalChar,
                color: rgbaColor, 
                alpha: alpha, 
                glow: 30 * alpha,
                size: 4,
                solid: true, 
                bgColor: rgbaColor, 
                blend: false
            };
        }
        return null;
    }
}
// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
            constructor(g, c) {
                super(g, c); this.name = "MiniPulse"; this.active = false; this.sessionTimer = 0; this.autoTimer = c.state.miniPulseFrequencySeconds * 60; this.pulses = []; 
                // Optimization: Pre-calculated render objects for the current frame
                this.renderPulses = [];
            }
            trigger() { if(this.active) return false; this.active = true; this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60; this.pulses = []; return true; }
            update() {
                const s = this.c.state;
                const d = this.c.derived; // Needed for pre-calc
                if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.miniPulseFrequencySeconds * 60; }
                if (this.active) {
                    this.sessionTimer--;
                    if (Math.random() < s.miniPulseSpawnChance) { this.pulses.push({ x: Utils.randomInt(0, this.g.cols), y: Utils.randomInt(0, this.g.rows), r: 0, maxR: s.miniPulseSize, speed: s.miniPulseSpeed }); }
                    if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
                }
                // Clear previous render cache
                this.renderPulses = [];
                for (let i = this.pulses.length - 1; i >= 0; i--) { 
                    const p = this.pulses[i]; 
                    p.r += p.speed; 
                    if (p.r > p.maxR + 100) {
                        this.pulses.splice(i, 1);
                        continue;
                    }
                    // --- OPTIMIZATION START ---
                    // Pre-calculate pixel coordinates (Center of the cell) for this frame
                    const ox = (p.x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5);
                    const oy = (p.y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
                    // Bounding Box (AABB) for fast rejection
                    // p.r is pixel radius (based on s.miniPulseSize which is pixels)
                    const minX = ox - p.r;
                    const maxX = ox + p.r;
                    const minY = oy - p.r;
                    const maxY = oy + p.r;
                    // Radius squared for fast distance check
                    const rSq = p.r * p.r;
                    const innerEdge = Math.max(0, p.r - s.miniPulseThickness);
                    const innerEdgeSq = innerEdge * innerEdge;
                    this.renderPulses.push({
                        ox, oy,
                        minX, maxX, minY, maxY,
                        r: p.r,
                        rSq,
                        innerEdge,
                        innerEdgeSq,
                        maxR: p.maxR
                    });
                }
            }
            getOverride(i) {
                if (this.renderPulses.length === 0) return null;
                const s = this.c.state; const d = this.c.derived;
                // Pixel coordinates of the current cell (Center)
                const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                const cx = (x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5); 
                const cy = (y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
                // Iterate backwards through pre-calculated render objects
                for (let k = this.renderPulses.length - 1; k >= 0; k--) {
                    const p = this.renderPulses[k];
                    // 1. AABB Check (Fast Rejection)
                    if (cx < p.minX || cx > p.maxX || cy < p.minY || cy > p.maxY) continue;
                    // 2. Precise Distance Check
                    let dist;
                    let distSq;
                    if (s.pulseCircular !== false) { // Default to true if undefined
                        const dx = cx - p.ox;
                        const dy = cy - p.oy;
                        distSq = (dx * dx) + (dy * dy);
                        // Check against squared radii
                        if (distSq <= p.rSq && distSq >= p.innerEdgeSq) {
                            dist = Math.sqrt(distSq); // Only calc sqrt if hit, for fading logic
                        } else {
                            continue;
                        }
                    } else {
                        // Rectangular distance (Chebyshev)
                        dist = Math.max(Math.abs(cx - p.ox), Math.abs(cy - p.oy));
                        if (dist > p.r || dist < p.innerEdge) continue;
                    }
                    // Hit! Calculate fade
                    let lifeFade = 1.0;
                    if(p.r > p.maxR) lifeFade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                    const combinedAlpha = lifeFade; 
                    if (combinedAlpha <= 0.01) continue;
                    let char = this.g.getChar(i);
                    // Use CELL_TYPE.EMPTY for robust gap detection
                    // Fallback to alpha check only if type is not reliable (though it should be)
                    let isGap = (this.g.types[i] === CELL_TYPE.EMPTY); 
                    if (isGap) {
                        if (s.miniPulsePreserveSpaces) return null;
                        // Optimization: Utils.CHARS is static, access is fast.
                        // Modulo math is fast.
                        const glitchIndex = (i + Math.floor(p.r)) % Utils.CHARS.length; 
                        char = Utils.CHARS[glitchIndex]; 
                    }
                    // Matches ClearPulse logic for "solid" pops in gaps
                    const useSolid = isGap;
                    const useBlend = !isGap;
                    // Ensure background fades with the effect
                    const bgAlpha = useSolid ? combinedAlpha : 0;
                    return { 
                        char: char, 
                        color: d.tracerColorStr, 
                        alpha: combinedAlpha, 
                        glow: s.tracerGlow * combinedAlpha, 
                        size: s.tracerSizeIncrease, 
                        solid: useSolid, 
                        blend: useBlend,
                        bgColor: `rgba(0,0,0,${bgAlpha})`
                    };
                }
                return null;
            }
        }
// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); this.name = "Pulse"; 
                this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
                this.snap = null; this.autoTimer = c.state.pulseFrequencySeconds * 60;
                this.renderData = null; // Cache for update-calc
                // Reusable object to prevent GC thrashing during render loop
                this._retObj = { 
                    char: '', color: '', alpha: 0, glow: 0, size: 0, solid: false, blend: false, bgColor: '' 
                };
            }
            trigger() {
                if(this.active) return false;
                const total = this.g.cols * this.g.rows;
                this.snap = { chars: new Uint16Array(this.g.chars), alphas: new Float32Array(this.g.alphas), colors: new Uint32Array(total), tracers: new Uint8Array(total), fillChars: new Uint16Array(total) };
                const d = this.c.derived; const s = this.c.state; const holdEnd = d.cycleDuration + d.holdFrames;
                for(let i=0; i<total; i++) {
                    let rgb = d.streamRgb; 
                    let isTracer = false; 
                    const style = this.g.complexStyles.get(i);
                    // 1. Determine Color
                    if(style) {
                        rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    } else {
                        // Fallback for non-styled cells (should be rare now with StandardMode fix)
                         // But we still need to check if it's a tracer to set the color to White/TracerColor if needed?
                         // Actually, relying on 'isTracer' below to override the color for the snapshot is better?
                         // No, 'snap.colors' should hold the VISUAL color.
                         // If it's a tracer without style, it should be TracerColor.
                         // But let's stick to the flow:
                    }
                    // 2. Identify Tracer State (Independent of Style)
                    const type = this.g.types[i]; 
                    const age = this.g.ages[i];
                    if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                        const at = age - 1; 
                        if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                             isTracer = true;
                             // If it IS a tracer, we generally want the snapshot color to be the Tracer Color
                             // UNLESS the style dictates a specific color (like Rainbow).
                             // However, StandardMode style returns GREEN. 
                             // Real visual tracer is WHITE.
                             // So we must Override 'rgb' if it is a tracer and NOT Rainbow mode?
                             // How to distinguish Rainbow vs Standard style?
                             // Rainbow has 'cycle:false' usually but so does Standard.
                             // Standard style color is Green. Tracer is White.
                             // If we capture Green into snapshot, 'Ignore Tracers' will show Green.
                             // We want White.
                             rgb = d.tracerRgb; 
                        } 
                    }
                    // Store packed color for all cells
                    this.snap.colors[i] = Utils.packRgb(rgb.r, rgb.g, rgb.b); 
                    this.snap.tracers[i] = isTracer ? 1 : 0; 
                    this.snap.fillChars[i] = Utils.getRandomChar().charCodeAt(0);
                }
                let ox, oy;
                if (s.pulseRandomPosition) {
                    ox = Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8);
                    oy = Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8);
                    const cx = Math.floor(this.g.cols / 2);
                    const cy = Math.floor(this.g.rows / 2);
                    const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
                    const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
                    if (pxDistX < s.pulseWidth && pxDistY < s.pulseWidth) { ox = cx; oy = cy; }
                } else {
                    ox = Math.floor(this.g.cols/2);
                    oy = Math.floor(this.g.rows/2);
                }
                this.origin = {x: ox, y: oy};
                this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelayFrames; this.radius = 0;
                const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * 60);
                return true; 
            }
            update() {
                const s = this.c.state;
                if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; }
                if(!this.active) { this.renderData = null; return; }
                const d = this.c.derived;
                if(this.state === 'WAITING') { 
                    if(--this.timer <= 0) { this.state = 'EXPANDING'; this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; }
                } else {
                    this.radius += this.speed; const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                    if(this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
                }
                // --- Optimization Pre-calc ---
                const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); 
                const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
                const width = s.pulseWidth * 2; 
                const innerEdge = this.radius - width;
                let ratio = 1;
                if (!s.pulseCircular) {
                    const canvasW = this.g.cols * d.cellWidth * s.stretchX;
                    const canvasH = this.g.rows * d.cellHeight * s.stretchY;
                    ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
                }
                // AABB for the outer radius
                // For circular: standard bounding box.
                // For rect: radius applies to the MAX dimension.
                // Rect dist = max(dx, dy * ratio).
                // So max dx = radius. max dy = radius / ratio.
                let minX, maxX, minY, maxY;
                if (s.pulseCircular) {
                    minX = ox - this.radius; maxX = ox + this.radius;
                    minY = oy - this.radius; maxY = oy + this.radius;
                } else {
                    minX = ox - this.radius; maxX = ox + this.radius;
                    const rY = this.radius / ratio;
                    minY = oy - rY; maxY = oy + rY;
                }
                this.renderData = {
                    ox, oy,
                    radius: this.radius,
                    radiusSq: this.radius * this.radius,
                    innerEdge,
                    innerEdgeSq: innerEdge * innerEdge, // innerEdge can be negative, handled
                    width,
                    ratio,
                    minX, maxX, minY, maxY
                };
            }
            getOverride(i) {
                if(!this.active || !this.snap || !this.renderData) return null;            
                const s = this.c.state; const d = this.c.derived;
                // Use renderData for fast rejection IF expanding
                const rd = this.renderData;
                let dist = 0;
                if (this.state === 'WAITING') {
                } else {
                    // EXPANDING
                    const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                    const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                    const cy = Math.floor(y * d.cellHeight * s.stretchY);
                    // AABB Check                    
                    if (rd.innerEdge > 0) {
                        // Check if definitely inside the hole
                        let inHole = false;
                        if (s.pulseCircular) {
                            // Inner AABB
                            if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                                cy > rd.oy - rd.innerEdge && cy < rd.oy + rd.innerEdge) {
                                // Potential hole match, do precise check
                                const dx = cx - rd.ox; const dy = cy - rd.oy;
                                if ((dx*dx + dy*dy) < rd.innerEdgeSq) return null; // Definitely inside hole
                            }
                        } else {
                            // Rect inner hole is exact AABB
                            const rY = rd.innerEdge / rd.ratio;
                            if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                                cy > rd.oy - rY && cy < rd.oy + rY) {
                                return null; // Inside rect hole
                            }
                        }
                    }
                    // Calculate Dist for wave edge
                    if (s.pulseCircular) {
                        const dx = cx - rd.ox; const dy = cy - rd.oy;
                        dist = Math.sqrt(dx*dx + dy*dy); // Sqrt needed for linear interpolation 'rel'
                    } else {
                        const dx = Math.abs(cx - rd.ox);
                        const dy = Math.abs(cy - rd.oy);
                        dist = Math.max(dx, dy * rd.ratio);
                    }
                    if (dist < rd.innerEdge) return null;
                }
                const snAlpha = this.snap.alphas[i]; let charCode = this.snap.chars[i];
                const tRgb = d.tracerRgb; const targetColor = `rgb(${tRgb.r},${tRgb.g},${tRgb.b})`;
                let baseColorStr = null; let isGap = false;
                if (snAlpha <= 0.01) { isGap = true; if (!s.pulsePreserveSpaces) charCode = this.snap.fillChars[i]; }
                const char = String.fromCharCode(charCode); const isTracer = (this.snap.tracers[i] === 1);
                // Common Gap Return
                const gapReturn = { char: '', color: '#000000', alpha: 0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
                if (this.state === 'WAITING' || dist > this.radius) {
                    if(baseColorStr === null) { const rgb = Utils.unpackRgb(this.snap.colors[i]); baseColorStr = `rgb(${rgb.r},${rgb.g},${rgb.b})`; }
                    // FIX: If ignoring tracers, return them with their ORIGINAL snapshot alpha/color, do not dim or force white.
                    if(isTracer && s.pulseIgnoreTracers) return { char, color: baseColorStr, alpha: snAlpha, glow: s.tracerGlow, size: s.tracerSizeIncrease, solid: true, bgColor: '#000000' };
                    if (isGap) return gapReturn;
                    return { char, color: baseColorStr, alpha: snAlpha * s.pulseDimming, glow: 0, size: 0, solid: true, bgColor: '#000000' };
                }
                if (s.pulsePreserveSpaces && isGap) return gapReturn;
                                                const rel = Math.max(0, Math.min(1, (this.radius - dist) / (s.pulseWidth * 2)));
                                                let actualCharAlpha = 1.0;
                                                let actualBgAlpha = 1.0;
                                                let actualSolid = true; 
                                                let actualBlend = false; // Default: Don't blend (draws opaque over grid)
                                                let actualGlow = Math.max(s.tracerGlow, 30 * (1.0 - rel));
                                                // Calculate where the inner edge of the fade zone begins
                                                // Fade out over approximately 1 character cell width at the inner boundary
                                                const fadePixelWidth = d.cellWidth; // One character cell width for fade
                                                const innerBoundaryDist = rd.innerEdge; // Exact inner edge of the main wave
                                                const fadeStartDist = innerBoundaryDist + fadePixelWidth; // Distance where fade begins
                                                if (dist < fadeStartDist && dist > innerBoundaryDist) {
                                                    // We are in the fade-out zone at the inner edge
                                                    const fadeProgress = (dist - innerBoundaryDist) / fadePixelWidth; // 0 at innerBoundaryDist, 1 at fadeStartDist
                                                    // FIX: Fade IN the snapshot from 0 (inner edge) to 1 (wave body).
                                                    // Previously reversed, causing a cut.
                                                    actualCharAlpha = fadeProgress;
                                                    actualBgAlpha = fadeProgress; 
                                                    actualSolid = true;             // Draw the background rect (which will be semi-transparent)
                                                    actualBlend = true;             // ENABLE BLEND: Draw standard grid underneath so we crossfade
                                                    actualGlow *= actualCharAlpha;  
                                                } else if (dist <= innerBoundaryDist) {
                                                    // Past the inner edge, no override.
                                                    return null;
                                                }
                                                // Existing color blending
                                                let finalColor = targetColor;
                                                if (s.pulseBlend) {
                                                    const baseInt = this.snap.colors[i]; 
                                                    const bR = (baseInt >> 16) & 0xFF; 
                                                    const bG = (baseInt >> 8) & 0xFF; 
                                                    const bB = baseInt & 0xFF;
                                                    const mR = Math.floor(tRgb.r + (bR - tRgb.r) * rel); 
                                                    const mG = Math.floor(tRgb.g + (bG - tRgb.g) * rel); 
                                                    const mB = Math.floor(tRgb.b + (bB - tRgb.b) * rel);
                                                    finalColor = `rgb(${mR},${mG},${mB})`;
                                                }
                                                // Final return object
                                                actualCharAlpha = Math.max(0, actualCharAlpha);
                                                actualBgAlpha = Math.max(0, actualBgAlpha);
                                                return { 
                                                    char, 
                                                    color: finalColor, 
                                                    alpha: actualCharAlpha, 
                                                    glow: actualGlow, 
                                                    size: s.tracerSizeIncrease, 
                                                    solid: actualSolid, 
                                                    blend: actualBlend,
                                                    bgColor: `rgba(0,0,0,${actualBgAlpha})` 
                                                };
            }
        }
// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.afterimages = new Map(); 
                this.timer = 0;
                this.spawnX = 0;
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this.spawnX = 0;
                this.afterimages.clear();
                this._generateBolt();
                return true; 
            }
            update() {
                const s = this.c.state;
                // Update afterimages (fade out)
                if (this.afterimages.size > 0) {
                    // Fade speed: higher = slower. Default ~20.
                    // 20 -> 0.05 decay. 
                    const decay = 1.0 / Math.max(1, s.supermanFadeSpeed || 20); 
                    for (const [index, alpha] of this.afterimages) {
                        const newAlpha = alpha - decay;
                        if (newAlpha <= 0.01) {
                            this.afterimages.delete(index);
                        } else {
                            this.afterimages.set(index, newAlpha);
                        }
                    }
                }
                if(!this.active && this.afterimages.size === 0) {
                     return;
                }
                if (this.active) {
                    this.timer--;
                    // Spawning logic
                    // Speed 40 ~ crosses screen in roughly 0.5-1s depending on refresh rate.
                    // Factor: Speed 40 -> 0.04 * cols per frame. 
                    // If cols=100, 4 cells/frame. 25 frames total.
                    const speedVal = s.supermanSpawnSpeed || 40;
                    const speedFactor = Math.max(1, speedVal) / 1000; 
                    this.spawnX += (this.g.cols * speedFactor);
                    if (this.spawnX > this.g.cols) this.spawnX = this.g.cols;
                    if (this.timer <= 0) {
                        this.active = false;
                        this.lightningPath.clear();
                        return;
                    }
                    this.flickerTimer++;
                    if (this.flickerTimer >= s.supermanFlickerRate) {
                        this._generateBolt();
                        this.flickerTimer = 0;
                    } else {
                        this._refreshAfterimages();
                    }
                }
            }
            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                let cy = startY;
                const limitX = Math.floor(this.spawnX);
                for (let x = 0; x < this.g.cols; x++) {
                    if (x > limitX) break;
                    // Jitter / Width logic
                    const variance = Math.max(1, s.supermanWidth); 
                    const noise = Utils.randomInt(-variance, variance);
                    // Gentle center pull to keep it on screen but allow jitter
                    const distFromCenter = (this.g.rows / 2) - cy;
                    cy += noise + (distFromCenter * 0.05); 
                    if (cy < 0) cy = 0;
                    if (cy >= this.g.rows) cy = this.g.rows - 1;
                    const thickness = s.supermanBoltThickness; 
                    const halfThick = Math.floor(thickness / 2);
                    for (let dy = -halfThick; dy <= halfThick; dy++) {
                        const thickY = Math.round(cy) + dy;
                        if (thickY >= 0 && thickY < this.g.rows) {
                            const idx = this.g.getIndex(x, thickY);
                            if (idx !== -1) {
                                this.lightningPath.add(idx);
                            }
                        }
                    }
                }
                this._refreshAfterimages();
            }
            _refreshAfterimages() {
                for (const idx of this.lightningPath) {
                    this.afterimages.set(idx, 1.0);
                }
            }
            getOverride(i) {
                if (this.afterimages.has(i)) {
                    const alphaChar = this.g.alphas[i];
                    if (alphaChar <= 0.05) return null;
                    const effectAlpha = this.afterimages.get(i);
                    const s = this.c.state;
                    return {
                        char: this.g.getChar(i),
                        color: s.supermanIncludeColors ? '#ffffffff' : '#b9e4b8ff', 
                        alpha: effectAlpha, 
                        glow: s.supermanGlow, 
                        size: 1,
                        solid: false, 
                        blend: true 
                    };
                }
                return null;
            }
        }
    // =========================================================================
    // 7.0 CANVAS RENDERER
    // =========================================================================
// --- CanvasRenderer.js ---
class CanvasRenderer {
    constructor(canvasId, grid, config, effects) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d', { alpha: false });
        this.bloomCvs = document.getElementById('bloomCanvas');
        this.bloomCtx = this.bloomCvs.getContext('2d', { alpha: true });
        // Off-screen buffer for overlap composition
        this.bufferCvs = document.createElement('canvas');
        this.bufferCtx = this.bufferCvs.getContext('2d', { alpha: true });
        // Unified Render State Arrays
        this.frameAlphas = null;
        this.frameChars = null;
        this.frameFlags = null; // Bit 0: Active, Bit 1: Overlap Allowed
        this.grid = grid;
        this.config = config;
        this.effects = effects;
        // Initialize Glyph Atlas
        // Assuming GlyphAtlas class is available globally or imported
        if (typeof GlyphAtlas !== 'undefined') {
            this.glyphAtlas = new GlyphAtlas(config);
        }
        this.w = 0;
        this.h = 0;
    }
    resize() {
        const scale = this.config.state.resolution;
        this.w = window.innerWidth;
        this.h = window.innerHeight;
        this._resizeCanvas(this.cvs, this.w, this.h, scale);
        // Bloom canvas is 1/4 size for performance and glow effect
        this._resizeCanvas(this.bloomCvs, this.w, this.h, scale * 0.25);
        this.bloomCtx.scale(0.25, 0.25);
        // Buffer canvas (1:1 scale for pixel accuracy)
        this._resizeCanvas(this.bufferCvs, this.w, this.h, scale);
        this.bufferCtx.scale(scale * this.config.state.stretchX, scale * this.config.state.stretchY);
        // Allocate Frame Buffers
        if (!this.grid.chars) return;
        const size = this.grid.chars.length;
        this.frameAlphas = new Float32Array(size);
        this.frameChars = new Uint16Array(size);
        this.frameFlags = new Uint8Array(size);
        this.updateSmoothing();
    }
    _resizeCanvas(canvas, width, height, scale) {
        canvas.width = width * scale;
        canvas.height = height * scale;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
    }
    /**
     * Updates canvas smoothing filters for blur effects.
     * Ensures visual fidelity when smoothing is enabled in settings.
     */
    updateSmoothing() {
        const smoothing = this.config.state.smoothingEnabled ? this.config.state.smoothingAmount : 0;
        this.cvs.style.filter = `blur(${smoothing}px)`;
    }
    /**
     * Calculates the alpha and phase of the tracer based on its age and active state.
     * Optimized logic with early returns and simplified operations.
     */
    _getTracerState(index, state) {
        const age = this.grid.ages[index];
        const decay = this.grid.decays[index];
        if (age <= 0 || decay >= 2) return { alpha: 0, phase: 'none' };
        const type = this.grid.types[index];
        if (type !== CELL_TYPE.TRACER && type !== CELL_TYPE.ROTATOR) return { alpha: 0, phase: 'none' };
        const activeTime = age - 1;
        const attack = state.tracerAttackFrames;
        const hold = state.tracerHoldFrames;
        const release = state.tracerReleaseFrames;
        if (activeTime < attack) return { alpha: (attack > 0) ? (activeTime / attack) : 1.0, phase: 'attack' };
        else if (activeTime < attack + hold) return { alpha: 1.0, phase: 'hold' };
        else if (activeTime < attack + hold + release) {
            const relTime = activeTime - (attack + hold);
            return { alpha: 1.0 - (relTime / release), phase: 'release' };
        }
        return { alpha: 0, phase: 'none' };
    }
    render(frame) {
        if (!this.frameAlphas) return;
        const { state: s, derived: d } = this.config;
        const scale = s.resolution;
        const bloomEnabled = s.enableBloom;
        // Update Glyph Atlas if enabled
        if (s.enableGlyphAtlas && this.glyphAtlas) {
            this.glyphAtlas.update();
        }
        this._resetContext(this.ctx, s, scale);
        if (bloomEnabled) this.bloomCtx.clearRect(0, 0, this.w * scale, this.h * scale);
        this._applyMirrorEffect(this.ctx, s, scale);
        if (bloomEnabled) {
            this.bloomCtx.save();
            this.bloomCtx.scale(scale * s.stretchX, scale * s.stretchY);
            this._applyMirrorEffect(this.bloomCtx, s, scale);
        }
        this._drawGrid(d, s, frame, bloomEnabled);
        if (s.overlapEnabled) {
            this._drawOverlap(d, s, frame, bloomEnabled, scale);
        }
        if (bloomEnabled) this._applyBloom(s, scale);
    }
    _drawOverlap(d, s, frame, bloomEnabled, scale) {
        const ctx = this.bufferCtx;
        const cvs = this.bufferCvs;
        // 1. Clear Buffer
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        // Save state
        ctx.save();
        // 2. Draw Mask (Active Grid)
        const xOff = s.fontOffsetX;
        const yOff = s.fontOffsetY;
        const overlapYOffset = d.paletteColorsStr.length * this.glyphAtlas.blockHeight;
        // Unified Dynamic Pass
        for (const i of this.grid.activeIndices) {
            // Filter 1: Decouple from Effects (Superman, etc)
            const style = this.grid.complexStyles.get(i);
            if (style && style.isEffect) continue;
            let gridAlpha = this.grid.alphas[i];
            let maskChar = this.grid.getChar(i);
            // Sync with Tracer Logic
            const tState = this._getTracerState(i, s);
            if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0;
            // Sync with Effect Overrides (Pulse Pause)
            const override = this.effects.getOverride(i);
            if (override) {
                if (typeof override.alpha === 'number') gridAlpha = override.alpha;
                if (override.char) maskChar = override.char;
            }
            if (gridAlpha <= 0.05) continue;
            const x = i % this.grid.cols;
            const y = Math.floor(i / this.grid.cols);
            const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
            const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
            const sprite = this.glyphAtlas.get(maskChar);
            if (sprite) {
                ctx.globalAlpha = gridAlpha;
                ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
            }
        }
        // 3. Composite Operation: "source-in"
        ctx.globalCompositeOperation = 'source-in';
        ctx.globalAlpha = 1.0; 
        // 4. Draw Imposition Layer (Dynamic)
        for (const i of this.grid.activeIndices) {
            // Same filters for efficiency
            const style = this.grid.complexStyles.get(i);
            if (style && style.isEffect) continue;
            const code = this.grid.overlapChars[i];
            if (code === 0) continue;
            const x = i % this.grid.cols;
            const y = Math.floor(i / this.grid.cols);
            const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
            const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
            const char = String.fromCharCode(code);
            const sprite = this.glyphAtlas.get(char);
            if (sprite) {
                ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + overlapYOffset, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
            }
        }
        ctx.restore(); // Restore composite mode
        // 5. Draw Buffer to Main Screen
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0); 
        this.ctx.drawImage(cvs, 0, 0);
        this.ctx.restore();
    }
    _resetContext(ctx, s, scale) {
        ctx.save();
        ctx.scale(scale * s.stretchX, scale * s.stretchY);
        ctx.fillStyle = `rgba(0,0,0,${s.clearAlpha})`;
        ctx.fillRect(0, 0, this.w / s.stretchX, this.h / s.stretchY);
    }
    _applyMirrorEffect(ctx, s, scale) {
        if (s.mirrorEnabled) {
            ctx.scale(-1, 1);
            ctx.translate(-(this.w / s.stretchX), 0);
        }
    }
    _applyBloom(s, scale) {
        // Safety check: Ensure bloom canvas has dimensions to avoid InvalidStateError
        if (this.bloomCvs.width === 0 || this.bloomCvs.height === 0) return;
        this.bloomCtx.restore();
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'lighter';
        this.ctx.filter = `blur(${s.bloomStrength * 4}px)`;
        this.ctx.globalAlpha = s.bloomOpacity;
        this.ctx.drawImage(this.bloomCvs, 0, 0, this.w * scale, this.h * scale);
        this.ctx.restore();
    }
    _drawGrid(d, s, frame, bloomEnabled) {
        const fontBase = d.fontBaseStr;
        // Only set font if NOT using atlas for everything
        // Or if we need it for fallbacks/tracers
        this.ctx.font = fontBase;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        if (bloomEnabled) {
            this.bloomCtx.font = fontBase;
            this.bloomCtx.textBaseline = 'middle';
            this.bloomCtx.textAlign = 'center';
        }
        const defaultColor = d.streamColorStr;
        let lastColor = defaultColor;
        this._setFillStyle(defaultColor, bloomEnabled); 
        const xOff = s.fontOffsetX;
        const yOff = s.fontOffsetY;
        const useActiveSet = !this.effects.hasActiveEffects();
        // Decide drawing mode once per frame
        const useAtlas = s.enableGlyphAtlas && !!this.glyphAtlas;
        const total = useActiveSet ? 0 : this.grid.cols * this.grid.rows;
        if (useActiveSet) {
            for (const i of this.grid.activeIndices) {
                this._processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas);
            }
        } else {
            for (let i = 0; i < total; i++) {
                this._processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas);
            }
        }
        this._drawTracers(d, s, frame, bloomEnabled, xOff, yOff);
        this.ctx.restore();
    }
    _processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas) {
            // Reset context shadow to prevent pollution from previous overrides
            this.ctx.shadowBlur = 0;
            this.ctx.shadowColor = 'transparent';
            const override = this.effects.getOverride(i);
            if (override && !override.blend) {
                this._drawOverride(i, override, d, s, bloomEnabled);
                return;
            }
            let gridAlpha = this.grid.alphas[i];
            if (gridAlpha <= 0.01) return;
            const tState = this._getTracerState(i, s);
            if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0;
            if (gridAlpha <= 0.01) return;
            const x = i % this.grid.cols;
            const y = Math.floor(i / this.grid.cols);
            const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
            const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
            let color = defaultColor;
            let pIdx = this.grid.paletteIndices[i];
            // Safety: If palette index is out of bounds (removed color), fallback to 0 (default)
            if (pIdx >= d.paletteColorsStr.length) pIdx = 0;
            const paletteColor = d.paletteColorsStr[pIdx] || defaultColor;
            const style = this.grid.complexStyles.get(i);
            if (style) {
                color = this._getCellColor(style, frame);
            } else {
                color = paletteColor;
            }
            // Check if we can use Atlas for this specific cell
            const canUseAtlas = useAtlas && (color === paletteColor);
            if (!canUseAtlas && color !== lastColor) {
                this._setFillStyle(color, bloomEnabled);
                lastColor = color;
            }
            if (canUseAtlas) {
                 this._drawCellCharAtlas(i, px, py, gridAlpha, s, bloomEnabled, pIdx);
            } else {
                 this._drawCellChar(i, px, py, gridAlpha, tState, d, s, bloomEnabled, fontBase);
            }
            if (override && override.blend) {
                this._drawOverride(i, override, d, s, bloomEnabled);
            }
    }
    _setFillStyle(color, bloomEnabled) {
        this.ctx.fillStyle = color;
        if (bloomEnabled) this.bloomCtx.fillStyle = color;
    }
    _getCellColor(style, frame) {
        if (style.glitter && Math.random() < 0.02) return '#ffffff';
        let h = style.h;
        if (style.cycle) h = (h + (frame * style.speed)) % 360;
        const rgb = Utils.hslToRgb(h | 0, style.s, style.l);
        return Utils.createRGBString(rgb);
    }
    _drawCellCharAtlas(i, px, py, alpha, s, bloomEnabled, pIdx) {
        const decay = this.grid.decays[i];
        const char = this.grid.getChar(i);
        const sprite = this.glyphAtlas.get(char);
        const yOffset = (pIdx || 0) * this.glyphAtlas.blockHeight;
        if (!sprite) return; // Should not happen
        // NOTE: Rotator crossfade in Atlas mode is simplified (no crossfade)
        // or we can implement it by drawing two sprites?
        // For strict performance, let's skip crossfade in Atlas mode OR just do simple swap
        // If user wants high quality crossfade, they disable Atlas. 
        // OR we do a simple alpha blend if rotProg > 0
        // Check Rotator
        const rotProg = this.grid.rotatorProg[i];
        if (rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
             // Crossfade
             const p = rotProg / s.rotatorCrossfadeFrames;
             const next = this.grid.nextChars.get(i);
             const nextSprite = next ? this.glyphAtlas.get(next) : null;
             // Outgoing
             this.ctx.globalAlpha = alpha * (1 - p);
             this.ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
             if(bloomEnabled) {
                 this.bloomCtx.globalAlpha = alpha * (1 - p);
                 this.bloomCtx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
             }
             // Incoming
             if (nextSprite) {
                 this.ctx.globalAlpha = alpha * p;
                 this.ctx.drawImage(this.glyphAtlas.canvas, nextSprite.x, nextSprite.y + yOffset, nextSprite.w, nextSprite.h, px - nextSprite.w/2, py - nextSprite.h/2, nextSprite.w, nextSprite.h);
                 if(bloomEnabled) {
                     this.bloomCtx.globalAlpha = alpha * p;
                     this.bloomCtx.drawImage(this.glyphAtlas.canvas, nextSprite.x, nextSprite.y + yOffset, nextSprite.w, nextSprite.h, px - nextSprite.w/2, py - nextSprite.h/2, nextSprite.w, nextSprite.h);
                 }
             }
             return;
        }
        // Standard Draw / Dissolve
        let scale = 1.0;
        if (s.dissolveEnabled && decay >= 2) {
             const prog = (decay - 2) / s.decayFadeDurationFrames;
             // simulate font size shrink by scaling image
             // Min size ratio
             const minRatio = s.dissolveMinSize / s.fontSize;
             scale = 1.0 - (prog * (1.0 - minRatio));
             scale = Math.max(0.1, scale); // Clamp
             if (s.deteriorationEnabled) {
                 const off = s.deteriorationStrength * prog;
                 this.ctx.globalAlpha = alpha * 0.4 * prog;
                 // Ghost 1
                 this.ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, (py - off) - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
                 // Ghost 2
                 this.ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, (py + off) - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
             }
        }
        this.ctx.globalAlpha = alpha;
        this.ctx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, py - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
        if (bloomEnabled) {
            this.bloomCtx.globalAlpha = alpha;
            this.bloomCtx.drawImage(this.glyphAtlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, py - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
        }
    }
    _drawCellChar(i, px, py, alpha, tState, d, s, bloomEnabled, fontBase) {
        const decay = this.grid.decays[i];
        const rotProg = this.grid.rotatorProg[i];
        const char = this.grid.getChar(i);
        if (rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
            const p = rotProg / s.rotatorCrossfadeFrames;
            // Draw outgoing character
            this.ctx.globalAlpha = alpha * (1 - p);
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.globalAlpha = alpha * (1 - p);
                this.bloomCtx.fillText(char, px, py);
            }
            // Draw incoming character
            const next = this.grid.nextChars.get(i);
            if (next) {
                this.ctx.globalAlpha = alpha * p;
                this.ctx.fillText(next, px, py);
                if (bloomEnabled) {
                    this.bloomCtx.globalAlpha = alpha * p;
                    this.bloomCtx.fillText(next, px, py);
                }
            }
        } else if (s.dissolveEnabled && decay >= 2) {
            const prog = (decay - 2) / s.decayFadeDurationFrames;
            const size = Math.max(1, s.fontSize - ((s.fontSize - s.dissolveMinSize) * prog));
            const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${size}px ${s.fontFamily}`;
            this.ctx.font = font;
            if (s.deteriorationEnabled) {
                const off = s.deteriorationStrength * prog;
                this.ctx.globalAlpha = alpha * 0.4 * prog;
                this.ctx.fillText(char, px, py - off);
                this.ctx.fillText(char, px, py + off);
            }
            this.ctx.globalAlpha = alpha;
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.globalAlpha = alpha;
                this.bloomCtx.fillText(char, px, py);
            }
            this.ctx.font = fontBase;
        } else {
            this.ctx.globalAlpha = alpha;
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.globalAlpha = alpha;
                this.bloomCtx.fillText(char, px, py);
            }
        }
    }
    _drawTracers(d, s, frame, bloomEnabled, xOff, yOff) {
        const tStr = d.tracerColorStr;
        this.ctx.shadowBlur = s.tracerGlow;
        this.ctx.shadowColor = tStr;
        const tFont = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${s.fontSize + s.tracerSizeIncrease}px ${s.fontFamily}`;
        this.ctx.font = tFont;
        if (bloomEnabled) this.bloomCtx.font = tFont;
        for (const i of this.grid.activeIndices) {
            if (this.effects.getOverride(i)) continue;
            const tState = this._getTracerState(i, s);
            if (tState.alpha > 0.01) {
                const x = i % this.grid.cols;
                const y = Math.floor(i / this.grid.cols);
                const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
                const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
                const style = this.grid.complexStyles.get(i);
                let cStr = tStr;
                if (style && style.isEffect) {
                    let h = style.h;
                    if (style.cycle) h = (h + (frame * style.speed)) % 360;
                    const tc = Utils.hslToRgb(h | 0, 100, 90);
                    cStr = Utils.createRGBString(tc);
                }
                this.ctx.fillStyle = cStr;
                this.ctx.shadowColor = cStr;
                if (bloomEnabled) this.bloomCtx.fillStyle = cStr;
                this.ctx.globalAlpha = tState.alpha;
                this.ctx.fillText(this.grid.getChar(i), px, py);
                if (bloomEnabled) {
                    this.bloomCtx.globalAlpha = tState.alpha;
                    this.bloomCtx.fillText(this.grid.getChar(i), px, py);
                }
            }
        }
    }
    _drawOverride(i, o, d, s, bloom) {
        const x = i % this.grid.cols;
        const y = Math.floor(i / this.grid.cols);
        const cx = (x * d.cellWidth) + s.fontOffsetX;
        const cy = (y * d.cellHeight) + s.fontOffsetY;
        const px = cx + (d.cellWidth * 0.5);
        const py = cy + (d.cellHeight * 0.5);
        if (o.solid) {
            const bg = o.bgColor || '#000000';
            this.ctx.fillStyle = bg;
            const w = Math.ceil(d.cellWidth) + 1;
            const h = Math.ceil(d.cellHeight) + 1;
            this.ctx.fillRect(Math.floor(cx), Math.floor(cy), w, h);
        }
        if (o.char && o.alpha > 0.01) {
            this.ctx.fillStyle = o.color;
            this.ctx.shadowColor = o.color;
            this.ctx.shadowBlur = o.glow || 0;
            const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${s.fontSize + (o.size || 0)}px ${s.fontFamily}`;
            this.ctx.font = font;
            this.ctx.globalAlpha = o.alpha;
            this.ctx.fillText(o.char, px, py);
            if (bloom) {
                this.bloomCtx.save();
                this.bloomCtx.fillStyle = o.color;
                this.bloomCtx.font = font;
                this.bloomCtx.globalAlpha = o.alpha;
                this.bloomCtx.fillText(o.char, px, py);
                this.bloomCtx.restore();
            }
            this.ctx.font = d.fontBaseStr;
        }
    }
}
    // =========================================================================
    // 8.0 FONT MANAGER
    // =========================================================================
// --- GlyphAtlas.js ---
class GlyphAtlas {
    constructor(config) {
        this.config = config;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true });
        // Map character codes to their x/y coordinates in the atlas
        this.charMap = new Map();
        // Atlas dimensions and cell size
        this.cellSize = 0;
        this.atlasWidth = 0;
        this.atlasHeight = 0;
        this.blockHeight = 0; // Height of one color set
        // State tracking for updates
        this.currentFont = '';
        this.currentPalette = '';
        this.needsUpdate = true;
        // Pre-calculated half sizes for centering
        this.halfCell = 0;
    }
    /**
     * Initializes or updates the atlas if configuration has changed.
     */
    update() {
        const s = this.config.state;
        const d = this.config.derived;
        // Check if update is needed (font, color, or size change)
        const maxSize = s.fontSize + s.tracerSizeIncrease;
        const style = s.italicEnabled ? 'italic ' : '';
        const fontBase = `${style}${s.fontWeight} ${maxSize}px ${s.fontFamily}`;
        const paletteStr = d.paletteColorsStr.join(',');
        // Include overlap color in dependency check
        const fullConfigStr = paletteStr + '|' + s.overlapColor;
        if (this.currentFont === fontBase && 
            this.currentPalette === fullConfigStr && 
            !this.needsUpdate) {
            return;
        }
        this.currentFont = fontBase;
        this.currentPalette = fullConfigStr;
        this.needsUpdate = false;
        // Calculate cell dimensions (add padding for glow/blur)
        const padding = Math.max(s.tracerGlow, 10) * 2;
        this.cellSize = Math.ceil(maxSize + padding);
        this.halfCell = this.cellSize / 2;
        // Calculate atlas dimensions
        const charList = Utils.CHARS;
        const cols = Math.ceil(Math.sqrt(charList.length));
        const rows = Math.ceil(charList.length / cols);
        this.atlasWidth = cols * this.cellSize;
        this.blockHeight = rows * this.cellSize; // Height of ONE color set
        // Total height = Palette Colors + 1 Overlap Color
        const colorsToDraw = [...d.paletteColorsStr, s.overlapColor];
        this.atlasHeight = this.blockHeight * colorsToDraw.length;
        // Resize canvas
        this.canvas.width = this.atlasWidth;
        this.canvas.height = this.atlasHeight;
        // Clear and set up context
        this.ctx.clearRect(0, 0, this.atlasWidth, this.atlasHeight);
        this.ctx.font = fontBase;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.charMap.clear();
        // Draw Characters for each color in the palette + overlap
        colorsToDraw.forEach((color, pIdx) => {
            this.ctx.fillStyle = color;
            const yOffset = pIdx * this.blockHeight;
            for (let i = 0; i < charList.length; i++) {
                const char = charList[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = col * this.cellSize + this.halfCell;
                const y = row * this.cellSize + this.halfCell + yOffset;
                this.ctx.fillText(char, x, y);
                // Store map ONLY for the first block (pIdx 0) as relative coords are same
                if (pIdx === 0) {
                    this.charMap.set(char, {
                        x: col * this.cellSize,
                        y: row * this.cellSize,
                        w: this.cellSize,
                        h: this.cellSize
                    });
                }
            }
        });
    }
    /**
     * Returns the source coordinates for a character.
     * @param {string} char 
     * @returns {Object|null} Source rect {x,y,w,h} or null
     */
    get(char) {
        return this.charMap.get(char);
    }
}
// --- SimulationSystem.js ---
class SimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.activeStreams = [];
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.modes = this._initializeModes(config);
        this.overlapInitialized = false;
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    update(frame) {
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            this._resetColumns();
        }
        this._manageStreams(frame);
        this._manageOverlapGrid(frame);
        this._updateCells(frame);
    }
    _manageOverlapGrid(frame) {
        if (!this.config.state.overlapEnabled) return;
        // Initialize if empty
        if (!this.overlapInitialized) {
            for(let i=0; i<this.grid.overlapChars.length; i++) {
                if (Math.random() < this.config.state.overlapDensity) {
                    this.grid.overlapChars[i] = Utils.getRandomChar().charCodeAt(0);
                } else {
                    this.grid.overlapChars[i] = 0; // Empty
                }
            }
            this.overlapInitialized = true;
            this.grid.noiseDirty = true;
        }
        // Slowly churn the noise
        // Note: User requested Shimmer to be optional. 
        // Wait, user requested "choosing overlap color should cause a refresh".
        // This means we need to redraw the noise layer when color changes.
        // The CanvasRenderer checks `noiseDirty`.
        // Changing color doesn't change characters, so Simulation doesn't care.
        // But CanvasRenderer needs to redraw.
        // So `ConfigurationManager` or `UIManager` should set `noiseDirty`?
        // Or `CanvasRenderer` should check if `overlapColor` changed.
        // I will handle color change in Renderer (by checking state vs last state).
        // Simulation only handles character churn.
        if (this.config.state.overlapShimmer) {
             const updates = Math.ceil(this.grid.overlapChars.length * 0.005); 
             for(let k=0; k<updates; k++) {
                const idx = Math.floor(Math.random() * this.grid.overlapChars.length);
                if (Math.random() < this.config.state.overlapDensity) {
                    this.grid.overlapChars[idx] = Utils.getRandomChar().charCodeAt(0);
                } else {
                    this.grid.overlapChars[idx] = 0;
                }
            }
            this.grid.noiseDirty = true;
        }
    }
    _resetColumns() {
        this.lastStreamInColumn = new Array(this.grid.cols).fill(null);
        this.activeStreams = [];
    }
    _manageStreams(frame) {
        const { state: s, derived: d } = this.config;
        const period = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
        if (frame % period === 0) {
            this._spawnStreams(s, d);
        }
        if (frame % d.cycleDuration === 0) {
            this._processActiveStreams(frame);
        }
    }
    _spawnStreams(s, d) {
        const columns = this._shuffleArray([...Array(this.grid.cols).keys()]);
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (const col of columns) {
            if (streamCount <= 0 && eraserCount <= 0) break;
            const hasContent = this._columnHasContent(col, Math.min(this.grid.rows, 40));
            const lastStream = this.lastStreamInColumn[col];
            if (hasContent && eraserCount > 0 && this._canSpawn(lastStream, s.minEraserGap)) {
                this._spawnStreamAt(col, true);
                eraserCount--;
            } else if (!hasContent && streamCount > 0 && this._canSpawn(lastStream, s.minStreamGap)) {
                this._spawnStreamAt(col, false);
                streamCount--;
            }
        }
    }
    _shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    _columnHasContent(col, maxRows) {
        for (let y = 0; y < maxRows; y++) {
            if (this.grid.decays[this.grid.getIndex(col, y)] > 0) return true;
        }
        return false;
    }
    _canSpawn(lastStream, minGap) {
        return !lastStream || !lastStream.active || lastStream.y > minGap;
    }
    _processActiveStreams(frame) {
        for (let i = this.activeStreams.length - 1; i >= 0; i--) {
            const stream = this.activeStreams[i];
            if (!stream.active) {
                this.activeStreams.splice(i, 1);
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            stream.age++;
            if (stream.age >= stream.visibleLen) {
                this._handleStreamCompletion(stream);
                continue;
            }
            if (stream.y < stream.len) {
                stream.y++;
                this._writeHead(stream, frame);
            }
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        if (!stream.isEraser) {
            this._spawnStreamAt(stream.x, true);
        }
    }
    _spawnStreamAt(x, forceEraser) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.lastStreamInColumn[x] = stream;
    }
    _initializeStream(x, forceEraser, s) {
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsStr?.length || 1))
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        stream.visibleLen = Math.max(Math.floor(Utils.randomFloat(s.ttlMinSeconds, s.ttlMaxSeconds) * 60), this.grid.rows + 20);
        return stream;
    }
    _initializeTracerStream(stream, s) {
        const lifeFrames = Math.max(Math.floor(Utils.randomFloat(s.ttlMinSeconds, s.ttlMaxSeconds) * 60), 60);
        stream.len = Utils.randomInt(4, this.grid.rows * 3);
        stream.visibleLen = lifeFrames;
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        if (this.grid.decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            this.grid.decays[idx] = 2;
        } else {
            this._clearCell(idx);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const { state: s, derived: d } = this.config;
            const cellType = s.rotatorEnabled && Math.random() < s.rotatorChance
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            this.grid.types[idx] = cellType;
            this.grid.ages[idx] = 1;
            this.grid.decays[idx] = 1;
            this.grid.rotatorProg[idx] = 0;
            if (Math.random() < s.paletteBias) {
                this.grid.paletteIndices[idx] = Math.floor(Math.random() * (d.paletteColorsStr?.length || 1));
            } else {
                this.grid.paletteIndices[idx] = stream.pIdx;
            }
            this.grid.activeIndices.add(idx);
            this.grid.setChar(idx, Utils.getRandomChar());
            if (s.overlapEnabled) {
                this.grid.overlapChars[idx] = Utils.getRandomChar().charCodeAt(0);
            }
            this.grid.brightness[idx] = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            this.grid.alphas[idx] = this.grid.brightness[idx];
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                this.grid.complexStyles.set(idx, style);
            } else {
                this.grid.complexStyles.delete(idx);
            }
        } else {
            this._clearCell(idx);
        }
    }
    _clearCell(idx) {
        this.grid.types[idx] = CELL_TYPE.EMPTY;
        this.grid.ages[idx] = 0;
        this.grid.decays[idx] = 0;
        this.grid.alphas[idx] = 0;
        this.grid.overlapChars[idx] = 0;
        this.grid.complexStyles.delete(idx);
        this.grid.nextChars.delete(idx);
        this.grid.activeIndices.delete(idx); // Improves performance
    }
    _updateCells(frame) {
        const { state: s, derived: d } = this.config;
        for (const idx of this.grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        const decay = this.grid.decays[idx];
        if (decay === 0) return;
        let age = this.grid.ages[idx];
        if (age > 0) {
            age = this._incrementAge(age, d.maxState);
            this.grid.ages[idx] = age;
        }
        if (s.rotatorEnabled && this.grid.types[idx] === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        if (decay >= 2) {
            this.grid.decays[idx]++;
            const newDecay = this.grid.decays[idx];
            if (this._shouldDecay(idx, newDecay, s.decayFadeDurationFrames)) {
                this._clearCell(idx);
                return;
            }
            this.grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, s.decayFadeDurationFrames);
        } else {
            this.grid.alphas[idx] = this._calculateAlpha(idx, age, decay, s.decayFadeDurationFrames);
        }
    }
    _incrementAge(age, maxState) {
        return age < maxState ? age + 1 : 0;
    }
    _handleRotator(idx, frame, s, d) {
        const prog = this.grid.rotatorProg[idx];
        if (prog > 0) {
            this._progressRotator(idx, prog, s.rotatorCrossfadeFrames);
        } else if (this.grid.decays[idx] === 1) {
            this._cycleRotator(idx, frame, s.rotatorCrossfadeFrames, d.rotatorCycleFrames);
        }
    }
    _progressRotator(idx, prog, crossfadeFrames) {
        if (prog >= crossfadeFrames) {
            const nextChar = this.grid.nextChars.get(idx);
            if (nextChar) {
                this.grid.setChar(idx, nextChar);
                if (this.config.state.overlapEnabled) {
                    const nextOverlap = this.grid.nextOverlapChars.get(idx);
                    if (nextOverlap) {
                        this.grid.overlapChars[idx] = nextOverlap;
                        this.grid.noiseDirty = true;
                    }
                }
            }
            this.grid.rotatorProg[idx] = 0;
        } else {
            this.grid.rotatorProg[idx] = prog + 1;
        }
    }
    _cycleRotator(idx, frame, crossfadeFrames, cycleFrames) {
        if (frame % cycleFrames === 0) {
            if (crossfadeFrames <= 2) {
                this.grid.setChar(idx, Utils.getUniqueChar(this.grid.getChar(idx)));
                if (this.config.state.overlapEnabled) {
                    this.grid.overlapChars[idx] = Utils.getUniqueChar(String.fromCharCode(this.grid.overlapChars[idx])).charCodeAt(0);
                }
            } else {
                this.grid.rotatorProg[idx] = 1;
                this.grid.nextChars.set(idx, Utils.getUniqueChar(this.grid.getChar(idx)));
                if (this.config.state.overlapEnabled) {
                    const currentOverlap = String.fromCharCode(this.grid.overlapChars[idx]);
                    this.grid.nextOverlapChars.set(idx, Utils.getUniqueChar(currentOverlap).charCodeAt(0));
                }
            }
        }
    }
    _shouldDecay(idx, decay, fadeDurationFrames) {
        return decay > fadeDurationFrames + 2;
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        if (age > 0) {
            return 1.0;
        } else if (decay === 1) {
            return 0.95 * this.grid.brightness[idx];
        } else if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            return 0.95 * (1 - ratio) * this.grid.brightness[idx];
        }
        return 0;
    }
}
    // =========================================================================
    // 6.0 EFFECT REGISTRY
    // =========================================================================
// --- StreamModes.js ---
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        const hue = (state.starPowerRainbowMode === 'char')
            ? (frame + (stream.x * 10)) % 360 // Character-based hue
            : stream.baseHue; // Fixed hue based on baseHue
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed, state.starPowerGlitter);
    }
    _createStyle(hue, saturation, lightness, cycle, speed, glitter) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, glitter, isEffect: true };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, glitter: false, isEffect: true };
    }
}
    // =========================================================================
    // 5.0 SIMULATION SYSTEM 
    // =========================================================================
// --- FontManager.js ---
class FontManager {
    constructor(config, notificationMgr) {
        this.config = config;
        this.notifications = notificationMgr;
        this.dbName = 'MatrixFontDB';
        this.storeName = 'fonts';
        this.db = null;
        this.loadedFonts = [];
        this.subscribers = [];
        this.embeddedFontName = 'MatrixEmbedded';
    }
    /**
     * Initialize the FontManager by injecting the embedded font and loading fonts from the database.
     */
    async init() {
        if (DEFAULT_FONT_DATA && DEFAULT_FONT_DATA.length > 50) {
            await this.injectEmbeddedFont();
        }
        try {
            await this._openDB();
            await this._loadFontsFromDB();
        } catch (error) {
            console.warn('Font DB Error:', error);
        }
    }
    /**
     * Add a subscription callback to be notified on font changes.
     * @param {Function} callback - The callback function to execute on changes.
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }
    /**
     * Notify all subscribers about font changes.
     * Executes the callback functions passed via subscribe.
     */
    _notify() {
        this.subscribers.forEach(callback => callback(this.loadedFonts));
    }
    /**
     * Inject the embedded default Matrix font if it hasn't already been loaded.
     */
    async injectEmbeddedFont() {
        const isFontInjected = this.loadedFonts.some(f => f.name === this.embeddedFontName);
        if (isFontInjected) return;
        await this._injectCSS(this.embeddedFontName, DEFAULT_FONT_DATA, "format('woff2')");
        this.loadedFonts.push({
            name: this.embeddedFontName,
            display: 'The Matrix Custom Code',
            isEmbedded: true,
        });
    }
    /**
     * Inject a font into the document as a CSS @font-face rule.
     * @param {string} name - Font's name.
     * @param {string} url - The URL or source of the font data.
     * @param {string} format - The format of the font data (e.g., 'format("woff2")').
     */
    async _injectCSS(name, url, format) {
        const existingStyle = document.getElementById(`style-${name}`);
        if (existingStyle) existingStyle.remove();
        const style = document.createElement('style');
        style.id = `style-${name}`;
        style.textContent = `
            @font-face {
                font-family: '${name}';
                src: url('${url}') ${format};
            }
        `;
        document.head.appendChild(style);
        // Wait for the font to be loaded
        try {
            await document.fonts.load(`1em '${name}'`);
            return true; // Font loaded successfully
        } catch (e) {
            console.error(`Failed to load font ${name}:`, e);
            return false; // Font failed to load
        }
    }
    /**
     * Open or create the IndexedDB for storing font data.
     * @returns {Promise} Resolves when the database connection is successful.
     */
    async _openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'name' });
                }
            };
            request.onsuccess = event => {
                this.db = event.target.result;
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }
    /**
     * Load all fonts stored in the database into the application.
     * @returns {Promise} Resolves once fonts are loaded.
     */
    async _loadFontsFromDB() {
        return new Promise(resolve => {
            if (!this.db) return resolve();
            const transaction = this.db.transaction(this.storeName, 'readonly');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.getAll().onsuccess = async event => { // <-- Make this async
                const storedFonts = event.target.result;
                // Reset the font list, keeping only the embedded font.
                this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
                // Use Promise.all to await all font injections from DB
                await Promise.all(storedFonts.map(async font => {
                    this.loadedFonts.push(font);
                    const type = font.mimeType || font.data.type;
                    const format = this._getFormatFromType(type);
                    await this._injectCSS(font.name, URL.createObjectURL(font.data), format);
                }));
                this._notify();
                resolve();
            };
        });
    }
    /**
     * Determine the CSS format string for a given MIME type.
     * @param {string} mimeType - The MIME type of the font file.
     * @returns {string} The corresponding format string for @font-face.
     */
    _getFormatFromType(mimeType) {
        if (mimeType.includes('woff2')) return "format('woff2')";
        if (mimeType.includes('woff')) return "format('woff')";
        if (mimeType.includes('opentype') || mimeType.includes('otf')) return "format('opentype')";
        return "format('truetype')";
    }
    /**
     * Import a custom font into the database and inject it as a CSS @font-face.
     * @param {File} file - The font file to import.
     */
    importFont(file) {
        const reader = new FileReader();
        reader.onload = event => {
            const blob = new Blob([event.target.result], { type: file.type });
            const fontName = `CustomFont_${Date.now()}`; // Unique font name.
            const record = {
                name: fontName,
                display: file.name,
                data: blob,
                mimeType: file.type,
            };
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.put(record).onsuccess = () => {
                const format = this._getFormatFromType(file.type);
                this._injectCSS(fontName, URL.createObjectURL(blob), format);
                this.loadedFonts.push(record);
                this.config.set('fontFamily', fontName);
                this._notify();
                this.notifications.show(`Imported: ${file.name}`, 'success');
            };
            transaction.onerror = () => {
                this.notifications.show('Database Write Failed', 'error');
            };
        };
        reader.readAsArrayBuffer(file);
    }
    /**
     * Delete a font by its ID from the database and the DOM.
     * @param {string} id - The ID of the font to delete.
     * @returns {Promise} Resolves once the font is deleted.
     */
    deleteFont(id) {
        return new Promise(resolve => {
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.delete(id).onsuccess = () => {
                document.getElementById(`style-${id}`)?.remove();
                this.loadedFonts = this.loadedFonts.filter(font => font.name !== id);
                if (this.config.state.fontFamily === id) {
                    this.config.set('fontFamily', this.config.defaults.fontFamily);
                }
                this._notify();
                resolve();
            };
        });
    }
    /**
     * Clear all fonts from the database and only keep embedded fonts.
     * @returns {Promise} Resolves once all fonts are deleted.
     */
    deleteAllFonts() {
        return new Promise(resolve => {
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.clear().onsuccess = () => {
                // Remove all non-embedded fonts.
                this.loadedFonts
                    .filter(font => !font.isEmbedded)
                    .forEach(font => document.getElementById(`style-${font.name}`)?.remove());
                // Keep only embedded fonts.
                this.loadedFonts = this.loadedFonts.filter(font => font.isEmbedded);
                this._notify();
                resolve();
            };
        });
    }
}
    // =========================================================================
    // 9.0 UI MANAGER
    // =========================================================================
// --- NotificationManager.js ---
class NotificationManager {
    constructor() {
        this.container = document.getElementById('toast-container') || this._createContainer();
    }
    /**
     * Creates and initializes the toast container if it doesn't exist.
     * @returns {HTMLElement} The toast container DOM element.
     */
    _createContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.setAttribute('aria-live', 'polite'); // Accessibility: Announce updates to screen readers.
        container.setAttribute('role', 'status'); // Accessibility: Define the type of content the container holds.
        document.body.appendChild(container);
        return container;
    }
    /**
     * Displays a notification with the specified message and type.
     * @param {string} message - The message to display in the notification.
     * @param {string} [type='info'] - The type of the notification ('info', 'success', 'error', etc.).
     * @param {number} [duration=3000] - The duration (in milliseconds) for the notification to be visible.
     */
    show(message, type = 'info', duration = 3000) {
        // Create the notification element.
        const toast = this._createToast(message, type);
        // Ensure the container is attached.
        if (!document.body.contains(this.container)) {
            document.body.appendChild(this.container);
        }
        // Add the notification to the container and apply the "visible" class for animation.
        this.container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        // Set timers for hiding and removing the notification.
        this._scheduleToastRemoval(toast, duration);
    }
    /**
     * Creates an individual toast element.
     * @private
     * @param {string} message - The message to display.
     * @param {string} type - The type of the notification.
     * @returns {HTMLElement} The toast DOM element.
     */
    _createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast-msg toast-${type}`;
        toast.textContent = message;
        toast.setAttribute('role', 'alert'); // Accessibility: Specify that this is an alert message.
        return toast;
    }
    /**
     * Schedules the removal of the notification after the specified duration.
     * Handles smooth animation states before removing the DOM element.
     * @private
     * @param {HTMLElement} toast - The toast element to remove.
     * @param {number} duration - How long the toast remains visible.
     */
    _scheduleToastRemoval(toast, duration) {
        setTimeout(() => {
            // Trigger fade-out animation by removing the "visible" class.
            toast.classList.remove('visible');
            // Remove the toast element from the DOM after the animation completes.
            setTimeout(() => toast.remove(), 300); // Matches CSS animation transition time.
        }, duration);
    }
}
    // =========================================================================
    // 2.0 CONFIGURATION MANAGER 
    // =========================================================================
// --- UIManager.js ---
class UIManager {
    constructor(c, effects, fonts, notificationMgr) {
        // Core dependencies and state
        this.c = c;
        this.effects = effects; // Renamed from this.eff for clarity, consistency
        this.fonts = fonts;
        this.notifications = notificationMgr;
        this.dom = this._initializeDOM();
        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 };
        this.ignoreNextClick = false; // Retain existing logic for drag/click distinction
        this.defs = this._generateDefinitions();
        // Event subscriptions
        this.c.subscribe((key, state) => this.refresh(key));
        this.fonts.subscribe(() => this.refresh('fontFamily'));
        // Initialization
        this.init();
    }
    /**
     * Establish initial DOM structure using expected selectors and IDs.
     * @private
     */
    _initializeDOM() {
        return {
            panel: document.getElementById('settingsPanel'),
            toggle: document.getElementById('menuToggle'),
            tabs: document.getElementById('navTabs'),
            content: document.getElementById('contentArea'),
            tooltip: document.getElementById('ui-tooltip') || this._createTooltip(),
            track: null, // Initialized later in init
        };
    }
    /**
     * Create the tooltip element and attach to the DOM.
     * @private
     */
    _createTooltip() {
        const tooltip = document.createElement('div');
        tooltip.id = 'ui-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
    }
    /**
     * Generate all UI component definitions for settings dynamically.
     * This method orchestrates the gathering of definitions from category-specific methods.
     * @private
     */
    _generateDefinitions() {
        return [
            { cat: 'Global', type: 'accordion_header', label: 'Code Basics' },
            { cat: 'Global', id: 'streamPalette', type: 'color_list', label: 'Code Colors', max: 3 },
            { cat: 'Global', id: 'paletteBias', type: 'range', label: 'Color Mix', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'% Mix', description: "Left: Solid Streams. Right: Random Characters. Middle: Blend." },
            ...this._generateGlobalSettings(),
            // APPEARANCE TAB
            ...this._generateAppearanceSettings(),
            // BEHAVIOR TAB
            ...this._generateBehaviorSettings(),
            // FX TAB
            ...this._generateFXSettings(),
            // SYSTEM TAB
            ...this._generateSystemTab()
        ];
    }
    /**
     * Generates definitions for the 'Global' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateGlobalSettings() {
        return [
            { cat: 'Global', id: 'tracerColor', type: 'color', label: 'Tracer Color', description: "The head of the stream that writes the code to the screen" },
            { cat: 'Global', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, unit: 'px' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20 },
            { cat: 'Global', id: 'releaseInterval', type: 'range', label: 'Event Timer', description: "For synchronized events (like tracer release) this is the interval between events.", min: 1, max: 10, step: 1 },
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'enableGlyphAtlas', type: 'checkbox', label: 'Performance pre-render' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: 'smoothingEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'Appearance' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateAppearanceSettings() {
        return [
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Details' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'fontWeight', type: 'select', label: 'Weight', options: [{label:'Thin',value:'100'},{label:'Light',value:'300'},{label:'Normal',value:'normal'},{label:'Bold',value:'bold'},{label:'Heavy',value:'900'}] , description: "If font supported; Bold should work but light/thin may not, depending on the font."},
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Allows for brightness variance when characters are written' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolving Stream Trails' }, 
            { cat: 'Appearance', id: 'dissolveMinSize', type: 'range', label: 'Dissolve Size', min: 1, max: 20, unit:'px', dep: 'dissolveEnabled', description: 'Higher numbers on smaller fonts will expand the trail instead of dissolve' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Trail Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghosting Offset', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Imposition Layer' },
            { cat: 'Appearance', id: 'overlapEnabled', type: 'checkbox', label: 'Enable Overlap' },
            { cat: 'Appearance', id: 'overlapColor', type: 'color', label: 'Overlap Color', dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapDensity', type: 'range', label: 'Overlap Density', min: 0.1, max: 1.0, step: 0.1, dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapTarget', type: 'select', label: 'Overlap Target', options: [{label:'Streams Only',value:'stream'},{label:'All Characters',value:'all'}], dep: 'overlapEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.05, max: 1.0, step: 0.05, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        ];
    }
    /**
     * Generates definitions for the 'Behavior' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateBehaviorSettings() {
        return [
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'ttlMinSeconds', type: 'range', label: 'Minimum Stream Life', min: 0.5, max: 20, step: 0.5, unit: 's' },
            { cat: 'Behavior', id: 'ttlMaxSeconds', type: 'range', label: 'Maximum Stream Life', min: 1, max: 30, step: 0.5, unit: 's' },
            { cat: 'Behavior', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 120, unit:'fr' },
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1, description: "Maximum number of tracers released per-cycle" },
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, dep: 'invertedTracerEnabled', description: "Invisible tracers that start erasing code" },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 5, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Before Eraser', min: 5, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps in Code Stream', min: 0, max: 0.5, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Tracers that only write occassional characters" },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Frequency', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 0.2, step: 0.01, dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: "Lock the rotator change to the cycles that move the tracers" },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'FX' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateFXSettings() {
        return [
            { cat: 'FX', type: 'header', label: 'Movie FX' }, // Using header for main section
            { cat: 'FX', type: 'accordion_header', label: 'Pulse' },
            { cat: 'FX', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'FX', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'FX', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'pulseEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Preserve Tracer Glow', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseDimming', type: 'range', label: 'Initial Dim Amount', min: 0.0, max: 1.0, step: 0.05, dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'pulseEnabled', description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: 'pulseEnabled' },
            { cat: 'FX', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'pulseEnabled', description: "Start at a full square" },
            { cat: 'FX', id: 'pulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: 'pulseEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Clear Pulse' },
            { cat: 'FX', type: 'button', label: 'Trigger Clear Pulse Now', action: 'clearpulse', class: 'btn-warn' },
            { cat: 'FX', id: 'clearPulseEnabled', type: 'checkbox', label: 'Enable Clear Pulse' },
            { cat: 'FX', id: 'clearPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'clearPulseEnabled', description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: 'clearPulseEnabled' },
            { cat: 'FX', id: 'clearPulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'clearPulseEnabled', description: "Start at a full square" },
            { cat: 'FX', id: 'clearPulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: 'clearPulseEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Pulse Storm' },
            { cat: 'FX', type: 'button', label: 'Trigger Pulse Storm Now', action: 'minipulse', class: 'btn-warn' },
            { cat: 'FX', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'FX', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'miniPulseEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulseThickness', type: 'range', label: 'Wave Width', min: 10, max: 100, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
            { cat: 'FX', id: 'miniPulseSize', type: 'range', label: 'Blast Size Max', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Deja Vu' },
            { cat: 'FX', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'FX', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'FX', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuMinRectHeight', type: 'range', label: 'Minimum Thickness', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Maximum Thickness', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuHoleBrightness', type: 'range', label: 'Intensity', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Enable Color Writing', dep: 'dejaVuEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuIntensity', type: 'range', label: 'Flash Frequency', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Length', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'FX', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Length Variance', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Superman' },
            { cat: 'FX', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'FX', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman FX' },
            { cat: 'FX', id: 'supermanFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'supermanEnabled' },
            { cat: 'FX', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'supermanEnabled' },
            { cat: 'FX', id: 'supermanIncludeColors', type: 'checkbox', label: 'Additional Glow', dep: 'supermanEnabled' },
            { cat: 'FX', id: 'supermanFadeSpeed', type: 'range', label: 'Fade Duration', min: 5, max: 60, dep: 'supermanEnabled', description: 'Higher values mean trails last longer.' },
            { cat: 'FX', id: 'supermanGlow', type: 'range', label: 'Voltage Glow', min: 1, max: 10, dep: 'supermanEnabled' },
            { cat: 'FX', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 10, step: 1, dep: 'supermanEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'supermanEnabled' },
            { cat: 'FX', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'FX', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 10, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'FX', id: 'supermanSpawnSpeed', type: 'range', label: 'Bolt Speed', min: 10, max: 100, dep: 'supermanEnabled', description: 'Speed from left to right' },
            { cat: 'FX', type: 'header', label: 'Special FX' }, // Header for Special FX
            { cat: 'FX', type: 'accordion_header', label: 'Star Power' },
            { cat: 'FX', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'FX', id: 'starPowerFreq', type: 'range', label: 'Frequency', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerGlitter', type: 'checkbox', label: 'Glitter', dep: 'starPowerEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Feel', dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'FX', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Rainbow Streams' },
            { cat: 'FX', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'FX', id: 'rainbowStreamChance', type: 'range', label: 'Frequency', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'FX', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
            { cat: 'FX', type: 'accordion_header', label: 'Firewall Anomaly' }, 
            { cat: 'FX', type: 'button', label: 'Trigger Firewall Now', action: 'firewall', class: 'btn-info' },
            { cat: 'FX', id: 'firewallEnabled', type: 'checkbox', label: 'Enable Firewall FX' },
            { cat: 'FX', id: 'firewallFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 300, step: 10, unit: 's', dep: 'firewallEnabled' },
            { cat: 'FX', type: 'accordion_subheader', label: 'Look', dep: 'firewallEnabled' },
            { cat: 'FX', id: 'firewallRandomColorEnabled', type: 'checkbox', label: 'Random Color', dep: 'firewallEnabled' },
            { cat: 'FX', id: 'firewallColor', type: 'color', label: 'Firewall Color', dep: ['firewallEnabled', '!firewallRandomColorEnabled'] },
            { cat: 'FX', id: 'firewallReverseDurationFrames', type: 'range', label: 'Reverse Duration', min: 5, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the code reverses before erasure.' },
            { cat: 'FX', id: 'firewallEraseDurationFrames', type: 'range', label: 'Erase Flash Duration', min: 10, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the column flashes white/red before clearing.' },
        ];
    }
    /**
     * Generates definitions for the 'System' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateSystemTab() {
        return [
            { cat: 'System', type: 'accordion_header', label: 'Config' },
            { cat: 'System', type: 'slot', idx: 0 },
            { cat: 'System', type: 'slot', idx: 1 },
            { cat: 'System', type: 'slot', idx: 2 },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
            { cat: 'System', type: 'accordion_header', label: 'Maintenance' },
            { cat: 'System', type: 'info_description', text: 'Clears the current font cache, and resets all font entries to default' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' },
            { cat: 'System', type: 'accordion_header', label: 'FAQ' },
            { cat: 'System', type: 'faq_item', question: 'What is this?', answer: 'This is a highly customizable Matrix Digital Rain simulation built with HTML5 Canvas and JavaScript.' },
            { cat: 'System', type: 'faq_item', question: 'How do I change the code?', answer: 'Use the settings panel on the right side of the screen to customize various aspects like colors, speeds, and effects.' },
            { cat: 'System', type: 'faq_item', question: 'Can I use my own font?', answer: 'Yes, go to the "Appearance" tab, under "Character Details" you can import your own TTF or OTF font file.' },
            { cat: 'System', type: 'faq_item', question: 'Why is it sometimes slow?', answer: 'Performance depends on your device and settings. Try reducing "Resolution Scale" or disabling some effects under the "FX" tab.' },
            { cat: 'System', type: 'faq_item', question: 'Is this more AI slop?', answer: 'Yes and no. LLM\'s were definitely used to make this, but the person who programmed it is a real person, and much of the code was hand-written, not just \'vibe coded\'. It\'s not perfect, but it\'s being slowly improved.' }
        ];
    }
    /**
     * Initialize the events, tabs, and UI components.
     */
    init() {
        // Toggle button for the settings panel
        this.dom.toggle.onclick = () => this.togglePanel();
        // Create and populate tabs and content containers
        this._setupTabs();
        // Update footer version
        document.getElementById('globalStatus').textContent = `Matrix Code v${APP_VERSION}`;
        // Initialize File Input Handlers
        this._setupFileHandlers();
        // Handle tab dragging and horizontal scrolling
        this._setupTabScroll();
        // Refresh UI
        this.refresh('ALL');
    }
    /**
     * Toggles the settings panel visibility.
     */
    togglePanel() {
        const isOpen = this.dom.panel.classList.toggle('open');
        this.dom.panel.setAttribute('aria-hidden', !isOpen);
        this.dom.toggle.setAttribute('aria-expanded', isOpen);
    }
    /**
     * Sets up the tabs and their corresponding content containers.
     * Creates category tabs and assigns content containers to each.
     * @private
     */
    _setupTabs() {
        this.dom.track = document.createElement('div'); // Initialize track here
        this.dom.track.id = 'tabTrack';
        this.dom.tabs.appendChild(this.dom.track);
        const categories = [...new Set(this.defs.map(def => def.cat))];
        const tabContentContainers = {}; // Mapping of category -> content container div
        // Create tabs and attach event handlers
        categories.forEach((category, index) => {
            const tabButton = this._createTabButton(category, index === 0);
            this.dom.track.appendChild(tabButton);
            // Create corresponding content container for the tab
            const contentContainer = this._createTabContentContainer(category, index === 0);
            this.dom.content.appendChild(contentContainer);
            tabContentContainers[category] = contentContainer;
        });
        // Populate tab content
        this._populateTabContent(tabContentContainers);
    }
    /**
     * Creates a tab button element for a category.
     * @private
     * @param {string} category - The category name for the tab.
     * @param {boolean} isActive - Whether the tab should be active by default.
     * @returns {HTMLElement} The created tab button element.
     */
    _createTabButton(category, isActive) {
        const button = document.createElement('button');
        button.className = `tab-btn ${isActive ? 'active' : ''}`;
        button.textContent = category;
        button.onclick = () => this._handleTabClick(category, button);
        return button;
    }
    /**
     * Handles when a tab is clicked and activates the corresponding tab content.
     * @private
     * @param {string} category - The category associated with the clicked tab.
     * @param {HTMLElement} button - The clicked tab button element.
     */
    _handleTabClick(category, button) {
        // Use this.scrollState.dragDistance for distinguishing drag from click
        if (this.scrollState.dragDistance > 3) {
            this.scrollState.dragDistance = 0; // Reset for next interaction
            return; 
        }
        // Deactivate all tabs and their content
        this.dom.tabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.dom.content.querySelectorAll('.tab-content-group').forEach(content => content.classList.remove('active'));
        // Activate selected tab and content
        button.classList.add('active');
        document.getElementById(`tab-content-${category}`).classList.add('active');
    }
    /**
     * Creates a tab content container for a given category.
     * @private
     * @param {string} category - The category name for the content container.
     * @param {boolean} isActive - Whether the content container should be active by default.
     * @returns {HTMLElement} The created tab content container element.
     */
    _createTabContentContainer(category, isActive) {
        const container = document.createElement('div');
        container.className = `tab-content-group ${isActive ? 'active' : ''}`;
        container.id = `tab-content-${category}`;
        return container;
    }
    /**
     * Populates tabs with content, including accordions and controls.
     * @private
     * @param {Object} tabContentContainers - A map of category names to their content container elements.
     */
    _populateTabContent(tabContentContainers) {
        let currentAccordionBody = null;
        let lastCat = null;
        this.defs.forEach(def => {
            const container = tabContentContainers[def.cat];
            if (!container) return;
            // Reset accordion context when switching tabs/categories
            if (def.cat !== lastCat) {
                currentAccordionBody = null;
                lastCat = def.cat;
            }
            // Handle Accordion Headers (Start new accordion)
            if (def.type === 'accordion_header') {
                currentAccordionBody = this._createAccordion(container, def.label);
                return;
            } 
            // Handle Accordion Subheaders
            else if (def.type === 'accordion_subheader') {
                if (currentAccordionBody) {
                    const el = this.renderControl(def);
                    if (el) currentAccordionBody.appendChild(el);
                }
                return;
            }
            // Handle Section Headers (Break out of accordion)
            // Exception: CAUTION ZONE remains inside for special handling below
            if (def.type === 'header' && def.label !== 'CAUTION ZONE') {
                currentAccordionBody = null;
                const el = this.renderControl(def);
                if (el) container.appendChild(el);
                return;
            }
            // Handle Controls
            if (currentAccordionBody) {
                // Special handling for CAUTION ZONE inside an accordion
                if (def.cat === 'System' && def.label === 'CAUTION ZONE' && def.type === 'header') {
                    const cautionZoneDiv = document.createElement('div');
                    cautionZoneDiv.className = 'caution-zone';
                    const headerEl = this.renderControl(def);
                    cautionZoneDiv.appendChild(headerEl);
                    currentAccordionBody.appendChild(cautionZoneDiv);
                } else {
                    if (def.caution) return; // Skip caution items here, handled separately
                    const controlElement = this.renderControl(def);
                    if (controlElement) currentAccordionBody.appendChild(controlElement);
                }
            } else {
                // Orphan controls (outside any accordion) - e.g. top level buttons or headers
                const controlElement = this.renderControl(def);
                if (controlElement) container.appendChild(controlElement);
            }
        });
        // Post-process: Insert Factory Reset into the created Caution Zone
        const factoryResetDef = this.defs.find(d => d.action === 'reset' && d.caution);
        if (factoryResetDef) {
            const cautionZoneDiv = this.dom.content.querySelector('.caution-zone');
            if (cautionZoneDiv) {
                const controlElement = this.renderControl(factoryResetDef);
                if (controlElement) cautionZoneDiv.appendChild(controlElement);
            }
        }
    }
    /**
     * Creates an accordion section with a header and a container for controls.
     * @private
     * @param {HTMLElement} tabContentGroup - The parent container for the accordion.
     * @param {string} label - The label for the accordion header.
     * @returns {HTMLElement} The body element of the created accordion where controls can be appended.
     */
    _createAccordion(tabContentGroup, label) {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.innerHTML = `
            ${label}
            <span class="accordion-icon">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </span>
        `;
        const body = document.createElement('div');
        body.className = 'accordion-content';
        header.onclick = () => this._toggleAccordion(header, body, tabContentGroup);
        accordionItem.appendChild(header);
        accordionItem.appendChild(body);
        tabContentGroup.appendChild(accordionItem);
        // Default open logic: Open if it is the FIRST accordion in this tab
        const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
        if (accordionsInTab.length === 1) { // Only open the very first accordion created
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon').classList.add('rotated');
        }
        return body;
    }
    /**
     * Toggles the visibility of an accordion section and manages sibling accordions.
     * @private
     * @param {HTMLElement} header - The header element of the accordion.
     * @param {HTMLElement} body - The body element of the accordion.
     * @param {HTMLElement} group - The parent group containing all accordions (tabContentGroup).
     */
    _toggleAccordion(header, body, group) {
        const isOpen = body.classList.contains('open');
        // Close other accordions in the group
        group.querySelectorAll('.accordion-content').forEach(siblingBody => {
            siblingBody.classList.remove('open');
            siblingBody.previousElementSibling?.classList.remove('active');
            siblingBody.previousElementSibling?.querySelector('.accordion-icon')?.classList.remove('rotated');
        });
        // Toggle the current accordion
        if (isOpen) {
            body.classList.remove('open');
            header.classList.remove('active');
            header.querySelector('.accordion-icon')?.classList.remove('rotated');
        } else {
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon')?.classList.add('rotated');
        }
    }
    /**
     * Setup input handlers for font and config import.
     * @private
     */
    _setupFileHandlers() {
        document.getElementById('importFile').onchange = e => this._handleConfigImport(e);
        document.getElementById('importFontFile').onchange = e => this._handleFontImport(e);
    }
    /**
     * Handles the import of a JSON configuration file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleConfigImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                // Merge loaded config with defaults to ensure all properties exist
                this.c.state = { ...this.c.defaults, ...data.state };
                this.c.updateDerivedValues();
                this.c.save();
                this.c.notify('ALL');
                this.notifications.show('Configuration Loaded', 'success');
            } catch (error) {
                console.error("Error loading config:", error);
                this.notifications.show('Invalid Configuration File', 'error');
            }
            event.target.value = ''; // Reset input value to allow re-importing the same file
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a custom font file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleFontImport(event) {
        const file = event.target.files[0];
        if (file) this.fonts.importFont(file);
        event.target.value = ''; // Reset input value
    }
    /**
     * Set up drag and scroll functionality for tabs.
     * @private
     */
    _setupTabScroll() {
        const tabs = this.dom.tabs;
        tabs.addEventListener('mousedown', e => this._startDrag(e));
        tabs.addEventListener('mouseleave', () => this._stopDrag());
        tabs.addEventListener('mouseup', () => this._stopDrag());
        tabs.addEventListener('mousemove', e => this._doDrag(e));
        // Ensure overflow handling matches standard behavior for wheel support
        tabs.style.overflowX = 'auto'; 
        tabs.style.overscrollBehaviorX = 'contain';
        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
        tabs.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaX) >= Math.abs(e.deltaY)) {
                return;
            }
            if (e.deltaY !== 0) {
                // preventDefault stops the browser "back" gesture or vertical page scroll
                e.preventDefault(); 
                tabs.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }
    /**
     * Initiates the drag operation for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse down event.
     */
    _startDrag(e) {
        if (e.button !== 0) return; // Only respond to primary click (left mouse button)
        this.scrollState.isDown = true;
        this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft;
        this.scrollState.scrollLeft = this.dom.tabs.scrollLeft;
        this.scrollState.dragDistance = 0;
        this.ignoreNextClick = false; // Reset flag
        this.dom.tabs.style.cursor = 'grabbing';
    }
    /**
     * Stops the drag operation for tab scrolling.
     * @private
     */
    _stopDrag() {
        this.scrollState.isDown = false;
        this.dom.tabs.style.cursor = 'grab';
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Handles the drag movement for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse move event.
     */
    _doDrag(e) {
        if (!this.scrollState.isDown) return;
        e.preventDefault(); // Prevent text highlighting during drag
        const x = e.pageX - this.dom.tabs.offsetLeft;
        const walk = (x - this.scrollState.startX) * 1.5; // Multiplier for faster scrolling
        this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk;
        this.scrollState.dragDistance = Math.abs(x - this.scrollState.startX); // Update based on actual movement
        if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; // Set flag if dragged enough to be considered a drag
    }
    /**
     * Retrieves the list of available fonts, including embedded and custom fonts.
     * @private
     * @returns {Array<Object>} An array of font objects suitable for select options.
     */
    _getFonts() {
        return [
            {label:'Gothic (Win)', value:'"MS Gothic", monospace'},
            {label:'Console', value:'Consolas, monaco, monospace'},
            ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true}))
        ];
    }
    /**
     * Updates the UI list of custom fonts (used in the font manager section).
     * @param {HTMLElement} el - The DOM element to populate with the font list.
     */
    updateFontList(el) {
        el.innerHTML = '';
        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
            const div = document.createElement('div');
            div.className = 'font-item';
            div.innerHTML = `<span class="font-name">${f.display}</span>`;
            const btn = document.createElement('div');
            btn.className = 'font-delete-btn';
            btn.innerHTML = '×';
            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
            div.appendChild(btn);
            el.appendChild(div);
        });
    }
    /**
     * Displays a tooltip with a given text near a target element.
     * @param {string} text - The text to display in the tooltip.
     * @param {HTMLElement} target - The element relative to which the tooltip should be positioned.
     */
    showTooltip(text, target) {
        this.dom.tooltip.textContent = text;
        this.dom.tooltip.classList.add('visible');
        const rect = target.getBoundingClientRect();
        const tipRect = this.dom.tooltip.getBoundingClientRect();
        let top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        let left = rect.left - tipRect.width - 12; // Default to left of target
        // Adjust position if it goes off-screen
        if (top < 10) top = 10;
        if (left < 10) left = rect.right + 12; // Move to right if it's too far left
        this.dom.tooltip.style.top = `${top}px`;
        this.dom.tooltip.style.left = `${left}px`;
    }
    /**
     * Hides the currently displayed tooltip.
     */
    hideTooltip() {
        this.dom.tooltip.classList.remove('visible');
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Creates a styled label group for a UI control, optionally including an info icon with a tooltip.
     * @param {Object} def - The definition object for the UI control.
     * @returns {HTMLElement} The created label group DOM element.
     */
    createLabelGroup(def) {
        const group = document.createElement('div');
        group.className = 'control-label-group';
        const text = document.createElement('span');
        text.textContent = def.label;
        group.appendChild(text);
        if (def.description) {
            const icon = document.createElement('span');
            icon.className = 'info-icon';
            icon.textContent = '?';
            const show = (e) => this.showTooltip(def.description, e.target);
            icon.onmouseenter = show;
            icon.onmouseleave = () => this.hideTooltip();
            // Handle touch events for mobile tooltips
            icon.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                if (this.dom.tooltip.classList.contains('visible')) { 
                    this.hideTooltip(); 
                } else { 
                    show(e); 
                    // Automatically hide tooltip after a short delay on touch devices
                    setTimeout(() => this.hideTooltip(), 3000); 
                } 
            });
            group.appendChild(icon);
        }
        return group;
    }
    /**
     * Renders the content of a color list control into the provided wrapper.
     * @private
     * @param {HTMLElement} wrapper - The container element.
     * @param {Object} def - The control definition.
     */
    _renderColorList(wrapper, def) {
        wrapper.innerHTML = '';
        const palette = this.c.get(def.id) || ["#00FF00"];
        palette.forEach((color, idx) => {
            const item = document.createElement('div');
            item.className = 'color-list-item';
            const cInput = document.createElement('input');
            cInput.type = 'color';
            cInput.value = color;
            cInput.oninput = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.set(def.id, newP);
            };
            item.appendChild(cInput);
            if (palette.length > 1 && idx > 0) {
                const delBtn = document.createElement('div');
                delBtn.className = 'btn-icon-remove';
                delBtn.textContent = '×';
                delBtn.onclick = () => {
                    const newP = this.c.get(def.id).filter((_, i) => i !== idx);
                    this.c.set(def.id, newP);
                    this._renderColorList(wrapper, def);
                    this.refresh('streamPalette');
                };
                item.appendChild(delBtn);
            }
            wrapper.appendChild(item);
        });
        if (palette.length < (def.max || 3)) {
            const addBtn = document.createElement('div');
            addBtn.className = 'btn-icon-add';
            addBtn.textContent = '+';
            addBtn.onclick = () => {
                const newP = [...this.c.get(def.id), "#ffffff"];
                this.c.set(def.id, newP);
                this._renderColorList(wrapper, def);
                this.refresh('streamPalette');
            };
            wrapper.appendChild(addBtn);
        }
    }
    /**
     * Dynamically renders a UI control element based on its definition.
     * @param {Object} def - The definition object for the control.
     * @returns {HTMLElement|null} The created control element, or null if it's an accordion header.
     */
    renderControl(def) {
        if (def.type === 'accordion_header') { return null; }
        if (def.type === 'accordion_subheader') {
            const el = document.createElement('div');
            el.className = 'accordion-subheader';
            el.textContent = def.label;
            if(def.dep) el.setAttribute('data-dep', JSON.stringify(def.dep));
            return el;
        }
        if (def.type === 'header') {
            const el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; return el;
        }
        if (def.type === 'about_content') {
            const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
            const logoChar = Utils.getRandomKatakanaChar();
            const initialColor = this.c.get('streamColor');
            const initialSvgDataUrl = Utils.generateGlyphSVG(logoChar, initialColor, 48, this.c.get('fontFamily'));
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <img id="matrixLogo" src="${initialSvgDataUrl}" alt="Matrix Logo" style="height: 48px; width: 48px; margin-right: 10px;"/>
                    <h3 style="margin:0; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                </div>
                <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
            return div;
        }
        if (def.type === 'info_description') {
            const div = document.createElement('div');
            div.className = 'info-description';
            div.textContent = def.text;
            return div;
        }
        if (def.type === 'faq_item') {
            const container = document.createElement('div');
            container.className = 'faq-item';
            const question = document.createElement('div');
            question.className = 'faq-question';
            question.textContent = def.question;
            const answer = document.createElement('div');
            answer.className = 'faq-answer';
            answer.textContent = def.answer;
            container.appendChild(question);
            container.appendChild(answer);
            return container;
        }
        const row = document.createElement('div');
        if (def.type === 'button') {
            const btn = document.createElement('button'); btn.className = `action-btn ${def.class||'btn-info'}`; btn.textContent = def.label; btn.id = `btn-${def.action}`; btn.name = def.action; btn.onclick = () => this.handleAction(def.action); row.appendChild(btn);
        } else if (def.type === 'slot') {
            row.className = 'slot-container';
            const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[def.idx].name; inp.id = `slot-input-${def.idx}`; inp.name = `slot_name_${def.idx}`; inp.onchange = e => this.c.renameSlot(def.idx, e.target.value);
            inp.onfocus = e => e.target.value = '';
            const grp = document.createElement('div'); grp.className = 'slot-btn-group';
            const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${def.idx}`; save.onclick = () => { this.c.saveToSlot(def.idx); this.notifications.show(`Saved Slot ${def.idx+1}`, 'success'); };
            const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${def.idx}`; load.onclick = () => { if(this.c.loadFromSlot(def.idx)) this.notifications.show(`Loaded Slot ${def.idx+1}`, 'success'); };
            grp.append(save, load); row.append(inp, grp);
        } else if (def.type === 'font_list') {
            row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
        } else {
            row.className = def.type === 'checkbox' ? 'checkbox-row' : 'control-row';
            const labelGroup = this.createLabelGroup(def);
            if(def.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
            if(!def.hideValue && def.type === 'range') { const valDisp = document.createElement('span'); valDisp.id = `val-${def.id}`; hdr.appendChild(valDisp); } row.appendChild(hdr); } 
                else { row.appendChild(labelGroup); }
            let inp;
            if(def.type === 'range') { 
                inp = document.createElement('input'); 
                inp.type = 'range'; 
                inp.min=def.min; 
                inp.max=def.max; 
                if(def.step) inp.step=def.step; 
                let isTouching = false;
                inp.value = def.invert ? (def.max+def.min)-this.c.get(def.id) : this.c.get(def.id);                            
                inp.oninput = e => { 
                    if (isTouching) return; // Block native updates during touch interaction
                    const v = parseFloat(e.target.value); 
                    let actual = def.invert ? (def.max+def.min)-v : v; 
                    // Sanitize to max 1 decimal place for state
                    if (typeof actual === 'number') actual = parseFloat(actual.toFixed(1));
                    this.c.set(def.id, actual); 
                    const disp = document.getElementById(`val-${def.id}`); 
                    if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                }; 
                let startX = 0;
                let startY = 0;
                let startValue = 0;
                let isHorizontalDrag = false;
                inp.addEventListener('touchstart', e => {
                    isTouching = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(e.target.value);
                    isHorizontalDrag = false;
                    // Prevent "jump to tap" visually
                    requestAnimationFrame(() => {
                        inp.value = startValue;
                    });
                }, { passive: false });
                inp.addEventListener('touchmove', e => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    const dx = x - startX;
                    const dy = y - startY;
                    if (!isHorizontalDrag && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 5) {
                        isHorizontalDrag = true;
                    }
                    if (isHorizontalDrag) {
                        e.preventDefault(); 
                        const rect = inp.getBoundingClientRect();
                        const relativeX = Math.min(Math.max(0, x - rect.left), rect.width);
                        const percent = relativeX / rect.width;
                        const min = parseFloat(def.min);
                        const max = parseFloat(def.max);
                        let newVal = min + (percent * (max - min));
                        if (def.step) {
                            const step = parseFloat(def.step);
                            newVal = Math.round(newVal / step) * step;
                        }
                        if (newVal < min) newVal = min;
                        if (newVal > max) newVal = max;
                        inp.value = newVal;
                        let actual = def.invert ? (max+min)-newVal : newVal; 
                        // Sanitize
                        if (typeof actual === 'number') actual = parseFloat(actual.toFixed(1));
                        this.c.set(def.id, actual); 
                        const disp = document.getElementById(`val-${def.id}`); 
                        if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                    }
                }, { passive: false });
                inp.addEventListener('touchend', () => {
                    isTouching = false;
                    isHorizontalDrag = false;
                });
            }
            else if(def.type === 'color') { const w = document.createElement('div'); w.className = 'color-wrapper'; inp = document.createElement('input'); inp.type = 'color'; inp.value = this.c.get(def.id); inp.id = `in-${def.id}`; inp.name = def.id; inp.oninput = e => this.c.set(def.id, e.target.value); w.appendChild(inp); row.appendChild(w); if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`; return row; }
            else if(def.type === 'color_list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'color-list-wrapper';
                wrapper.id = `in-${def.id}`;
                this._renderColorList(wrapper, def);
                row.appendChild(wrapper);
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`;
                return row;
            }
            else if(def.type === 'checkbox') { inp = document.createElement('input'); inp.type = 'checkbox'; inp.checked = this.c.get(def.id); inp.onchange = e => this.c.set(def.id, e.target.checked); row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; }
            else if(def.type === 'select') { inp = document.createElement('select'); (typeof def.options === 'function' ? def.options() : def.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(def.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(def.id, e.target.value); }
            row.appendChild(inp);
            if(def.id) { inp.id = `in-${def.id}`; inp.name = def.id; }
            if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`;
        }
        return row;
    }
    /**
     * Handles UI actions triggered by buttons or other interactive elements.
     * @param {string} action - The action identifier.
     */
    handleAction(action) {
        if(action === 'reset' && confirm('Reset all settings?')) this.c.reset();
        if(action === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts().then(() => this.notifications.show('Cache Cleared', 'success'));
        if(action === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state}, `matrix_conf_v${APP_VERSION}.json`);
        if(action === 'import') document.getElementById('importFile').click();
        if(action === 'importFont') document.getElementById('importFontFile').click();
        if(action === 'pulse') { if(this.effects.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
        if(action === 'clearpulse') { if(this.effects.trigger('ClearPulse')) this.notifications.show('Clear Pulse Triggered', 'success'); else this.notifications.show('Clear Pulse active...', 'info'); }
        if(action === 'minipulse') { if(this.effects.trigger('MiniPulse')) this.notifications.show('Pulse Storm Triggered', 'success'); else this.notifications.show('Pulse Storm active...', 'info'); }
        if(action === 'dejavu') { if(this.effects.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
        if(action === 'superman') { if(this.effects.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
        if(action === 'firewall') { if(this.effects.trigger('Firewall')) this.notifications.show('Firewall Breach Detected', 'danger'); else this.notifications.show('Firewall active...', 'info'); 
        }
    }
    /**
     * Refreshes the UI to reflect current configuration settings.
     * @param {string} key - The specific configuration key to refresh, or 'ALL' to refresh all controls.
     */
    refresh(key) {
        try {
            if(key === 'ALL') { 
                this.defs.forEach(d => { if(d.id) this.refresh(d.id); }); 
                this.refresh('fontFamily'); // Special refresh for font list
                this.dom.content.querySelectorAll('.accordion-content').forEach(accordionBody => {
                    const allDepRows = accordionBody.querySelectorAll('[data-dep]');
                    allDepRows.forEach(row => {
                        try {
                            const depRule = JSON.parse(row.getAttribute('data-dep')); 
                            const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                            let conditionsMet = true;
                            for (let rule of rules) { 
                                let target = rule; 
                                let expected = true; 
                                if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                                const actual = !!this.c.get(target); 
                                if (actual !== expected) { conditionsMet = false; break; } 
                            }
                            if(conditionsMet) row.classList.remove('control-disabled'); 
                            else row.classList.add('control-disabled');
                        } catch(e) { console.warn("Error processing dependency row:", e); }
                    });
                });
                return; 
            }
            if(key === 'fontFamily') {
                const sel = document.getElementById('in-fontFamily');
                if(sel) { 
                    sel.innerHTML = ''; 
                    this._getFonts().forEach(o => { 
                        const opt = document.createElement('option'); 
                        opt.value = o.value; 
                        opt.textContent = o.label; 
                        if(o.custom) opt.className = 'custom-font-opt'; 
                        if(this.c.get('fontFamily') === o.value) opt.selected = true; 
                        sel.appendChild(opt); 
                    }); 
                }
                const list = document.getElementById('fontListUI'); 
                                if (list) this.updateFontList(list); 
                                // Update logo when font family changes, re-randomize char
                                const logo = document.getElementById('matrixLogo');
                                if (logo) {
                                    const randomChar = Utils.getRandomKatakanaChar();
                                    const currentColor = this.c.get('streamColor');
                                    logo.src = Utils.generateGlyphSVG(randomChar, currentColor, 48, this.c.get('fontFamily'));
                                }
                                const favicon = document.getElementById('favicon');
                                if (favicon) {
                                    const randomChar = Utils.getRandomKatakanaChar();
                                    const currentColor = this.c.get('streamColor');
                                    favicon.href = Utils.generateGlyphSVG(randomChar, currentColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                                }
                                return;
                            }
            if (key === 'streamColor') {
                const logo = document.getElementById('matrixLogo');
                if (logo) {
                    const randomChar = Utils.getRandomKatakanaChar(); // Re-randomize char on color change too
                    const currentColor = this.c.get('streamColor');
                    logo.src = Utils.generateGlyphSVG(randomChar, currentColor, 48, this.c.get('fontFamily'));
                }
                const favicon = document.getElementById('favicon');
                if (favicon) {
                    const randomChar = Utils.getRandomKatakanaChar();
                    const currentColor = this.c.get('streamColor');
                    favicon.href = Utils.generateGlyphSVG(randomChar, currentColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                }
            }
            if (key === 'streamPalette') {
                 const palette = this.c.get('streamPalette');
                 const biasRow = document.getElementById('row-paletteBias');
                 if (biasRow) {
                     if (palette && palette.length > 1) {
                         biasRow.classList.remove('control-disabled');
                     } else {
                         biasRow.classList.add('control-disabled');
                     }
                 }
                 // Re-render the list itself if needed? 
                 // Actually the _renderColorList calls refresh implicitly by updating DOM? 
                 // No, _renderColorList updates DOM directly. 
                 // But we need to update the Bias slider state.
            }
            if(key) {
                const inp = document.getElementById(`in-${key}`);
                if(inp) { 
                    const def = this.defs.find(d=>d.id===key); 
                    if(def) { 
                        const val = this.c.get(key); 
                        if(def.type === 'checkbox') inp.checked = val; 
                        else if(def.type === 'color_list') this._renderColorList(inp, def);
                        else if(def.type === 'range') { 
                            inp.value = def.invert ? (def.max+def.min)-val : val; 
                            const disp = document.getElementById(`val-${key}`); 
                            if(disp) {
                                let displayVal = val;
                                if (!def.transform && typeof val === 'number') {
                                    displayVal = parseFloat(val.toFixed(1));
                                }
                                disp.textContent = def.transform ? def.transform(val) : displayVal + (def.unit || ''); 
                            }
                        } else {
                            inp.value = val;
                        }
                    } 
                }
            }
            // Update dependents
            this.dom.content.querySelectorAll(`[data-dep*="${key}"]`).forEach(row => {
                try {
                    const depRule = JSON.parse(row.getAttribute('data-dep')); 
                    const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                    let conditionsMet = true;
                    for (let rule of rules) { 
                        let target = rule; 
                        let expected = true; 
                        if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                        const actual = !!this.c.get(target); 
                        if (actual !== expected) { conditionsMet = false; break; } 
                    }
                    if(conditionsMet) row.classList.remove('control-disabled'); 
                    else row.classList.add('control-disabled');
                } catch(e) { console.warn("Error processing dependency row:", e); }
            });
        } catch(e) { console.warn("UI Refresh Error:", e); }
    }
}
    // =========================================================================
    // 10.0 MATRIX KERNEL
    // =========================================================================
// --- MatrixKernel.js ---
class MatrixKernel {
    constructor() {
        // Initialize core components
        this._initializeManagers();
        this._initializeEffects();
        // Frame handling and rendering variables
        this.frame = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.timestep = 1000 / 60;
        this._effectTimers = {}; // Initialize map for effect timers
        this._supermanTimer = 0; // Initialize Superman effect timer (will be managed in _effectTimers)
        this._setupResizeListener();
        // Configuration subscription for dynamic updates
        this._setupConfigSubscriptions();
    }
    async initAsync() {
        // Asynchronous initialization steps
        await this._initializeRendererAndUI();
        // Perform the initial resize setup and start the loop
        this._resize();
        requestAnimationFrame((time) => this._loop(time));
    }
    /**
     * Initializes core managers (Notification, Config, Grid, Simulation, EffectRegistry).
     * @private
     */
    _initializeManagers() {
        this.notifications = new NotificationManager();
        this.config = new ConfigurationManager();
        this.grid = new MatrixGrid(this.config);
        this.simulation = new SimulationSystem(this.grid, this.config);
        this.effectRegistry = new EffectRegistry(this.grid, this.config);
    }
    /**
     * Registers all active visual effects with the EffectRegistry.
     * @private
     */
    _initializeEffects() {
        const effects = [
            PulseEffect,
            ClearPulseEffect,
            MiniPulseEffect,
            DejaVuEffect,
            SupermanEffect,
            FirewallEffect
        ];
        effects.forEach((EffectClass) => this.effectRegistry.register(new EffectClass(this.grid, this.config)));
    }
    /**
     * Initializes the CanvasRenderer, FontManager, and UIManager.
     * @private
     */
    async _initializeRendererAndUI() {
        this.renderer = new CanvasRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
        this.fontMgr = new FontManager(this.config, this.notifications);
        this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications);
        // Initialize font manager and await its completion
        await this.fontMgr.init();
    }
    /**
     * Sets up a debounced window resize listener.
     * @private
     */
    _setupResizeListener() {
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this._resize(), 100); // Debounce resize events
        });
    }
    /**
     * Sets up subscriptions to configuration changes that trigger UI or rendering updates.
     * @private
     */
    _setupConfigSubscriptions() {
        const resizeTriggers = new Set([
            'resolution',
            'stretchX',
            'stretchY',
            'fontSize',
            'horizontalSpacingFactor'
        ]);
        const smoothingTriggers = new Set([
            'smoothingEnabled',
            'smoothingAmount'
        ]);
        this.config.subscribe((key) => {
            // Resize the canvas and grid on resolution-related changes
            if (resizeTriggers.has(key) || key === 'ALL') {
                this._resize();
            }
            // Update renderer when smoothing settings change
            if (smoothingTriggers.has(key)) {
                this.renderer.updateSmoothing();
            }
            const autoEffects = [
                { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
                { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
                { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
                { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
                { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
                { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' }
            ];
            autoEffects.forEach(effect => {
                if ((key === effect.enabledKey && this.config.state[effect.enabledKey]) || key === 'ALL') {
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                } else if (key === effect.enabledKey && !this.config.state[effect.enabledKey]) {
                    // If an effect is specifically disabled, remove its timer
                    delete this._effectTimers[effect.effectName];
                }
            });
        });
    }
    /**
     * Resizes the grid and renderer dimensions based on current window size and configuration.
     * @private
     */
    _resize() {
        this.grid.resize(
            window.innerWidth / this.config.state.stretchX,
            window.innerHeight / this.config.state.stretchY
        );
        this.renderer.resize();
    }
    /**
     * The main animation loop, handling updates and rendering.
     * Uses a fixed timestep for consistent simulation speed.
     * @private
     * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
     */
    _loop(time) {
        if (!this.lastTime) this.lastTime = time;
        const delta = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += delta;
        while (this.accumulator >= this.timestep) {
            this._updateFrame();
            this.accumulator -= this.timestep;
        }
        this.renderer.render(this.frame);
        requestAnimationFrame((nextTime) => this._loop(nextTime));
    }
    /**
     * Updates the simulation logic for a single frame.
     * @private
     */
    _updateFrame() {
        this.frame++;
        this.effectRegistry.update();
        this.simulation.update(this.frame);
        const autoEffects = [
            { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
            { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
            { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
            { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
            { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
            { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' }
        ];
        autoEffects.forEach(effect => {
            if (this.config.state[effect.enabledKey]) {
                if (!this._effectTimers[effect.effectName]) {
                    // Initialize timer with randomization if not already set
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
                this._effectTimers[effect.effectName]--;
                if (this._effectTimers[effect.effectName] <= 0) {
                    this.effectRegistry.trigger(effect.effectName);
                    // Reset timer with randomization
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5);
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
            } else {
                // If effect is disabled, ensure its timer is reset or cleared
                if (this._effectTimers[effect.effectName]) {
                    delete this._effectTimers[effect.effectName];
                }
            }
        });
    }
}
// Initialize the MatrixKernel on DOMContentLoaded
window.addEventListener('DOMContentLoaded', async () => {
    const kernel = new MatrixKernel();
    await kernel.initAsync();
});
</script>
    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>