<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(10, 12, 16, 0.96); 
            --panel-border: rgba(34, 197, 94, 0.3);
            --text-main: #4ade80;
            --text-muted: #86efac;
            --accent: #22c55e;
            --accent-glow: rgba(34, 197, 94, 0.4);
            --danger: #ef4444;
            --info: #3b82f6;
            --warn: #f59e0b;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-right: env(safe-area-inset-right, 20px);
        }
        * { box-sizing: border-box; }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        body { 
            overflow: hidden; 
            background-color: var(--bg-color); 
            margin: 0; 
            font-family: 'Segoe UI', 'Roboto', monospace; 
            overscroll-behavior: none;
        }
        
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; }

        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }

        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }

        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }

        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }

        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        
        #tabTrack { display: inline-flex; width: max-content; }

        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }

        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }

        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }

        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }

        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}

/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1rem;
    border-radius: 6px;
    margin-top: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 22px; height: 22px; border-radius: 50%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }

        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 10000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }

        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }

        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
        input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }

        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }

        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }

        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }

        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }

        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        
        #menuToggle { 
            position: fixed; 
            top: max(0.75rem, var(--safe-top)); 
            right: max(1.2rem, var(--safe-right)); 
            z-index: 30; width: 44px; height: 44px; 
            border-radius: 50%; color: var(--text-main); background: rgba(10, 12, 16, 0.6); 
            backdrop-filter: blur(4px); border: 1px solid var(--panel-border); 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            transition: all 0.3s ease; 
        }
        #menuToggle:hover { background: var(--accent); color: #000; box-shadow: 0 0 20px var(--accent); transform: rotate(90deg); }

        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
</style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <canvas id="bloomCanvas" style="display:none;"></canvas>

    <button id="menuToggle">
        <svg width="28" height="28" viewBox="0 0 16 16" fill="currentColor">
            <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"></path></svg>
    </button>
    <input type="file" id="importFile" accept=".json" style="display:none;" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" style="display:none;" />

    <div id="settingsPanel">
        <div id="panelHeader"><h2>Settings</h2></div>
        <div id="navTabs"></div>
        <div id="contentArea"></div>
        <div id="panelFooter"><div id="globalStatus" class="status-msg">Matrix Code v7.3</div></div>
    </div>

    <script>

// --- Utils.js ---
const APP_VERSION = "7.1";

        // =========================================================================
        // 1. CORE UTILITIES / CONSTANTS
        // =========================================================================
        const Utils = {
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomFloat: (min, max) => Math.random() * (max - min) + min,
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 255, b: 0 };
            },
            packRgb: (r, g, b) => (r << 16) | (g << 8) | b,
            unpackRgb: (intVal) => ({ r: (intVal >> 16) & 0xFF, g: (intVal >> 8) & 0xFF, b: intVal & 0xFF }),
            hslToRgb: (h, s, l) => {
                s /= 100; l /= 100;
                const k = n => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
                return { r: Math.round(255 * f(0)), g: Math.round(255 * f(8)), b: Math.round(255 * f(4)) };
            },
            CHARS: '012345789Z:<=>"*+-._!|⽇゠ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲンワヲン',
            getRandomChar: () => Utils.CHARS.charAt(Math.floor(Math.random() * Utils.CHARS.length)),
            getUniqueChar: (exclude) => { let c; do { c = Utils.getRandomChar(); } while (c === exclude); return c; },
            downloadJson: (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
        };

        const CELL_TYPE = { EMPTY: 0, TRAIL: 1, TRACER: 2, ROTATOR: 3 };

        // =========================================================================
        // 1.1 NOTIFICATION SYSTEM 
        // =========================================================================


// --- NotificationManager.js ---
class NotificationManager {
            constructor() {
                this.container = document.getElementById('toast-container');
                if (!this.container) {
                    this.container = document.createElement('div');
                    this.container.id = 'toast-container';
                    document.body.appendChild(this.container);
                }
            }

            show(msg, type = 'info') {
                const d = document.createElement('div');
                d.className = `toast-msg toast-${type}`;
                d.textContent = msg;
                if(!document.body.contains(this.container)) document.body.appendChild(this.container);
                this.container.appendChild(d);
                requestAnimationFrame(() => d.classList.add('visible'));
                setTimeout(() => { d.classList.remove('visible'); setTimeout(() => d.remove(), 300); }, 3000);
            }
        }

        // =========================================================================
        // 2. CONFIGURATION (Singleton)
        // =========================================================================


// --- ConfigurationManager.js ---
class ConfigurationManager {
            constructor() {
                this.storageKey = 'matrix_config_v7.3'; 
                this.slotsKey = 'matrix_slots_v7.3';
                
                this.defaults = {
                    // --- GLOBAL ---
                    streamColor: "#65d778", 
                    streamSpeed: 15,
                    clearAlpha: 0.6,
                    enableBloom: true, 
                    bloomStrength: 2, 
                    bloomOpacity: 0.45,
                    resolution: 1, 
                    smoothingEnabled: true, 
                    smoothingAmount: 0.4, 
                    stretchX: 1, 
                    stretchY: 1.1,

                    // --- STREAMS ---
                    streamSpawnCount: 4,
                    eraserSpawnCount: 4, 
                    releaseInterval: 4,
                    minStreamGap: 15,
                    minEraserGap: 15,
                    holeRate: 0.15,
                    ttlMinSeconds: 2, 
                    ttlMaxSeconds: 5.5, 
                    decayFadeDurationFrames: 24,
                    dissolveEnabled: true, 
                    dissolveMinSize: 19, 
                    deteriorationEnabled: true, 
                    deteriorationType: 'ghost', 
                    deteriorationStrength: 2,
                    invertedTracerEnabled: true, 
                    invertedTracerChance: 0.1,

                    // --- FONT & GLYPHS ---
                    fontFamily: 'MatrixEmbedded', 
                    fontSize: 26, 
                    fontWeight: 'normal', 
                    italicEnabled: false,
                    mirrorEnabled: false, 
                    fontOffsetY: 0, 
                    fontOffsetX: 0,
                    horizontalSpacingFactor: 0.7, 
                    verticalSpacingFactor: 0.95,
                    variableBrightnessEnabled: true, 
                    brightnessVariance: 20,

                    // --- MUTATORS (TRACERS) ---
                    tracerColor: "#d9f2f2", 
                    tracerSizeIncrease: 1, 
                    tracerGlow: 15,
                    tracerAttackFrames: 8, 
                    tracerHoldFrames: 0, 
                    tracerReleaseFrames: 6,

                    // --- MUTATORS (ROTATORS) ---
                    rotatorEnabled: true, 
                    rotatorChance: 0.13, 
                    rotatorSyncToTracer: true, 
                    rotatorSyncMultiplier: 0.5,
                    rotatorCycleFactor: 11, 
                    rotatorCrossfadeFrames: 6,

                    // --- GLYPH FX (STAR POWER) ---
                    starPowerEnabled: false, 
                    starPowerFreq: 100, 
                    starPowerRainbowMode: 'char',
                    starPowerColorCycle: false, 
                    starPowerCycleSpeed: 14, 
                    starPowerSaturation: 100, 
                    starPowerIntensity: 51, 
                    starPowerGlitter: false,

                    // --- GLYPH FX (RAINBOW) ---
                    rainbowStreamEnabled: false, 
                    rainbowStreamChance: 1, 
                    rainbowStreamIntensity: 50,

                    // --- EVENTS (PULSE) ---
                    pulseEnabled: true, 
                    pulseFrequencySeconds: 180, 
                    pulseDelayFrames: 60, 
                    pulseDurationSeconds: 2.2, 
                    pulsePreserveSpaces: true, 
                    pulseRandomPosition: true, 
                    pulseWidth: 130, 
                    pulseDimming: 0.2, 
                    pulseIgnoreTracers: true,
                    pulseCircular: false,
                    pulseBlend: true,
                    pulseInstantStart: false,

                    // --- EVENTS (MINI PULSE) ---
                    miniPulseEnabled: true,
                    miniPulseFrequencySeconds: 450,
                    miniPulseDurationSeconds: 5,
                    miniPulseSpawnChance: 0.03,
                    miniPulseSize: 140,
                    miniPulseThickness: 64,
                    miniPulseSpeed: 14,

                    // --- EVENTS (DEJA VU) ---
                    dejaVuEnabled: true, 
                    dejaVuAutoMode: true,
                    dejaVuFrequencySeconds: 300, 
                    dejaVuDurationSeconds: 5,
                    dejaVuBarDurationFrames: 30, 
                    dejaVuVarianceFrames: 60, 
                    dejaVuIntensity: 0.06,
                    dejaVuHoleBrightness: 0.02, 
                    dejaVuMinRectHeight: 1, 
                    dejaVuMaxRectHeight: 10, 
                    dejaVuRandomizeColors: true, 

                    // --- EVENTS (SUPERMAN) ---
                    supermanEnabled: true,
                    supermanDurationSeconds: 5,
                    supermanFlickerRate: 3, // How many frames between shape changes (lower is faster)
                    supermanWidth: 4, // Vertical spread (amplitude)
                    supermanProb: 4, // Branching probability
                    supermanIncludeColors: false, // If true, keeps original color but super-bright
                    supermanGlow: 4, 
                    supermanBoltThickness: 4,
                };

                this.state = { ...this.defaults };
                this.derived = {};
                this.slots = this._loadSlots();
                this.subscribers = [];
                this.load();
                this.updateDerivedValues();
            }

            _loadSlots() { try { const s = localStorage.getItem(this.slotsKey); if (s) return JSON.parse(s); } catch (e) {} return Array(3).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null })); }
            saveSlots() { try { localStorage.setItem(this.slotsKey, JSON.stringify(this.slots)); } catch (e) {} }
            load() { try { const s = localStorage.getItem(this.storageKey); if (s) { const parsed = JSON.parse(s); if(parsed.customFonts) delete parsed.customFonts; this.state = { ...this.defaults, ...parsed }; } } catch (e) {} }
            save() { try { localStorage.setItem(this.storageKey, JSON.stringify(this.state)); } catch (e) {} }
            
            get(key) { return this.state[key]; }
            
            set(key, value) {
                this.state[key] = value;
                if (key === 'streamMinLength') this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
                if (key === 'streamMaxLength') this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
                this.updateDerivedValues(); 
                this.save(); 
                this.notify(key);
            }
            
            reset() { this.state = { ...this.defaults }; this.updateDerivedValues(); this.save(); this.notify('ALL'); }
            saveToSlot(i) { this.slots[i] = { name: this.slots[i].name, data: JSON.parse(JSON.stringify(this.state)) }; this.saveSlots(); }
            loadFromSlot(i) { if(!this.slots[i].data) return false; this.state = { ...this.defaults, ...this.slots[i].data }; this.updateDerivedValues(); this.save(); this.notify('ALL'); return true; }
            renameSlot(i, n) { this.slots[i].name = n; this.saveSlots(); }
            subscribe(cb) { this.subscribers.push(cb); }
            notify(k) { this.subscribers.forEach(cb => cb(k, this.state)); }
            
            updateDerivedValues() {
                const s = this.state;
                const cycleDur = 21 - s.streamSpeed;
                const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
                const vFactor = Math.max(0.5, s.verticalSpacingFactor);
                
                let rotFrames;
                if (s.rotatorSyncToTracer) {
                    rotFrames = Math.max(1, Math.floor(cycleDur / s.rotatorSyncMultiplier));
                } else {
                    rotFrames = Math.max(10, Math.round(60 - (s.rotatorCycleFactor * 2.5)));
                }

                this.derived = {
                    cycleDuration: cycleDur,
                    safeAttack: Math.max(1, Math.min(s.tracerAttackFrames, cycleDur)),
                    safeRelease: Math.min(s.tracerReleaseFrames, cycleDur),
                    holdFrames: Math.max(0, s.tracerHoldFrames),
                    maxState: cycleDur + Math.max(0, s.tracerHoldFrames) + cycleDur,
                    rotatorCycleFrames: rotFrames,
                    cellWidth: s.fontSize * hFactor, 
                    cellHeight: s.fontSize * vFactor,
                    varianceMin: 1.0 - (s.brightnessVariance / 100),
                    streamRgb: Utils.hexToRgb(s.streamColor), 
                    tracerRgb: Utils.hexToRgb(s.tracerColor),
                    streamColorStr: `rgb(${Utils.hexToRgb(s.streamColor).r},${Utils.hexToRgb(s.streamColor).g},${Utils.hexToRgb(s.streamColor).b})`,
                    tracerColorStr: `rgb(${Utils.hexToRgb(s.tracerColor).r},${Utils.hexToRgb(s.tracerColor).g},${Utils.hexToRgb(s.tracerColor).b})`,
                    fontBaseStr: `${s.italicEnabled?'italic':''} ${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
                };
            }
        }

        // =========================================================================
        // 3. DATA LAYER
        // =========================================================================


// --- MatrixGrid.js ---
class MatrixGrid {
            constructor(config) {
                this.config = config;
                this.cols = 0; this.rows = 0;
                this.activeIndices = new Set();
                this.chars = new Uint16Array(0);
                this.types = new Uint8Array(0);
                this.alphas = new Float32Array(0);
                this.decays = new Uint8Array(0);
                this.ages = new Int32Array(0);
                this.brightness = new Float32Array(0);
                this.rotatorProg = new Uint8Array(0);
                this.complexStyles = new Map(); 
                this.nextChars = new Map();
            }

            resize(width, height) {
                const d = this.config.derived;
                const nc = Math.max(1, Math.floor(width / d.cellWidth));
                const nr = Math.max(1, Math.floor(height / d.cellHeight));
                if (nc !== this.cols || nr !== this.rows) {
                    const total = nc * nr;
                    this.chars = new Uint16Array(total); this.types = new Uint8Array(total);
                    this.alphas = new Float32Array(total); this.decays = new Uint8Array(total);
                    this.ages = new Int32Array(total); this.brightness = new Float32Array(total);
                    this.rotatorProg = new Uint8Array(total);
                    this.complexStyles.clear(); this.nextChars.clear();
                    this.activeIndices.clear();
                    this.cols = nc; this.rows = nr;
                }
            }
            getIndex(x, y) { if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return -1; return y * this.cols + x; }
            setChar(idx, charStr) { this.chars[idx] = charStr.charCodeAt(0); }
            getChar(idx) { return String.fromCharCode(this.chars[idx]); }
        }

        // =========================================================================
        // 3.1 STREAM MODES (STRATEGY)
        // =========================================================================
        /**
         * Strategy Pattern for Stream Behavior.
         * Allows different visual styles (Standard, Star Power, Rainbow) to be swapped dynamically.
         * New modes can be added by extending StreamMode and registering in SimulationSystem.
         */


// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,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";


// --- StreamModes.js ---
class StreamMode {
            constructor(config) { this.config = config; }
            spawn(st) {} 
            style(st, frame, s) { return null; }
        }
        
        class StandardMode extends StreamMode {
            spawn(st) {}
            style(st, frame, s) { return null; }
        }

        class StarPowerMode extends StreamMode {
            spawn(st) { st.baseHue = Utils.randomInt(0, 360); }
            style(st, frame, s) {
                return { 
                    h: (s.starPowerRainbowMode === 'char' ? (frame + (st.x * 10)) % 360 : st.baseHue), 
                    s: s.starPowerSaturation, 
                    l: s.starPowerIntensity, 
                    cycle: s.starPowerColorCycle, 
                    speed: s.starPowerCycleSpeed, 
                    glitter: s.starPowerGlitter 
                };
            }
        }

        class RainbowMode extends StreamMode {
            spawn(st) { st.baseHue = Utils.randomInt(0, 360); }
            style(st, frame, s) {
                return { h: st.baseHue, s: 100, l: s.rainbowStreamIntensity, cycle: false, speed: 0, glitter: false };
            }
        }

        // =========================================================================
        // 4. SIMULATION LAYER
        // =========================================================================


// --- SimulationSystem.js ---
class SimulationSystem {
            constructor(grid, config) {
                this.grid = grid;
                this.config = config;
                this.activeStreams = [];
                this.lastStreamInColumn = new Array(grid.cols).fill(null);
                this.modes = {
                    'STANDARD': new StandardMode(config),
                    'STAR_POWER': new StarPowerMode(config),
                    'RAINBOW': new RainbowMode(config)
                };
            }

            update(frame) {
                if (this.lastStreamInColumn.length !== this.grid.cols) {
                    this.lastStreamInColumn = new Array(this.grid.cols).fill(null);
                    this.activeStreams = [];
                }
                this._manageStreams(frame);
                this._updateCells(frame);
            }

            _manageStreams(frame) {
                const s = this.config.state;
                const d = this.config.derived;
                
                const period = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));

                if (frame % period === 0) {
                    const cols = new Array(this.grid.cols);
                    for(let i=0; i<cols.length; i++) cols[i] = i;
                    for (let i = cols.length - 1; i > 0; i--) { 
                        const j = Math.floor(Math.random() * (i + 1)); 
                        [cols[i], cols[j]] = [cols[j], cols[i]]; 
                    }

                    let tCount = s.streamSpawnCount;
                    let eCount = s.eraserSpawnCount;

                    for (const col of cols) {
                        if (tCount <= 0 && eCount <= 0) break;

                        let hasContent = false;
                        for(let y=0; y < Math.min(this.grid.rows, 40); y++) { 
                            if(this.grid.decays[this.grid.getIndex(col, y)] > 0) { hasContent = true; break; } 
                        }

                        const last = this.lastStreamInColumn[col];

                        if (hasContent) {
                            if (eCount > 0) {
                                const gapOk = !last || !last.active || last.y > s.minEraserGap;
                                if (gapOk) {
                                    this._spawnStreamAt(col, true);
                                    eCount--;
                                }
                            } 
                        } else {
                            if (tCount > 0) {
                                const gapOk = !last || !last.active || last.y > s.minStreamGap;
                                if (gapOk) {
                                    this._spawnStreamAt(col, false);
                                    tCount--;
                                }
                            }
                        }
                    }
                }

                if(frame % d.cycleDuration !== 0) return;

                for (let i = this.activeStreams.length - 1; i >= 0; i--) {
                    const st = this.activeStreams[i];
                    if (!st.active) {
                        this.activeStreams.splice(i, 1);
                        continue;
                    }
                    if (st.delay > 0) { st.delay--; continue; }
                    
                    st.age++;
                    
                    if (st.age >= st.visibleLen) {
                        if (!st.isEraser) {
                            st.active = false; 
                            this._spawnStreamAt(st.x, true); 
                        } else {
                            st.active = false; 
                        }
                        continue;
                    }
                    
                    if (st.y < st.len) { st.y++; this._writeHead(st, frame); }
                }
            }

            _spawnStreamAt(x, forceEraser) {
                const s = this.config.state;
                const st = { x, y: -1, active: true, delay: 0, len: 0, holes: new Set(), decayY: -1, decayStarted: false, age: 0, visibleLen: 0, mode: 'STANDARD', baseHue: 0, isInverted: false, isEraser: false };
                
                if (forceEraser) {
                    st.isEraser = true;
                    st.isInverted = false;
                    st.len = this.grid.rows + 5;
                } else {
                    st.isEraser = false;
                    st.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
                    st.len = Utils.randomInt(4, this.grid.rows * 3);
                    for(let i=0; i<st.len; i++) if(Math.random() < s.holeRate) st.holes.add(i);
                    st.holes.delete(0);
                }

                let lifeFrames = Math.floor(Utils.randomFloat(s.ttlMinSeconds, s.ttlMaxSeconds) * 60);
                lifeFrames = Math.max(60, lifeFrames); 
                if (st.isEraser) lifeFrames = Math.max(lifeFrames, this.grid.rows + 20);
                st.visibleLen = lifeFrames;

                st.mode = 'STANDARD';
                if (s.starPowerEnabled && Math.random() < (s.starPowerFreq / 100)) st.mode = 'STAR_POWER';
                else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) st.mode = 'RAINBOW';
                this.modes[st.mode].spawn(st);
                
                st.y = -1; 
                this.activeStreams.push(st);
                this.lastStreamInColumn[x] = st;
            }

            _writeHead(st, frame) {
                const idx = this.grid.getIndex(st.x, st.y);
                if (idx === -1) return;
                
                let shouldWrite = false;
                if (st.isEraser) shouldWrite = false;
                else if (st.isInverted) shouldWrite = st.holes.has(st.y);
                else shouldWrite = !st.holes.has(st.y);

                if (shouldWrite) {
                    const s = this.config.state;
                    this.grid.types[idx] = (s.rotatorEnabled && Math.random() < s.rotatorChance) ? CELL_TYPE.ROTATOR : CELL_TYPE.TRACER;
                    this.grid.ages[idx] = 1; this.grid.decays[idx] = 1; this.grid.rotatorProg[idx] = 0;
                    
                    this.grid.activeIndices.add(idx);
                    
                    const char = Utils.getRandomChar();
                    this.grid.setChar(idx, char);
                    if(this.grid.types[idx] === CELL_TYPE.ROTATOR) this.grid.nextChars.set(idx, Utils.getUniqueChar(char));
                    this.grid.brightness[idx] = s.variableBrightnessEnabled ? Utils.randomFloat(this.config.derived.varianceMin, 1.0) : 1.0;
                    this.grid.alphas[idx] = this.grid.brightness[idx];
                    const style = this.modes[st.mode].style(st, frame, s);
                    if(style) this.grid.complexStyles.set(idx, style); else this.grid.complexStyles.delete(idx);
                } else {
                    if (st.isEraser) {
                        if (this.grid.decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
                            this.grid.ages[idx] = 0;
                            this.grid.decays[idx] = 2;
                        } else {
                            this._clearCell(idx);
                        }
                    } else {
                        this._clearCell(idx);
                    }
                }
            }

            _clearCell(idx) {
                this.grid.types[idx] = CELL_TYPE.EMPTY; this.grid.ages[idx] = 0; this.grid.decays[idx] = 0;
                this.grid.alphas[idx] = 0; this.grid.complexStyles.delete(idx); this.grid.nextChars.delete(idx);
                
                // Performance: Remove from active tracking when cell becomes empty.
                this.grid.activeIndices.delete(idx);
            }

            _updateCells(frame) {
                const s = this.config.state; const d = this.config.derived;
                for(const i of this.grid.activeIndices) {
                    const decay = this.grid.decays[i]; if(decay === 0) continue;
                    let age = this.grid.ages[i];
                    if (age > 0) { age++; if (age > d.maxState) age = 0; this.grid.ages[i] = age; }
                    if (s.rotatorEnabled && this.grid.types[i] === CELL_TYPE.ROTATOR) {
                        const prog = this.grid.rotatorProg[i];
                        if (prog > 0) {
                            this.grid.rotatorProg[i]++;
                            if (this.grid.rotatorProg[i] > s.rotatorCrossfadeFrames) {
                                const next = this.grid.nextChars.get(i); if(next) this.grid.setChar(i, next); this.grid.rotatorProg[i] = 0;
                            }
                        } else if (decay === 1) {
                            const cyclePhase = frame % d.rotatorCycleFrames;
                            if (s.rotatorCrossfadeFrames <= 2) { if (cyclePhase === 0) this.grid.setChar(i, Utils.getUniqueChar(this.grid.getChar(i))); }
                            else { if (cyclePhase === 0) { this.grid.rotatorProg[i] = 1; this.grid.nextChars.set(i, Utils.getUniqueChar(this.grid.getChar(i))); } }
                        }
                    }
                    if (decay >= 2) { this.grid.decays[i]++; if (this.grid.decays[i] > s.decayFadeDurationFrames + 2) { this._clearCell(i); continue; } }
                    let alpha = 0;
                    if (age > 0) alpha = 1.0; 
                    else if (decay === 1) alpha = 0.95 * this.grid.brightness[i]; 
                    else if (decay >= 2) { const p = (decay - 2) / s.decayFadeDurationFrames; alpha = (0.95 * (1 - p)) * this.grid.brightness[i]; }
                    this.grid.alphas[i] = alpha;
                }
            }
        }

        // =========================================================================
        // 5. EFFECT SYSTEM
        // =========================================================================


// --- EffectRegistry.js ---
class EffectRegistry {
            constructor(grid, config) { this.grid = grid; this.config = config; this.effects = []; }
            register(effect) { this.effects.push(effect); }
            trigger(name) { const fx = this.effects.find(e => e.name === name); if(fx) return fx.trigger(); return false; }
            update() { this.effects.forEach(e => e.update()); }
            getOverride(i) { for(const fx of this.effects) { const o = fx.getOverride(i); if(o) return o; } return null; }
            hasActiveEffects() { return this.effects.some(e => e.active); }
        }

        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; }
            trigger() { return false; }
            update() {}
            getOverride(i) { return null; }
        }


// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
            constructor(g, c) { super(g, c); this.name = "DejaVu"; this.active = false; this.autoTimer = c.state.dejaVuFrequencySeconds * 60; this.map = null; }
            trigger() { if(this.active) return false; this.active = true; this.timer = this.c.state.dejaVuDurationSeconds * 60; this.bars = []; this.map = new Uint8Array(this.g.rows); return true; }
            update() {
                const s = this.c.state;
                if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
                if(!this.active) return;
                if(this.timer-- <= 0) { this.active = false; this.bars = []; this.map = null; return; }
                this.map.fill(0);
                if(Math.random() < s.dejaVuIntensity) {
                    const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
                    this.bars.push({ y, h, age: 0, maxAge: s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10) });
                }
                for(let i=this.bars.length-1; i>=0; i--) {
                    const b = this.bars[i]; b.age++;
                    if(b.age > b.maxAge) this.bars.splice(i, 1); else { for(let r=b.y; r < b.y+b.h && r < this.g.rows; r++) this.map[r] = 1; }
                }
                for(let y=0; y<this.g.rows; y++) {
                    if(this.map[y] === 1) {
                        for(let x=0; x<this.g.cols; x++) {
                            if(Math.random() < 0.1) {
                                const i = this.g.getIndex(x, y); this.g.rotatorProg[i] = 0; const c = Utils.getRandomChar(); this.g.setChar(i, c);
                                if(s.dejaVuRandomizeColors) this.g.complexStyles.set(i, { h: Utils.randomInt(0,360), s: 90, l: 70, glitched: true });
                            }
                        }
                    }
                }
            }
            getOverride(i) {
                if(!this.active || !this.map) return null;
                const y = Math.floor(i / this.g.cols);
                if(this.map[y] === 1) {
                    const s = this.c.state; const alpha = this.g.alphas[i] < 0.1 ? s.dejaVuHoleBrightness : 1.0; if(alpha < 0.01) return null;
                    return { char: this.g.getChar(i), color: this.c.derived.tracerColorStr, alpha, glow: 20 * alpha, size: 2 };
                }
                return null;
            }
        }

        // =========================================================================
        // 6. RENDERER
        // =========================================================================


// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
            constructor(g, c) {
                super(g, c); this.name = "MiniPulse"; this.active = false; this.sessionTimer = 0; this.autoTimer = c.state.miniPulseFrequencySeconds * 60; this.pulses = []; 
            }
            trigger() { if(this.active) return false; this.active = true; this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60; this.pulses = []; return true; }
            update() {
                const s = this.c.state;
                if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.miniPulseFrequencySeconds * 60; }
                if (this.active) {
                    this.sessionTimer--;
                    if (Math.random() < s.miniPulseSpawnChance) { this.pulses.push({ x: Utils.randomInt(0, this.g.cols), y: Utils.randomInt(0, this.g.rows), r: 0, maxR: s.miniPulseSize, speed: s.miniPulseSpeed }); }
                    if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
                }
                for (let i = this.pulses.length - 1; i >= 0; i--) { const p = this.pulses[i]; p.r += p.speed; if (p.r > p.maxR + 100) this.pulses.splice(i, 1); }
            }
            getOverride(i) {
                if (this.pulses.length === 0) return null;
                const s = this.c.state; const d = this.c.derived;
                const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                const cx = (x * d.cellWidth * s.stretchX); const cy = (y * d.cellHeight * s.stretchY);
                for (const p of this.pulses) {
                    const ox = (p.x * d.cellWidth * s.stretchX); const oy = (p.y * d.cellHeight * s.stretchY);
                    let dist = s.pulseCircular ? Math.sqrt(Math.pow(cx - ox, 2) + Math.pow(cy - oy, 2)) : Math.max(Math.abs(cx - ox), Math.abs(cy - oy));
                    const innerEdge = p.r - s.miniPulseThickness;
                    if (dist <= p.r && dist >= innerEdge) {
                        let fade = 1.0;
                        if(p.r > p.maxR) fade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                        let char = this.g.getChar(i);
                        if (this.g.alphas[i] <= 0.05) { const glitchIndex = (i + Math.floor(p.r)) % Utils.CHARS.length; char = Utils.CHARS[glitchIndex]; }
                        return { char: char, color: d.tracerColorStr, alpha: fade, glow: s.tracerGlow * fade, size: s.tracerSizeIncrease, solid: false };
                    }
                }
                return null;
            }
        }


// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); this.name = "Pulse"; 
                this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
                this.snap = null; this.autoTimer = c.state.pulseFrequencySeconds * 60;
            }
            trigger() {
                if(this.active) return false;
                const total = this.g.cols * this.g.rows;
                this.snap = { chars: new Uint16Array(this.g.chars), alphas: new Float32Array(this.g.alphas), colors: new Uint32Array(total), tracers: new Uint8Array(total), fillChars: new Uint16Array(total) };
                const d = this.c.derived; const s = this.c.state; const holdEnd = d.cycleDuration + d.holdFrames;
                for(let i=0; i<total; i++) {
                    let rgb = d.streamRgb; let isTracer = false; const style = this.g.complexStyles.get(i);
                    if(style) rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    else {
                        const type = this.g.types[i]; const age = this.g.ages[i];
                        if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { const at = age - 1; if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { rgb = d.tracerRgb; isTracer = true; } }
                    }
                    this.snap.colors[i] = Utils.packRgb(rgb.r, rgb.g, rgb.b); this.snap.tracers[i] = isTracer ? 1 : 0; this.snap.fillChars[i] = Utils.getRandomChar().charCodeAt(0);
                }
                this.origin = s.pulseRandomPosition ? {x:Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8), y:Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8)} : {x:Math.floor(this.g.cols/2), y:Math.floor(this.g.rows/2)};
                this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelayFrames; this.radius = 0;
                const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * 60);
                return true; 
            }
            update() {
                const s = this.c.state;
                if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; }
                if(!this.active) return;
                if(this.state === 'WAITING') { 
                    if(--this.timer <= 0) { this.state = 'EXPANDING'; this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; }
                } else {
                    this.radius += this.speed; const d = this.c.derived; const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                    if(this.radius > maxDim + 400) { this.active = false; this.snap = null; }
                }
            }
            getOverride(i) {
                if(!this.active || !this.snap) return null;
                const s = this.c.state; const d = this.c.derived;
                const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                const cx = Math.floor(x * d.cellWidth * s.stretchX); const cy = Math.floor(y * d.cellHeight * s.stretchY);
                const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
                let dist = s.pulseCircular ? Math.sqrt(Math.pow(cx - ox, 2) + Math.pow(cy - oy, 2)) : Math.max(Math.abs(cx - ox), Math.abs(cy - oy));
                const width = s.pulseWidth * 2; const innerEdge = this.radius - width;
                if (this.state !== 'WAITING' && dist < innerEdge) return null; 
                const snAlpha = this.snap.alphas[i]; let charCode = this.snap.chars[i];
                const tRgb = d.tracerRgb; const targetColor = `rgb(${tRgb.r},${tRgb.g},${tRgb.b})`;
                let baseColorStr = null; let isGap = false;
                if (snAlpha <= 0.01) { isGap = true; if (!s.pulsePreserveSpaces) charCode = this.snap.fillChars[i]; }
                const char = String.fromCharCode(charCode); const isTracer = (this.snap.tracers[i] === 1);
                if (this.state === 'WAITING' || dist > this.radius) {
                    if(baseColorStr === null) { const rgb = Utils.unpackRgb(this.snap.colors[i]); baseColorStr = `rgb(${rgb.r},${rgb.g},${rgb.b})`; }
                    if(isTracer && s.pulseIgnoreTracers) return { char, color: targetColor, alpha: 1.0, glow: s.tracerGlow, size: s.tracerSizeIncrease, solid: true, bgColor: '#000000' };
                    if (isGap) return { char: '', color: '#000000', alpha: 0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
                    return { char, color: baseColorStr, alpha: snAlpha * s.pulseDimming, glow: 0, size: 0, solid: true, bgColor: '#000000' };
                }
                if (s.pulsePreserveSpaces && isGap) return { char: '', color: '#000000', alpha: 0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
                const rel = Math.max(0, Math.min(1, (this.radius - dist) / width));
                let finalColor = targetColor;
                if (s.pulseBlend) {
                    const baseInt = this.snap.colors[i]; const bR = (baseInt >> 16) & 0xFF; const bG = (baseInt >> 8) & 0xFF; const bB = baseInt & 0xFF;
                    const mR = Math.floor(tRgb.r + (bR - tRgb.r) * rel); const mG = Math.floor(tRgb.g + (bG - tRgb.g) * rel); const mB = Math.floor(tRgb.b + (bB - tRgb.b) * rel);
                    finalColor = `rgb(${mR},${mG},${mB})`;
                }
                return { char, color: finalColor, alpha: 1.0, glow: Math.max(s.tracerGlow, 30 * (1.0 - rel)), size: s.tracerSizeIncrease, solid: true, bgColor: '#000000' };
            }
        }


// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.timer = 0;
            }

            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this._generateBolt();
                return true; 
            }

            update() {
                if(!this.active) return;
                this.timer--;
                
                if (this.timer <= 0) {
                    this.active = false;
                    this.lightningPath.clear();
                    return;
                }

                // Flicker logic: regenerate the bolt shape every N frames
                const s = this.c.state;
                this.flickerTimer++;
                if (this.flickerTimer >= s.supermanFlickerRate) {
                    this._generateBolt();
                    this.flickerTimer = 0;
                }
            }

            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                
                // Create multiple "tendrils" for a thick electricity look
                const tendrils = 3; 
                
                for(let t=0; t<tendrils; t++) {
                    let cy = startY + Utils.randomInt(-3, 3); // Slight variance at source
                    for (let x = 0; x < this.g.cols; x++) {
                        // Erratic movement calculation
                        const variance = Math.max(0.1, s.supermanWidth / 4); // Scale variance by setting
                        const move = Utils.randomInt(-variance, variance);
                        cy += move;
                        
                        // Bounds checking
                        if (cy < 0) cy = 0;
                        if (cy >= this.g.rows) cy = this.g.rows - 1;

                        const thickness = s.supermanBoltThickness; // Change this value to make it thicker (e.g., 2, 3, 5)
                        const halfThick = Math.floor(thickness / 2);

                        for (let dy = -halfThick; dy <= halfThick; dy++) {
                            const thickY = cy + dy;
                            // Check bounds to prevent wrapping or errors
                            if (thickY >= 0 && thickY < this.g.rows) {
                                const idx = this.g.getIndex(x, thickY);
                                if (idx !== -1) this.lightningPath.add(idx);
                            }
                        }

                        // Branching logic (Tree structure)
                        if (Math.random() < s.supermanProb) {
                            this._createBranch(x, cy, Utils.randomInt(20, 25));
                        }
                    }
                }
            }

            _createBranch(startX, startY, length) {
                let cy = startY;
                const s = this.c.state;
                // Determine direction (usually forks out)
                const dirY = Math.random() > 0.2 ? 0.5 : -1;

                for (let i = 1; i < length; i++) {
                    let cx = startX + i;
                    if (cx >= this.g.cols) break;

                    // Branches move away from main line faster
                    cy += (Utils.randomInt(0, 0.5) * dirY); 
                    
                    if (cy < 0 || cy >= this.g.rows) break;
                    
                    const idx = this.g.getIndex(cx, cy);
                    if (idx !== -1) this.lightningPath.add(idx);
                }
            }

            getOverride(i) {
                if (!this.active || !this.lightningPath.has(i)) return null;

                // Check if there is actual content at this grid position
                // "Ignored spaces" interpretation: Only light up if there is a char
                const alpha = this.g.alphas[i];
                if (alpha <= 0.05) return null;

                const s = this.c.state;
                
                // High Voltage look
                return {
                    char: this.g.getChar(i),
                    color: s.supermanIncludeColors ? null : '#21cd33ff', 
                    color: s.supermanIncludeColors ? '#ffffffff' : '#b9e4b8ff', 
                    alpha: 1.0, 
                    glow: s.supermanGlow, 
                    size: 2, // Slight size bump for "electricity" swelling
                    solid: true
                };
            }
        }

// --- CanvasRenderer.js ---
class CanvasRenderer {
            constructor(canvasId, grid, config, effects) {
                this.cvs = document.getElementById(canvasId); this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.bloomCvs = document.getElementById('bloomCanvas'); this.bloomCtx = this.bloomCvs.getContext('2d', { alpha: true });
                this.grid = grid; this.config = config; this.effects = effects; this.w = 0; this.h = 0;
            }
            resize() {
                const s = this.config.state; this.w = window.innerWidth; this.h = window.innerHeight; const scale = s.resolution;
                this.cvs.width = this.w * scale; this.cvs.height = this.h * scale; this.cvs.style.width = this.w + "px"; this.cvs.style.height = this.h + "px";
                this.bloomCvs.width = (this.w * scale) * 0.25; this.bloomCvs.height = (this.h * scale) * 0.25; this.bloomCtx.scale(0.25, 0.25);
                this.updateSmoothing();
            }
            updateSmoothing() { const s = this.config.state; const blur = s.smoothingEnabled ? `${s.smoothingAmount}px` : '0px'; this.cvs.style.filter = `blur(${blur})`; }
            _getTracerState(i, s) {
                const age = this.grid.ages[i]; if (age <= 0 || this.grid.decays[i] >= 2) return { alpha: 0, phase: 'none' };
                const type = this.grid.types[i]; const isTracerCandidate = (type === CELL_TYPE.TRACER || type === CELL_TYPE.ROTATOR);
                if (!isTracerCandidate) return { alpha: 0, phase: 'none' };
                const activeTime = age - 1; const attack = s.tracerAttackFrames; const hold = s.tracerHoldFrames; const release = s.tracerReleaseFrames;
                if (activeTime < attack) return { alpha: (attack > 0) ? (activeTime / attack) : 1.0, phase: 'attack' };
                else if (activeTime < attack + hold) return { alpha: 1.0, phase: 'hold' };
                else if (activeTime < attack + hold + release) { const relTime = activeTime - (attack + hold); return { alpha: 1.0 - (relTime / release), phase: 'release' }; }
                return { alpha: 0, phase: 'none' };
            }
            render(frame) {
                const s = this.config.state; const d = this.config.derived; const scale = s.resolution; const bloom = s.enableBloom;
                this.ctx.save(); this.ctx.scale(scale * s.stretchX, scale * s.stretchY);
                this.ctx.fillStyle = `rgba(0,0,0,${s.clearAlpha})`; this.ctx.fillRect(0, 0, this.w / s.stretchX, this.h / s.stretchY);
                if(bloom) this.bloomCtx.clearRect(0, 0, this.w * scale, this.h * scale);
                const fontBase = d.fontBaseStr; this.ctx.font = fontBase; this.ctx.textBaseline = 'middle'; this.ctx.textAlign = 'center';
                if(s.mirrorEnabled) { this.ctx.scale(-1, 1); this.ctx.translate(-(this.w / s.stretchX), 0); }
                if(bloom) { this.bloomCtx.font = fontBase; this.bloomCtx.textBaseline = 'middle'; this.bloomCtx.textAlign = 'center'; this.bloomCtx.save(); this.bloomCtx.scale(scale * s.stretchX, scale * s.stretchY); if(s.mirrorEnabled) { this.bloomCtx.scale(-1, 1); this.bloomCtx.translate(-(this.w / s.stretchX), 0); } }
                
                const defaultColor = d.streamColorStr; let lastColor = defaultColor;
                this.ctx.fillStyle = defaultColor; this.ctx.shadowBlur = 0; this.ctx.shadowColor = 'transparent';
                if(bloom) this.bloomCtx.fillStyle = defaultColor;
                const xOff = s.fontOffsetX; const yOff = s.fontOffsetY; const total = this.grid.cols * this.grid.rows;

                const useActiveSet = !this.effects.hasActiveEffects();

                if (useActiveSet) {
                    for(const i of this.grid.activeIndices) {
                        // Copied Body for Optimization
                        const override = this.effects.getOverride(i);
                        if(override) { this._drawOverride(i, override, d, s, bloom); lastColor = null; this.ctx.shadowBlur = 0; this.ctx.shadowColor = 'transparent'; continue; }
                        let gridAlpha = this.grid.alphas[i]; if(gridAlpha <= 0.01) continue;
                        const tState = this._getTracerState(i, s); if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0; 
                        if(gridAlpha <= 0.01) continue;
                        const decay = this.grid.decays[i];
                        const x = i % this.grid.cols; const y = Math.floor(i / this.grid.cols);
                        const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff; const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
                        let color = defaultColor; const style = this.grid.complexStyles.get(i);
                        if(style) { if(style.glitter && Math.random() < 0.02) color = '#ffffff'; else { let h = style.h; if(style.cycle) h = (h + (frame * style.speed)) % 360; color = Utils.hslToRgb(h|0, style.s, style.l); color = `rgb(${color.r},${color.g},${color.b})`; } }
                        if(color !== lastColor) { this.ctx.fillStyle = color; if(bloom) this.bloomCtx.fillStyle = color; lastColor = color; }
                        const rotProg = this.grid.rotatorProg[i]; const char = this.grid.getChar(i);
                        if(rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
                            const p = rotProg / s.rotatorCrossfadeFrames; this.ctx.globalAlpha = gridAlpha * (1 - p); this.ctx.fillText(char, px, py);
                            const next = this.grid.nextChars.get(i); if(next) { this.ctx.globalAlpha = gridAlpha * p; this.ctx.fillText(next, px, py); }
                        } else if(s.dissolveEnabled && decay >= 2) {
                            const prog = (decay - 2) / s.decayFadeDurationFrames; const size = Math.max(1, s.fontSize - ((s.fontSize - s.dissolveMinSize) * prog));
                            const font = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${size}px ${s.fontFamily}`; this.ctx.font = font; 
                            if(s.deteriorationEnabled) { const off = s.deteriorationStrength * prog; this.ctx.globalAlpha = gridAlpha * 0.4 * prog; this.ctx.fillText(char, px, py - off); this.ctx.fillText(char, px, py + off); }
                            this.ctx.globalAlpha = gridAlpha; this.ctx.fillText(char, px, py);
                            if(bloom) { this.bloomCtx.globalAlpha = gridAlpha; this.bloomCtx.fillText(char, px, py); }
                            this.ctx.font = fontBase; 
                        } else { this.ctx.globalAlpha = gridAlpha; this.ctx.fillText(char, px, py); if(bloom) { this.bloomCtx.globalAlpha = gridAlpha; this.bloomCtx.fillText(char, px, py); } }
                    }
                } else {
                    for(let i=0; i<total; i++) {
                        // Original Body
                        const override = this.effects.getOverride(i);
                        if(override) { this._drawOverride(i, override, d, s, bloom); lastColor = null; this.ctx.shadowBlur = 0; this.ctx.shadowColor = 'transparent'; continue; }
                        let gridAlpha = this.grid.alphas[i]; if(gridAlpha <= 0.01) continue;
                        const tState = this._getTracerState(i, s); if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0; 
                        if(gridAlpha <= 0.01) continue;
                        const decay = this.grid.decays[i];
                        const x = i % this.grid.cols; const y = Math.floor(i / this.grid.cols);
                        const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff; const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
                        let color = defaultColor; const style = this.grid.complexStyles.get(i);
                        if(style) { if(style.glitter && Math.random() < 0.02) color = '#ffffff'; else { let h = style.h; if(style.cycle) h = (h + (frame * style.speed)) % 360; color = Utils.hslToRgb(h|0, style.s, style.l); color = `rgb(${color.r},${color.g},${color.b})`; } }
                        if(color !== lastColor) { this.ctx.fillStyle = color; if(bloom) this.bloomCtx.fillStyle = color; lastColor = color; }
                        const rotProg = this.grid.rotatorProg[i]; const char = this.grid.getChar(i);
                        if(rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
                            const p = rotProg / s.rotatorCrossfadeFrames; this.ctx.globalAlpha = gridAlpha * (1 - p); this.ctx.fillText(char, px, py);
                            const next = this.grid.nextChars.get(i); if(next) { this.ctx.globalAlpha = gridAlpha * p; this.ctx.fillText(next, px, py); }
                        } else if(s.dissolveEnabled && decay >= 2) {
                            const prog = (decay - 2) / s.decayFadeDurationFrames; const size = Math.max(1, s.fontSize - ((s.fontSize - s.dissolveMinSize) * prog));
                            const font = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${size}px ${s.fontFamily}`; this.ctx.font = font; 
                            if(s.deteriorationEnabled) { const off = s.deteriorationStrength * prog; this.ctx.globalAlpha = gridAlpha * 0.4 * prog; this.ctx.fillText(char, px, py - off); this.ctx.fillText(char, px, py + off); }
                            this.ctx.globalAlpha = gridAlpha; this.ctx.fillText(char, px, py);
                            if(bloom) { this.bloomCtx.globalAlpha = gridAlpha; this.bloomCtx.fillText(char, px, py); }
                            this.ctx.font = fontBase; 
                        } else { this.ctx.globalAlpha = gridAlpha; this.ctx.fillText(char, px, py); if(bloom) { this.bloomCtx.globalAlpha = gridAlpha; this.bloomCtx.fillText(char, px, py); } }
                    }
                }

                const tStr = d.tracerColorStr; this.ctx.shadowBlur = s.tracerGlow; this.ctx.shadowColor = tStr;
                const tFont = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${s.fontSize + s.tracerSizeIncrease}px ${s.fontFamily}`;
                this.ctx.font = tFont; if(bloom) this.bloomCtx.font = tFont;

                for(const i of this.grid.activeIndices) {
                    if(this.effects.getOverride(i)) continue;
                    const tState = this._getTracerState(i, s);
                    if (tState.alpha > 0.01) {
                        const x = i % this.grid.cols; const y = Math.floor(i / this.grid.cols);
                        const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff; const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
                        const style = this.grid.complexStyles.get(i);
                        let cStr = tStr;
                        if (style) { let h = style.h; if(style.cycle) h = (h + (frame * style.speed)) % 360; let tc = Utils.hslToRgb(h|0, 100, 90); cStr = `rgb(${tc.r},${tc.g},${tc.b})`; }
                        this.ctx.fillStyle = cStr; this.ctx.shadowColor = cStr; if(bloom) this.bloomCtx.fillStyle = cStr;
                        this.ctx.globalAlpha = tState.alpha; this.ctx.fillText(this.grid.getChar(i), px, py);
                        if(bloom) { this.bloomCtx.globalAlpha = tState.alpha; this.bloomCtx.fillText(this.grid.getChar(i), px, py); }
                    }
                }
                this.ctx.restore(); 
                if(bloom) { this.bloomCtx.restore(); this.ctx.save(); this.ctx.globalCompositeOperation = 'lighter'; this.ctx.filter = `blur(${s.bloomStrength * 4}px)`; this.ctx.globalAlpha = s.bloomOpacity; this.ctx.drawImage(this.bloomCvs, 0, 0, this.w * scale, this.h * scale); this.ctx.restore(); }
            }

            _drawOverride(i, o, d, s, bloom) {
                const x = i % this.grid.cols; const y = Math.floor(i / this.grid.cols);
                const cx = (x * d.cellWidth) + s.fontOffsetX; const cy = (y * d.cellHeight) + s.fontOffsetY;
                const px = cx + (d.cellWidth * 0.5); const py = cy + (d.cellHeight * 0.5);
                if (o.solid) { const bg = o.bgColor || '#000000'; this.ctx.fillStyle = bg; const w = Math.ceil(d.cellWidth) + 1; const h = Math.ceil(d.cellHeight) + 1; this.ctx.fillRect(Math.floor(cx), Math.floor(cy), w, h); }
                if(o.char && o.alpha > 0.01) {
                    this.ctx.fillStyle = o.color; this.ctx.shadowColor = o.color; this.ctx.shadowBlur = o.glow || 0;
                    const font = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${s.fontSize + (o.size || 0)}px ${s.fontFamily}`;
                    this.ctx.font = font; this.ctx.globalAlpha = o.alpha; this.ctx.fillText(o.char, px, py);
                    if(bloom) { this.bloomCtx.save(); this.bloomCtx.fillStyle = o.color; this.bloomCtx.font = font; this.bloomCtx.globalAlpha = o.alpha; this.bloomCtx.fillText(o.char, px, py); this.bloomCtx.restore(); }
                    this.ctx.font = d.fontBaseStr; 
                }
            }
        }

        // =========================================================================
        // 7. FONT MANAGER
        // =========================================================================


// --- FontManager.js ---
class FontManager {
            constructor(config, notificationMgr) {
                this.config = config; this.notifications = notificationMgr;
                this.dbName = 'MatrixFontDB'; this.storeName = 'fonts'; this.db = null;
                this.loadedFonts = []; this.subs = []; this.embeddedFontName = 'MatrixEmbedded';
            }
            async init() { if(DEFAULT_FONT_DATA && DEFAULT_FONT_DATA.length > 50) this.injectEmbeddedFont(); try { await this._openDB(); await this._loadFontsFromDB(); } catch(e) { console.warn("Font DB Error", e); } }
            subscribe(cb) { this.subs.push(cb); }
            _notify() { this.subs.forEach(cb => cb(this.loadedFonts)); }
            injectEmbeddedFont() { if(this.loadedFonts.some(f => f.name === this.embeddedFontName)) return; this._injectCSS(this.embeddedFontName, DEFAULT_FONT_DATA, "format('woff2')"); this.loadedFonts.push({ name: this.embeddedFontName, display: "The Matrix Custom Code", isEmbedded: true }); }
            _injectCSS(name, url, format) { const existing = document.getElementById(`style-${name}`); if(existing) existing.remove(); const style = document.createElement('style'); style.id = `style-${name}`; style.textContent = `@font-face { font-family: '${name}'; src: url('${url}') ${format}; }`; document.head.appendChild(style); }
            _openDB() { return new Promise((res, rej) => { const r = indexedDB.open(this.dbName, 1); r.onupgradeneeded = e => { if(!e.target.result.objectStoreNames.contains(this.storeName)) { e.target.result.createObjectStore(this.storeName, { keyPath: 'name' }); } }; r.onsuccess = e => { this.db = e.target.result; res(); }; r.onerror = rej; }); }
            _loadFontsFromDB() { return new Promise((res) => { if(!this.db) return res(); const t = this.db.transaction(this.storeName, 'readonly'); t.objectStore(this.storeName).getAll().onsuccess = e => { this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded); e.target.result.forEach(f => { this.loadedFonts.push(f); const type = f.mimeType || f.data.type; const format = this._getFormatFromType(type); this._injectCSS(f.name, URL.createObjectURL(f.data), format); }); this._notify(); res(); }; }); }
            _getFormatFromType(type) { if (type.includes('woff2')) return "format('woff2')"; if (type.includes('woff')) return "format('woff')"; if (type.includes('opentype') || type.includes('otf')) return "format('opentype')"; return "format('truetype')"; }
            importFont(file) {
                const reader = new FileReader();
                reader.onload = e => {
                    const blob = new Blob([e.target.result], {type: file.type}); const id = `CustomFont_${Date.now()}`;
                    const rec = { name: id, display: file.name, data: blob, mimeType: file.type };
                    const t = this.db.transaction(this.storeName, 'readwrite');
                    t.objectStore(this.storeName).put(rec).onsuccess = () => { const format = this._getFormatFromType(file.type); this._injectCSS(id, URL.createObjectURL(blob), format); this.loadedFonts.push(rec); this.config.set('fontFamily', id); this._notify(); this.notifications.show(`Imported: ${file.name}`, 'success'); };
                    t.onerror = () => this.notifications.show("Database Write Failed", 'error');
                };
                reader.readAsArrayBuffer(file);
            }
            deleteFont(id) { return new Promise(res => { const t = this.db.transaction(this.storeName, 'readwrite'); t.objectStore(this.storeName).delete(id).onsuccess = () => { document.getElementById(`style-${id}`)?.remove(); this.loadedFonts = this.loadedFonts.filter(f => f.name !== id); if(this.config.state.fontFamily === id) { this.config.set('fontFamily', this.config.defaults.fontFamily); } this._notify(); res(); }; }); }
            deleteAllFonts() { return new Promise(res => { const t = this.db.transaction(this.storeName, 'readwrite'); t.objectStore(this.storeName).clear().onsuccess = () => { this.loadedFonts.filter(f => !f.isEmbedded).forEach(f => { document.getElementById(`style-${f.name}`)?.remove(); }); this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded); this._notify(); res(); }; }); }
        }

        // =========================================================================
        // 8. UI MANAGER
        // =========================================================================


// --- UIManager.js ---
class UIManager {
                    constructor(c, effects, fonts, notificationMgr) {
                        this.c = c; this.eff = effects; this.fonts = fonts; this.notifications = notificationMgr;
                        this.dom = { panel: document.getElementById('settingsPanel'), toggle: document.getElementById('menuToggle'), tabs: document.getElementById('navTabs'), content: document.getElementById('contentArea'), track: null, tooltip: null };
                        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 }; this.ignoreNextClick = false;
                        this.fonts.subscribe(f => this.refresh('fontFamily'));
                        this.defs = [
            // GLOBAL TAB
            { cat: 'Global', type: 'accordion_header', label: 'Code Timing' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20 },
            { cat: 'Global', id: 'releaseInterval', type: 'range', label: 'Release Rhythm (Nth Tick)', min: 1, max: 10, step: 1 },
        
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: 'smoothingEnabled' },
        
            // APPEARANCE TAB
            { cat: 'Appearance', type: 'accordion_header', label: 'Colors' },
            { cat: 'Appearance', id: 'streamColor', type: 'color', label: 'Code Color' },
            { cat: 'Appearance', id: 'tracerColor', type: 'color', label: 'Tracer Color' },
        
            { cat: 'Appearance', type: 'accordion_header', label: 'Glyph Details' },
            { cat: 'Appearance', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, unit: 'px' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'fontWeight', type: 'select', label: 'Weight', options: [{label:'Thin',value:'100'},{label:'Light',value:'300'},{label:'Normal',value:'normal'},{label:'Bold',value:'bold'},{label:'Heavy',value:'900'}] },
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Randomizes the luminance of individual characters within a stream for a shimmering / flashing look.' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
        
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.05, max: 1.0, step: 0.05, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
        
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolve (Shrink) Effect' }, 
            { cat: 'Appearance', id: 'dissolveMinSize', type: 'range', label: 'Dissolve Target Size', min: 1, max: 20, unit:'px', dep: 'dissolveEnabled' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghost Distance', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
        
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        
            // BEHAVIOR TAB
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'ttlMinSeconds', type: 'range', label: 'Min Life', min: 0.5, max: 20, step: 0.5, unit: 's' },
            { cat: 'Behavior', id: 'ttlMaxSeconds', type: 'range', label: 'Max Life', min: 1, max: 30, step: 0.5, unit: 's' },
            { cat: 'Behavior', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 120, unit:'fr' },
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1 },
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, dep: 'invertedTracerEnabled' },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 5, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Before Eraser', min: 5, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps / Broken Code', min: 0, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
        
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Spawns 'eraser' signals that travel downwards, clearing existing code trails." },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Tracer Chance', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%' },
        
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 0.2, step: 0.01, dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
        
            { cat: 'Behavior', type: 'accordion_header', label: 'Movie FX' },
            { cat: 'Behavior', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'Behavior', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'Behavior', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Pos', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseDimming', type: 'range', label: 'Dimming', min: 0.0, max: 1.0, step: 0.05, dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Ignore Tracers', dep: 'pulseEnabled' },
            { cat: 'Behavior', id: 'pulseCircular', type: 'checkbox', label: 'Circular', dep: 'pulseEnabled' },
            
            { cat: 'Behavior', type: 'button', label: 'Trigger Storm', action: 'minipulse', class: 'btn-warn' },
            { cat: 'Behavior', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'Behavior', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Behavior', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Behavior', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'Behavior', id: 'miniPulseSize', type: 'range', label: 'Blast Size', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Behavior', id: 'miniPulseThickness', type: 'range', label: 'Thickness', min: 10, max: 100, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Behavior', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
        
            { cat: 'Behavior', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'Behavior', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'Behavior', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuIntensity', type: 'range', label: 'Intensity', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Dur', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Var', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuMinRectHeight', type: 'range', label: 'Min Height', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Max Height', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuHoleBrightness', type: 'range', label: 'Hole Bright', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Behavior', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Colors', dep: 'dejaVuEnabled' },
            
            { cat: 'Behavior', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'Behavior', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman FX' },
            { cat: 'Behavior', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Behavior', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'Behavior', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 25, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'Behavior', id: 'supermanIncludeColors', type: 'checkbox', label: 'Extra Bright', dep: 'supermanEnabled' },
            { cat: 'Behavior', id: 'supermanGlow', type: 'range', label: 'Voltage Glow', min: 1, max: 15, dep: 'supermanEnabled' },
            { cat: 'Behavior', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 5, step: 1, dep: 'supermanEnabled' },

            { cat: 'Behavior', type: 'accordion_header', label: 'Special FX' },
            { cat: 'Behavior', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'Behavior', id: 'starPowerFreq', type: 'range', label: 'Spawn Rate', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'Behavior', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'Behavior', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'Behavior', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'Behavior', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Behavior', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Behavior', id: 'starPowerGlitter', type: 'checkbox', label: 'Glitter', dep: 'starPowerEnabled' },
            
            { cat: 'Behavior', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'Behavior', id: 'rainbowStreamChance', type: 'range', label: 'Rainbow Chance', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Behavior', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
        
            // SYSTEM TAB
            { cat: 'System', type: 'accordion_header', label: 'Config' },
            { cat: 'System', type: 'slot', idx: 0 },
            { cat: 'System', type: 'slot', idx: 1 },
            { cat: 'System', type: 'slot', idx: 2 },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
        
            { cat: 'System', type: 'accordion_header', label: 'Maintenance' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
        
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' }
        ];
                        this.c.subscribe((k, s) => this.refresh(k));
                        this.init();
                    }
                    
                    _getFonts() { return [ {label:'Gothic (Win)', value:'"MS Gothic", monospace'}, {label:'Console', value:'Consolas, monaco, monospace'}, ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true})) ]; }
                    
                    updateFontList(el) {
                        el.innerHTML = '';
                        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
                            const div = document.createElement('div'); div.className = 'font-item';
                            div.innerHTML = `<span class="font-name">${f.display}</span>`;
                            const btn = document.createElement('div'); btn.className = 'font-delete-btn'; btn.innerHTML = '×';
                            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
                            div.appendChild(btn); el.appendChild(div);
                        });
                    }
        
                    init() {
                        this.dom.toggle.onclick = () => this.dom.panel.classList.toggle('open');
                        this.dom.track = document.createElement('div'); this.dom.track.id = 'tabTrack'; this.dom.tabs.appendChild(this.dom.track);
                        if(!this.dom.tooltip) { this.dom.tooltip = document.createElement('div'); this.dom.tooltip.id = 'ui-tooltip'; document.body.appendChild(this.dom.tooltip); }
                        
                        // Ensure overflow handling matches standard behavior for wheel support
                        this.dom.tabs.style.overflowX = 'auto'; 
                        this.dom.tabs.style.overscrollBehaviorX = 'contain';
        
                        const cats = [...new Set(this.defs.map(d => d.cat))];
                        const tabContentContainers = {}; // Map category to its tab content container
        
                        cats.forEach((cat, i) => {
                            // Create Tab Button
                            const btn = document.createElement('button');
                            btn.className = `tab-btn ${i === 0 ? 'active' : ''}`;
                            btn.textContent = cat;
                            btn.onclick = () => { 
                                if(this.ignoreNextClick) return;
                                this.dom.tabs.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); 
                                this.dom.content.querySelectorAll('.tab-content-group').forEach(g=>g.classList.remove('active')); document.getElementById(`tab-content-${cat}`).classList.add('active'); 
                            };
                            this.dom.track.appendChild(btn);
        
                            // Create Tab Content Container (for accordions)
                            const tabContentGroup = document.createElement('div');
                            tabContentGroup.className = `tab-content-group ${i === 0 ? 'active' : ''}`;
                            tabContentGroup.id = `tab-content-${cat}`;
                            this.dom.content.appendChild(tabContentGroup);
                            tabContentContainers[cat] = tabContentGroup;
                        });
        
                        // Now populate tab content with accordions and controls
                        let activeAppendingBody = null; // Renamed for clarity: this is where we put controls
        
                        this.defs.forEach(d => {
                            const tabContentGroup = tabContentContainers[d.cat];
                            if (!tabContentGroup) return; // Should not happen with correct defs
        
                            if (d.type === 'accordion_header') {
                                const accordionItem = document.createElement('div');
                                accordionItem.className = 'accordion-item';
        
                                const header = document.createElement('div');
                                header.className = 'accordion-header';
                                header.innerHTML = `${d.label} <span class="accordion-icon"><svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg></span>`;
                                accordionItem.appendChild(header);
        
                                const body = document.createElement('div');
                                body.className = 'accordion-content';
                                accordionItem.appendChild(body);
                                tabContentGroup.appendChild(accordionItem);
                                
                                activeAppendingBody = body; // Update the outer variable
        
                                header.onclick = () => {
                                    const isOpen = body.classList.contains('open');
                                    
                                    // Close peers
                                    tabContentGroup.querySelectorAll('.accordion-content').forEach(peerBody => {
                                        if (peerBody !== body) { 
                                            peerBody.classList.remove('open');
                                            if(peerBody.previousElementSibling) {
                                                peerBody.previousElementSibling.classList.remove('active');
                                                const icon = peerBody.previousElementSibling.querySelector('.accordion-icon');
                                                if(icon) icon.classList.remove('rotated');
                                            }
                                        }
                                    });
        
                                    // Toggle self
                                    if (isOpen) {
                                        body.classList.remove('open');
                                        header.classList.remove('active');
                                        header.querySelector('.accordion-icon').classList.remove('rotated');
                                    } else {
                                        body.classList.add('open');
                                        header.classList.add('active');
                                        header.querySelector('.accordion-icon').classList.add('rotated');
                                    }
                                };
                                
                                // Default open logic: Open if it is the FIRST accordion in this tab
                                const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
                                if (accordionsInTab.length === 1) { 
                                    body.classList.add('open');
                                    header.classList.add('active');
                                    header.querySelector('.accordion-icon').classList.add('rotated');
                                }
        
                            } else if (activeAppendingBody) {
                                // Handle special case for CAUTION ZONE in Maintenance accordion
                                if (d.cat === 'System' && d.label === 'CAUTION ZONE' && d.type === 'header') {
                                    const cautionZoneDiv = document.createElement('div');
                                    cautionZoneDiv.className = 'caution-zone';
                                    const headerEl = this.renderControl(d); // Render the header itself
                                    cautionZoneDiv.appendChild(headerEl);
                                    
                                    activeAppendingBody.appendChild(cautionZoneDiv); // Append container
                                    
                                    // Temporarily redirect append target for items inside caution zone
                                    const originalAppendingBody = activeAppendingBody;
                                    activeAppendingBody = cautionZoneDiv; 
                                    
                                    // Render next control (Factory Reset All) into cautionZoneDiv
                                    // Look ahead in defs
                                    const nextDefIndex = this.defs.indexOf(d) + 1;
                                    if (nextDefIndex < this.defs.length && this.defs[nextDefIndex].caution) {
                                        const nextControlElement = this.renderControl(this.defs[nextDefIndex]);
                                        if (nextControlElement) {
                                            activeAppendingBody.appendChild(nextControlElement);
                                            // Remove from defs iteration logic?? No, forEach continues.
                                            // We must flag it as processed or handle it.
                                            // Actually, the simplest way without modifying the loop structure is to let the loop hit it, 
                                            // but we need to know it's already done.
                                            // OR: simpler approach: Just let the loop continue. 
                                            // But 'activeAppendingBody' is now 'cautionZoneDiv'.
                                            // The next item will be appended to 'cautionZoneDiv'.
                                            // We just need to reset 'activeAppendingBody' back to 'originalAppendingBody' after the next item.
                                            // But we can't easily do that inside a forEach loop.
                                            
                                            // Alternative: Do NOT perform lookahead.
                                            // Just let 'activeAppendingBody' remain as 'cautionZoneDiv' for the next item.
                                            // But we need to break out of it after the next item.
                                            // This implies structure knowledge. 
                                            
                                            // Let's stick to the visual container logic:
                                            // We rendered the header. We set 'activeAppendingBody' to the caution div.
                                            // The NEXT item in the loop will be appended to 'activeAppendingBody' (the caution div).
                                            // We need a way to "pop" the stack.
                                            // Since we know it's the last item in the System tab usually, maybe it's fine?
                                            // Or we can flag the next item to pop.
                                            // Let's assume caution items are always leaf nodes in this specific UI.
                                            
                                            // Actually, simpler: Just render the caution zone container here, append the header.
                                            // Let the loop proceed.
                                            // The loop will append the next item to 'activeAppendingBody'.
                                            // If 'activeAppendingBody' is the caution zone, it works.
                                            // But subsequent items (if any) would also go there.
                                            // In this specific config, Factory Reset is the last item in Maintenance.
                                            // So it is fine.
                                        }
                                    }
                                } else {
                                    if (d.caution) return;
                                    const controlElement = this.renderControl(d);
                                    if (controlElement) {
                                        activeAppendingBody.appendChild(controlElement);
                                    }
                                }
                            }
                        });
        
                        document.getElementById('importFile').onchange = e => { 
                            const f = e.target.files[0]; if(!f) return; 
                            const r=new FileReader(); r.onload=ev=>{ try { const d=JSON.parse(ev.target.result); this.c.state={...this.c.defaults, ...d.state}; this.c.updateDerivedValues(); this.c.save(); this.c.notify('ALL'); this.notifications.show('Config Loaded', 'success'); } catch(e){ this.notifications.show('Invalid File', 'error'); } e.target.value = ''; }; r.readAsText(f); 
                        };
                        document.getElementById('importFontFile').onchange = e => { const f=e.target.files[0]; if(f) this.fonts.importFont(f); e.target.value = ''; };
        
                        // --- DRAG LOGIC ---
                        const startDrag = (e) => { if (e.button !== 0) return; this.scrollState.isDown = true; this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft; this.scrollState.scrollLeft = this.dom.tabs.scrollLeft; this.scrollState.dragDistance = 0; this.ignoreNextClick = false; this.dom.tabs.style.cursor = 'grabbing'; };
                        const stopDrag = () => { this.scrollState.isDown = false; this.dom.tabs.style.cursor = 'grab'; };
                        const doDrag = (e) => { if (!this.scrollState.isDown) return; e.preventDefault(); const x = e.pageX - this.dom.tabs.offsetLeft; const walk = (x - this.scrollState.startX) * 1.5; this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk; this.scrollState.dragDistance += Math.abs(x - this.scrollState.startX); if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; };
        
                        this.dom.tabs.addEventListener('mousedown', startDrag); this.dom.tabs.addEventListener('mouseleave', stopDrag);
                        this.dom.tabs.addEventListener('mouseup', stopDrag); this.dom.tabs.addEventListener('mousemove', doDrag);
        
                        // --- MOUSE WHEEL SUPPORT ---
                                        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
                                        this.dom.tabs.addEventListener('wheel', (e) => {
                                            if (e.deltaY !== 0) {
                                                // preventDefault stops the browser "back" gesture or vertical page scroll
                                                e.preventDefault(); 
                                                this.dom.tabs.scrollLeft += e.deltaY;
                                            }
                                        }, { passive: false });
                        
                                        this.refresh('ALL');
                                    }
            showTooltip(text, target) {
                this.dom.tooltip.textContent = text; this.dom.tooltip.classList.add('visible');
                const rect = target.getBoundingClientRect(); const tipRect = this.dom.tooltip.getBoundingClientRect();
                let top = rect.top + (rect.height / 2) - (tipRect.height / 2); let left = rect.left - tipRect.width - 12; 
                if (top < 10) top = 10; if (left < 10) left = rect.right + 12; 
                this.dom.tooltip.style.top = `${top}px`; this.dom.tooltip.style.left = `${left}px`;
            }
            hideTooltip() { this.dom.tooltip.classList.remove('visible'); }

            createLabelGroup(d) {
                const group = document.createElement('div'); group.className = 'control-label-group';
                const text = document.createElement('span'); text.textContent = d.label; group.appendChild(text);
                if (d.description) {
                    const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = '?';
                    const show = (e) => this.showTooltip(d.description, e.target);
                    icon.onmouseenter = show; icon.onmouseleave = () => this.hideTooltip();
                    icon.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if (this.dom.tooltip.classList.contains('visible')) { this.hideTooltip(); } else { show(e); setTimeout(() => this.hideTooltip(), 3000); } });
                    group.appendChild(icon);
                }
                return group;
            }

            renderControl(d) {
                if (d.type === 'accordion_header') { return null; }
                if (d.type === 'header') {
                    const el = document.createElement('div'); el.className = 'section-header'; el.textContent = d.label; return el;
                }
                if (d.type === 'about_content') {
                    const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
                    div.innerHTML = `<h3 style="margin-top:0; margin-bottom: 1rem; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3><div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
                    return div;
                }
                const row = document.createElement('div');
                if (d.type === 'button') {
                    const btn = document.createElement('button'); btn.className = `action-btn ${d.class||'btn-info'}`; btn.textContent = d.label; btn.id = `btn-${d.action}`; btn.name = d.action; btn.onclick = () => this.handleAction(d.action); row.appendChild(btn);
                } else if (d.type === 'slot') {
                    row.className = 'slot-container';
                    const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[d.idx].name; inp.id = `slot-input-${d.idx}`; inp.name = `slot_name_${d.idx}`; inp.onchange = e => this.c.renameSlot(d.idx, e.target.value);
                    const grp = document.createElement('div'); grp.className = 'slot-btn-group';
                    const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${d.idx}`; save.onclick = () => { this.c.saveToSlot(d.idx); this.notifications.show(`Saved Slot ${d.idx+1}`, 'success'); };
                    const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${d.idx}`; load.onclick = () => { if(this.c.loadFromSlot(d.idx)) this.notifications.show(`Loaded Slot ${d.idx+1}`, 'success'); };
                    grp.append(save, load); row.append(inp, grp);
                } else if (d.type === 'font_list') {
                    row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
                } else {
                    row.className = d.type === 'checkbox' ? 'checkbox-row' : 'control-row';
                    const labelGroup = this.createLabelGroup(d);
                    if(d.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
                    if(!d.hideValue && d.type === 'range') { const valDisp = document.createElement('span'); valDisp.id = `val-${d.id}`; hdr.appendChild(valDisp); } row.appendChild(hdr); } 
                        else { row.appendChild(labelGroup); }
                    let inp;

                    if(d.type === 'range') { 
                        inp = document.createElement('input'); 
                        inp.type = 'range'; 
                        inp.min=d.min; 
                        inp.max=d.max; 
                        if(d.step) 
                            inp.step=d.step; 
                            inp.value = d.invert ? (d.max+d.min)-this.c.get(d.id) : this.c.get(d.id);                            
                            inp.oninput = e => { 
                                
                                    const v = parseFloat(e.target.value); 
                                    const actual = d.invert ? (d.max+d.min)-v : v; 
                                    this.c.set(d.id, actual); 
                                    const disp = document.getElementById(`val-${d.id}`); 
                                    
                                    if(disp) disp.textContent = d.transform ? d.transform(actual) : actual + (d.unit || '');
                                }; 

                            let startX = 0; 
                            let startY = 0; 
                            let isDragging = false; 
                            this._isDraggingHorizontally = false; 
                            inp.addEventListener('touchstart', e => { 
                                startX = e.touches[0].clientX; 
                                startY = e.touches[0].clientY; 
                                isDragging = true; 
                                this._isDraggingHorizontally = false; }); 

                            inp.addEventListener('touchmove', e => { 
                                if (!isDragging) return; 
                                    const currentX = e.touches[0].clientX; 
                                    const currentY = e.touches[0].clientY; const dx = currentX - startX; 
                                    const dy = currentY - startY; // If vertical movement is much greater than horizontal, prevent default 

                                if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 10) { // Threshold of 10px to differentiate from accidental slight vertical movement 
                                    e.preventDefault(); this._isDraggingHorizontally = false; }
                                    else if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 10) { 
                                            this._isDraggingHorizontally = true; } 
                                        else { 
                                            this._isDraggingHorizontally = false; }}); 
                                            
                                        inp.addEventListener('touchend', () => { isDragging = false; this._isDraggingHorizontally = false; }); }

                    else if(d.type === 'color') { const w = document.createElement('div'); w.className = 'color-wrapper'; inp = document.createElement('input'); inp.type = 'color'; inp.value = this.c.get(d.id); inp.id = `in-${d.id}`; inp.name = d.id; inp.oninput = e => this.c.set(d.id, e.target.value); w.appendChild(inp); row.appendChild(w); if(d.dep) row.setAttribute('data-dep', JSON.stringify(d.dep)); if(d.id) row.id = `row-${d.id}`; return row; }
                    else if(d.type === 'checkbox') { inp = document.createElement('input'); inp.type = 'checkbox'; inp.checked = this.c.get(d.id); inp.onchange = e => this.c.set(d.id, e.target.checked); row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; }
                    else if(d.type === 'select') { inp = document.createElement('select'); (typeof d.options === 'function' ? d.options() : d.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(d.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(d.id, e.target.value); }
                    row.appendChild(inp);
                    if(d.id) { inp.id = `in-${d.id}`; inp.name = d.id; }
                    if(d.dep) row.setAttribute('data-dep', JSON.stringify(d.dep)); if(d.id) row.id = `row-${d.id}`;
                }
                return row;
            }

            handleAction(a) {
                if(a === 'reset' && confirm('Reset all settings?')) this.c.reset();
                if(a === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts().then(() => this.notifications.show('Cache Cleared', 'success'));
                if(a === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state}, 'matrix_conf.json');
                if(a === 'import') document.getElementById('importFile').click();
                if(a === 'importFont') document.getElementById('importFontFile').click();
                if(a === 'pulse') { if(this.eff.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
                if(a === 'minipulse') { if(this.eff.trigger('MiniPulse')) this.notifications.show('Storm Triggered', 'success'); else this.notifications.show('Storm already active...', 'info'); }
                if(a === 'dejavu') { if(this.eff.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
                if(a === 'superman') { if(this.eff.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
            }

            refresh(k) {
                try {
                    if(k === 'ALL') { this.defs.forEach(d => { if(d.id) this.refresh(d.id); }); this.refresh('fontFamily'); 
                        this.dom.content.querySelectorAll('.accordion-content').forEach(accordionBody => {
                            const allDepRows = accordionBody.querySelectorAll('[data-dep]');
                            allDepRows.forEach(row => {
                                try {
                                    const depRule = JSON.parse(row.getAttribute('data-dep')); const rules = Array.isArray(depRule) ? depRule : [depRule]; let conditionsMet = true;
                                    for (let rule of rules) { let target = rule; let expected = true; if (target.startsWith('!')) { target = target.substring(1); expected = false; } const actual = !!this.c.get(target); if (actual !== expected) { conditionsMet = false; break; } }
                                    if(conditionsMet) row.classList.remove('control-disabled'); else row.classList.add('control-disabled');
                                } catch(e) {}
                            });
                        });
                        return; 
                    }
                    if(k === 'fontFamily') {
                        const sel = document.getElementById('in-fontFamily');
                        if(sel) { sel.innerHTML = ''; this._getFonts().forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get('fontFamily') === o.value) opt.selected = true; sel.appendChild(opt); }); }
                        const list = document.getElementById('fontListUI'); if(list) this.updateFontList(list); return;
                    }
                    if(k) {
                        const inp = document.getElementById(`in-${k}`);
                        if(inp) { const def = this.defs.find(d=>d.id===k); if(def) { const val = this.c.get(k); if(def.type === 'checkbox') inp.checked = val; else if(def.type === 'range') { inp.value = def.invert ? (def.max+def.min)-val : val; const disp = document.getElementById(`val-${k}`); if(disp) disp.textContent = def.transform ? def.transform(val) : val + (def.unit || ''); } else inp.value = val; } }
                    }
                    this.dom.content.querySelectorAll(`[data-dep*="${k}"]`).forEach(row => {
                        try {
                            const depRule = JSON.parse(row.getAttribute('data-dep')); const rules = Array.isArray(depRule) ? depRule : [depRule]; let conditionsMet = true;
                            for (let rule of rules) { let target = rule; let expected = true; if (target.startsWith('!')) { target = target.substring(1); expected = false; } const actual = !!this.c.get(target); if (actual !== expected) { conditionsMet = false; break; } }
                            if(conditionsMet) row.classList.remove('control-disabled'); else row.classList.add('control-disabled');
                        } catch(e) {}
                    });
                } catch(e) { console.warn("UI Error", e); }
            }
        }
        
        // =========================================================================
        // 9. KERNEL
        // =========================================================================


// --- MatrixKernel.js ---
class MatrixKernel {
            constructor() {
                this.notifications = new NotificationManager();
                this.config = new ConfigurationManager();
                this.grid = new MatrixGrid(this.config);
                this.simulation = new SimulationSystem(this.grid, this.config);
                this.effectRegistry = new EffectRegistry(this.grid, this.config);
                
                this.effectRegistry.register(new PulseEffect(this.grid, this.config));
                this.effectRegistry.register(new MiniPulseEffect(this.grid, this.config));
                this.effectRegistry.register(new DejaVuEffect(this.grid, this.config));
                this.effectRegistry.register(new SupermanEffect(this.grid, this.config));

                this.renderer = new CanvasRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
                this.fontMgr = new FontManager(this.config, this.notifications);
                this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications);

                this.fontMgr.init();
                this.frame = 0; this.lastTime = 0; this.accumulator = 0; this.timestep = 1000 / 60;
                let resizeTimer;
                window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(() => this._resize(), 100); });
                
                this.config.subscribe((k) => { 
                    if(['resolution','stretchX','stretchY','fontSize','horizontalSpacingFactor'].includes(k) || k === 'ALL') this._resize(); 
                    if(['smoothingEnabled', 'smoothingAmount'].includes(k)) this.renderer.updateSmoothing();
                });
                
                this._resize();
                requestAnimationFrame(t => this._loop(t));
            }
        

            _resize() { this.renderer.resize(); this.grid.resize(window.innerWidth / this.config.state.stretchX, window.innerHeight / this.config.state.stretchY); }

            _loop(time) {
                if (!this.lastTime) this.lastTime = time;
                const delta = time - this.lastTime; this.lastTime = time;
                this.accumulator += delta;
                while (this.accumulator >= this.timestep) {
                    this.frame++;
                    this.effectRegistry.update();
                    this.simulation.update(this.frame);
                    this.accumulator -= this.timestep;
                }
                this.renderer.render(this.frame);
                requestAnimationFrame(t => this._loop(t));
            }
        }
        window.addEventListener('DOMContentLoaded', () => new MatrixKernel());


    </script>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>