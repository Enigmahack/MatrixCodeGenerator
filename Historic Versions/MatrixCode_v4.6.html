<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Digital Rain v4.6</title>
    <style>
        /* --- CSS RESET & BASE --- */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(10, 12, 16, 0.85);
            --panel-border: rgba(34, 197, 94, 0.3);
            --text-main: #4ade80;
            --text-muted: #86efac;
            --accent: #22c55e;
            --accent-glow: rgba(34, 197, 94, 0.4);
            --danger: #ef4444;
            --info: #3b82f6;
            --input-bg: rgba(0, 0, 0, 0.5);
        }
        body { overflow: hidden; background-color: var(--bg-color); margin: 0; font-family: 'Segoe UI', 'Roboto', monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; }

        /* --- UI PANEL --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; width: 340px;
            background-color: var(--panel-bg); 
            backdrop-filter: blur(12px);
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        
        #panelHeader { 
            padding: 1.25rem; 
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }

        /* --- TABS --- */
        #navTabs { 
            display: flex; overflow-x: auto; 
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.5);
        }
        #navTabs::-webkit-scrollbar { height: 3px; display: block; }
        #navTabs::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); }
        #navTabs::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }
        
        .tab-btn { 
            flex: 0 0 auto; 
            padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }

        /* Content Area */
        #contentArea { flex: 1; overflow-y: auto; padding: 1.5rem; }
        .control-group { display: none; animation: fadeIn 0.3s ease; }
        .control-group.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .control-row { margin-bottom: 1.5rem; }
        .control-header { display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .control-desc { font-size: 0.75rem; color: #6b7280; margin-bottom: 0.5rem; display: block; line-height: 1.3; }

        /* Inputs */
        input[type="range"] { 
            width: calc(100% - 16px);
            height: 6px; background: #1f2937; border-radius: 3px; outline: none;
            appearance: none; -webkit-appearance: none;
            padding: 0 8px; 
            margin: 0;
        }
        .control-row > input[type="range"] {
            width: calc(100% - 16px); 
        }

        input[type="range"]::-webkit-slider-thumb { 
            width: 16px; height: 16px; background: var(--accent); border-radius: 50%; 
            cursor: pointer; box-shadow: 0 0 10px var(--accent); transition: transform 0.1s;
            appearance: none; -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .color-wrapper { display: flex; align-items: center; gap: 10px; }
        input[type="color"] { 
            border: none; width: 40px; height: 40px; padding: 0; background: none; 
            cursor: pointer; border-radius: 50%; overflow: hidden;
            appearance: none; -webkit-appearance: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }

        .checkbox-row { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0; cursor: pointer; }
        input[type="checkbox"] { 
            width: 40px; height: 20px; background: #374151; border-radius: 20px; 
            position: relative; transition: 0.3s; cursor: pointer;
            appearance: none; -webkit-appearance: none;
        }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }

        input[type="file"] { display: none; }

        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; font-family: inherit; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; margin-bottom: 0.75rem; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); box-shadow: 0 0 15px rgba(34, 197, 94, 0.3); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-info:hover { background: rgba(59, 130, 246, 0.4); box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.4); }

        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1 1 120px; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .btn-save { color: var(--accent); border-color: rgba(34,197,94,0.3); }
        .btn-save:hover { background: rgba(34,197,94,0.2); }
        .btn-load { color: var(--info); border-color: rgba(59,130,246,0.3); }
        .btn-load:hover { background: rgba(59,130,246,0.2); }
        .btn-disabled { opacity: 0.3; cursor: not-allowed; }

        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; }
        
        #menuToggle { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 30; width: 44px; height: 44px; border-radius: 50%; color: var(--text-main); background: rgba(10, 12, 16, 0.6); backdrop-filter: blur(4px); border: 1px solid var(--panel-border); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        #menuToggle:hover { background: var(--accent); color: #000; box-shadow: 0 0 20px var(--accent); transform: rotate(90deg); }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <canvas id="bloomCanvas" style="display:none;"></canvas>

    <button id="menuToggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0-.33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l-.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
    </button>

    <input type="file" id="importFile" accept=".json" style="display:none;" />

    <div id="settingsPanel">
        <div id="panelHeader"><h2>System Config v4.6</h2></div>
        <div id="navTabs"></div>
        <div id="contentArea"></div>
        <div id="panelFooter">
            <div id="globalStatus" class="status-msg"></div>
        </div>
    </div>

    <script>
        const APP_VERSION = "4.6";
        const Utils = {
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomFloat: (min, max) => Math.random() * (max - min) + min,
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 255, b: 0 };
            },
            rgbaString: (rgbStr, a) => `rgba(${rgbStr},${a})`,
            CHARS: 'カサタナハヤラワキシチニヒミリウクヌフムケセテメオコソホヲ01245789:+=<>.*',
            getRandomChar: () => Utils.CHARS.charAt(Math.floor(Math.random() * Utils.CHARS.length)),
            getUniqueChar: (exclude) => { let c; do { c = Utils.getRandomChar(); } while (c === exclude); return c; },
            downloadJson: (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
        };

        class ConfigurationManager {
            constructor() {
                this.storageKey = 'matrix_config_v4_6'; this.slotsKey = 'matrix_slots_v1';
                this.defaults = {
                    // Appearance & Stream Settings
                    streamColor: '#01cb23', streamSpeed: 15, trailGlow: 28, clearAlpha: 0.90, 
                    streamMinLength: 10, streamMaxLength: 75, holeRate: 0.15, 
                    
                    // TTL Settings
                    ttlMinFrames: 12, ttlMaxFrames: 110, 
                    decayFadeDurationFrames: 50, 
                    
                    variableBrightnessEnabled: true, brightnessVariance: 20, 
                    dissolveEnabled: true, 
                    
                    // Tracer Settings (ADSR Config)
                    tracerColor: '#ffffff', tracerSizeIncrease: 2, tracerGlow: 32, 
                    tracerAttackFrames: 10,  // Phase 1 (Fade In)
                    tracerHoldFrames: 15,    // Phase 2 (Hold Max Brightness)
                    tracerReleaseFrames: 10, // Phase 3 (Fade Out/Blend)
                    
                    invertedTracerEnabled: true, invertedTracerChance: 0.25,
                    
                    // Rotator Settings 
                    rotatorChance: 0.125, rotatorCycleFactor: 18, rotatorCrossfadeFrames: 7,
                    
                    // Pulse Settings 
                    pulseEnabled: true, pulseFrequencySeconds: 180, pulseDelayFrames: 60, 
                    pulseDurationSeconds: 1.5, pulsePreserveSpaces: true, pulseRandomPosition: true,
                    
                    // Bloom Settings 
                    enableBloom: true, bloomStrength: 2,
                    
                    // Layout Settings
                    fontSize: 24,
                    cellSpacingFactor: 0.95,
                    horizontalSpacingFactor: 1.15
                };
                this.state = { ...this.defaults };
                this.slots = this._loadSlots();
                this.subscribers = [];
                this.load();
                this.updateDerivedValues();
            }
            _loadSlots() {
                try { const stored = localStorage.getItem(this.slotsKey); if (stored) return JSON.parse(stored); } catch (e) {}
                return Array(5).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null }));
            }
            saveSlotsToStorage() { try { localStorage.setItem(this.slotsKey, JSON.stringify(this.slots)); } catch (e) {} }
            load() { try { const stored = localStorage.getItem(this.storageKey); if (stored) this.state = { ...this.defaults, ...JSON.parse(stored) }; } catch (e) {} }
            save() { try { localStorage.setItem(this.storageKey, JSON.stringify(this.state)); } catch (e) {} }
            get(key) { return this.state[key]; }
            set(key, value) {
                this.state[key] = value;
                if (key === 'streamMinLength') this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
                if (key === 'streamMaxLength') this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
                this.updateDerivedValues(); this.save(); this.notifySubscribers(key);
            }
            reset() { this.state = { ...this.defaults }; this.updateDerivedValues(); this.save(); this.notifySubscribers('ALL'); }
            saveToSlot(index) { this.slots[index] = { name: this.slots[index].name, data: JSON.parse(JSON.stringify(this.state)) }; this.saveSlotsToStorage(); }
            loadFromSlot(index) { if(!this.slots[index].data) return false; this.state = { ...this.defaults, ...this.slots[index].data }; this.updateDerivedValues(); this.save(); this.notifySubscribers('ALL'); return true; }
            renameSlot(index, name) { this.slots[index].name = name; this.saveSlotsToStorage(); }
            getExportData() { return { version: APP_VERSION, timestamp: new Date().toISOString(), state: this.state }; }
            validateAndLoadImport(json) {
                try {
                    const data = JSON.parse(json); if (!data.state) throw new Error("Invalid file");
                    this.state = { ...this.defaults, ...data.state }; this.updateDerivedValues(); this.save(); this.notifySubscribers('ALL');
                    return { success: true, message: "Settings Imported" };
                } catch (e) { return { success: false, message: e.message }; }
            }
            updateDerivedValues() {
                const s = this.state; 
                const sRgb = Utils.hexToRgb(s.streamColor); 
                const tRgb = Utils.hexToRgb(s.tracerColor);
                
                // --- ADSR REFACTOR & BOUNDING LOGIC ---
                const cycleDur = 21 - s.streamSpeed; 
                
                // Clamp fade values to cycle duration to prevent math errors
                const safeAttack = Math.min(s.tracerAttackFrames, cycleDur);
                const safeRelease = Math.min(s.tracerReleaseFrames, cycleDur);
                const holdDur = Math.max(0, s.tracerHoldFrames);

                this.derived = {
                    cycleDuration: cycleDur, // Duration of one vertical step
                    safeAttack: safeAttack,
                    safeRelease: safeRelease,
                    holdFrames: holdDur,

                    // Total Life = Phase 1 (Enter/Attack) + Phase 2 (Hold) + Phase 3 (Exit/Release)
                    maxState: cycleDur + holdDur + cycleDur,  
                    
                    rotatorCycleFrames: Math.max(10, Math.round(60 - (s.rotatorCycleFactor * 2.5))),
                    streamRgb: sRgb, tracerRgb: tRgb, 
                    streamRgbStr: `${sRgb.r},${sRgb.g},${sRgb.b}`, 
                    tracerRgbStr: `${tRgb.r},${tRgb.g},${tRgb.b}`,
                    cellWidth: s.fontSize / s.horizontalSpacingFactor, 
                    cellHeight: (s.fontSize / s.horizontalSpacingFactor) * s.cellSpacingFactor,
                    varianceMin: 1.0 - (s.brightnessVariance / 100)
                };
            }
            subscribe(cb) { this.subscribers.push(cb); }
            notifySubscribers(key) { this.subscribers.forEach(cb => cb(key, this.state)); }
        }

        class Cell { 
            constructor() { 
                this.char = Utils.getRandomChar(); 
                this.nextChar = Utils.getRandomChar(); 
                this.state = 0; // Tracer Age (0 to maxState)
                this.decayAge = 0; // Trail Age
                // Rotator state properties
                this.isRotator = false; 
                this.rotationProgress = 0; 
                this.brightnessFactor = null; 
            } 
            resetBrightness(c) { if (!c.state.variableBrightnessEnabled) this.brightnessFactor = 1.0; else if (this.brightnessFactor === null) this.brightnessFactor = Utils.randomFloat(c.derived.varianceMin, 1.0); } 
        }
        

        class ColumnStream {
            constructor(x, gm) { 
                this.x = x; 
                this.gm = gm; 
                this.y = -1; 
                this.timer = 0; 
                this.active = false; 
                this.delay = Utils.randomInt(20,500); 
                this.written = 0; 
                this.length = 0; 
                this.holes = new Set(); 
                this.decayY = -1; 
                this.decayStarted = false; 
                this.isInverted = false; 
                this.visibleLength = 20;
                this.age = 0; 
            }
            
            prepare() {
                const s = this.gm.config.state;
                
                this.length = Utils.randomInt(Math.min(s.streamMinLength, s.streamMaxLength), s.streamMaxLength);
                this.holes.clear(); for(let i=0;i<this.length;i++) if(Math.random()<s.holeRate) this.holes.add(i);
                this.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
                
                const minFrames = s.ttlMinFrames !== undefined ? s.ttlMinFrames : 50; 
                const maxFrames = s.ttlMaxFrames !== undefined ? s.ttlMaxFrames : 250;
                this.visibleLength = Utils.randomInt(minFrames, maxFrames); 

                this.age = 0; 
                this.written = 0; 
                if(!this.isInverted) while(this.written<this.length && this.holes.has(this.written)) this.written++;
                
                this.active = true; 
                this.y = -1; 
                this.delay = 0; 
                this.decayY = -1; 
                this.decayStarted = false;
            }

            update() {
                if(!this.active) { if(this.delay>0) this.delay--; return; }
                const s = this.gm.config.state; const d = this.gm.config.derived; this.timer++;
                
                // Use new Cycle Duration Logic
                if(this.timer % d.cycleDuration === 0) { 
                    this.age++; 

                    // TTL Logic (Time-Based Eraser)
                    if(this.age >= this.visibleLength && !this.decayStarted) { 
                        this.decayY = (this.age - this.visibleLength) - 1; 
                        this.decayStarted = true; 
                    }

                    this.stepHead(s); 
                    if(this.decayStarted) this.stepTail(); 
                    this.timer = 0; 
                }
                
                // Deactivate only when the eraser has cleared the bottom
                if(this.decayStarted && this.decayY >= this.gm.rows) { 
                    this.active = false; 
                    this.delay = Utils.randomInt(50, 150); 
                }
            }
            stepHead(s) {
                if(this.written>=this.length) return;
                this.y++;
                if(this.y>=0 && this.y<this.gm.rows) {
                    const draw = this.isInverted ? this.holes.has(this.written) : !this.holes.has(this.written);
                    const cell = this.gm.getCell(this.x, this.y);
                    if(draw) { 
                        cell.state=1; cell.decayAge=1; cell.char=cell.nextChar; cell.nextChar=Utils.getUniqueChar(cell.char); 
                        // Assign rotator chance
                        cell.isRotator=Math.random()<s.rotatorChance; 
                        cell.brightnessFactor=null; 
                    }
                    else { cell.state=0; cell.decayAge=0; }
                } this.written++;
            }
            stepTail() { this.decayY++; if(this.decayY>=0 && this.decayY<this.gm.rows) { const c = this.gm.getCell(this.x, this.decayY); if(c.decayAge===1) c.decayAge=2; } }
        }
        
        class GridManager {
            constructor(c) { this.config = c; this.grid = []; this.streams = []; this.cols = 0; this.rows = 0; this.releaseTimer = 0; }
            resize(w, h) { const d = this.config.derived; const nc = Math.max(1, Math.floor(w/d.cellWidth)); const nr = Math.max(1, Math.floor(h/d.cellHeight)); if(nc!==this.cols || nr!==this.rows) this.init(nc,nr); }
            init(c, r) { this.cols=c; this.rows=r; this.grid=Array(r).fill(null).map(()=>Array(c).fill(null).map(()=>new Cell())); this.streams=Array(c).fill(null).map((_,i)=>new ColumnStream(i,this)); }
            getCell(x, y) { return (y>=0 && y<this.rows && x>=0 && x<this.cols) ? this.grid[y][x] : null; }
            update(frame) {
                const s = this.config.state; 
                const d = this.config.derived; 

                if(this.releaseTimer<=0) {
                    const av = this.streams.filter(st=>!st.active && st.delay<=0).sort(()=>Math.random()-0.5);
                    let cnt = 4; for(const st of av) { if(cnt--<=0) break; let clr=true; for(let y=0;y<Math.min(this.rows,40);y++) if(this.grid[y][st.x].decayAge>0) { clr=false; break; } if(clr) st.prepare(); else st.delay=20; }
                    this.releaseTimer = d.cycleDuration * 5;
                } else this.releaseTimer--;
                this.streams.forEach(st=>st.update());
                
                const cyclePhase = frame % d.rotatorCycleFrames; 
                const crossfadeStart = d.rotatorCycleFrames - s.rotatorCrossfadeFrames;

                for(let y=0;y<this.rows;y++) for(let x=0;x<this.cols;x++) {
                    const c = this.grid[y][x]; 
                    
                    // --- UPDATED STATE LOGIC FOR ADSR TRACER ---
                    if(c.state > 0) { 
                        if (++c.state > d.maxState) c.state = 0; 
                    } 
                    if(c.decayAge>=2) { if (++c.decayAge > s.decayFadeDurationFrames+2) c.decayAge = 0; }
                    
                    // FIX: ROTATOR LOGIC
                    // Rotators now only spin once the Tracer (state) is completely finished (state === 0)
                    // and it has transitioned to being a standard trail (decayAge > 0)
                    if(c.isRotator && c.state === 0 && c.decayAge > 0) {
                        const safe = y===0 || this.grid[y-1][x].decayAge<2;
                        if(cyclePhase===crossfadeStart && c.rotationProgress===0 && safe) { 
                            c.rotationProgress=1; 
                            c.nextChar=Utils.getUniqueChar(c.char); 
                        }
                        else if(c.rotationProgress>0) { 
                            c.rotationProgress++; 
                            if(c.rotationProgress>s.rotatorCrossfadeFrames) { 
                                c.char=c.nextChar; 
                                c.nextChar=Utils.getUniqueChar(c.char); 
                                c.rotationProgress=0; 
                            } 
                        }
                    } 
                    c.resetBrightness(this.config);
                }
            }
        }

        class PulseEffect {
            constructor(c, gm) { 
                this.config=c; this.gm=gm; this.active=false; this.state='IDLE'; this.origin={x:0,y:0}; this.radius=0; this.snapshot=[]; 
                this.auto = this.config.state.pulseFrequencySeconds * 60; 
            }
            trigger() { 
                if(this.active) return; 
                const s=this.config.state; 
                
                // Snapshot generation
                this.snapshot=Array(this.gm.rows).fill(0).map((_,y)=>Array(this.gm.cols).fill(0).map((_,x)=>{ 
                    const c=this.gm.getCell(x,y); 
                    const isEmpty = c.state===0&&c.decayAge===0;
                    const charToStore = (s.pulsePreserveSpaces && isEmpty) ? ' ' : c.char;
                    return { 
                        char: charToStore, 
                        empty: isEmpty, 
                        color:RendererHelpers.getStreamColor(c,this.config) 
                    }; 
                })); 
                
                this.origin = s.pulseRandomPosition ? {x:Utils.randomInt(this.gm.cols*0.2, this.gm.cols*0.8), y:Utils.randomInt(this.gm.rows*0.2, this.gm.rows*0.8)} : {x:Math.floor(this.gm.cols/2), y:Math.floor(this.gm.rows/2)}; 
                this.active=true; 
                this.state='WAITING'; 
                this.timer=s.pulseDelayFrames; 
                this.radius=0; 
                
                const maxDist = Math.max(
                    Math.abs(this.origin.x), Math.abs(this.origin.y), 
                    Math.abs(this.gm.cols - this.origin.x), Math.abs(this.gm.rows - this.origin.y)
                );
                const durationFrames = Math.max(1, s.pulseDurationSeconds * 60);
                this.speed = (maxDist + 5) / durationFrames;
            }
            update() { if(!this.active && this.config.state.pulseEnabled && --this.auto<=0) { this.trigger(); this.auto = this.config.state.pulseFrequencySeconds*60 + Utils.randomInt(0, 1000); } if(!this.active) return; if(this.state==='WAITING') { if(--this.timer<=0) this.state='EXPANDING'; } else { this.radius+=this.speed; if(this.radius>Math.max(this.gm.cols,this.gm.rows)*1.5) { this.active=false; this.snapshot=[]; } } }
            getRenderMode(x,y) { if(!this.active) return 'LIVE'; if(this.state==='WAITING') return 'FROZEN'; const d=Math.max(Math.abs(x-this.origin.x), Math.abs(y-this.origin.y)); return d>this.radius ? 'FROZEN' : (d>this.radius-6 ? 'OVERRIDE' : 'LIVE'); }
            
            getOverrideData(x, y) { 
                const s = this.config.state;
                const d = this.config.derived;
                const snap = this.snapshot[y] ? this.snapshot[y][x] : null;

                if (!snap) return null;
                if (s.pulsePreserveSpaces && (snap.empty || snap.char.trim() === '')) return null;

                return { 
                    char: snap.char, 
                    color: Utils.rgbaString(d.tracerRgbStr, 1.0), 
                    glow: s.tracerGlow * 1.5, 
                    shadow: s.tracerColor, 
                    size: s.tracerSizeIncrease 
                };
            }
        }

        const RendererHelpers = {
            // --- NEW ADSR COLOR LOGIC ---
            getStreamColor: (c, cfg) => {
                const s = cfg.state, d = cfg.derived; 
                
                // 1. TRACER HEAD LOGIC
                if(c.state > 0) {
                    const cycleDur = d.cycleDuration;
                    const holdDur = d.holdFrames; // using derived value
                    const activeTime = c.state - 1; // 0-indexed time

                    // Thresholds
                    const endPhase1 = cycleDur;
                    const endPhase2 = cycleDur + holdDur;
                    
                    // --- PHASE 1: ATTACK (Fade In) ---
                    // Logic: The cell is moving into existence. 
                    // We only fade in during the LAST 'safeAttack' frames of this cycle.
                    if (activeTime < endPhase1) {
                        const timeInPhase = activeTime; 
                        // The frame where fade STARTS
                        const fadeStartFrame = endPhase1 - d.safeAttack; 
                        
                        if (timeInPhase < fadeStartFrame) {
                            return 'rgba(0,0,0,0)'; // Waiting to fade in
                        } else {
                            // Linear fade 0.0 -> 1.0
                            const p = (timeInPhase - fadeStartFrame) / d.safeAttack;
                            const alpha = Math.max(0, Math.min(1, p));
                            return `rgba(${d.tracerRgb.r},${d.tracerRgb.g},${d.tracerRgb.b},${alpha.toFixed(2)})`;
                        }
                    }
                    
                    // --- PHASE 2: SUSTAIN (Hold) ---
                    // Logic: Full brightness for the duration of holdFrames
                    else if (activeTime < endPhase2) {
                        return d.tracerRgbStr ? `rgba(${d.tracerRgbStr},1)` : '#fff';
                    }
                    
                    // --- PHASE 3: RELEASE (Fade Out / Blend) ---
                    // Logic: Blend from Tracer White to Stream Green.
                    // We fade out during the FIRST 'safeRelease' frames of this cycle.
                    else {
                        const timeInPhase = activeTime - endPhase2; // 0 at start of Phase 3
                        
                        // FIX: SNAP/GLITCH PREVENTION
                        // If we have passed the release duration, return Stream Color immediately.
                        if (timeInPhase >= d.safeRelease) {
                            const baseAlpha = 0.95 * (c.brightnessFactor || 1.0);
                            return Utils.rgbaString(d.streamRgbStr, baseAlpha);
                        }

                        // Calculate Blend Progress (0.0 -> 1.0)
                        const p = timeInPhase / d.safeRelease;

                        // Interpolate RGB (Tracer -> Stream)
                        const r = Math.round(d.tracerRgb.r + (d.streamRgb.r - d.tracerRgb.r) * p);
                        const g = Math.round(d.tracerRgb.g + (d.streamRgb.g - d.tracerRgb.g) * p);
                        const b = Math.round(d.tracerRgb.b + (d.streamRgb.b - d.tracerRgb.b) * p);
                        
                        // Interpolate Alpha (1.0 -> 0.95) 
                        const targetAlpha = 0.95; 
                        const a = 1.0 - (p * (1.0 - targetAlpha));

                        return `rgba(${r},${g},${b},${a.toFixed(2)})`;
                    }
                } 

                // 2. TRAIL DECAY LOGIC (Standard)
                else if(c.decayAge === 1) {
                    let a = 0.95; 
                    if(c.brightnessFactor) a *= c.brightnessFactor;
                    return Utils.rgbaString(d.streamRgbStr, a);
                } else if(c.decayAge >= 2) {
                    let a = 0.95 * (1 - ((c.decayAge - 2) / s.decayFadeDurationFrames));
                    if(c.brightnessFactor) a *= c.brightnessFactor;
                    return Utils.rgbaString(d.streamRgbStr, Math.max(0, a));
                }

                return 'rgba(0,0,0,0)';
            },

            // Rotator Fade: Adapted to handle extended state logic
            getRotatorColor: (c, cfg, prog) => {
                const d = cfg.derived;
                let rgbStr = d.streamRgbStr, a = 1.0; 

                // If currently in Tracer Phase 0, 1, or 2
                if (c.state > 0) { 
                    rgbStr = d.tracerRgbStr; 
                }
                else if(c.decayAge >= 2) {
                    a = 0.95 * (1 - ((c.decayAge - 2) / cfg.state.decayFadeDurationFrames));
                }

                if (c.brightnessFactor) a *= c.brightnessFactor;
                a *= prog; 

                return a <= 0 ? 'rgba(0,0,0,0)' : Utils.rgbaString(rgbStr, a);
            }
        };


        class CanvasRenderer {
            constructor(id, c, gm, eff) { this.cvs=document.getElementById(id); this.ctx=this.cvs.getContext('2d',{alpha:false}); this.c=c; this.gm=gm; this.eff=eff; this.bCvs=document.getElementById('bloomCanvas'); this.bCtx=this.bCvs.getContext('2d',{alpha:true}); 
            this.batches={trails:[],tracers:[],overrides:[],frozen:[],dissolve1:[],dissolve2:[],dissolve3:[]}; 
            window.addEventListener('resize',()=>this.resize()); this.resize(); }
            resize() { this.w=window.innerWidth; this.h=window.innerHeight; this.cvs.width=this.w; this.cvs.height=this.h; this.ctx.textBaseline='middle'; this.ctx.textAlign='center'; this.bCvs.width=this.w*0.25; this.bCvs.height=this.h*0.25; this.bCtx.scale(0.25,0.25); this.bCtx.textBaseline='middle'; this.bCtx.textAlign='center'; this.gm.resize(this.w,this.h); }
            render() {
                const s=this.c.state, d=this.c.derived, bloom=s.enableBloom;
                this.ctx.fillStyle=`rgba(0,0,0,${s.clearAlpha})`; this.ctx.fillRect(0,0,this.w,this.h); if(bloom) this.bCtx.clearRect(0,0,this.w,this.h);
                this.ctx.save(); this.ctx.scale(-1,1); this.ctx.translate(-this.w,0); if(bloom) { this.bCtx.save(); this.bCtx.scale(-1,1); this.bCtx.translate(-this.w,0); }
                this.batches.trails=[]; this.batches.tracers=[]; this.batches.overrides=[]; this.batches.frozen=[]; 
                this.batches.dissolve1=[]; this.batches.dissolve2=[]; this.batches.dissolve3=[];
                
                const eff = this.eff.effects[0];
                for(let y=0;y<this.gm.rows;y++) for(let x=0;x<this.gm.cols;x++) {
                    const md = eff.getRenderMode(x,y); 
                    const xp=x*d.cellWidth+d.cellWidth/2, yp=y*d.cellHeight+d.cellHeight/2;
                    
                    if(md==='FROZEN') { 
                        const dt=eff.snapshot[y][x]; 
                        if(!dt.empty || dt.char.trim() !== '') this.batches.frozen.push({x:xp,y:yp,c:dt.char,col:dt.color}); 
                    } 
                    else if(md==='OVERRIDE') { 
                        const dt=eff.getOverrideData(x,y); 
                        if(dt) this.batches.overrides.push({x:xp,y:yp,c:dt.char,col:dt.color,g:dt.glow,sc:dt.shadow,sz:dt.size}); 
                    }
                    else { 
                        const c = this.gm.getCell(x, y); 
                        if(c.state>0||c.decayAge>0) { 

                            // ROTATOR CROSSFADE LOGIC
                            if (c.isRotator && c.rotationProgress > 0) {
                                const prog = c.rotationProgress / s.rotatorCrossfadeFrames;
                                
                                // Check for dissolve condition
                                if (c.decayAge >= 2 && s.dissolveEnabled) {
                                    const progress = (c.decayAge - 2) / Math.max(1, s.decayFadeDurationFrames);
                                    
                                    const oldCharData = { x: xp, y: yp, c: c.char, col: RendererHelpers.getRotatorColor(c, this.c, 1.0 - prog) };
                                    if(progress < 0.33) this.batches.dissolve1.push(oldCharData);
                                    else if(progress < 0.66) this.batches.dissolve2.push(oldCharData);
                                    else this.batches.dissolve3.push(oldCharData);

                                    this.batches.trails.push({ x: xp, y: yp, c: c.nextChar, col: RendererHelpers.getRotatorColor(c, this.c, prog) });

                                } else {
                                    // Standard Rotator Crossfade 
                                    this.batches.trails.push({ x: xp, y: yp, c: c.char, col: RendererHelpers.getRotatorColor(c, this.c, 1.0 - prog) });
                                    this.batches.trails.push({ x: xp, y: yp, c: c.nextChar, col: RendererHelpers.getRotatorColor(c, this.c, prog) });
                                }

                            } 
                            // STANDARD TRACER/TRAIL/DISSOLVE LOGIC 
                            else {
                                const col = RendererHelpers.getStreamColor(c,this.c); 
                                
                                // Identify Tracer Heads (Phases 1, 2, 3 all count as state > 0)
                                if(c.state > 0) { 
                                    this.batches.tracers.push({x:xp,y:yp,c:c.char,col:col}); 
                                } else { // Trail/Decay
                                    if (c.decayAge >= 2 && s.dissolveEnabled) {
                                        const progress = (c.decayAge - 2) / Math.max(1, s.decayFadeDurationFrames);
                                        if(progress < 0.33) this.batches.dissolve1.push({x:xp,y:yp,c:c.char,col:col});
                                        else if(progress < 0.66) this.batches.dissolve2.push({x:xp,y:yp,c:c.char,col:col});
                                        else this.batches.dissolve3.push({x:xp,y:yp,c:c.char,col:col});
                                    } else { // Standard Trail
                                        this.batches.trails.push({x:xp,y:yp,c:c.char,col:col}); 
                                    }
                                }
                            }
                        } 
                    }
                }
                
                const font=`bold ${s.fontSize}px 'Segoe UI', monospace`; 
                const tFont=`bold ${s.fontSize+s.tracerSizeIncrease}px 'Segoe UI', monospace`;

                if (bloom) {
                    this.bCtx.shadowBlur = 0; 
                    
                    // 1. Trails and Rotator Crossfades
                    this.bCtx.font = font; 
                    this.batches.trails.forEach(i => { this.bCtx.fillStyle = i.col; this.bCtx.fillText(i.c, i.x, i.y); });
                    
                    // 2. Dissolve Parts 
                    if(s.dissolveEnabled) {
                        this.bCtx.font = font;
                        this.batches.dissolve1.forEach(i => { this.bCtx.fillStyle = i.col; this.bCtx.fillText(i.c, i.x, i.y); });
                        this.batches.dissolve2.forEach(i => { this.bCtx.fillStyle = i.col; this.bCtx.fillText(i.c, i.x, i.y); });
                        this.batches.dissolve3.forEach(i => { this.bCtx.fillStyle = i.col; this.bCtx.fillText(i.c, i.x, i.y); });
                    }

                    // 3. Tracers
                    this.bCtx.font = tFont;
                    this.batches.tracers.forEach(i => { this.bCtx.fillStyle = i.col; this.bCtx.fillText(i.c, i.x, i.y); });
                    
                    // 4. Overrides 
                    if(this.batches.overrides.length) { 
                        this.batches.overrides.forEach(i => {
                            this.bCtx.font = `bold ${s.fontSize + i.sz}px monospace`;
                            this.bCtx.fillStyle = i.col;
                            this.bCtx.fillText(i.c, i.x, i.y);
                        }); 
                        this.bCtx.font = tFont; 
                    }
                }
                
                // 1. Trails (Standard Glow or No Glow for Bloom)
                this.ctx.font=font; 
                this.ctx.shadowBlur=bloom?0:s.trailGlow; this.ctx.shadowColor=s.streamColor;
                this.batches.trails.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)});
                
                // 2. Dissolve (Always No Glow)
                if(s.dissolveEnabled) {
                    const baseSize = s.fontSize;
                    this.ctx.shadowBlur=0; 
                    
                    if(this.batches.dissolve1.length){ 
                        this.ctx.font=`bold ${Math.max(1, baseSize - 2)}px 'Segoe UI', monospace`;
                        this.batches.dissolve1.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)}); 
                    }
                    if(this.batches.dissolve2.length){ 
                        this.ctx.font=`bold ${Math.max(1, baseSize - 4)}px 'Segoe UI', monospace`;
                        this.batches.dissolve2.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)}); 
                    }
                    if(this.batches.dissolve3.length){ 
                        this.ctx.font=`bold ${Math.max(1, baseSize - 8)}px 'Segoe UI', monospace`;
                        this.batches.dissolve3.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)}); 
                    }
                    this.ctx.font = font;
                }
                
                // 3. Frozen 
                if(this.batches.frozen.length) { this.ctx.shadowBlur=0; this.batches.frozen.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)}); }
                
                // 4. Tracers 
                this.ctx.font=tFont; 
                this.ctx.shadowBlur=bloom?0:s.tracerGlow; this.ctx.shadowColor=s.tracerColor;
                this.batches.tracers.forEach(i=>{this.ctx.fillStyle=i.col;this.ctx.fillText(i.c,i.x,i.y)});
                
                // 5. Overrides
                if(this.batches.overrides.length) { 
                    this.batches.overrides.forEach(i=>{
                        this.ctx.font=`bold ${s.fontSize+i.sz}px monospace`;
                        this.ctx.shadowBlur=bloom?0:i.g; 
                        this.ctx.shadowColor=i.sc;
                        this.ctx.fillStyle=i.col;
                        this.ctx.fillText(i.c,i.x,i.y);
                    }); 
                }

                this.ctx.restore(); 
                
                // --- BLOOM COMPOSITE ---
                if(bloom) { 
                    this.bCtx.restore(); 
                    this.ctx.save(); 
                    this.ctx.globalCompositeOperation='lighter'; 
                    this.ctx.filter=`blur(${s.bloomStrength * 4}px)`; 
                    this.ctx.drawImage(this.bCvs,0,0,this.w,this.h); 
                    this.ctx.restore(); 
                }
            }
        }

        class ControlRenderer {
            static renderRange(def, config, updateDisplay) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row'; wrapper.dataset.id = def.id;
                const header = document.createElement('div'); header.className = 'control-header'; header.innerHTML = `<span>${def.label}</span><span id="val-${def.id}"></span>`; wrapper.appendChild(header);
                if(def.desc) { const desc = document.createElement('span'); desc.className = 'control-desc'; desc.textContent = def.desc; wrapper.appendChild(desc); }
                const input = document.createElement('input'); input.type = 'range'; input.id = `in-${def.id}`; input.min = def.min; input.max = def.max; if(def.step) input.step = def.step; input.value = config.get(def.id);
                input.oninput = (e) => { const val = parseFloat(e.target.value); config.set(def.id, val); updateDisplay(def, val, wrapper.querySelector(`#val-${def.id}`)); };
                wrapper.appendChild(input); updateDisplay(def, input.value, wrapper.querySelector(`#val-${def.id}`)); return wrapper;
            }
            static renderColor(def, config) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const flex = document.createElement('div'); flex.className = 'color-wrapper';
                const input = document.createElement('input'); input.type = 'color'; input.id = `in-${def.id}`; input.value = config.get(def.id); input.oninput = (e) => config.set(def.id, e.target.value);
                const label = document.createElement('label'); label.textContent = def.label; label.style.flex = "1"; flex.append(input, label); wrapper.appendChild(flex);
                if(def.desc) { const desc = document.createElement('span'); desc.className = 'control-desc'; desc.style.marginTop = "0.5rem"; desc.textContent = def.desc; wrapper.appendChild(desc); } return wrapper;
            }
            static renderCheckbox(def, config) {
                const wrapper = document.createElement('div'); wrapper.className = 'checkbox-row';
                const labelGroup = document.createElement('div'); const label = document.createElement('div'); label.textContent = def.label; labelGroup.appendChild(label);
                if(def.desc) { const desc = document.createElement('div'); desc.className = 'control-desc'; desc.textContent = def.desc; labelGroup.appendChild(desc); }
                const input = document.createElement('input'); input.type = 'checkbox'; input.id = `in-${def.id}`; input.checked = config.get(def.id);
                input.onclick = (e) => e.stopPropagation(); input.onchange = (e) => config.set(def.id, e.target.checked);
                wrapper.onclick = () => { input.checked = !input.checked; input.dispatchEvent(new Event('change')); }; wrapper.append(labelGroup, input); return wrapper;
            }
            static renderSlot(def, config, refreshUI, showStatus) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.textContent = `Save Slot ${def.index + 1}`; wrapper.appendChild(header);
                const container = document.createElement('div'); container.className = 'slot-container';
                const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.className = 'slot-name-input'; nameInput.value = config.slots[def.index].name; nameInput.onchange = (e) => config.renameSlot(def.index, e.target.value);
                const btnGroup = document.createElement('div'); btnGroup.className = 'slot-btn-group';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn-icon btn-save'; saveBtn.textContent = 'SAVE'; saveBtn.onclick = () => { config.saveToSlot(def.index); refreshUI(); showStatus(`Saved ${config.slots[def.index].name}`, 'success'); };
                const loadBtn = document.createElement('button'); const isEmpty = !config.slots[def.index].data; loadBtn.className = `btn-icon btn-load ${isEmpty ? 'btn-disabled' : ''}`; loadBtn.textContent = 'LOAD'; loadBtn.disabled = isEmpty; loadBtn.onclick = () => { if(config.loadFromSlot(def.index)) showStatus(`Loaded ${config.slots[def.index].name}`, 'success'); };
                btnGroup.append(saveBtn, loadBtn); container.append(nameInput, btnGroup); wrapper.appendChild(container); return wrapper;
            }
        }

        class UIManager {
            constructor(c, eff) {
                this.c = c; this.eff = eff;
                this.els = {
                    panel: document.getElementById('settingsPanel'), toggle: document.getElementById('menuToggle'),
                    tabs: document.getElementById('navTabs'), content: document.getElementById('contentArea'),
                    status: document.getElementById('globalStatus'), file: document.getElementById('importFile')
                };
                this.defs = [
                    { category: 'Appearance', id: 'streamColor', type: 'color', label: 'Stream Color' },
                    { category: 'Appearance', id: 'streamSpeed', type: 'range', label: 'Stream Speed', min: 4, max: 20 },
                    { category: 'Appearance', id: 'ttlMinFrames', type: 'range', label: 'Min Length (Frames)', min: 10, max: 400, unit: 'fr', desc: 'Minimum duration before the stream fades out.' },
                    { category: 'Appearance', id: 'ttlMaxFrames', type: 'range', label: 'Max Length (Frames)', min: 100, max: 600, unit: 'fr', desc: 'Maximum duration before the stream fades out.' },
                    { category: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out', min: 1, max: 120, unit:'fr', desc: 'Adjusts the length of the fade out. '},
                    { category: 'Appearance', id: 'holeRate', type: 'range', label: 'Stream Emptiness %', min: 0, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', desc: 'Frequency of gaps in the trails.' },
                    { category: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Character Brightness', desc: 'Random dimmer for stream characters.' },
                    { category: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Range of Brightness', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
                    
                    { category: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Progressive Dissolve', desc: 'Characters shrink while fading.' }, 
                    
                    // Tracer Settings (UPDATED CONTROLS)
                    { category: 'Tracers', id: 'tracerColor', type: 'color', label: 'Tracer Color' },
                    { category: 'Tracers', id: 'tracerGlow', type: 'range', label: 'Glow Intensity', min: 0, max: 50, unit:'px' },
                    { category: 'Tracers', id: 'tracerSizeIncrease', type: 'range', label: 'Size Boost', min: 0, max: 20, unit:'px' },
                    
                    // New ADSR Controls
                    { category: 'Tracers', id: 'tracerAttackFrames', type: 'range', label: 'Fade In (Attack)', min: 1, max: 20, unit: 'fr', desc: 'Frames to fade in before full brightness.' },
                    { category: 'Tracers', id: 'tracerHoldFrames', type: 'range', label: 'Hold (Sustain)', min: 0, max: 60, unit: 'fr', desc: 'How long the tracer stays at max brightness.' },
                    { category: 'Tracers', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out (Release)', min: 1, max: 20, unit: 'fr', desc: 'Frames to blend to stream color after hold.' },
                    
                    { category: 'Tracers', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Hidden Tracers', desc: 'Dark tracers that draw random characters.' },
                    { category: 'Tracers', id: 'invertedTracerChance', type: 'range', label: 'Hidden Tracer Frequency', min: 0.05, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', dep: 'invertedTracerEnabled' },

                    // Rotator Settings
                    { category: 'Rotators', id: 'rotatorChance', type: 'range', label: 'Frequency', min: 0, max: 0.2, step: 0.01, transform: v=>(v*100).toFixed(1)+'%', desc: 'How often a rotating character is written. ' },
                    { category: 'Rotators', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20 },
                    { category: 'Rotators', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Rotation Fade Speed', min: 1, max: 9, unit: 'fr', desc: 'How many frames the character takes to crossfade during a change.' },
                    
                    // Effects Settings
                    { category: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Pulse Effect' },
                    { category: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 5, step: 0.5, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled', desc: 'Keeps the spaces in the blast pattern' },
                    { category: 'Effects', id: 'btnManualPulse', type: 'button', label: 'Manual Pulse Trigger', btnClass: 'action-btn', action: 'triggerPulse' }, 
                    
                    // Layout Settings
                    { category: 'Layout', id: 'fontSize', type: 'range', label: 'Character Size', min: 10, max: 60, unit: 'px', onUpdate: 'layout' },
                    { category: 'Layout', id: 'horizontalSpacingFactor', type: 'range', label: 'Horziontal Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout' },
                    { category: 'Layout', id: 'cellSpacingFactor', type: 'range', label: 'Vertical Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout' },
                    { category: 'Layout', id: 'streamMinLength', type: 'range', label: 'Min Stream Height', min: 10, max: 300, unit: 'rows', desc:'The length of the smallest stream. ' },
                    { category: 'Layout', id: 'streamMaxLength', type: 'range', label: 'Max Stream Height', min: 50, max: 500, unit: 'rows', desc:'The length on the longest stream.'},
                    
                    // Performance Settings
                    { category: 'Performance', id: 'enableBloom', type: 'checkbox', label: 'Upscaling Bloom', desc: 'Use upscaling bloom' },
                    { category: 'Performance', id: 'bloomStrength', type: 'range', label: 'Bloom Blur', min: 0, max: 10, unit: 'px', dep: 'enableBloom' },
                    
                    // System Settings
                    { category: 'System', id: 'slot0', type: 'slot', index: 0 },
                    { category: 'System', id: 'slot1', type: 'slot', index: 1 },
                    { category: 'System', id: 'slot2', type: 'slot', index: 2 },
                    { category: 'System', id: 'btnExport', type: 'button', label: 'Export JSON', btnClass: 'btn-info', action: 'export' },
                    { category: 'System', id: 'btnImport', type: 'button', label: 'Import JSON', btnClass: 'btn-info', action: 'import' },
                    { category: 'System', id: 'btnForceReset', type: 'button', label: 'Factory Reset', btnClass: 'btn-danger', action: 'reset' },
                ];
                this.init();
            }

            init() {
                this.els.toggle.addEventListener('click', () => this.els.panel.classList.toggle('open'));
                this.els.file.addEventListener('change', (e) => this.handleImport(e));
                this.c.subscribe((k, s) => this.refresh(k, s));
                
                this.els.tabs.addEventListener('wheel', (e) => {
                    if (e.deltaY !== 0) {
                        e.preventDefault();
                        this.els.tabs.scrollLeft += e.deltaY;
                    }
                });

                this.buildUI();
            }

            buildUI() {
                const cats = [...new Set(this.defs.map(d => d.category))];
                cats.forEach((cat, i) => {
                    const btn = document.createElement('button');
                    btn.className = `tab-btn ${i===0?'active':''}`;
                    btn.textContent = cat;
                    btn.onclick = () => this.switchTab(cat, btn);
                    this.els.tabs.appendChild(btn);

                    const group = document.createElement('div');
                    group.className = `control-group ${i===0?'active':''}`;
                    group.id = `group-${cat}`;
                    
                    this.defs.filter(d => d.category === cat).forEach(def => {
                        let el;
                        if(def.type === 'range') el = ControlRenderer.renderRange(def, this.c, this.updateDisplay);
                        else if(def.type === 'color') el = ControlRenderer.renderColor(def, this.c);
                        else if(def.type === 'checkbox') el = ControlRenderer.renderCheckbox(def, this.c);
                        else if(def.type === 'slot') el = ControlRenderer.renderSlot(def, this.c, () => this.refresh('ALL', this.c.state), (m,t) => this.showStatus(m,t));
                        else if(def.type === 'button') {
                            el = document.createElement('button');
                            el.className = `action-btn ${def.btnClass}`;
                            el.textContent = def.label;
                            el.onclick = () => this.handleAction(def.action);
                        }
                        if(el) group.appendChild(el);
                    });
                    if(cat==='Layout') {
                        const b = document.createElement('button'); b.className='action-btn btn-info'; b.textContent='Apply Layout'; b.onclick=()=>window.dispatchEvent(new Event('resize')); group.appendChild(b);
                    }
                    this.els.content.appendChild(group);
                });
            }
            switchTab(cat, btn) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.control-group').forEach(g => g.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`group-${cat}`).classList.add('active');
            }
            updateDisplay(def, val, el) {
                if(!el) return;
                if(def.transform) el.textContent = def.transform(val);
                else el.textContent = val + (def.unit || '');
            }
            refresh(key, state) {
                if(key === 'ALL') { this.els.content.innerHTML=''; this.els.tabs.innerHTML=''; this.buildUI(); return; }
                const def = this.defs.find(d => d.id === key);
                if(def && def.type !== 'button' && def.type !== 'slot') {
                    const input = document.getElementById(`in-${key}`);
                    if(input) { if(def.type === 'checkbox') input.checked = state[key]; else input.value = state[key]; }
                    const disp = document.getElementById(`val-${key}`);
                    if(disp) this.updateDisplay(def, state[key], disp);
                }
                this.defs.forEach(d => {
                    if(d.dep === key) {
                        const wrap = document.getElementById(`in-${d.id}`)?.closest('.control-row, .checkbox-row');
                        if(wrap) wrap.style.display = state[key] ? (d.type==='checkbox'?'flex':'block') : 'none';
                    }
                });
            }
            handleAction(a) {
                if(a==='reset' && confirm("Reset all?")) this.c.reset();
                if(a==='export') Utils.downloadJson(this.c.getExportData(), 'matrix_config.json');
                if(a==='import') this.els.file.click();
                if(a==='triggerPulse') { this.eff.triggerPulse(); this.showStatus('Pulse Effect Triggered', 'info'); } 
            }
            handleImport(e) { const f=e.target.files[0]; if(!f)return; const r=new FileReader(); r.onload=ev=>{const res=this.c.validateAndLoadImport(ev.target.result); this.showStatus(res.message, res.success?'success':'error');}; r.readAsText(f); }
            showStatus(msg, type) { this.els.status.textContent=msg; this.els.status.className=`status-msg status-${type}`; setTimeout(()=>this.els.status.textContent='',3000); }
        }

        const config = new ConfigurationManager();
        const grid = new GridManager(config);
        const eff = new EffectSystem(config, grid);
        function EffectSystem(c, g) { this.effects=[new PulseEffect(c,g)]; this.update=function(f){this.effects.forEach(e=>e.update(f))}; this.getActive=function(){return this.effects.find(e=>e.active)}; this.triggerPulse=function(){this.effects[0].trigger()}; }
        const renderer = new CanvasRenderer('matrixCanvas', config, grid, eff);
        new UIManager(config, eff);
        let frame=0; function loop(){ frame++; grid.update(frame); eff.update(frame); renderer.render(); requestAnimationFrame(loop); } loop();
    </script>
</body>
</html>
