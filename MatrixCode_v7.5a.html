<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain</title>
    <style>
/* --- CSS VARIABLES & THEME --- */
:root {
    --bg-color: #000;
    --panel-bg: rgba(10, 12, 16, 0.96);
    --panel-border: rgba(34, 197, 94, 0.3);
    --text-main: #4ade80;
    --text-muted: #86efac;
    --accent: #22c55e;
    --accent-glow: rgba(34, 197, 94, 0.4);
    --danger: #ef4444;
    --info: #3b82f6; /* Preserved from existing */
    --warn: #f59e0b; /* Preserved from existing */
    --safe-top: env(safe-area-inset-top, 20px);
    --safe-right: env(safe-area-inset-right, 20px);
}
#fps-counter {
    position: fixed;
    top: 10px;
    left: 10px;
    color: var(--text-main);
    font-family: monospace;
    font-size: 14px;
    z-index: 10000; /* Ensure it is above the canvas */
    text-shadow: 0 0 5px var(--accent-glow);
    padding: 2px 5px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    user-select: none;
}
        * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(34, 197, 94, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        /* Firefox Support */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0, 0, 0, 0.3);
        }
        html, body {
    height: 100%;
    font-family: 'Segoe UI', 'Roboto', monospace;
    background-color: var(--bg-color);
    overscroll-behavior: none;
    overflow: hidden; /* Retained from existing style */
}
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; transform: translateZ(0); -webkit-transform: translateZ(0); }
        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; height: 100dvh; width: 340px;
            background-color: var(--panel-bg); 
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); }
        #panelHeader { 
            padding: 1.25rem; 
            padding-top: max(1.25rem, var(--safe-top));
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }
        /* --- TABS NAVIGATION --- */
        #navTabs { 
            overflow-x: auto; 
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            position: relative;
            width: 100%;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }
        /* --- ENABLE & STYLE SCROLLBARS --- */
        #navTabs::-webkit-scrollbar { 
            display: block; 
            height: 2px;    
        }
        #navTabs::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2); 
        }
        #navTabs::-webkit-scrollbar-thumb {
            background: var(--accent);       
            border-radius: 2px; 
        }
        #tabTrack { display: inline-flex; width: max-content; }
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
            user-select: none;
            min-height: 48px;
            scroll-snap-align: start;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }
        /* Value Display Styling */
        .control-header span[id^="val-"] {
            font-family: monospace; font-size: 0.85rem;
            color: var(--accent); background: rgba(34, 197, 94, 0.1);
            padding: 2px 6px; border-radius: 4px;
            min-width: 24px; text-align: center; display: inline-block;
        }
        /* --- CONTENT AREA --- */
        #contentArea { 
            flex: 1; overflow-y: auto; 
            padding: 1.5rem; 
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 20px) + 60px);
            -webkit-overflow-scrolling: touch; 
        }
        .control-group { display: none; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.3s ease; }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        .section-header {
            margin-top: 1rem; margin-bottom: 0.25rem;
            font-size: 0.8rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
        }
        .accordion-subheader {
            margin-top: 0.75rem; margin-bottom: 0.2rem;
            font-size: 0.85rem; font-weight: 700; color: #fff;
            text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 3px;
            padding-left: 0.25rem;
        }
        .info-description {
            font-size: 1.0rem;
            color: var(--text-muted);
            padding: 0.5rem 0.25rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .faq-item {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        .faq-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .faq-question {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        /* --- TAB CONTENT STYLES --- */
        .tab-content-group {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease;
            width: 100%;
        }
        .tab-content-group.active {
            display: flex;
        }
        /* --- ACCORDION STYLES --- */
.accordion-item {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    overflow: hidden;
}
.accordion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.8rem 1.2rem;
    cursor: pointer;
    background-color: rgba(34, 197, 94, 0.1);
    border-bottom: 1px solid rgba(0,0,0,0.3);
    color: var(--text-main);
    font-weight: 600;
    font-size: 0.95rem;
    user-select: none;
    transition: background-color 0.2s ease;
}
.accordion-header:hover {
    background-color: rgba(34, 197, 94, 0.2);
}
.accordion-header.active {
    background-color: rgba(34, 197, 94, 0.25);
}
.accordion-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
}
.accordion-icon.rotated {
    transform: rotate(90deg);
}
.accordion-content {
    padding: 1rem 1.2rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid rgba(255,255,255,0.05);
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 1rem;
}
.accordion-content.open {
    display: flex; /* Shown when open */
}
/* Specific styling for caution zone in System tab */
.caution-zone {
    border: 1px solid var(--danger);
    background-color: rgba(239, 68, 68, 0.1);
    padding: 1.5rem;
    border-radius: 6px;
    margin-top: 1.5rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.caution-zone .section-header {
    color: var(--danger);
    border-bottom-color: var(--danger);
    text-align: center;
    margin-bottom: 0.5rem;
}
        /* --- TOOLTIP & TOAST --- */
        .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; margin-right: 10px; }
        .info-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: 25%;
            border: 1px solid var(--text-muted); color: var(--text-muted);
            font-size: 12px; cursor: help; transition: all 0.2s; margin-left: 8px; margin-right: 8px;
        }
        .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }
        #ui-tooltip {
            position: fixed; background: #1f2937; border: 1px solid var(--accent); color: #fff;
            padding: 10px 14px; border-radius: 6px; font-size: 0.8rem; line-height: 1.4;
            z-index: 10000; pointer-events: none; opacity: 0; transition: opacity 0.15s;
            max-width: 240px; box-shadow: 0 4px 25px rgba(0,0,0,0.6); visibility: hidden;
        }
        #ui-tooltip.visible { opacity: 1; visibility: visible; }
        #toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .toast-msg {
            background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
            color: #fff; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem; opacity: 0; transform: translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; align-items: center; gap: 10px;
        }
        .toast-msg.visible { opacity: 1; transform: translateY(0); }
        .toast-success { border-color: var(--accent); color: var(--text-main); }
        .toast-error { border-color: var(--danger); color: #fca5a5; }
        .toast-info { border-color: var(--info); color: #93c5fd; }
        /* Controls */
        input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
        input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }
        /* Color List Styling */
        .color-list-wrapper { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; width: 100%; margin-top: 8px; }
        .color-list-item { position: relative; display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; }
        .color-list-item input[type="color"] { width: 48px; height: 48px; border-width: 2px; }
        .btn-icon-remove {
            position: absolute; top: -6px; right: -6px;
            width: 20px; height: 20px; border-radius: 50%;
            background: #ef4444; color: white; border: 1px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; cursor: pointer; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            line-height: 1; padding-bottom: 2px;
        }
        .btn-icon-add {
            width: 48px; height: 48px; border-radius: 50%;
            border: 2px dashed var(--accent);
            background: rgba(34, 197, 94, 0.1);
            color: var(--accent);
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            line-height: 1; padding-bottom: 3px;
        }
        .btn-icon-add:hover { background: rgba(34, 197, 94, 0.3); transform: scale(1.05); }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }
        select {
            width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            font-family: monospace; font-size: 0.9rem; outline: none;
        }
        select:focus { border-color: var(--accent); }
        option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }
        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }
        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .font-item { 
            display: flex; align-items: center; justify-content: space-between; 
            background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
        }
        .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .font-delete-btn {
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }
        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
        #menuToggle {
    position: fixed;
    top: max(0.75em, var(--safe-top));
    right: max(1.2em, var(--safe-right));
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--panel-border);
    background: rgba(10, 12, 16, 0.6);
    color: var(--text-main);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 30;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px); /* Retained from existing style */
    cursor: pointer; /* Retained from existing style */
}
#menuToggle:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 20px var(--accent);
    transform: rotate(30deg);
}
        @media (max-width: 600px) {
            #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
        }
/* --- MODAL UI --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 50;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
    backdrop-filter: blur(5px);
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
    background: var(--panel-bg); border: 1px solid var(--accent);
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
    width: 90%; max-width: 600px;
    border-radius: 8px;
    display: flex; flex-direction: column;
    max-height: 90vh;
}
.modal-header {
    padding: 1rem; border-bottom: 1px solid var(--panel-border);
    display: flex; justify-content: space-between; align-items: center;
    background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
}
.modal-title { font-size: 1.1rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; margin: 0; }
.modal-close { cursor: pointer; color: var(--text-muted); font-size: 1.5rem; line-height: 1; }
.modal-close:hover { color: var(--danger); }
.modal-body { padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; }
.modal-footer {
    padding: 1rem; border-top: 1px solid var(--panel-border);
    display: flex; justify-content: flex-end; gap: 1rem;
}
textarea.char-input {
    width: 100%; height: 100px; background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1); color: var(--text-main);
    padding: 0.5rem; font-family: monospace; font-size: 1rem;
    resize: vertical;
}
textarea.char-input:focus { outline: none; border-color: var(--accent); }
.modal-label { display: block; margin-bottom: 0.5rem; color: #fff; font-size: 0.9rem; font-weight: bold; }
.modal-desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; }
/* --- CHARACTER SELECTOR REFINEMENTS --- */
/* Fix label colors */
.checkbox-row span {
    color: var(--text-main);
    font-size: 0.95rem;
    font-weight: 600;
}
/* Character Grid */
.char-grid-container {
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 10px;
    max-height: 250px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 8px;
    margin-top: 10px;
}
.char-grid-item {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 20px;
    color: var(--text-muted);
    user-select: none;
    transition: all 0.2s;
}
.char-grid-item:hover {
    border-color: var(--accent);
    background: rgba(34, 197, 94, 0.2);
    color: #fff;
}
.char-grid-item.selected {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent-glow);
}
.char-grid-item.empty {
    opacity: 0.3;
    pointer-events: none;
    background: #000;
}
.char-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.scan-status {
    font-size: 0.8rem;
    color: var(--warn);
    margin-top: 5px;
    min-height: 1.2em;
}
</style>
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E">
</head>
<body>
    <div id="fps-counter" style="display: none;">FPS: 60</div>
    <!-- Primary Canvas for Matrix Animation -->
    <canvas id="matrixCanvas" aria-label="Matrix Digital Rain Animation"></canvas>
    <!-- Hidden Bloom Canvas for Layer Effects -->
    <canvas id="bloomCanvas" hidden aria-hidden="true"></canvas>
    <!-- Toggle Button for Opening Settings Menu -->
    <button id="menuToggle" aria-controls="settingsPanel" aria-expanded="false" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03 .66.07 .98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"></path>
        </svg>
    </button>
    <!-- Input for Importing Files -->
    <input type="file" id="importFile" accept=".json" hidden aria-label="Import JSON Configuration" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" hidden aria-label="Import Font Files" />
    <!-- Settings Panel -->
    <aside id="settingsPanel" role="dialog" aria-hidden="true">
        <header id="panelHeader" role="banner">
            <h2 class="panel-title">Settings</h2>
        </header>
        <!-- Navigation Tabs -->
        <nav id="navTabs" role="tablist" aria-label="Settings Navigation"></nav>
        <!-- Content Area -->
        <main id="contentArea">
            <!-- Dynamic content will populate through scripts -->
        </main>
        <!-- Panel Footer -->
        <footer id="panelFooter">
            <p id="globalStatus" class="status-msg"></p>
        </footer>
    </aside>
    <script>
// --- Utils.js ---
const APP_VERSION = "7.5a"; // Retained current version
// =========================================================================
// 1. CORE UTILITIES / CONSTANTS
// =========================================================================
const Utils = {
    /**
     * Generates a random integer between min (inclusive) and max (inclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (inclusive).
     * @returns {number} A random integer.
     */
    randomInt: (min, max) => min + Math.floor(Math.random() * (max - min + 1)),
    /**
     * Generates a random floating-point number between min (inclusive) and max (exclusive).
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random floating-point number.
     */
    randomFloat: (min, max) => min + Math.random() * (max - min),
    /**
     * Converts a 6-character hex color code (e.g., "#RRGGBB") to an { r, g, b } object format.
     * @param {string} hex - The hex color string.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hexToRgb: (hex) => {
        if (typeof hex !== "string" || !/^#?([A-Fa-f0-9]{6})$/.test(hex)) {
            // Default to a valid fallback RGB value
            return { r: 0, g: 255, b: 0 }; // Default green
        }
        const value = parseInt(hex.replace(/^#/, ''), 16);
        return {
            r: (value >> 16) & 0xFF,
            g: (value >> 8) & 0xFF,
            b: value & 0xFF
        };
    },
    /**
     * Packs 3 RGB components (r, g, b) into a single 24-bit integer.
     * @param {number} r - Red component (0-255).
     * @param {number} g - Green component (0-255).
     * @param {number} b - Blue component (0-255).
     * @returns {number} The packed 24-bit integer.
     */
    packRgb: (r, g, b) => ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF),
    /**
     * Unpacks a 24-bit integer into RGB components {r, g, b}.
     * @param {number} intVal - The packed 24-bit integer.
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    unpackRgb: (intVal) => ({
        r: (intVal >> 16) & 0xFF,
        g: (intVal >> 8) & 0xFF,
        b: intVal & 0xFF
    }),
    /**
     * Converts HSL (hue, saturation, lightness) to RGB { r, g, b }.
     * @param {number} h - Hue (0-360).
     * @param {number} s - Saturation (0-100).
     * @param {number} l - Lightness (0-100).
     * @returns {{r: number, g: number, b: number}} An object with red, green, and blue components.
     */
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - chroma / 2;
        let rgb = [0, 0, 0];
        if (h >= 0 && h < 60) rgb = [chroma, x, 0];
        else if (h >= 60 && h < 120) rgb = [x, chroma, 0];
        else if (h >= 120 && h < 180) rgb = [0, chroma, x];
        else if (h >= 180 && h < 240) rgb = [0, x, chroma];
        else if (h >= 240 && h < 300) rgb = [x, 0, chroma];
        else if (h >= 300 && h < 360) rgb = [chroma, 0, x];
        return {
            r: Math.round((rgb[0] + m) * 255),
            g: Math.round((rgb[1] + m) * 255),
            b: Math.round((rgb[2] + m) * 255)
        };
    },
    /**
     * Creates an RGB color string from an {r, g, b} object.
     * @param {{r: number, g: number, b: number}} color - The color object.
     * @returns {string} An RGB color string (e.g., "rgb(255,0,0)").
     */
    createRGBString: (color) => `rgb(${color.r},${color.g},${color.b})`,
    // List of available characters for random selection
    CHARS: '012345789Z:<=>"*+-._!|⽇゠ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲンワヲン',
    // Subset of Katakana characters for specific use cases
    KATAKANA_CHARS: 'ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲン',
    /**
     * Returns a random character from the predefined KATAKANA_CHARS list.
     * @returns {string} A single random Katakana character.
     */
    getRandomKatakanaChar: () => {
        const index = Utils.randomInt(0, Utils.KATAKANA_CHARS.length - 1);
        return Utils.KATAKANA_CHARS[index];
    },
    /**
     * Returns a random character from the predefined CHARS list.
     * @returns {string} A single random character.
     */
    getRandomChar: () => {
        const index = Utils.randomInt(0, Utils.CHARS.length - 1);
        return Utils.CHARS[index];
    },
    /**
     * Generates a random character from the CHARS list, excluding the provided character.
     * @param {string} exclude - The character to exclude from the random selection.
     * @returns {string|null} A unique random character, or null if no other characters are available.
     */
    getUniqueChar: (exclude) => {
        if (Utils.CHARS.length <= 1) return null;
        let char;
        do {
            char = Utils.getRandomChar();
        } while (char === exclude);
        return char;
    },
    /**
     * Computes the SHA-256 hash of an ArrayBuffer.
     * @param {ArrayBuffer} buffer - The input buffer.
     * @returns {Promise<string>} The hex string of the hash.
     */
    computeSHA256: async (buffer) => {
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    },
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
    /**
     * Downloads a JSON object as a file.
     * @param {Object} data - The JSON object to download.
     * @param {string} [filename="file.json"] - The name of the file to save.
     */
    downloadJson: (data, filename = "file.json") => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    },
    /**
     * Generates an SVG data URL for a single Matrix glyph.
     * @param {string} char - The character to render (e.g., '0').
     * @param {string} color - The color of the character (e.g., '#00FF00').
     * @param {number} size - The font size in pixels.
     * @param {string} fontFamily - The font family to use.
     * @returns {string} A data URL containing the SVG image.
     */
    generateGlyphSVG: (char, color, size = 24, fontFamily = 'monospace') => {
        // Ensure the char is a string and handle potential empty or non-string inputs
        char = String(char || ' '); 
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                <rect width="${size}" height="${size}" fill="transparent"/>
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
                      font-family="${fontFamily}" font-size="${size * 0.8}" fill="${color}">
                    ${char}
                </text>
            </svg>
        `.replace(/\s+/g, ' ').trim(); // Minify SVG string
        // Encode SVG to UTF-8 before Base64 encoding for characters outside Latin1 range
        const utf8Svg = unescape(encodeURIComponent(svg));
        return `data:image/svg+xml;base64,${btoa(utf8Svg)}`;
    }
};
// Predefined cell types for use in the grid
const CELL_TYPE = {
    EMPTY: 0,
    TRAIL: 1,
    TRACER: 2,
    ROTATOR: 3
};
    // =========================================================================
    // 1.1 NOTIFICATION SYSTEM 
    // =========================================================================
// --- ConfigurationManager.js ---
class ConfigurationManager {
    constructor() {
        this.storageKey = 'matrix_config_v7.5a';
        this.slotsKey = 'matrix_slots_v7.5a';
        this.defaults = this._initializeDefaults();
        this.state = { ...this.defaults };
        this.derived = {};
        this.slots = this._loadSlots();
        this.subscribers = [];
        this._previousSmoothingEnabled = undefined;
        this._previousSmoothingAmount = undefined;
        this._loadState();
        this.updateDerivedValues();
    }
    // ====================
    // Initialization Helpers
    // ====================
    /**
     * Initializes the default configuration settings.
     * @private
     * @returns {Object} An object containing all default configuration properties.
     */
    _initializeDefaults() {
        return {
            // --- GLOBAL ---
            streamColor: "#65d778",
            streamPalette: ["#65d778"],
            paletteBias: 0,
            tracerColor: "#d9f2f2",
            fontSize: 24,
            streamSpeed: 16,
            releaseInterval: 2,
            resolution: 1,
            enableGlyphAtlas: true,
            smoothingEnabled: false,
            smoothingAmount: 0.1,
            showFpsCounter: true,
            suppressToasts: false,
            // --- APPEARANCE ---
            fontFamily: "MatrixEmbedded",
            fontWeight: "normal",
            italicEnabled: false,
            mirrorEnabled: false,
            variableBrightnessEnabled: true,
            brightnessVariance: 20,
            // Overlap / Imposition Layer
            overlapEnabled: false,
            overlapColor: "#FFD700",
            overlapDensity: 0.2,
            overlapTarget: "all",
            dissolveEnabled: true,
            dissolveMinSize: 18,
            deteriorationEnabled: true,
            deteriorationStrength: 4,
            enableBloom: true,
            bloomStrength: 4,
            bloomOpacity: 0.45,
            tracerGlow: 12,
            clearAlpha: 0.7,
            horizontalSpacingFactor: 0.7,
            verticalSpacingFactor: 1,
            fontOffsetX: 0,
            fontOffsetY: 0,
            stretchX: 1,
            stretchY: 1.2,
            // --- BEHAVIOR ---
            decayFadeDurationFrames: 23,
            streamSpawnCount: 6,
            eraserSpawnCount: 16,
            minStreamGap: 30,
            minEraserGap: 30,
            minGapTypes: 20,
            holeRate: 0.1,
            desyncIntensity: 0, 
            eraserStopChance: 1, 
            tracerStopChance: 1,
            tracerAttackFrames: 3,
            tracerHoldFrames: 0,
            tracerReleaseFrames: 5,
            invertedTracerEnabled: true,
            invertedTracerChance: 0.1,
            rotatorEnabled: true,
            rotatorChance: 0.13,
            rotatorSyncToTracer: true,
            rotatorSyncMultiplier: 0.5,
            rotatorCycleFactor: 20,
            rotatorCrossfadeFrames: 6,
            rotateDuringFade: false,
            rotatorDesyncEnabled: false,
            rotatorDesyncVariance: 0,
            // --- FX ---
            shaderEnabled: false,
            customShader: null, 
            shaderParameter: 0,
            pulseEnabled: true,
            pulseFrequencySeconds: 300,
            pulseDelaySeconds: 0.7,
            pulseDurationSeconds: 1.2,
            pulsePreserveSpaces: true,
            pulseIgnoreTracers: true,
            pulseDimming: 0.2,
            pulseBlend: false,
            pulseWidth: 130,
            pulseRandomPosition: true,
            pulseInstantStart: false,
            pulseCircular: false,
            clearPulseEnabled: true,
            clearPulseFrequencySeconds: 235,
            clearPulseDurationSeconds: 0.7,
            clearPulsePreserveSpaces: true,
            clearPulseBlend: false,
            clearPulseWidth: 190,
            clearPulseRandomPosition: true,
            clearPulseInstantStart: false,
            clearPulseCircular: false,
            miniPulseEnabled: true,
            miniPulseFrequencySeconds: 450,
            miniPulseDurationSeconds: 5,
            miniPulsePreserveSpaces: true,
            miniPulseThickness: 100,
            miniPulseSpawnChance: 0.06,
            miniPulseSpeed: 16,
            miniPulseSize: 360,
            dejaVuEnabled: true,
            dejaVuFrequencySeconds: 350,
            dejaVuDurationSeconds: 5,
            dejaVuMinRectHeight: 1,
            dejaVuMaxRectHeight: 10,
            dejaVuHoleBrightness: 0.02,
            dejaVuRandomizeColors: false,
            dejaVuIntensity: 0.1,
            dejaVuBarDurationFrames: 28,
            dejaVuVarianceFrames: 43,
            supermanEnabled: true,
            supermanFrequencySeconds: 290,
            supermanDurationSeconds: 6,
            supermanIncludeColors: true,
            supermanFadeSpeed: 6,
            supermanGlow: 4,
            supermanBoltThickness: 5,
            supermanFlickerRate: 2,
            supermanWidth: 4,
            supermanSpawnSpeed: 69,
            starPowerEnabled: false,
            starPowerFreq: 100,
            starPowerRainbowMode: "char",
            starPowerSaturation: 100,
            starPowerIntensity: 51,
            starPowerGlitter: false,
            starPowerColorCycle: true,
            starPowerCycleSpeed: 5,
            rainbowStreamEnabled: false,
            rainbowStreamChance: 0.5,
            rainbowStreamIntensity: 50,
            firewallEnabled: false,
            firewallFrequencySeconds: 150,
            firewallRandomColorEnabled: true,
            firewallColor: "#00ff00",
            firewallReverseDurationFrames: 20,
            firewallEraseDurationFrames: 50,
            // --- BOOT / CRASH ---
            bootSequenceEnabled: false,
            crashEnabled: false,
            crashFrequencySeconds: 600,
            runBothInOrder: true,
            // --- INPUT BINDINGS ---
            keyBindings: {
                "Pulse": "p",
                "ClearPulse": "w",
                "MiniPulse": "e",
                "DejaVu": "r",
                "Superman": "t",
                "Firewall": "y",
                "ToggleUI": " ",
                "BootSequence": "b",
                "CrashSequence": "x",
                "BootCrashSequence": "c"
            },
            hideMenuIcon: true,
            // --- FONT SETTINGS ---
            fontSettings: {
                "MatrixEmbedded": {
                    active: true,
                    useCustomChars: false,
                    customCharacters: ""
                }
            },
            // Properties not directly exposed in UI but used in defaults.json or internally
            deteriorationType: "ghost",
            tracerSizeIncrease: 1,
            supermanProb: 4,
            dejaVuAutoMode: true,
            clearPulseIgnoreTracers: true, 
            clearPulseCircular: false, 
            clearPulseInstantStart: false,
            dejaVuPerformanceMode: false,
            pulseDelayFrames: 60,
            overlapShimmer: false
        };
    }
    /**
     * Loads configuration slots from local storage.
     * @private
     * @returns {Array<Object>} An array of slot data.
     */
    _loadSlots() {
        try {
            const storedSlots = localStorage.getItem(this.slotsKey);
            if (storedSlots) {
                return JSON.parse(storedSlots);
            }
        } catch (e) {
            console.warn('Failed to load slots:', e);
        }
        // Default slots if not found or error occurs
        return [
            { name: "Trilogy", data: JSON.parse(JSON.stringify(this.defaults)) },
            { name: "Save Slot 2", data: null },
            { name: "Save Slot 3", data: null }
        ];
    }
    /**
     * Saves configuration slots to local storage.
     */
    saveSlots() {
        try {
            localStorage.setItem(this.slotsKey, JSON.stringify(this.slots));
        } catch (e) {
            console.warn('Failed to save slots:', e);
        }
    }
    /**
     * Loads the application state from local storage.
     * @private
     */
    _loadState() {
        try {
            let storedState = localStorage.getItem(this.storageKey);
            // Fallback to previous version if current version not found
            if (!storedState) {
                const legacyKey = 'matrix_config_v7.5';
                storedState = localStorage.getItem(legacyKey);
                if (storedState) {
                    console.log("Migrating configuration from v7.5");
                    // Optionally notify user here, but we can't access notifications yet.
                }
            }
            if (storedState) {
                const parsed = JSON.parse(storedState);
                delete parsed.customFonts; // Remove unsupported keys if present
                this.state = { ...this.defaults, ...parsed };
                // Migration: Ensure streamPalette exists
                if (!this.state.streamPalette) {
                    this.state.streamPalette = [this.state.streamColor];
                }
                // Migration: Convert eraserStopChance from float to integer if needed
                if (this.state.eraserStopChance > 0 && this.state.eraserStopChance < 1) {
                    this.state.eraserStopChance = Math.round(this.state.eraserStopChance * 100);
                }
                // Clamp to max 25
                if (this.state.eraserStopChance > 25) {
                    this.state.eraserStopChance = 25;
                }
            }
        } catch (e) {
            console.warn('Failed to load configuration:', e);
        }
    }
    /**
     * Saves the current application state to local storage.
     */
    save() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.state));
        } catch (e) {
            console.warn('Failed to save configuration:', e);
        }
    }
    /**
     * Retrieves the value of a specific configuration key.
     * @param {string} key - The key of the configuration setting.
     * @returns {*} The value of the configuration setting.
     */
    get(key) {
        return this.state[key];
    }
    /**
     * Sets the value of a configuration key and triggers updates.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The new value for the setting.
     */
    set(key, value) {
        if (this.state[key] === value) return; // Skip if no change in value
        // Special handling for shaderEnabled
        if (key === 'shaderEnabled') {
            if (value === true) { // Shader is being enabled
                // Store current smoothing values only if they are not already forced
                if (this.state.smoothingEnabled !== false) {
                    this._previousSmoothingEnabled = this.state.smoothingEnabled;
                } else {
                    this._previousSmoothingEnabled = undefined; // No previous value to restore
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this._previousSmoothingAmount = this.state.smoothingAmount;
                } else {
                    this._previousSmoothingAmount = undefined; // No previous value to restore
                }
                // Force smoothing off
                if (this.state.smoothingEnabled !== false) {
                    this.state.smoothingEnabled = false;
                    this.notify('smoothingEnabled');
                }
                if (this.state.smoothingAmount !== 0.1) {
                    this.state.smoothingAmount = 0.1; // Minimum value as per UI definition
                    this.notify('smoothingAmount');
                }
            } else { // Shader is being disabled
                // Restore previous smoothing values if they were stored
                if (this._previousSmoothingEnabled !== undefined && this.state.smoothingEnabled !== this._previousSmoothingEnabled) {
                    this.state.smoothingEnabled = this._previousSmoothingEnabled;
                    this.notify('smoothingEnabled');
                }
                if (this._previousSmoothingAmount !== undefined && this.state.smoothingAmount !== this._previousSmoothingAmount) {
                    this.state.smoothingAmount = this._previousSmoothingAmount;
                    this.notify('smoothingAmount');
                }
                // Clear stored previous values
                this._previousSmoothingEnabled = undefined;
                this._previousSmoothingAmount = undefined;
            }
        }
        this.state[key] = value; // Update the actual key's value
        this.updateDerivedValues();
        this.save();
        this.notify(key);
    }
    /**
     * Resets the application state to its default values.
     */
    reset() {
        this.state = JSON.parse(JSON.stringify(this.defaults));
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
    }
    /**
     * Saves the current application state to a specific slot.
     * @param {number} index - The index of the slot (0-2).
     */
    saveToSlot(index) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index] = {
                name: this.slots[index].name,
                data: JSON.parse(JSON.stringify(this.state)) // Deep clone state
            };
            this.saveSlots();
        } else {
            console.warn(`Attempted to save to non-existent slot index: ${index}`);
        }
    }
    /**
     * Loads the application state from a specific slot.
     * @param {number} index - The index of the slot (0-2).
     * @returns {boolean} True if the state was loaded successfully, false otherwise.
     */
    loadFromSlot(index) {
        if (!this.slots[index]?.data) return false; // Use optional chaining for safety
        this.state = { ...this.defaults, ...this.slots[index].data };
        this.updateDerivedValues();
        this.save();
        this.notify('ALL');
        return true;
    }
    /**
     * Renames a specific configuration slot.
     * @param {number} index - The index of the slot (0-2).
     * @param {string} name - The new name for the slot.
     */
    renameSlot(index, name) {
        if (this.slots[index]) { // Ensure slot exists
            this.slots[index].name = name;
            this.saveSlots();
        } else {
            console.warn(`Attempted to rename non-existent slot index: ${index}`);
        }
    }
    /**
     * Subscribes a callback function to configuration changes.
     * @param {Function} callback - The function to call when configuration changes.
     */
    subscribe(callback) {
        if (typeof callback === "function") {
            this.subscribers.push(callback);
        }
    }
    /**
     * Notifies all subscribed listeners about a configuration change.
     * @param {string} key - The key of the changed configuration setting.
     */
    notify(key) {
        this.subscribers.forEach((callback) => callback(key, this.state));
    }
    /**
     * Updates all derived configuration values based on the current state.
     * These are values calculated from base settings for performance or convenience.
     */
    updateDerivedValues() {
        const s = this.state;
        const cycleDuration = 21 - s.streamSpeed;
        const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
        const vFactor = Math.max(0.5, s.verticalSpacingFactor);
        const rotatorCycleFrames = s.rotatorSyncToTracer
            ? Math.max(1, Math.floor(cycleDuration / s.rotatorSyncMultiplier))
            : Math.max(10, Math.round(60 - s.rotatorCycleFactor * 2.5));
        this.derived = {
            cycleDuration,
            safeAttack: Math.min(Math.max(1, s.tracerAttackFrames), cycleDuration),
            safeRelease: Math.min(s.tracerReleaseFrames, cycleDuration),
            holdFrames: Math.max(0, s.tracerHoldFrames),
            maxState: cycleDuration + Math.max(0, s.tracerHoldFrames) + cycleDuration,
            rotatorCycleFrames,
            cellWidth: s.fontSize * hFactor,
            cellHeight: s.fontSize * vFactor,
            varianceMin: 1.0 - s.brightnessVariance / 100,
            streamRgb: Utils.hexToRgb(s.streamColor),
            tracerRgb: Utils.hexToRgb(s.tracerColor),
            streamColorStr: Utils.createRGBString(Utils.hexToRgb(s.streamColor)),
            paletteRgbs: (s.streamPalette || [s.streamColor]).map(c => Utils.hexToRgb(c)),
            paletteColorsStr: (s.streamPalette || [s.streamColor]).map(c => Utils.createRGBString(Utils.hexToRgb(c))),
            tracerColorStr: Utils.createRGBString(Utils.hexToRgb(s.tracerColor)),
            fontBaseStr: `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
        };
        // Active Fonts Logic
        const fontSettings = s.fontSettings || {};
        const activeFonts = [];
        for (const [name, conf] of Object.entries(fontSettings)) {
            if (conf.active) {
                let chars = Utils.CHARS;
                if (conf.useCustomChars && conf.customCharacters) {
                    const clean = conf.customCharacters.replace(/\s+/g, '');
                    if (clean.length > 0) chars = clean;
                }
                activeFonts.push({ name, chars });
            }
        }
        if (activeFonts.length === 0) activeFonts.push({ name: 'MatrixEmbedded', chars: Utils.CHARS });
        this.derived.activeFonts = activeFonts;
    }
}
    // =========================================================================
    // 3.0 MATRIX GRID
    // =========================================================================
// --- FontData.js ---
const DEFAULT_FONT_DATA ="data:application/octet-stream;base64,d09GMgABAAAAABNAAA0AAAAANtwAABLpAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGlwGYACEGhEICtQov1oLgXoAATYCJAODbgQgBYRYB4YaG60qsyLYOAAgyntGVE3mIP5PyROZeUF/NWSvBIIzjOrpE5K4Q9hxhAMNj8M88ibjVcuOzYJvE99g40+GE5HPiEgqEl5d1mptQ5dHw0IhPkKSWfgH5bD3k1TE2J6sTfKoCfak6WY4P/Db/D9XsK6xomzGbBxSBiaRUqk994wE+yMuKtRFldUL/55sU1f9IsrAbd2w1hYiYo1/r4javbrXu6/inaWgk7eXp6XDJAgge5GazX8u0wTMVrBTKXB3W5mnFoacSfyGNUwNo3AK9a40wCUTeplrEcTaluswkxds2lS5qgQPxLLDvKzFYaqODWNFrkTG8Z/G3H/b0t0kqWNmJ4hIM42sNBKtQNrdQuR/10qbf0BqcghleVuvBjrzmiOeA1QtZ0qYTf6fV1lpAdWyL6JSBPKU2la4SllXf0K7wvO13574dtgT0Uz1kqiVu4hGW2g08apeOpXQyfZLDt/WGEZm1Nad8vig27aIV8ULU5eU0YEtgK7Ol4jTmwHeB2wsi+l1ixwAAcKBTv4YQgkwXMTsQUgh0OGZkHku4aJMOEIlR6jmCLU3RGiCA8EBkiY3AdZFaAMBYHaaB8D61R30lTqFqL5JkAbdthlBgeq/9qXvp9nQAKzFNrcVA9mF+KE/PYGj+H69W1h+nkE5ZLCEN+H10UgijSyu3LUkljjkhIt6jTXd+77r1+q/3gOQTTR0UuBx+Qh3Pu6Uq4a627O+6MfqP+4u+Pfgn/mn/rF/5B/6gSe/K932tLsdbcHjVZC4qHkQygHD6UAqQO1m9sISRDAQQiiD2BwuMCzC8PUTRghFWp0egBlGUCDIAoAMYDp7K7iAwBsFBRMSShhieKvduXHIdR/UqwOkPMt2XM8PwihO0iwvyqpu2o4YB4A6gz8aT6az+QLin95o2knwngqq5+ARxLnHIXwWELOAw8kI7gJAUQoClBci1N8MABQgfxbsujQHNXP1bS5Ib4YziHJQQKjV0WVRkYPKaaux23aWR/pNuNW4+VL5nW9eT89X5Su8aYi5fIlhxmHNwyy35UTRI3m5PJK6By/A3tyCMv5HXqcWL7elxymLItN2cZrZbEQurCo1IXzZ7eY5t/zpskxAofpzMTQzZhlzl+/uDsvOxqGNvUh0YySJgm6RNxrlAtqPArFna5Hp5Iy30bRucj16UuM8EliDMTs64DDOWtNIDBg/bTSDD93Akf1d/EnufemXdisrf7A1LCP+ZvoFL1edjkMa2bD1lOXVZxIIocT4C97G20ln8cPSXlPzv9nprHDXWBCelM/mDuNb36Q8TkA4VSBErqgjqu6vfypyABgGuvh4RFJdXNYrVP8y+uFPBV+sOcvpHfs6CBbUnksbpr37F8abGGmrHgDPWtIvm5SRJv+UayViwdJ1o+mXNZ2qPMUor+8Ehp6Ld6Y2hxLaCnfZiPibAj8H+Fat/IEIzVeGf09HRsDFro668/H9qxjKxb4eggWlL/s0Bh7Sj8RfIgwhOd1ytWVaZxiWXzPKB38SC/qcYykBBPxdkAVvg1BJmSNi/U19QwVaWmJ5/wVgaOgr9vVsliIZYkFvd+AKJ7a+wgvfmr8D7O4sMj0f3Z7PyLw3XR76NVVwRnrb3Vl/IXFgo2Jz/b3II50L4GgBjvmeXu7rn09ACrgbB/191NuzeKfh6TqtrUW1om0Lnwy2+yef1LYKmwiJ2x2HZdDqkKMiZrxXaC7LODLQJ72w7LSeNu5XvfPTXNr7iFGuyD+hAkkJSYf/Yd7bVqw5C8FImElUhSxMHR6PovsNfVO/0xjThkyp5/UEglm6LjClznyjv9D1HD8pXYQlyFnePZVdBpRWNRYbvIhzv2Nyl53/btUFSFSiAtTNspMDlCevTwd5mvGB/xaCSt4YI48GkVEVdxqoOVMrqPC34IOkjQ1ePdFra2795HUWvMw9DY75eJz+rOLFiB4fNtL2wdyCjW+tlkwxcSE5wN3OIhVoF4IKkEgnx961mY5By82g8Wbpl+bK8f10VLeVw466hCmV+Rl7n443hWXi81G/b1caY3jfWhWBDKzH3Yhux9Mbu13HsLAlD9TCy8AH1Tx1QM3c08wNGUbRbtAGaE8o8SZh0Hf0SjYEDTxEjyzKrVROmWA06LA8X9c6dCt8/kKWWKhSyV6r7R5FpoCJ0h1zhMGDlKsKMSk7CXkY5Z/sAqR2Ps69Iv7Gdoam5dHgwYaLNe3BPf5yRk/XpLzXtgzd9RLsBQGvkmHNjpGa2dJFTX8vOJ1ceiXxe/0Fa4HIqEDKBJh8J6yMv5//rnc/k9ADPiTYj8pJmxjJlsw8MlIAefJ2+V/OAfdbd9OJwG6IRZzjpKVfMuBx85SIp/idiU4m0X0hb/BNk/JRGzLVoMjqauJpBrL0bGNaMCf6RKv4uZIv8Xpk5stAX/k/cTn1azVttS82K7yXvPcoRvW9v7eZfF3CfwgsCNjF4kAUvqeqZ6qQeL97qn6q/gJQYuIyYE1ln+zg5s7+C+r2sTjspFWQ8Zn5ZXn8uUavbGKJtXiVK7oIA4LdARxo6fsgjd7qUomFsA4zanIuE8y6LqMDYYYWA6FhLmxrsVBUo0kEbUJ4cZKjIgOVTRwf42CMZIzRLko2pMSgYAgKSL0M1qcbSjjynUZawujHkDMvUhhYGYBVC4rawepSY8EQy+44VMYvhGlsA6iqUWu8YHSvmYGCVxl4ODOLAinNAyKBf3o1rU2nsa30/GdGMISyl0ae9nUKYae8x6wT3A7DyI0G2Dq5rToTTGkEDR1TnFbAU/9aoK63QdKGGMce3AIi8Vd0V3bnRQsPLDxQKGO7c1Mg1yo8sPBMuNlo3XLZdnmLTxV++bmda4U9I6MTo0DacUAJxSUKVHWcrIRvQQ3x/5OPZ+oBKRtjL4sFaaKxP3uxcwh9l9g/7mDxxXe+2oLF4LsvsWDVTyrfU+fVJwogok6b+HWHNscnN1hb8CZzz9faOOL94AwRv7HiK6hYrc4I5n4X4IkOG7fl+4836XSsTOXXzaubGrv6g+JoghkyWJN+S58HZtXLdXoOL5ErcOpaOzQTmfCtd7ZR03qPvWE+OYTuDOgY53yRCanHzaZzfu8qYwGxlBWXeeyENqTyEJJ4CP77WA+tuWA4BN8/09tfBgqinLpT3wgCI52W/HzvbEN+6zi7lP5DSKyTHvIDNIpAtpWMesxu2oGUJkvjGRr9RFZzRjzngdK8RlGZ6Gi50iLSkdPWhhsST+4e/tjx7NfxCbZUUszix02wJNISqRSY+sU6xHioruQBq9RP4adgjnSPzC6elbOZv5xVwiwGBn9fos7vM3WP8jdTl1iw39VkQzGeaNKiGKEqkc/gM/kZPQqGgMHnJ6qjeVvmop5YdOnK+dyv2zeClcFVMxhuv7Kq438Kyw3DvLNUpXMENo4gvSoe45of9hMsCwDpUnojaqE0ZVngBEs9LCHJqQBThaqay4va10Tobb1++b+TJZEWCywnU8ok8uH7V7uvds3EjEA9RiPR/FfF+seSYNe66JpouO5GLu7gLRpplR2728A85B0QrM7SFuxTS1Tig4SDmIRTCQcXhV2irNRbXDC/eEEtJj4tOK2qpABbQDcbLGC4eJgNUvrZM7UgwbyjwRaXkIIsqKpTEkX4RS2zhCSLPBK3F6qXk4ggEc93RzxMpraP3PhNBt/zMC8VGBjUlmGzXLTYLAKygxK8xmJ0tBjslbaKi0D8KeBSbh6yNnC/tyLSerBq8UzvQ17LmsQik7LJUE0vIM6OtAdX25u/sZi3GhYN13IygsS+OZnUeVBArUmwuU+gHj4th1M8SjWhufDP8g4fjGwun+L7xh1dDXXuSC00wUjHNt/aIG2QtsyqClGTa3yfFhJa13Iq3LhLRNTVNSE1K2sgvRhB7tL44XzaXQT5iiEsFTKg/xtjZ8vso7MvON5cXtPPEWEpZFGzOFQU9sdDxrHDjGMQPxPXBlJZm6zo0gr6CghrNvTouxcbuzldtQjm/ctSeUBHE+Ss1X1qyx08JTDxjZkUC+UUEs2LOaJ24XRRZVTZTQ0dPBelA/yihDo+1Al81/4ioG9wOdePWOVWRWJOQraPEhUwMAsxZewVUaWb7OXZsGr6iu2bzF2Z3yFWcnaIJVlUvKp0zzfXNnxLriF/S58UENubt4FktCribGrykgjNbAWMLlq5TSqbJ82QLtaJcHycMGkMLY/j1n+GF3+oXAV2X4L3yaBzs7Ain/bo3fB+rqxWdmnJpXFw2t3bvyxGGavcYFTM4Hmz55s+mbtAF8wnC4r2jw8tgUF/WTrSJEvzWum1dmMtd1d09V4CpvoeHWyWWTth1nnHm4erSoLqyUw3rOgcZd2SgqxqcubAnMIk+4Jq+zu9ZDuwl/rCHE+Hh8+BV1D8BIRCxz7zrvgF9U9xEjQkvsR/k09GRIA1kOotw9n9NASxgLKeIsAKsTzieh8NLrDKf46v+rx1R9qlO3jIfctHNzvy7p7l6/nGKyILogYqZ/52IeJIN23fBMyhFeWkP3f/mXtWqzMYi+cVUwygAM4sJFFPkQZzZenSTdMl//yveLn7Jbx7BnqaAOG5iNzbZznWHimbQ1FRtFsiGRKsBBOAFaryDYe2JTGZ1PX/WDjVIfvKwnELWdw4IStcEiYPmISe/n+Lf/vw+AjWl77fb3/N/NZ9/7zlr6BoOgGj2I5RwCP9Snwgv3JAg0sCdtmcBdhlPBxaT8ohaWGvdnX19MbCo9v1Wu8M9HDSg5RK18hAXpCwBnxXSFeuaf31fh69bVXrr59KYQwBCgEKG3+HQvn/M3QkoouLF3MUuxScvKVz1eFXUyOzZG7umq/+mvXsAWrG3Q6xBBsvJmlw4bjxXbRStw4XI9B/HIzkKEO8iP7b/Ik3bkgjImzZ1GsfY3URoe2NwMbL8XKOm3+kv9udJzg5Tg7f+y5R0mYSetmXZG/dM6BgRVXl0upuJGeEz97aiLqyGqSZBX11980rVoTGBddA+R9323n7gbChJVI/w3d6V1HRdz4XU2pSa7KFOYLCgIJAPjaxkpCXBmXNI9LRcu0vfWDOcRANxFw4n1ub27AGJUXvU38ximpiVN4x6/vkiWJ67t4X9duC6qxwHvwwB8c6bZ29DmVbo0U8+/vV3PgjQwk/kfim4l4Pm8cYyJaC7iOUFHQpULOHnCIli7icDXlDYJsT4764blVLfOex4460hGp2KTx1p2ZBJtyQCM1C8/kGi6UhOAiOAIu1XatNXhcljhI3pXJdeAjddR5969GtEDS0SrFeAawjgWykgH2avYctRqVWK9vB3gRkBEgGrpViZH1IFsgpjBwNxUBFyGBJVV7SJDL5SAZOqQYo/2MVZrFmQSkxKCNOX+NgiNRV0QGj7RQ0GE4SJrNbqAUztfmhN45ILUkqGV6E0MVjpvym8qOxrU1tP+ThDEKT1PhQBKnpQopCYcTT2g1flm3NQT3B3YvJ3e7XaxEM+VaUPGAH1XrFQMR0gAonIalYhVzZx6GsDxz2nBidOD7k55ipb/oFdhf4U/v5PV/ECZeNE2buti6BaKaf+SFptt4eQIBg/ruXuBUN34LZcfYWGf6+nWFPqQgWN84JzlRyJq4YADvjXZnqZ09q1RsPl7k9H1yxWruJCQ6VOvgOO+AhLGMXq3lSvg9ewzP4yd5U6VC1cmBid5kr5lI1HxPHXDFb7RtuyU5XLOMYhvEMyeAdEHF273+cpZfkLcSDaXCWPa9mAJ7wQVfM4+nvn0CpBEbhpphMgfHBKbD+c82bw7oq7Wpu35jsuMxCDbnHM8WbIjLFbFTJLCD1VcRLseKlOcabKmd8EG5JdTLZVCZX1Vm19XwiJg1UZZqvLlXGus+ETFc556pKGgpBrziLz1RZukuGxPJdXQDmeOHGe8eUEMlxxEAkQtsMG4LoHbbkczLsCOOzE+BRcDiQRLXohJKq9RMDciFOecaHDZG0DlvascOORMZVAN+HAylX/F9CqVd/Yo1cqubLoBcq0YT4ySC3/bRQKxLD6JOntZ/5YUlbdxryjZ5l7D3QQyw1q/gGuKW7WaCNVmN6tQOFShIt2Qx2l5DZbbkxbRn2WI6gOQRX1+V6UltSRJ75hUvCFB83jDXn7LwLKr5ZW9VHzvhUKqvdIhnTInAG/MezlqBbcs0vkZteqi5Zfl4X8Qlkn9ghu8aWEit4mdbUjUtyOFd5tpeFhA6Y/n9zAJlUKFKQKdGiTZdAIlOoNDqDyWJzeHyBWCKVyRWD6aHWaHUIw/UNDI2MTUzNzC0s7RAiQowEKTIykKMgX7fKKqpq6hqaWto6ugQiiUyh0ugMJovN4fL4AqFILJHK5AqlSq3R6hCG6xsYGhmbmJqZW1haWdtoS/T5n1JGJ6LVGXb/N8luK2UltZknHfsQi8Ynz5YwnE9SgGZYfZ6doBhO8EkK0Ixez15QDCcoQDP6PAfGcALQDKvPcyQejKAkBVh9nhMjKIaDYgM=";
    // =========================================================================
    // 4.0 STREAM MODE
    // =========================================================================
// --- MatrixGrid.js ---
class MatrixGrid {
    constructor(config) {
        this.config = config;
        // Grid dimensions
        this.cols = 0;
        this.rows = 0;
        // Grid storage and state tracking
        this.activeIndices = new Set(); // Tracks active (non-empty) cells
        this.chars = null;
        this.types = null;
        this.alphas = null;
        this.decays = null;
        this.ages = null;
        this.brightness = null;
        this.rotatorProg = null;
        this.rotatorOffsets = null;
        // Auxiliary storage
        this.complexStyles = new Map(); // Tracks complex character styling
        this.nextChars = new Map(); // Tracks characters for transitions
    }
    /**
     * Resizes the grid based on new width and height, reallocating arrays only if dimensions change.
     * @param {number} width - The new width of the grid area.
     * @param {number} height - The new height of the grid area.
     */
    resize(width, height) {
        const d = this.config.derived;
        const newCols = Math.max(1, Math.floor(width / d.cellWidth));
        const newRows = Math.max(1, Math.floor(height / d.cellHeight));
        if (newCols !== this.cols || newRows !== this.rows) {
            this._resizeGrid(newCols, newRows);
        }
    }
    /**
     * Gets the 1D array index from 2D coordinates (x, y).
     * @param {number} x - The column index.
     * @param {number} y - The row index.
     * @returns {number} The 1D index, or -1 if out of bounds.
     */
    getIndex(x, y) {
        if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) {
            return -1; // Out of bounds
        }
        return y * this.cols + x;
    }
    /**
     * Sets a character at the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @param {string} charStr - The character string to set.
     */
    setChar(idx, charStr) {
        if (typeof charStr === "string" && charStr.length > 0) {
            this.chars[idx] = charStr.charCodeAt(0);
        }
    }
    /**
     * Gets the character from the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @returns {string} The character at the index.
     */
    getChar(idx) {
        // Ensure chars array is not null before accessing
        if (!this.chars || idx < 0 || idx >= this.chars.length) return '';
        return String.fromCharCode(this.chars[idx]);
    }
    /**
     * Sets the font index at the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @param {number} fontIndex - The index of the font to use.
     */
    setFont(idx, fontIndex) {
        if (this.fontIndices && idx >= 0 && idx < this.fontIndices.length) {
            this.fontIndices[idx] = fontIndex;
        }
    }
    /**
     * Gets the font index from the specified grid index.
     * @param {number} idx - The 1D index of the cell.
     * @returns {number} The font index at the index.
     */
    getFont(idx) {
        if (!this.fontIndices || idx < 0 || idx >= this.fontIndices.length) return 0;
        return this.fontIndices[idx];
    }
    /**
     * Reinitializes all grid arrays and dimensions.
     * @private
     * @param {number} newCols - The new number of columns.
     * @param {number} newRows - The new number of rows.
     */
    _resizeGrid(newCols, newRows) {
        const totalCells = newCols * newRows;
        // Reinitialize arrays with new size
        this.chars = new Uint16Array(totalCells);
        this.types = new Uint8Array(totalCells);
        this.alphas = new Float32Array(totalCells);
        this.decays = new Uint8Array(totalCells);
        this.ages = new Int32Array(totalCells);
        this.brightness = new Float32Array(totalCells);
        this.rotatorProg = new Float32Array(totalCells);
        this.rotatorOffsets = new Uint8Array(totalCells); // Offset for desync logic
        for(let i=0; i<totalCells; i++) {
            this.rotatorOffsets[i] = Math.floor(Math.random() * 255);
        }
        // Color Palette Index (0-2)
        this.paletteIndices = new Uint8Array(totalCells);
        // Font Index (0-255) for multi-font support
        this.fontIndices = new Uint8Array(totalCells);
        // Imposition Layer (Overlap)
        this.overlapChars = new Uint16Array(totalCells);
        // Cell Locks (for pausing simulation under effects)
        this.cellLocks = new Uint8Array(totalCells);
        this.activeIndices = new Set();
        this.complexStyles = new Map();
        this.nextChars = new Map();
        this.nextOverlapChars = new Map();
        // Update grid dimensions
        this.cols = newCols;
        this.rows = newRows;
    }
}
// --- FontData.js ---
// --- EffectRegistry.js ---
class EffectRegistry {
            constructor(grid, config) { this.grid = grid; this.config = config; this.effects = []; }
            register(effect) { this.effects.push(effect); }
            trigger(name) { const fx = this.effects.find(e => e.name === name); if(fx) return fx.trigger(); return false; }
            update() { this.effects.forEach(e => e.update()); }
            getOverride(i) { for(const fx of this.effects) { const o = fx.getOverride(i); if(o) return o; } return null; }
            hasActiveEffects() { return this.effects.some(e => e.active); }
        }
        class AbstractEffect {
            constructor(g, c) { this.g = g; this.c = c; this.name = "Base"; }
            trigger() { return false; }
            update() {}
            getOverride(i) { return null; }
        }
// --- BootEffect.js ---
class BootEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry;
        this.name = "BootSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = 3.5; 
        this.originalShader = null; 
        this.originalShaderEnabled = false; 
        this.originalShaderParameter = 0.5; 
    }
    trigger() {
        if (this.active) return false;
        this.originalShaderEnabled = this.c.state.shaderEnabled;
        this.originalShader = this.c.state.customShader;
        this.originalShaderParameter = this.c.state.shaderParameter;
        this.c.set('shaderEnabled', true);
        this.c.set('customShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; // 0.0 to 1.0 over 3.5s
varying vec2 vTexCoord;
// --- UTILS ---
float random(float n) {
    return fract(sin(n * 12.9898) * 43758.5453123);
}
float noise(float p) {
    float i = floor(p);
    float f = fract(p);
    return mix(random(i), random(i + 1.0), f * f * (3.0 - 2.0 * f));
}
float sdRoundedBox(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
float vignetteRect(vec2 uv, float margin) {
    vec2 v = smoothstep(0.0, margin, uv) * smoothstep(1.0, 1.0 - margin, uv);
    return v.x * v.y;
}
float smoothstep_custom(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * (3.0 - 2.0 * x);
}
// "Scanner Sheet" with subtle torn edges
// axis: 0 = none, 1 = jagged horizontal edges, 2 = jagged vertical edges
float scannerSheet(vec2 uv, vec2 center, vec2 size, float blur, int axis) {
    vec2 pos = uv - center;
    // Torn edge effect
    float jagged = 0.0;
    if (axis == 1) {
        jagged = (noise(uv.x * 50.0) - 0.5) * 0.005; 
        pos.y += jagged;
    } else if (axis == 2) {
        jagged = (noise(uv.y * 50.0) - 0.5) * 0.005;
        pos.x += jagged;
    }
    vec2 d = abs(pos) - size;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    return 1.0 - smoothstep(0.0, blur, dist);
}
// Asymmetrical Scanner Scenes (Full Span + Torn Edges)
vec3 getScannerScene(int pattern, vec2 uv) {
    vec3 col = vec3(1.0); 
    // Pattern 0: Split Scan (Full Width)
    if (pattern == 0) {
        float top = scannerSheet(uv, vec2(0.5, 0.75), vec2(1.0, 0.25), 0.02, 1);
        float bot = scannerSheet(uv, vec2(0.5, 0.25), vec2(1.0, 0.25), 0.02, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.6), vec2(1.0, 0.05), 0.01, 1); 
        vec3 cTop = vec3(0.85, 0.9, 0.95);
        vec3 cBot = vec3(1.0);
        col = mix(vec3(0.9), cBot, bot);
        col = mix(col, cTop, top);
        col = mix(col, vec3(0.7), art);
    }
    // Pattern 1: Faded Gradient + Full Height Side Bar
    if (pattern == 1) {
        float grad = smoothstep(0.0, 1.0, uv.y);
        col = vec3(mix(0.6, 1.0, grad));
        float bar = scannerSheet(uv, vec2(0.15, 0.5), vec2(0.08, 1.0), 0.05, 2); 
        col = mix(col, vec3(0.95), bar);
    }
    // Pattern 2: Bottom Bar (Full Width)
    if (pattern == 2) {
        col = vec3(0.85);
        float bar = scannerSheet(uv, vec2(0.5, 0.15), vec2(1.0, 0.15), 0.03, 1);
        float art = scannerSheet(uv, vec2(0.5, 0.85), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), bar);
        col = mix(col, vec3(0.9), art);
    }
    // Pattern 3: Thick Vertical Block (Full Height)
    if (pattern == 3) {
        col = vec3(1.0);
        float side = scannerSheet(uv, vec2(0.9, 0.5), vec2(0.15, 1.0), 0.08, 2);
        float block = scannerSheet(uv, vec2(0.3, 0.5), vec2(0.15, 1.0), 0.01, 2); 
        vec3 blueLeak = vec3(0.7, 0.85, 1.0);
        col = mix(col, blueLeak, side);
        col = mix(col, vec3(0.8), block);
    }
    // Pattern 4: Top Header (Full Width)
    if (pattern == 4) {
        col = vec3(0.95);
        float head = scannerSheet(uv, vec2(0.5, 0.9), vec2(1.0, 0.1), 0.02, 1);
        float bar = scannerSheet(uv, vec2(0.5, 0.1), vec2(1.0, 0.05), 0.01, 1);
        col = mix(col, vec3(1.0), head);
        col = mix(col, vec3(0.85), bar);
    }
    // Pattern 5: Corner Heavy (Full Span components)
    if (pattern == 5) {
        col = vec3(0.9);
        float vStrip = scannerSheet(uv, vec2(0.1, 0.5), vec2(0.15, 1.0), 0.1, 2);
        float hStrip = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.08), 0.02, 1);
        col = mix(col, vec3(1.0), vStrip);
        col = mix(col, vec3(0.8), hStrip);
    }
    // Pattern 6: Wide Horizontal Split (Full Width)
    if (pattern == 6) {
        col = vec3(1.0);
        float mid = scannerSheet(uv, vec2(0.5, 0.4), vec2(1.0, 0.15), 0.05, 1);
        col = mix(vec3(0.85), vec3(1.0), mid);
    }
    return col;
}
void main() {
    vec4 origColor = texture2D(uTexture, vTexCoord);
    vec2 uv = vTexCoord;
    vec2 p = uv * 2.0 - 1.0;
    float aspect = uResolution.x / uResolution.y;
    p.x *= aspect;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0); 
    // --- TIMING ---
    float t_dot = smoothstep_custom(0.15, 0.25, uParameter);
    float t_v_stretch = smoothstep_custom(0.25, 0.35, uParameter);
    float t_h_stretch = smoothstep_custom(0.35, 0.45, uParameter);
    vec3 whiteLayer = vec3(0.0);
    float whiteAlpha = 0.0;
    if (uParameter < 0.45) {
        if (uParameter > 0.15) {
            float line_thickness = 0.008; 
            float max_height = 2.0; 
            float max_width = 2.0 * aspect;
            float current_radius = line_thickness * t_dot;
            float added_height = mix(0.0, max_height, t_v_stretch * t_v_stretch);
            float added_width = mix(0.0, max_width, t_h_stretch * t_h_stretch);
            float active_radius = mix(current_radius, 0.0, t_h_stretch);
            float d = sdRoundedBox(p, vec2(added_width, added_height), active_radius);
            float glow = 1.0 - smoothstep(0.0, 0.015, d);
            float core = 1.0 - smoothstep(0.0, 0.0005, d);
            whiteAlpha = max(glow, core);
            if (t_h_stretch < 0.1) {
                 float total_h = added_height + active_radius;
                 float v_fade = smoothstep(total_h, total_h * 0.5, abs(p.y));
                 whiteAlpha *= v_fade;
            } else {
                 whiteAlpha = mix(whiteAlpha, 1.0, t_h_stretch);
            }
            whiteLayer = vec3(1.0);
        }
    } else {
        // --- FLASHES ---
        float t_flash_phase = (uParameter - 0.45) / 0.55; 
        float cycle_count = 22.0; 
        float raw_cycle = t_flash_phase * cycle_count;
        float cycle_index = floor(raw_cycle);
        float rnd = random(cycle_index + 123.45); 
        int pattern = int(rnd * 7.0); 
        whiteLayer = getScannerScene(pattern, uv);
        whiteAlpha = 1.0; 
        float fade_out = smoothstep_custom(0.90, 1.0, uParameter);
        whiteAlpha *= (1.0 - fade_out);
    }
    // --- COMPOSITE ---
    // Tighter, less intense vignette
    float border = vignetteRect(uv, 0.01); // 1% margin
    whiteAlpha *= border;
    vec3 background = vec3(0.0);
    if (uParameter > 0.90) {
         background = origColor.rgb;
    }
    finalColor.rgb = mix(background, whiteLayer, whiteAlpha);
    gl_FragColor = finalColor;
}
`); 
        this.c.set('shaderParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        console.log("BootEffect Triggered");
        return true;
    }
    update() {
        if (!this.active) return;
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        let progress = elapsedTime / this.durationSeconds;
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('customShader', this.originalShader);
            this.c.set('shaderEnabled', this.originalShaderEnabled);
            this.c.set('shaderParameter', this.originalShaderParameter);
            console.log("BootEffect Finished");
            if (this.c.get('runBothInOrder') && this.registry) {
                this.registry.trigger('CrashSequence');
            }
            return;
        }
        this.c.set('shaderParameter', progress);
    }
    getOverride(i) {
        return null;
    }
}
// --- ClearPulseEffect.js ---
class ClearPulseEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "ClearPulse";
        this.active = false;
        this.origin = { x: 0, y: 0 };
        this.radius = 0;
        this.snap = null;
        this.autoTimer = c.state.clearPulseFrequencySeconds * 60;
        this.renderData = null;
    }
    trigger() {
        if (this.active) return false;
        const total = this.g.cols * this.g.rows;
        const s = this.c.state;
        const d = this.c.derived;
        const activeFonts = d.activeFonts;
        const numFonts = activeFonts.length;
        // Snapshot colors and fill chars to avoid per-frame calculations
        this.snap = { 
            fillChars: new Uint16Array(total),
            fillFonts: new Uint8Array(total),
            colors: new Uint32Array(total),
            fonts: new Uint8Array(this.g.fonts)
        };
        for (let i = 0; i < total; i++) {
            // Snapshot Fill Char
            const fIdx = Math.floor(Math.random() * numFonts);
            this.snap.fillFonts[i] = fIdx;
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if(chars && chars.length > 0) {
                 this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                 this.snap.fillChars[i] = 32;
            }
            // Snapshot Color (Simulating the logic that was previously in getOverride)
            let rgb;
            const style = this.g.complexStyles.get(i);
            if(style) {
                rgb = Utils.hslToRgb(style.h, style.s, style.l);
            } else {
                rgb = d.streamRgb;
            }
            this.snap.colors[i] = Utils.packRgb(rgb.r, rgb.g, rgb.b);
        }
        let ox, oy;
        if (s.clearPulseRandomPosition) {
            ox = Utils.randomInt(this.g.cols * 0.2, this.g.cols * 0.8);
            oy = Utils.randomInt(this.g.rows * 0.2, this.g.rows * 0.8);
            const cx = Math.floor(this.g.cols / 2);
            const cy = Math.floor(this.g.rows / 2);
            const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
            const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
            if (pxDistX < s.clearPulseWidth && pxDistY < s.clearPulseWidth) { ox = cx; oy = cy; }
        } else {
            ox = Math.floor(this.g.cols / 2);
            oy = Math.floor(this.g.rows / 2);
        }
        this.origin = { x: ox, y: oy };
        this.active = true;
        this.radius = s.clearPulseInstantStart ? s.clearPulseWidth * 2 : 0;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        this.speed = (maxDim + 200) / Math.max(1, s.clearPulseDurationSeconds * 60);
        return true;
    }
    update() {
        const s = this.c.state;
        if (!this.active && s.clearPulseEnabled && this.autoTimer-- <= 0) {
            this.trigger();
            this.autoTimer = s.clearPulseFrequencySeconds * 60;
        }
        if (!this.active) { this.renderData = null; return; }
        this.radius += this.speed;
        const d = this.c.derived;
        const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
        if (this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
        // --- Optimization Pre-calc ---
        const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX);
        const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
        const width = s.clearPulseWidth * 2;
        const innerEdge = this.radius - width;
        let ratio = 1;
        if (!s.clearPulseCircular) {
            const canvasW = this.g.cols * d.cellWidth * s.stretchX;
            const canvasH = this.g.rows * d.cellHeight * s.stretchY;
            ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
        }
        let minX, maxX, minY, maxY;
        if (s.clearPulseCircular) {
            minX = ox - this.radius; maxX = ox + this.radius;
            minY = oy - this.radius; maxY = oy + this.radius;
        } else {
            minX = ox - this.radius; maxX = ox + this.radius;
            const rY = this.radius / ratio;
            minY = oy - rY; maxY = oy + rY;
        }
        this.renderData = {
            ox, oy,
            radius: this.radius,
            radiusSq: this.radius * this.radius,
            innerEdge,
            innerEdgeSq: innerEdge * innerEdge,
            width,
            ratio,
            minX, maxX, minY, maxY
        };
    }
    getOverride(i) {
        if (!this.active || !this.snap || !this.renderData) return null;
        const s = this.c.state;
        const d = this.c.derived;
        const rd = this.renderData;
        const x = i % this.g.cols; 
        const y = Math.floor(i / this.g.cols);
        const cx = Math.floor(x * d.cellWidth * s.stretchX);
        const cy = Math.floor(y * d.cellHeight * s.stretchY);
        // 1. Outer AABB (Optimization)
        if (cx < rd.minX || cx > rd.maxX || cy < rd.minY || cy > rd.maxY) return null;
        // 2. Inner Hole Check (Optimization)
        if (rd.innerEdge > 0) {
            if (s.clearPulseCircular) {
                if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                    cy > rd.oy - rd.innerEdge && cy < rd.oy + rd.innerEdge) {
                    const dx = cx - rd.ox; const dy = cy - rd.oy;
                    if ((dx * dx + dy * dy) < rd.innerEdgeSq) return null;
                }
            } else {
                const rY = rd.innerEdge / rd.ratio;
                if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                    cy > rd.oy - rY && cy < rd.oy + rY) {
                    return null;
                }
            }
        }
        // 3. Distance Calculation
        let dist;
        if (s.clearPulseCircular) {
            const dx = cx - rd.ox; const dy = cy - rd.oy;
            dist = Math.sqrt(dx * dx + dy * dy);
        } else {
            const dx = Math.abs(cx - rd.ox);
            const dy = Math.abs(cy - rd.oy);
            dist = Math.max(dx, dy * rd.ratio);
        }
        // 4. Wave Bounds Check
        if (dist < rd.innerEdge || dist > rd.radius) return null;
        // Check Live Alpha to determine if cell is empty
        const alpha = this.g.alphas[i];
        const isGap = (alpha <= 0.01);
        if (s.clearPulsePreserveSpaces && isGap) return null;
        let char;
        let fontIdx;
        if (isGap) {
            // Fill the gap (Reveal effect) using snapshot
            char = String.fromCharCode(this.snap.fillChars[i]);
            fontIdx = this.snap.fillFonts[i];
        } else {
            // Use LIVE character (Flow continues)
            char = this.g.getChar(i);
            fontIdx = this.snap.fonts[i];
        }
        const activeFonts = this.c.derived.activeFonts;
        const fontData = activeFonts[fontIdx] || activeFonts[0];
        const fontName = fontData.name;
        // Color Calculation
        const tRgb = d.tracerRgb;
        const rel = Math.max(0, Math.min(1, (rd.radius - dist) / rd.width));
        let finalColor = `rgb(${tRgb.r},${tRgb.g},${tRgb.b})`; 
        if (s.clearPulseBlend) { 
            // Use snapshot color which is pre-calculated for all cells (Stream or Style)
            const baseInt = this.snap.colors[i];
            const bR = (baseInt >> 16) & 0xFF; 
            const bG = (baseInt >> 8) & 0xFF; 
            const bB = baseInt & 0xFF;
            const mR = Math.floor(tRgb.r + (bR - tRgb.r) * rel);
            const mG = Math.floor(tRgb.g + (bG - tRgb.g) * rel); 
            const mB = Math.floor(tRgb.b + (bB - tRgb.b) * rel);
            finalColor = `rgb(${mR},${mG},${mB})`;
        }
        const useSolid = isGap; 
        const useBlend = !isGap && s.clearPulseBlend;
        return { 
            char, 
            font: fontName,
            color: finalColor, 
            alpha: 1.0, 
            glow: Math.max(s.tracerGlow, 30 * (1.0 - rel)), 
            size: s.tracerSizeIncrease, 
            solid: useSolid, 
            blend: useBlend, 
            bgColor: '#000000' 
        };
    }
}
// --- CrashEffect.js ---
class CrashEffect extends AbstractEffect {
    constructor(g, c, registry) {
        super(g, c);
        this.registry = registry; 
        this.name = "CrashSequence";
        this.active = false;
        this.startTime = 0;
        this.durationSeconds = 30; 
        this.originalShader = null;
        this.originalShaderEnabled = false;
        this.originalShaderParameter = 0.5;
        this.frame = 0;
        this.snapshotOverlay = new Map(); 
        this.blackSheets = []; 
        this.supermanState = {
            active: false,
            type: 0, 
            axis: 0, 
            cells: new Set(), 
            fluxTriangles: [], 
            flickerTimer: 0,
            initialBranches: [],
            burstTimer: 0, 
            isBursting: false,
            cooldown: 0,
            edgeType: 0,
            isMirrored: false
        };
        this.shaderState = {
            activeId: 0, 
            timer: 0,
            duration: 0
        };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.globalRevealAlpha = 1.0;
        this.sheetState = { spawning: true, timer: 600 };
        this.chaosState = {
            activeCount: 0,
            breakTimer: 0,
            nextBreak: 180 
        };
    }
    trigger() {
        if (this.active) return false;
        this.originalShaderEnabled = this.c.state.shaderEnabled;
        this.originalShader = this.c.state.customShader;
        this.originalShaderParameter = this.c.state.shaderParameter;
        this.c.set('shaderEnabled', true);
        this.c.set('customShader', `
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uParameter; 
varying vec2 vTexCoord;
float random(float n) { return fract(sin(n) * 43758.5453123); }
float rect(vec2 uv, vec2 pos, vec2 size) {
    vec2 d = abs(uv - pos) - size;
    return 1.0 - step(0.0, max(d.x, d.y));
}
void main() {
    vec2 uv = vTexCoord;
    float phase_idx = floor(uParameter + 0.001);
    float progress = fract(uParameter); 
    vec4 finalColor = texture2D(uTexture, uv);
    if (phase_idx == 2.0) {
        vec4 distColor = vec4(0.0);
        float active = 0.0;
        if (progress < 0.33) { 
            if (uv.y < 0.25) { 
                vec2 center = vec2(0.5, 0.125); 
                vec2 dist = uv - center;
                dist *= 0.6; dist.y *= 0.3; 
                distColor = texture2D(uTexture, center + dist);
                distColor.rgb *= 1.5;
                active = 1.0;
            }
        } else if (progress < 0.66) { 
            if (uv.y > 0.1 && uv.y < 0.225) { 
                vec2 center = vec2(0.5, 0.1625); 
                vec2 dist = uv - center;
                dist *= 0.6; dist.y *= 0.1; 
                distColor = texture2D(uTexture, center + dist);
                distColor.rgb *= 1.5;
                active = 1.0;
            }
        } else { 
            vec2 center = vec2(0.5, 0.5);
            vec2 dist = uv - center;
            dist.y *= 0.02; 
            distColor = texture2D(uTexture, center + dist);
            distColor.rgb *= 1.5;
            float localP = (progress - 0.66) / 0.34;
            active = 1.0 - localP;
        }
        if (active > 0.0) finalColor = mix(finalColor, distColor, 0.5 * active);
    }
    if (phase_idx == 3.0) {
        for (float i = 0.0; i < 3.0; i++) {
            float seed = i * 12.34;
            float dur = 0.2 + random(seed)*0.3; 
            float offset = random(seed + 1.0) * 10.0;
            float localT = mod(uTime + offset, dur + 0.1); 
            if (localT < dur) {
                float prog = localT / dur;
                float cycleIdx = floor((uTime + offset) / (dur + 0.1));
                float subSeed = seed + cycleIdx * 7.89;
                vec2 pos = vec2(random(subSeed), random(subSeed + 1.0));
                float type = random(subSeed + 2.0); 
                if (type < 0.6) { 
                    vec2 size = vec2(0.3 + random(subSeed)*0.5, 0.05 + random(subSeed)*0.1);
                    if (rect(uv, pos, size) > 0.0) {
                        float smearX = (uv.x - pos.x) * 0.5 + pos.x; 
                        finalColor = mix(finalColor, texture2D(uTexture, vec2(smearX, uv.y)), 0.8);
                    }
                } else if (type < 0.8) { 
                    vec2 size = vec2(0.2 + random(subSeed)*0.3, 0.005); 
                    if (rect(uv, pos, size) > 0.0) {
                        float gray = dot(finalColor.rgb, vec3(0.299, 0.587, 0.114));
                        finalColor.rgb = vec3(gray * 2.0); 
                    }
                } else { 
                    vec2 size = vec2(0.02, 0.5 + random(subSeed)*0.5); 
                    if (size.y < 1.0) size.y = 1.0; 
                    if (rect(uv, pos, size) > 0.0) {
                        float fade = 1.0 - prog; 
                        finalColor = mix(finalColor, vec4(1.0), fade * 0.8);
                    }
                }
            }
        }
    }
    if (phase_idx == 7.0) {
        float startY = 0.45;
        float initHeight = 0.05; 
        float expand = min(progress / 0.2, 1.0); 
        float currentTop = (startY - initHeight) - ((startY - initHeight) * expand); 
        if (uv.y <= startY && uv.y >= currentTop) {
            float alpha = 1.0 - smoothstep(0.1, 0.4, progress);
            finalColor = mix(finalColor, vec4(0.0, 0.0, 0.0, 1.0), alpha);
        }
        if (progress > 0.3 && progress < 0.35) {
             if (abs(uv.y - 0.2) < 0.02) finalColor = texture2D(uTexture, vec2(0.5, 0.2)) * 2.0;
        }
    }
    if (phase_idx == 8.0) {
        vec2 center = vec2(0.5, 0.5);
        vec2 dist = uv - center;
        dist.y *= 0.1; 
        vec4 distColor = texture2D(uTexture, center + dist);
        float alpha = 1.0 - smoothstep(0.0, 0.8, progress);
        finalColor = mix(finalColor, distColor, alpha);
        finalColor.rgb += vec3(alpha * 0.5); 
    }
    if (phase_idx == 9.0) {
        float sampleX = 0.3;
        vec4 stretchColor = texture2D(uTexture, vec2(sampleX, uv.y));
        float flicker = 0.5 + 0.5 * sin(progress * 30.0); 
        if (abs(uv.x - 0.33) < 0.05) { stretchColor.rgb *= 0.3; }
        stretchColor.rgb *= (1.0 + flicker);
        float alpha = (0.5 + 0.5 * flicker) * (1.0 - progress); 
        finalColor = mix(finalColor, stretchColor, alpha);
    }
    gl_FragColor = finalColor;
}
`);
        this.c.set('shaderParameter', 0.0); 
        this.active = true;
        this.startTime = performance.now();
        this.currentPhase = 0;
        this.frame = 0;
        this.snapshotOverlay.clear(); 
        this.blackSheets = []; 
        this.supermanState = { active: false, axis: 0, cells: new Set(), fluxTriangles: [], flickerTimer: 0, initialBranches: [], burstTimer: 0, isBursting: false, cooldown: 0, edgeType: 0, isMirrored: false };
        this.shaderState = { activeId: 0, timer: 0, duration: 0 };
        this.smithState = { active: false, triggered: false, timer: 0, duration: 60 };
        this.burstCount = 0;
        this.globalRevealAlpha = 1.0;
        this.sheetState = { spawning: true, timer: 600 };
        this.chaosState = { activeCount: 0, breakTimer: 0, nextBreak: 180 };
        console.log("CrashEffect Triggered (Sheets Gray Fix)");
        return true;
    }
    update() {
        if (!this.active) return;
        this.frame++; 
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        const progress = elapsedTime / this.durationSeconds;
        if (progress >= 1.0) {
            this.active = false;
            this.c.set('customShader', this.originalShader);
            this.c.set('shaderEnabled', this.originalShaderEnabled);
            this.c.set('shaderParameter', this.originalShaderParameter);
            this.snapshotOverlay.clear();
            this.blackSheets = [];
            this.supermanState.cells.clear();
            console.log("CrashEffect Finished");
            return;
        }
        // --- CHAOS LOGIC ---
        if (this.chaosState.breakTimer > 0) {
            this.chaosState.breakTimer--;
            this.globalRevealAlpha = 0.0; 
            this.c.set('shaderParameter', 0.0); 
            return; 
        } else {
            this.chaosState.nextBreak--;
            if (this.chaosState.nextBreak <= 0) {
                this.chaosState.breakTimer = 60; 
                this.chaosState.nextBreak = 180 + Math.random() * 180; 
                this.chaosState.activeCount = 0;
                return;
            }
        }
        if (this.globalRevealAlpha < 1.0) this.globalRevealAlpha += 0.1;
        this.chaosState.activeCount = 0;
        if (this.supermanState.active) this.chaosState.activeCount++;
        if (this.shaderState.activeId !== 0) this.chaosState.activeCount++;
        if (this.snapshotOverlay.size > 0) this.chaosState.activeCount++; 
        const canSpawn = this.chaosState.activeCount < 2;
        this.sheetState.timer--;
        if (this.sheetState.timer <= 0) {
            this.sheetState.spawning = !this.sheetState.spawning;
            this.sheetState.timer = this.sheetState.spawning ? 600 : 300; 
        }
        if (this.sheetState.spawning) this._updateBlackSheets();
        else {
            for (let i = this.blackSheets.length - 1; i >= 0; i--) {
                const s = this.blackSheets[i];
                s.age++;
                if (s.age >= s.life) this.blackSheets.splice(i, 1);
                s.posX += s.dx; s.posY += s.dy;
                s.w += (s.targetW - s.w) * 0.05; s.h += (s.targetH - s.h) * 0.05;
                s.c = Math.floor(s.posX); s.r = Math.floor(s.posY);
            }
        }
        for (const s of this.blackSheets) {
            if (Math.random() < 0.01) s.targetAlpha = (s.targetAlpha > 0.5) ? 0.0 : s.maxAlpha;
            s.currentAlpha += (s.targetAlpha - s.currentAlpha) * 0.1;
            s.posX += s.dx; s.posY += s.dy;
            if (Math.random() < 0.02) { s.targetW = Math.max(2, s.targetW + (Math.random() - 0.5) * 4); s.targetH = Math.max(2, s.targetH + (Math.random() - 0.5) * 4); }
            s.w += (s.targetW - s.w) * 0.05; s.h += (s.targetH - s.h) * 0.05;
            s.c = Math.floor(s.posX); s.r = Math.floor(s.posY);
        }
        this._updateSnapshots();
        if (this.supermanState.active) {
            this._updateSuperman();
            this.supermanState.globalTimer--;
            if (this.supermanState.globalTimer <= 0) {
                this.supermanState.active = false;
                this.supermanState.cells.clear();
                this.supermanState.fluxTriangles = [];
            }
        } else if (canSpawn) {
            if (Math.random() < 0.03) {
                const type = Math.random() < 0.6 ? 0 : 1; 
                this._triggerSuperman(type);
            }
        }
        if (canSpawn && Math.random() < 0.04) this._triggerWhiteBlock(); 
        if (canSpawn && Math.random() < 0.03) this._triggerColumnBurst(); 
        if (!this.smithState.triggered && canSpawn && Math.random() < 0.005) { 
            this._triggerSmith();
        }
        if (this.smithState.active) {
            this.smithState.timer--;
            if (this.smithState.timer <= 0) this.smithState.active = false;
        }
        if (this.registry && canSpawn) { 
            if (Math.random() < 0.002) this.registry.trigger('ClearPulse');
            // Removed MiniPulse
        }
        if (this.shaderState.activeId === 0) {
            if (canSpawn && Math.random() < 0.02) {
                const r = Math.random();
                let id = 0;
                let dur = 0;
                if (r < 0.15) { id = 2; dur = 60; } 
                else if (r < 0.50) { id = 3; dur = 45; } 
                else if (r < 0.70) { id = 7; dur = 60; } 
                else if (r < 0.85) { id = 8; dur = 30; } 
                else { id = 9; dur = 45; } 
                this.shaderState.activeId = id;
                this.shaderState.duration = dur;
                this.shaderState.timer = 0;
            }
        } else {
            this.shaderState.timer++;
            if (this.shaderState.timer >= this.shaderState.duration) {
                this.shaderState.activeId = 0;
                this.c.set('shaderParameter', 0.0);
            } else {
                const p = this.shaderState.timer / this.shaderState.duration;
                this.c.set('shaderParameter', this.shaderState.activeId + p);
            }
        }
    }
    _updateBlackSheets() {
        if (this.blackSheets.length < 500) { 
            if (Math.random() < 0.8) { 
                const grid = this.g;
                const r = Math.random();
                let w, h;
                if (r < 0.4) { w = Math.floor(Math.random() * 4) + 1; h = Math.floor(Math.random() * 4) + 1; } 
                else if (r < 0.8) { w = Math.floor(Math.random() * 8) + 5; h = Math.floor(Math.random() * 8) + 5; } 
                else { w = Math.floor(Math.random() * 13) + 13; h = Math.floor(Math.random() * 13) + 13; }
                let c;
                if (Math.random() < 0.8) { 
                    if (Math.random() < 0.5) c = Math.floor(Math.random() * (grid.cols * 0.2)); 
                    else c = Math.floor(grid.cols * 0.8 + Math.random() * (grid.cols * 0.2)) - w; 
                    if (c < 0) c = 0; 
                } else { c = Math.floor(Math.random() * (grid.cols - w)); }
                const row = Math.floor(Math.random() * (grid.rows - h));
                const duration = Math.floor(Math.random() * 200) + 100; 
                const axis = Math.random() < 0.5 ? 0 : 1;
                const expandAmount = Math.floor(Math.random() * w) + 2; 
                const speedScale = Math.random() * 0.6 + 0.2;
                this.blackSheets.push({ 
                    c, r: row, w, h, axis, expandAmount, age: 0, life: duration, 
                    posX: c, posY: row, dx: (Math.random() - 0.5) * speedScale, dy: (Math.random() - 0.5) * speedScale, targetW: w, targetH: h, 
                    flashFrames: 0, 
                    maxAlpha: 0.75 + Math.random() * 0.2, 
                    currentAlpha: 0.0, targetAlpha: 1.0 
                });
            }
        }
        for (let i = this.blackSheets.length - 1; i >= 0; i--) {
            const s = this.blackSheets[i];
            s.age++;
            if (s.age >= s.life) this.blackSheets.splice(i, 1);
        }
    }
    _triggerSmith() {
        this.smithState.triggered = true;
        this.smithState.active = true;
        this.smithState.timer = 60; 
        const grid = this.g;
        const w = Math.floor(grid.cols * 0.8);
        const h = Math.floor(grid.rows * 0.8);
        const startC = Math.floor((grid.cols - w) / 2);
        const startR = Math.floor((grid.rows - h) / 2);
        const endFrame = this.frame + 60;
        let smithColor = '#00FF00'; 
        if (this.c.derived && this.c.derived.streamColorStr) smithColor = this.c.derived.streamColorStr;
        else if (this.c.state.streamColor) smithColor = this.c.state.streamColor;
        for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
                const nx = c / w;
                const ny = r / h;
                const i = (startR + r) * grid.cols + (startC + c);
                const dx = nx - 0.5;
                const dy = ny - 0.3;
                const headDist = (dx*dx)/(0.2*0.2) + (dy*dy)/(0.3*0.3);
                let isSmithPixel = false;
                let brightness = 0.0;
                if (headDist < 1.0) {
                    isSmithPixel = true;
                    brightness = 0.5; 
                    if (ny > 0.28 && ny < 0.34 && Math.abs(nx - 0.5) < 0.18) brightness = 0.0; 
                    if (ny > 0.65) brightness = 0.2; 
                    if (ny > 0.65 && Math.abs(nx - 0.5) < 0.04) brightness = 0.8; 
                }
                if (ny > 0.65 && Math.abs(nx - 0.5) < 0.45) {
                    isSmithPixel = true;
                    if (Math.abs(nx - 0.5) < 0.04) brightness = 0.8; 
                    else brightness = 0.2; 
                }
                if (isSmithPixel) {
                    this.snapshotOverlay.set(i, {
                        char: grid.getChar(i), 
                        color: smithColor, 
                        alpha: brightness, 
                        endFrame: endFrame, 
                        isFrozen: true, 
                        isSmith: true
                    });
                }
            }
        }
    }
    _triggerSuperman(type) {
        this.supermanState.active = true;
        this.supermanState.type = type; 
        this.supermanState.axis = Math.random() < 0.5 ? 0 : 1;
        this.supermanState.globalTimer = (type === 0) ? 60 : 150; 
        this.supermanState.flickerTimer = 0;
        this.supermanState.isBursting = true; 
        this.supermanState.burstTimer = 0;
        this.supermanState.cooldown = 0;
        if (type === 0) this._initializeSupermanBranches();
    }
    _initializeSupermanBranches() {
        this.supermanState.initialBranches = [];
        const grid = this.g;
        const numBranches = Math.floor(Math.random() * 3) + 1; 
        const isHorizEdge = Math.random() < 0.5;
        this.supermanState.edgeType = isHorizEdge ? 0 : 1;
        for (let i = 0; i < numBranches; i++) {
            let targetX, targetY;
            if (this.supermanState.axis === 0) { 
                if (isHorizEdge) { targetX = Math.floor(grid.cols/2 + Math.random()*(grid.cols/2)); targetY = grid.rows - 1; }
                else { targetX = grid.cols - 1; targetY = Math.floor(grid.rows/2 + Math.random()*(grid.rows/2)); }
            } else { 
                if (isHorizEdge) { targetX = Math.floor(Math.random()*(grid.cols/2)); targetY = grid.rows - 1; }
                else { targetX = 0; targetY = Math.floor(grid.rows/2 + Math.random()*(grid.rows/2)); }
            }
            this.supermanState.initialBranches.push({ targetX, targetY, isHorizEdge });
        }
    }
    _updateSuperman() {
        const s = this.supermanState;
        if (s.type === 0) { 
            if (s.isBursting) s.burstTimer++;
            const grid = this.g;
            for (const branch of s.initialBranches) {
                const speed = (Math.random() - 0.5) * 4.0;
                if (branch.isHorizEdge) { branch.targetX += speed; } else { branch.targetY += speed; }
            }
        }
        s.flickerTimer++;
        if (s.flickerTimer >= 3) { s.flickerTimer = 0; this._generateSupermanBolt(); }
    }
    _generateSupermanBolt() {
        const s = this.supermanState;
        s.cells.clear();
        s.fluxTriangles = [];
        const grid = this.g;
        const axis = s.axis;
        const startX = axis === 0 ? 0 : grid.cols - 1;
        const startY = 0;
        const endX = axis === 0 ? grid.cols - 1 : 0;
        const endY = grid.rows - 1;
        if (s.type === 1) { 
            this._drawDisplacedLine(startX, startY, endX, endY, 6.0, 5, s.cells);
        } else { 
            const tDiv = 0.4;
            const divX = startX + (endX - startX) * tDiv;
            const divY = startY + (endY - startY) * tDiv;
            this._drawLine(startX, startY, endX, endY, s.cells, 2.0, 0.0);
            for (const branch of s.initialBranches) {
                this._drawLine(divX, divY, branch.targetX, branch.targetY, s.cells, 2.0, 0.0);
                s.fluxTriangles.push({ p1: {x: divX, y: divY}, p2: {x: endX, y: endY}, p3: {x: branch.targetX, y: branch.targetY} });
            }
        }
    }
    _drawLine(x0, y0, x1, y1, set, jitterAmt = 2.0, thickness = 0.0) {
        const dist = Math.sqrt((x1-x0)**2 + (y1-y0)**2);
        const steps = Math.ceil(dist);
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            let x = x0 + (x1 - x0) * t;
            let y = y0 + (y1 - y0) * t;
            x += (Math.random() - 0.5) * jitterAmt; 
            y += (Math.random() - 0.5) * jitterAmt;
            if (thickness > 0) {
                const r = Math.floor(thickness);
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        const ix = Math.floor(x + dx);
                        const iy = Math.floor(y + dy);
                        if (ix >= 0 && ix < this.g.cols && iy >= 0 && iy < this.g.rows) set.add(iy * this.g.cols + ix);
                    }
                }
            } else {
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                if (ix >= 0 && ix < this.g.cols && iy >= 0 && iy < this.g.rows) set.add(iy * this.g.cols + ix);
            }
        }
    }
    _drawDisplacedLine(x0, y0, x1, y1, jitter, depth, set) {
        if (depth === 0) { this._drawLine(x0, y0, x1, y1, set, 0, 0); return; }
        const mx = (x0 + x1) / 2;
        const my = (y0 + y1) / 2;
        const dx = x1 - x0;
        const dy = y1 - y0;
        const len = Math.sqrt(dx*dx + dy*dy);
        const nx = -dy / len;
        const ny = dx / len;
        const offset = (Math.random() - 0.5) * jitter * 2.0; 
        const dmx = mx + nx * offset;
        const dmy = my + ny * offset;
        this._drawDisplacedLine(x0, y0, dmx, dmy, jitter * 0.6, depth - 1, set);
        this._drawDisplacedLine(dmx, dmy, x1, y1, jitter * 0.6, depth - 1, set);
    }
    _pointInTriangle(px, py, p1, p2, p3) {
        const area = 0.5 * (-p2.y * p3.x + p1.y * (-p2.x + p3.x) + p1.x * (p2.y - p3.y) + p2.x * p3.y);
        const s = 1 / (2 * area) * (p1.y * p3.x - p1.x * p3.y + (p3.y - p1.y) * px + (p1.x - p3.x) * py);
        const t = 1 / (2 * area) * (p1.x * p2.y - p1.y * p2.x + (p1.y - p2.y) * px + (p2.x - p1.x) * py);
        return s > 0 && t > 0 && (1 - s - t) > 0;
    }
    _triggerWhiteBlock() {
        const grid = this.g;
        const h = 11; 
        const r = Math.floor(Math.random() * (grid.rows - h));
        const duration = 18; 
        const endFrame = this.frame + duration;
        for (let row = r; row < r + h; row++) {
            for (let col = 0; col < grid.cols; col++) {
                const i = row * grid.cols + col;
                this.snapshotOverlay.set(i, { char: grid.getChar(i), color: '#FFFFFF', alpha: 1.0, endFrame: endFrame, isFrozen: true });
            }
        }
    }
    _triggerColumnBurst() {
        const grid = this.g;
        const col = Math.floor(Math.random() * grid.cols);
        let startRow = Math.floor(Math.random() * (grid.rows / 2)); 
        let height = Math.floor(Math.random() * (grid.rows / 2)) + (grid.rows / 4);
        if (Math.random() < 0.3) { startRow = 0; height = grid.rows; }
        const duration = 8; 
        const endFrame = this.frame + duration;
        for (let r = startRow; r < startRow + height && r < grid.rows; r++) {
            const i = r * grid.cols + col;
            this.snapshotOverlay.set(i, { char: Utils.getRandomChar(), color: '#FFFFFF', alpha: 1.0, endFrame: endFrame, isFrozen: true });
        }
    }
    _updateSnapshots() {
        const currentFrame = this.frame; 
        for (const [index, snapshot] of this.snapshotOverlay.entries()) {
            if (currentFrame > snapshot.endFrame) this.snapshotOverlay.delete(index);
            else {
                if (snapshot.isSmith) {
                    const rem = snapshot.endFrame - currentFrame;
                    if (rem < 30) snapshot.alpha = rem / 30.0;
                } else {
                    const rem = snapshot.endFrame - currentFrame;
                    if (rem < 3) snapshot.alpha = rem / 3.0; 
                }
            }
        }
    }
    _generateVines() {}
    getOverride(i) {
        if (!this.active) return null;
        const grid = this.g;
        const col = i % grid.cols;
        const row = Math.floor(i / grid.cols);
        if (this.supermanState.cells.has(i)) {
            return { char: grid.getChar(i), color: '#FFFFFF', alpha: 1.0, glow: 5, size: 0, solid: false, blend: true };
        }
        for (const tri of this.supermanState.fluxTriangles) {
            if (this._pointInTriangle(col, row, tri.p1, tri.p2, tri.p3)) {
                let fluxColor = '#00FF00'; 
                if (this.c.derived && this.c.derived.streamColorStr) fluxColor = this.c.derived.streamColorStr;
                else if (this.c.state.streamColor) fluxColor = this.c.state.streamColor;
                return { char: grid.getChar(i), color: fluxColor, alpha: 1.0, glow: 2, solid: true, bgColor: '#000000', blend: true };
            }
        }
        const snapshot = this.snapshotOverlay.get(i);
        if (snapshot) {
            if (snapshot.isSmith) {
                return { char: snapshot.char, color: snapshot.color, alpha: snapshot.alpha, glow: 0, size: 0, solid: false, blend: true };
            }
            return { char: snapshot.char, color: snapshot.color, alpha: snapshot.alpha, glow: 8, size: 0, solid: false, blend: true };
        }
        if (this.globalRevealAlpha < 0.05) return null; 
        let totalAlpha = 0.0;
        for (const s of this.blackSheets) {
            if (col >= s.c && col < s.c + s.w &&
                row >= s.r && row < s.r + s.h) {
                let sheetAlpha = s.currentAlpha * s.maxAlpha;
                // Edge Fading: Soften the edges of the rectangle
                const nx = (col - s.posX) / s.w;
                const ny = (row - s.posY) / s.h;
                // Linear fade on all sides (20% of width/height)
                const fadeSize = 0.2;
                const fadeL = nx < fadeSize ? nx / fadeSize : 1.0;
                const fadeR = (1.0 - nx) < fadeSize ? (1.0 - nx) / fadeSize : 1.0;
                const fadeT = ny < fadeSize ? ny / fadeSize : 1.0;
                const fadeB = (1.0 - ny) < fadeSize ? (1.0 - ny) / fadeSize : 1.0;
                sheetAlpha *= Math.min(fadeL, fadeR, fadeT, fadeB);
                // Accumulation: Allow slight darkening on overlap
                // Base is Max, plus a small fraction of the product to simulate density without instant black
                totalAlpha = Math.max(totalAlpha, sheetAlpha) + (sheetAlpha * 0.2); 
                if (totalAlpha > 1.0) totalAlpha = 1.0;
            }
        }
        if (totalAlpha > 0.01) {
            if (this.globalRevealAlpha < 1.0) totalAlpha *= this.globalRevealAlpha;
            let dimColor = '#00FF00';
            if (this.c.derived && this.c.derived.streamColorStr) dimColor = this.c.derived.streamColorStr;
            else if (this.c.state.streamColor) dimColor = this.c.state.streamColor;
            // Fix: Check if cell is active to prevent lighting up empty space
            const isActive = this.g.alphas[i] > 0.05;
            // Text fades out as sheet gets darker
            const textAlpha = isActive ? Math.max(0, 1.0 - totalAlpha) : 0.0;
            return { 
                char: isActive ? grid.getChar(i) : '', 
                color: dimColor, 
                alpha: textAlpha, 
                solid: true, 
                bgColor: `rgba(0, 0, 0, ${totalAlpha})`, // Pure Black
                blend: false 
            };
        }
        return null;
    }
}
// --- DejaVuEffect.js ---
class DejaVuEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "DejaVu"; 
                this.active = false; 
                this.autoTimer = c.state.dejaVuFrequencySeconds * 60; 
                this.map = null;
                // Reusable object to prevent GC thrashing
                this._retObj = { 
                    char: '', color: '', alpha: 0, glow: 0, size: 0 
                }; 
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.dejaVuDurationSeconds * 60; 
                this.bars = []; 
                this.map = new Uint8Array(this.g.rows); 
                return true; 
            }
            update() {
                const s = this.c.state;
                if(!this.active && s.dejaVuEnabled && s.dejaVuAutoMode && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; }
                if(!this.active) return;
                if(this.timer-- <= 0) { this.active = false; this.bars = []; this.map = null; return; }
                this.map.fill(0);
                // Generate new bars
                if(Math.random() < s.dejaVuIntensity) {
                    const h = Utils.randomInt(s.dejaVuMinRectHeight, s.dejaVuMaxRectHeight); 
                    const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
                    this.bars.push({ y, h, age: 0, maxAge: s.dejaVuBarDurationFrames + Utils.randomInt(-10, 10) });
                }
                // Cache derived values
                const activeFonts = this.c.derived.activeFonts;
                const glitchCount = Math.max(1, Math.floor(this.g.cols * 0.05));
                const cols = this.g.cols;
                const rows = this.g.rows;
                const randomizeColors = s.dejaVuRandomizeColors;
                // Single pass for update, map fill, and glitch application
                for(let i=this.bars.length-1; i>=0; i--) {
                    const b = this.bars[i]; 
                    b.age++;
                    if(b.age > b.maxAge) {
                        this.bars.splice(i, 1); 
                        continue;
                    } 
                    const limit = Math.min(rows, b.y + b.h);
                    for(let r=b.y; r < limit; r++) {
                        this.map[r] = 1; 
                        // Apply glitches
                        for(let k=0; k<glitchCount; k++) {
                            // Optimized random integer generation
                            const x = (Math.random() * cols) | 0;
                            const idx = r * cols + x;
                            this.g.rotatorProg[idx] = 0; 
                            // Optimized font/char picking
                            const fontIdx = (Math.random() * activeFonts.length) | 0;
                            const fontData = activeFonts[fontIdx];
                            const chars = fontData.chars;
                            // Ensure chars array is valid
                            if (chars && chars.length > 0) {
                                const char = chars[(Math.random() * chars.length) | 0];
                                this.g.setChar(idx, char);
                                this.g.setFont(idx, fontIdx);
                            }
                            if(randomizeColors) {
                                this.g.complexStyles.set(idx, { h: (Math.random() * 360) | 0, s: 90, l: 70, glitched: true });
                            }
                        }
                    }
                }
            }
            getOverride(i) {
                if(!this.active || !this.map) return null;
                // Optimization: Map lookup is O(1) array access.
                // Replace Math.floor with bitwise OR for performance
                const y = (i / this.g.cols) | 0;
                // Fast rejection
                if(this.map[y] === 0) return null;
                const s = this.c.state; 
                // Fix: Preserve existing alpha for active cells to maintain trail gradients
                const baseAlpha = this.g.alphas[i];
                const alpha = baseAlpha < 0.1 ? s.dejaVuHoleBrightness : baseAlpha; 
                if(alpha < 0.01) return null;
                const fontIdx = this.g.getFont(i);
                const fontName = this.c.derived.activeFonts[fontIdx]?.name || s.fontFamily;
                this._retObj.char = this.g.getChar(i);
                this._retObj.font = fontName;
                this._retObj.color = this.c.derived.tracerColorStr;
                this._retObj.alpha = alpha;
                this._retObj.glow = 0;
                this._retObj.size = 2;
                return this._retObj;
            }
        }
// --- FirewallEffect.js ---
class FirewallEffect extends AbstractEffect {
    constructor(g, c) {
        super(g, c);
        this.name = "Firewall";
        this.active = false;
        this.autoTimer = c.state.firewallFrequencySeconds * 60;
        this.column = -1;
        this.state = 'IDLE'; 
        this.reverseTimer = 0;
        this.eraseTimer = 0;
        this.snapChars = null;
        this.cleanupFrames = 2; // Add a final cleanup buffer frame
        this.shiftCounter = 0;
        this.shiftInterval = 2; // Shift every 2 frames during reversing
        this._firewallRandomColor = null; // Store the random color for a given trigger
    } // Added missing closing brace
    trigger() {
        if (this.active) return false;
        // 1. Pick Random Column
        this.column = Utils.randomInt(1, this.g.cols - 2); 
        this.reverseTimer = this.c.state.firewallReverseDurationFrames; 
        this.eraseTimer = this.c.state.firewallEraseDurationFrames + this.cleanupFrames; // Add buffer
        this.active = true;
        this.state = 'REVERSING';
        // 2. Snapshot the existing code
        this.snapChars = new Uint16Array(this.g.rows);
        for (let y = 0; y < this.g.rows; y++) {
            const idx = this.g.getIndex(this.column, y);
            this.snapChars[y] = this.g.chars[idx];
        }
        // Generate random color once per trigger if enabled
        if (this.c.state.firewallRandomColorEnabled) {
            const randomHue = Utils.randomInt(0, 359);
            this._firewallRandomColor = Utils.hslToRgb(randomHue, 100, 70);
        } else {
            this._firewallRandomColor = null; // Clear if not using random color
        }
        return true;
    }
    update() {
        const s = this.c.state;
        // Auto-trigger logic
        if (!this.active && s.firewallEnabled && this.autoTimer-- <= 0) { 
            this.trigger(); 
            this.autoTimer = s.firewallFrequencySeconds * 60; 
        }
        if (!this.active) { return; }
        if (this.state === 'REVERSING') {
            if (this.reverseTimer-- <= 0) {
                this.state = 'ERASING';
            } else {
                this.shiftCounter++;
                if (this.shiftCounter >= this.shiftInterval) {
                    this._shiftColumnCharsUpwards();
                    this.shiftCounter = 0;
                }
            }
        } else if (this.state === 'ERASING') {
            this.eraseTimer--;
            // If we are in the last two frames (cleanup buffer), ensure the column is empty
            if (this.eraseTimer <= this.cleanupFrames) {
                // Deep clean the column so it is totally empty
                for (let y = 0; y < this.g.rows; y++) {
                    const idx = this.g.getIndex(this.column, y);
                    this.g.types[idx] = CELL_TYPE.EMPTY;
                    this.g.alphas[idx] = 0;
                    this.g.ages[idx] = 0;
                    this.g.decays[idx] = 0;
                    this.g.rotatorProg[idx] = 0;
                    this.g.complexStyles.delete(idx);
                }
            }
            if (this.eraseTimer <= 0) {
                this.active = false;
                this.snapChars = null;
            }
        }
    }
    _shiftColumnCharsUpwards() {
        if (!this.snapChars) return;
        const topChar = this.snapChars[0];
        for (let y = 0; y < this.g.rows - 1; y++) {
            this.snapChars[y] = this.snapChars[y + 1];
        }
        this.snapChars[this.g.rows - 1] = topChar;
    }
    getOverride(i) {
        if (!this.active || this.snapChars === null) return null;
        const x = i % this.g.cols; 
        if (x !== this.column) return null; 
        const y = Math.floor(i / this.g.cols);
        const s = this.c.state;
        const d = this.c.derived;
        const originalChar = String.fromCharCode(this.snapChars[y]);
        // Fix for residual flash: If timer is in cleanup phase, return a transparent block.
        if (this.state === 'ERASING' && this.eraseTimer <= this.cleanupFrames) {
             return { char: '', color: '#000000', alpha: 0.0, glow: 0, size: 0, solid: true, bgColor: '#000000' };
        }
        // --- PHASE 1: REVERSE FLOW ---
        if (this.state === 'REVERSING') {
            const charCode = this.snapChars[y];
            return {
                char: String.fromCharCode(charCode),
                color: d.streamColorStr, // Use stream color
                alpha: 1.0,
                glow: 20,
                size: 2,
                solid: false,
                blend: false
            };
        } 
        // --- PHASE 2: ERASE & FADE ---
        else if (this.state === 'ERASING') {
            const maxT = s.firewallEraseDurationFrames - this.cleanupFrames; // Base duration for fade
            const progress = 1.0 - (this.eraseTimer / maxT);
            // Calculate Alpha for the Fade
            const alpha = Math.max(0, 1.0 - progress);
            if (alpha <= 0.01) return null;
            let finalRgb;
            if (s.firewallRandomColorEnabled) {
                finalRgb = this._firewallRandomColor;
            } else {
                // Use the configured firewall color
                finalRgb = Utils.hexToRgb(s.firewallColor);
            }
            // Create RGBA string so the BLOCK fades
            const rgbaColor = `rgba(${finalRgb.r}, ${finalRgb.g}, ${finalRgb.b}, ${alpha})`;
            return {
                char: originalChar,
                color: rgbaColor, 
                alpha: alpha, 
                glow: 30 * alpha,
                size: 4,
                solid: true, 
                bgColor: rgbaColor, 
                blend: false
            };
        }
        return null;
    }
}
// --- MiniPulseEffect.js ---
class MiniPulseEffect extends AbstractEffect {
            constructor(g, c) {
                super(g, c); this.name = "MiniPulse"; this.active = false; this.sessionTimer = 0; this.autoTimer = c.state.miniPulseFrequencySeconds * 60; this.pulses = []; 
                // Optimization: Pre-calculated render objects for the current frame
                this.renderPulses = [];
            }
            trigger() { if(this.active) return false; this.active = true; this.sessionTimer = this.c.state.miniPulseDurationSeconds * 60; this.pulses = []; return true; }
            update() {
                const s = this.c.state;
                const d = this.c.derived; // Needed for pre-calc
                if (!this.active && s.miniPulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.miniPulseFrequencySeconds * 60; }
                if (this.active) {
                    this.sessionTimer--;
                    if (Math.random() < s.miniPulseSpawnChance) { this.pulses.push({ x: Utils.randomInt(0, this.g.cols), y: Utils.randomInt(0, this.g.rows), r: 0, maxR: s.miniPulseSize, speed: s.miniPulseSpeed }); }
                    if (this.sessionTimer <= 0 && this.pulses.length === 0) this.active = false;
                }
                // Clear previous render cache
                this.renderPulses = [];
                for (let i = this.pulses.length - 1; i >= 0; i--) { 
                    const p = this.pulses[i]; 
                    p.r += p.speed; 
                    if (p.r > p.maxR + 100) {
                        this.pulses.splice(i, 1);
                        continue;
                    }
                    // --- OPTIMIZATION START ---
                    // Pre-calculate pixel coordinates (Center of the cell) for this frame
                    const ox = (p.x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5);
                    const oy = (p.y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
                    // Bounding Box (AABB) for fast rejection
                    // p.r is pixel radius (based on s.miniPulseSize which is pixels)
                    const minX = ox - p.r;
                    const maxX = ox + p.r;
                    const minY = oy - p.r;
                    const maxY = oy + p.r;
                    // Radius squared for fast distance check
                    const rSq = p.r * p.r;
                    const innerEdge = Math.max(0, p.r - s.miniPulseThickness);
                    const innerEdgeSq = innerEdge * innerEdge;
                    this.renderPulses.push({
                        ox, oy,
                        minX, maxX, minY, maxY,
                        r: p.r,
                        rSq,
                        innerEdge,
                        innerEdgeSq,
                        maxR: p.maxR
                    });
                }
            }
            getOverride(i) {
                if (this.renderPulses.length === 0) return null;
                const s = this.c.state; const d = this.c.derived;
                // Pixel coordinates of the current cell (Center)
                const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                const cx = (x * d.cellWidth * s.stretchX) + (d.cellWidth * s.stretchX * 0.5); 
                const cy = (y * d.cellHeight * s.stretchY) + (d.cellHeight * s.stretchY * 0.5);
                // Iterate backwards through pre-calculated render objects
                for (let k = this.renderPulses.length - 1; k >= 0; k--) {
                    const p = this.renderPulses[k];
                    // 1. AABB Check (Fast Rejection)
                    if (cx < p.minX || cx > p.maxX || cy < p.minY || cy > p.maxY) continue;
                    // 2. Precise Distance Check
                    let dist;
                    let distSq;
                    if (s.pulseCircular !== false) { // Default to true if undefined
                        const dx = cx - p.ox;
                        const dy = cy - p.oy;
                        distSq = (dx * dx) + (dy * dy);
                        // Check against squared radii
                        if (distSq <= p.rSq && distSq >= p.innerEdgeSq) {
                            dist = Math.sqrt(distSq); // Only calc sqrt if hit, for fading logic
                        } else {
                            continue;
                        }
                    } else {
                        // Rectangular distance (Chebyshev)
                        dist = Math.max(Math.abs(cx - p.ox), Math.abs(cy - p.oy));
                        if (dist > p.r || dist < p.innerEdge) continue;
                    }
                    // Hit! Calculate fade
                    let lifeFade = 1.0;
                    if(p.r > p.maxR) lifeFade = Math.max(0, 1.0 - ((p.r - p.maxR) / 100));
                    const combinedAlpha = lifeFade; 
                    if (combinedAlpha <= 0.01) continue;
                    let char = this.g.getChar(i);
                    let fontIdx = this.g.getFont(i);
                    // Use CELL_TYPE.EMPTY for robust gap detection
                    // Fallback to alpha check only if type is not reliable (though it should be)
                    let isGap = (this.g.types[i] === CELL_TYPE.EMPTY); 
                    if (isGap) {
                        if (s.miniPulsePreserveSpaces) return null;
                        // Use active fonts for glitches
                        const activeFonts = d.activeFonts;
                        fontIdx = (i + Math.floor(p.r)) % activeFonts.length;
                        const fontData = activeFonts[fontIdx] || activeFonts[0];
                        const chars = fontData.chars;
                        if (chars && chars.length > 0) {
                            const glitchIndex = (i + Math.floor(p.r)) % chars.length; 
                            char = chars[glitchIndex]; 
                        } else {
                            char = Utils.CHARS[0];
                        }
                    }
                    const activeFonts = d.activeFonts;
                    const fontData = activeFonts[fontIdx] || activeFonts[0];
                    const fontName = fontData.name;
                    // Matches ClearPulse logic for "solid" pops in gaps
                    const useSolid = isGap;
                    const useBlend = !isGap;
                    // Ensure background fades with the effect
                    const bgAlpha = useSolid ? combinedAlpha : 0;
                    return { 
                        char: char, 
                        font: fontName,
                        color: d.tracerColorStr, 
                        alpha: combinedAlpha, 
                        glow: s.tracerGlow * combinedAlpha, 
                        size: s.tracerSizeIncrease, 
                        solid: useSolid, 
                        blend: useBlend,
                        bgColor: `rgba(0,0,0,${bgAlpha})`
                    };
                }
                return null;
            }
        }
// --- PulseEffect.js ---
class PulseEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); this.name = "Pulse"; 
                this.active = false; this.origin = {x:0, y:0}; this.radius = 0;
                this.snap = null; this.autoTimer = c.state.pulseFrequencySeconds * 60;
                this.renderData = null; // Cache for update-calc
                // Reusable object to prevent GC thrashing during render loop
                this._retObj = { 
                    char: '', font: null, color: '', alpha: 0, glow: 0, size: 0, solid: false, blend: false, bgColor: '' 
                };
            }
            trigger() {
                if(this.active) return false;
                const total = this.g.cols * this.g.rows;
                // Add fonts and fillFonts to snapshot
                this.snap = { 
                    chars: new Uint16Array(this.g.chars), 
                    fonts: new Uint8Array(this.g.fonts),
                    alphas: new Float32Array(this.g.alphas), 
                    colors: new Uint32Array(total), 
                    tracers: new Uint8Array(total), 
                    fillChars: new Uint16Array(total),
                    fillFonts: new Uint8Array(total)
                };
                const d = this.c.derived; const s = this.c.state; const holdEnd = d.cycleDuration + d.holdFrames;
                const activeFonts = d.activeFonts;
                const numFonts = activeFonts.length;
                for(let i=0; i<total; i++) {
                    let rgb = d.streamRgb; 
                    let isTracer = false; 
                    const style = this.g.complexStyles.get(i);
                    // 1. Determine Color
                    if(style) {
                        rgb = Utils.hslToRgb(style.h, style.s, style.l);
                    } else {
                        // Fallback for non-styled cells (should be rare now with StandardMode fix)
                         // But we still need to check if it's a tracer to set the color to White/TracerColor if needed?
                         // Actually, relying on 'isTracer' below to override the color for the snapshot is better?
                         // No, 'snap.colors' should hold the VISUAL color.
                         // If it's a tracer without style, it should be TracerColor.
                         // But let's stick to the flow:
                    }
                    // 2. Identify Tracer State (Independent of Style)
                    const type = this.g.types[i]; 
                    const age = this.g.ages[i];
                    if(type === CELL_TYPE.TRACER || (type === CELL_TYPE.ROTATOR && age > 0)) { 
                        const at = age - 1; 
                        if(at >= 0 && at < holdEnd + s.tracerReleaseFrames) { 
                             isTracer = true;
                             // If it IS a tracer, we generally want the snapshot color to be the Tracer Color
                             // UNLESS the style dictates a specific color (like Rainbow).
                             // However, StandardMode style returns GREEN. 
                             // Real visual tracer is WHITE.
                             // So we must Override 'rgb' if it is a tracer and NOT Rainbow mode?
                             // How to distinguish Rainbow vs Standard style?
                             // Rainbow has 'cycle:false' usually but so does Standard.
                             // Standard style color is Green. Tracer is White.
                             // If we capture Green into snapshot, 'Ignore Tracers' will show Green.
                             // We want White.
                             rgb = d.tracerRgb; 
                        } 
                    }
                    // Store packed color for all cells
                    this.snap.colors[i] = Utils.packRgb(rgb.r, rgb.g, rgb.b); 
                    this.snap.tracers[i] = isTracer ? 1 : 0; 
                    // Generate Fill Char/Font for gaps
                    const fIdx = Math.floor(Math.random() * numFonts);
                    this.snap.fillFonts[i] = fIdx;
                    const fontData = activeFonts[fIdx] || activeFonts[0];
                    const chars = fontData.chars;
                    if(chars && chars.length > 0) {
                        this.snap.fillChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
                    } else {
                        this.snap.fillChars[i] = 32;
                    }
                }
                let ox, oy;
                if (s.pulseRandomPosition) {
                    ox = Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8);
                    oy = Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8);
                    const cx = Math.floor(this.g.cols / 2);
                    const cy = Math.floor(this.g.rows / 2);
                    const pxDistX = Math.abs(ox - cx) * d.cellWidth * s.stretchX;
                    const pxDistY = Math.abs(oy - cy) * d.cellHeight * s.stretchY;
                    if (pxDistX < s.pulseWidth && pxDistY < s.pulseWidth) { ox = cx; oy = cy; }
                } else {
                    ox = Math.floor(this.g.cols/2);
                    oy = Math.floor(this.g.rows/2);
                }
                this.origin = {x: ox, y: oy};
                this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelaySeconds * 60; this.radius = 0;
                const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                this.speed = (maxDim + 200) / Math.max(1, s.pulseDurationSeconds * 60);
                return true; 
            }
            update() {
                const s = this.c.state;
                if(!this.active && s.pulseEnabled && this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; }
                if(!this.active) { this.renderData = null; return; }
                const d = this.c.derived;
                if(this.state === 'WAITING') { 
                    if(--this.timer <= 0) { this.state = 'EXPANDING'; this.radius = s.pulseInstantStart ? s.pulseWidth * 2 : 0; }
                } else {
                    this.radius += this.speed; const maxDim = Math.max(this.g.cols * d.cellWidth * s.stretchX, this.g.rows * d.cellHeight * s.stretchY);
                    if(this.radius > maxDim + 400) { this.active = false; this.snap = null; this.renderData = null; return; }
                }
                // --- Optimization Pre-calc ---
                const ox = Math.floor(this.origin.x * d.cellWidth * s.stretchX); 
                const oy = Math.floor(this.origin.y * d.cellHeight * s.stretchY);
                const width = s.pulseWidth * 2; 
                const innerEdge = this.radius - width;
                let ratio = 1;
                if (!s.pulseCircular) {
                    const canvasW = this.g.cols * d.cellWidth * s.stretchX;
                    const canvasH = this.g.rows * d.cellHeight * s.stretchY;
                    ratio = (canvasH > 0) ? (canvasW / canvasH) : 1;
                }
                // AABB for the outer radius
                // For circular: standard bounding box.
                // For rect: radius applies to the MAX dimension.
                // Rect dist = max(dx, dy * ratio).
                // So max dx = radius. max dy = radius / ratio.
                let minX, maxX, minY, maxY;
                if (s.pulseCircular) {
                    minX = ox - this.radius; maxX = ox + this.radius;
                    minY = oy - this.radius; maxY = oy + this.radius;
                } else {
                    minX = ox - this.radius; maxX = ox + this.radius;
                    const rY = this.radius / ratio;
                    minY = oy - rY; maxY = oy + rY;
                }
                this.renderData = {
                    ox, oy,
                    radius: this.radius,
                    radiusSq: this.radius * this.radius,
                    innerEdge,
                    innerEdgeSq: innerEdge * innerEdge, // innerEdge can be negative, handled
                    width,
                    ratio,
                    minX, maxX, minY, maxY
                };
                // --- Global Simulation Locking ---
                // Freeze the simulation for any cell that is waiting or outside the pulse
                if (this.g.cellLocks) {
                    if (this.state === 'WAITING') {
                         this.g.cellLocks.fill(1);
                    } else if (this.state === 'EXPANDING') {
                        // 1. Lock everything by default (frozen background)
                        this.g.cellLocks.fill(1);
                        // 2. Unlock cells inside the expanding pulse
                        // Convert pixel AABB to Grid Coordinates
                        const cW = d.cellWidth * s.stretchX;
                        const cH = d.cellHeight * s.stretchY;
                        // Bounds clamped to grid
                        const startCol = Math.max(0, Math.floor(minX / cW));
                        const endCol = Math.min(this.g.cols, Math.ceil(maxX / cW));
                        const startRow = Math.max(0, Math.floor(minY / cH));
                        const endRow = Math.min(this.g.rows, Math.ceil(maxY / cH));
                        const ox = this.renderData.ox;
                        const oy = this.renderData.oy;
                        const radius = this.radius;
                        const radiusSq = this.renderData.radiusSq;
                        const innerEdge = this.renderData.innerEdge;
                        const ratio = this.renderData.ratio;
                        for (let y = startRow; y < endRow; y++) {
                            const cy = Math.floor(y * cH);
                            // Optimization: Check row bounds against Y-range of pulse first? 
                            // AABB handles it mostly.
                            for (let x = startCol; x < endCol; x++) {
                                const cx = Math.floor(x * cW);
                                // Exact Check: Is this cell inside the pulse radius?
                                let dist = 0;
                                if (s.pulseCircular) {
                                    const dx = cx - ox; 
                                    const dy = cy - oy;
                                    // Optimization: Check squared distance first
                                    const dSq = dx*dx + dy*dy;
                                    if (dSq > radiusSq) continue; // Outside outer radius (keep locked)
                                    // Wait, logic inversion:
                                    // If dist < radius, it is INSIDE the wave or the hole.
                                    // If inside the hole (dist < innerEdge), it is effectively 'passed' and should be normal grid again?
                                    // NO. The hole reveals the original grid, so simulation should RESUME (unlocked).
                                    // The wave itself replaces the grid (visual override). Simulation *could* run underneath, but locked is safer?
                                    // Actually, if we want to "pause" the background, we pause it until the wave PASSES.
                                    // Once the wave passes (dist < innerEdge), the cell is back to normal simulation?
                                    // "The imposition layer needs to pause completely." -> Implies while faded out.
                                    // Faded out = Waiting OR Outside Radius.
                                    // Inside Radius = Wave (Override) + Hole (Normal).
                                    // So anything where dist < radius is UNLOCKED.
                                    // Using sqrt for precise check against innerEdge/Radius logic consistency
                                    dist = Math.sqrt(dSq);
                                } else {
                                    const dx = Math.abs(cx - ox);
                                    const dy = Math.abs(cy - oy);
                                    dist = Math.max(dx, dy * ratio);
                                }
                                if (dist < innerEdge) {
                                    // Inside the hole -> Simulation Active
                                    const idx = y * this.g.cols + x;
                                    this.g.cellLocks[idx] = 0;
                                }
                            }
                        }
                    }
                }
            }
            getOverride(i) {
                if(!this.active || !this.snap || !this.renderData) return null;            
                const s = this.c.state; const d = this.c.derived;
                // Use renderData for fast rejection IF expanding
                const rd = this.renderData;
                let dist = 0;
                // Reset pooled object properties
                this._retObj.char = '';
                this._retObj.font = null;
                this._retObj.color = '';
                this._retObj.alpha = 0;
                this._retObj.glow = 0;
                this._retObj.size = 0;
                this._retObj.solid = false;
                this._retObj.blend = false;
                this._retObj.bgColor = '';
                if (this.state === 'WAITING') {
                } else {
                    // EXPANDING
                    const x = i % this.g.cols; const y = Math.floor(i / this.g.cols);
                    const cx = Math.floor(x * d.cellWidth * s.stretchX); 
                    const cy = Math.floor(y * d.cellHeight * s.stretchY);
                    // AABB Check                    
                    if (rd.innerEdge > 0) {
                        // Check if definitely inside the hole
                        let inHole = false;
                        if (s.pulseCircular) {
                            // Inner AABB
                            if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                                cy > rd.oy - rd.innerEdge && cy < rd.oy + rd.innerEdge) {
                                // Potential hole match, do precise check
                                const dx = cx - rd.ox; const dy = cy - rd.oy;
                                if ((dx*dx + dy*dy) < rd.innerEdgeSq) return null; // Definitely inside hole
                            }
                        } else {
                            // Rect inner hole is exact AABB
                            const rY = rd.innerEdge / rd.ratio;
                            if (cx > rd.ox - rd.innerEdge && cx < rd.ox + rd.innerEdge &&
                                cy > rd.oy - rY && cy < rd.oy + rY) {
                                return null; // Inside rect hole
                            }
                        }
                    }
                    // Calculate Dist for wave edge
                    if (s.pulseCircular) {
                        const dx = cx - rd.ox; const dy = cy - rd.oy;
                        dist = Math.sqrt(dx*dx + dy*dy); // Sqrt needed for linear interpolation 'rel'
                    } else {
                        const dx = Math.abs(cx - rd.ox);
                        const dy = Math.abs(cy - rd.oy);
                        dist = Math.max(dx, dy * rd.ratio);
                    }
                    if (dist < rd.innerEdge) return null;
                }
                const snAlpha = this.snap.alphas[i]; 
                let charCode = this.snap.chars[i];
                let fontIdx = this.snap.fonts[i]; // Default to captured font
                const tRgb = d.tracerRgb; const targetColor = `rgb(${tRgb.r},${tRgb.g},${tRgb.b})`;
                let baseColorStr = null; let isGap = false;
                if (snAlpha <= 0.01) { 
                    isGap = true; 
                    if (!s.pulsePreserveSpaces) {
                         charCode = this.snap.fillChars[i];
                         fontIdx = this.snap.fillFonts[i]; // Use fill font
                    }
                }
                const char = String.fromCharCode(charCode); const isTracer = (this.snap.tracers[i] === 1);
                // Resolve Font Name
                const activeFonts = this.c.derived.activeFonts;
                const fontData = activeFonts[fontIdx] || activeFonts[0];
                const fontName = fontData.name;
                // Common Gap Return
                const gapReturn = this._retObj; // Use pooled object for gapReturn
                gapReturn.char = '';
                gapReturn.font = null;
                gapReturn.color = '#000000';
                gapReturn.alpha = 0;
                gapReturn.glow = 0;
                gapReturn.size = 0;
                gapReturn.solid = true;
                gapReturn.bgColor = '#000000';
                let result = this._retObj; // Use pooled object for result
                if (this.state === 'WAITING' || dist > this.radius) {
                    if(baseColorStr === null) { const rgb = Utils.unpackRgb(this.snap.colors[i]); baseColorStr = `rgb(${rgb.r},${rgb.g},${rgb.b})`; }
                    // FIX: If ignoring tracers, return them with their ORIGINAL snapshot alpha/color, do not dim or force white.
                    if(isTracer && s.pulseIgnoreTracers) {
                         result.char = char;
                         result.font = fontName;
                         result.color = baseColorStr;
                         result.alpha = snAlpha;
                         result.glow = s.tracerGlow;
                         result.size = s.tracerSizeIncrease;
                         result.solid = true;
                         result.bgColor = '#000000';
                    } else if (isGap) {
                         result = gapReturn;
                    } else {
                         result.char = char;
                         result.font = fontName;
                         result.color = baseColorStr;
                         result.alpha = snAlpha * s.pulseDimming;
                         result.glow = 0;
                         result.size = 0;
                         result.solid = true;
                         result.bgColor = '#000000';
                    }
                } else {
                    if (s.pulsePreserveSpaces && isGap) {
                         result = gapReturn;
                    } else {
                        const rel = Math.max(0, Math.min(1, (this.radius - dist) / (s.pulseWidth * 2)));
                        let actualCharAlpha = 1.0;
                        let actualBgAlpha = 1.0;
                        let actualSolid = true; 
                        let actualBlend = false; // Default: Don't blend (draws opaque over grid)
                        let actualGlow = Math.max(s.tracerGlow, 30 * (1.0 - rel));
                        // Calculate where the inner edge of the fade zone begins
                        // Fade out over approximately 1 character cell width at the inner boundary
                        const fadePixelWidth = d.cellWidth; // One character cell width for fade
                        const innerBoundaryDist = rd.innerEdge; // Exact inner edge of the main wave
                        const fadeStartDist = innerBoundaryDist + fadePixelWidth; // Distance where fade begins
                        if (dist < fadeStartDist && dist > innerBoundaryDist) {
                            // We are in the fade-out zone at the inner edge
                            const fadeProgress = (dist - innerBoundaryDist) / fadePixelWidth; // 0 at innerBoundaryDist, 1 at fadeStartDist
                            // FIX: Fade IN the snapshot from 0 (inner edge) to 1 (wave body).
                            actualCharAlpha = fadeProgress;
                            actualBgAlpha = fadeProgress; 
                            actualSolid = true;             // Draw the background rect (which will be semi-transparent)
                            actualBlend = true;             // ENABLE BLEND: Draw standard grid underneath so we crossfade
                            actualGlow *= actualCharAlpha;  
                        } else if (dist <= innerBoundaryDist) {
                            // Past the inner edge, no override.
                            return null;
                        }
                        // Existing color blending
                        let finalColor = targetColor;
                        if (s.pulseBlend) {
                            const baseInt = this.snap.colors[i]; 
                            const bR = (baseInt >> 16) & 0xFF; 
                            const bG = (baseInt >> 8) & 0xFF; 
                            const bB = baseInt & 0xFF;
                            const mR = Math.floor(tRgb.r + (bR - tRgb.r) * rel); 
                            const mG = Math.floor(tRgb.g + (bG - tRgb.g) * rel); 
                            const mB = Math.floor(tRgb.b + (bB - tRgb.b) * rel);
                            finalColor = `rgb(${mR},${mG},${mB})`;
                        }
                        // Populate pooled object
                        result.char = char; 
                        result.font = fontName;
                        result.color = finalColor; 
                        result.alpha = Math.max(0, actualCharAlpha); 
                        result.glow = actualGlow; 
                        result.size = s.tracerSizeIncrease; 
                        result.solid = actualSolid; 
                        result.blend = actualBlend;
                        result.bgColor = `rgba(0,0,0,${Math.max(0, actualBgAlpha)})`; 
                    }
                }
                return result;
            }
        }
// --- SupermanEffect.js ---
class SupermanEffect extends AbstractEffect {
            constructor(g, c) { 
                super(g, c); 
                this.name = "Superman"; 
                this.active = false; 
                this.lightningPath = new Set();
                this.afterimages = new Map(); 
                this.timer = 0;
                this.spawnX = 0;
            }
            trigger() { 
                if(this.active) return false; 
                this.active = true; 
                this.timer = this.c.state.supermanDurationSeconds * 60; 
                this.flickerTimer = 0;
                this.spawnX = 0;
                this.afterimages.clear();
                this._generateBolt();
                return true; 
            }
            update() {
                const s = this.c.state;
                // Update afterimages (fade out)
                if (this.afterimages.size > 0) {
                    // Fade speed: higher = slower. Default ~20.
                    // 20 -> 0.05 decay. 
                    const decay = 1.0 / Math.max(1, s.supermanFadeSpeed || 20); 
                    for (const [index, alpha] of this.afterimages) {
                        const newAlpha = alpha - decay;
                        if (newAlpha <= 0.01) {
                            this.afterimages.delete(index);
                        } else {
                            this.afterimages.set(index, newAlpha);
                        }
                    }
                }
                if(!this.active && this.afterimages.size === 0) {
                     return;
                }
                if (this.active) {
                    this.timer--;
                    // Spawning logic
                    // Speed 40 ~ crosses screen in roughly 0.5-1s depending on refresh rate.
                    // Factor: Speed 40 -> 0.04 * cols per frame. 
                    // If cols=100, 4 cells/frame. 25 frames total.
                    const speedVal = s.supermanSpawnSpeed || 40;
                    const speedFactor = Math.max(1, speedVal) / 1000; 
                    this.spawnX += (this.g.cols * speedFactor);
                    if (this.spawnX > this.g.cols) this.spawnX = this.g.cols;
                    if (this.timer <= 0) {
                        this.active = false;
                        this.lightningPath.clear();
                        return;
                    }
                    this.flickerTimer++;
                    if (this.flickerTimer >= s.supermanFlickerRate) {
                        this._generateBolt();
                        this.flickerTimer = 0;
                    } else {
                        this._refreshAfterimages();
                    }
                }
            }
            _generateBolt() {
                this.lightningPath.clear();
                const s = this.c.state;
                const startY = Math.floor(this.g.rows / 2);
                let cy = startY;
                const limitX = Math.floor(this.spawnX);
                for (let x = 0; x < this.g.cols; x++) {
                    if (x > limitX) break;
                    // Jitter / Width logic
                    const variance = Math.max(1, s.supermanWidth); 
                    const noise = Utils.randomInt(-variance, variance);
                    // Gentle center pull to keep it on screen but allow jitter
                    const distFromCenter = (this.g.rows / 2) - cy;
                    cy += noise + (distFromCenter * 0.05); 
                    if (cy < 0) cy = 0;
                    if (cy >= this.g.rows) cy = this.g.rows - 1;
                    const thickness = s.supermanBoltThickness; 
                    const halfThick = Math.floor(thickness / 2);
                    for (let dy = -halfThick; dy <= halfThick; dy++) {
                        const thickY = Math.round(cy) + dy;
                        if (thickY >= 0 && thickY < this.g.rows) {
                            const idx = this.g.getIndex(x, thickY);
                            if (idx !== -1) {
                                this.lightningPath.add(idx);
                            }
                        }
                    }
                }
                this._refreshAfterimages();
            }
            _refreshAfterimages() {
                for (const idx of this.lightningPath) {
                    this.afterimages.set(idx, 1.0);
                }
            }
            getOverride(i) {
                if (this.afterimages.has(i)) {
                    const alphaChar = this.g.alphas[i];
                    if (alphaChar <= 0.05) return null;
                    const effectAlpha = this.afterimages.get(i);
                    const s = this.c.state;
                    const fontIdx = this.g.getFont(i);
                    const fontName = this.c.derived.activeFonts[fontIdx]?.name || s.fontFamily;
                    return {
                        char: this.g.getChar(i),
                        font: fontName,
                        color: s.supermanIncludeColors ? '#ffffffff' : '#b9e4b8ff', 
                        alpha: effectAlpha, 
                        glow: s.supermanGlow, 
                        size: 1,
                        solid: false, 
                        blend: true 
                    };
                }
                return null;
            }
        }
    // =========================================================================
    // 7.0 CANVAS RENDERER
    // =========================================================================
// --- CanvasRenderer.js ---
class CanvasRenderer {
    constructor(canvasId, grid, config, effects) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d', { alpha: false });
        this.bloomCvs = document.getElementById('bloomCanvas');
        this.bloomCtx = this.bloomCvs.getContext('2d', { alpha: true });
        // Off-screen buffer for overlap composition
        this.bufferCvs = document.createElement('canvas');
        this.bufferCtx = this.bufferCvs.getContext('2d', { alpha: true });
        // Scratch canvas for temporary operations
        this.scratchCvs = document.createElement('canvas');
        this.scratchCtx = this.scratchCvs.getContext('2d', { alpha: true });
        // Unified Render State Arrays
        this.frameAlphas = null;
        this.frameChars = null;
        this.frameFlags = null; // Bit 0: Active, Bit 1: Overlap Allowed
        this.grid = grid;
        this.config = config;
        this.effects = effects;
        // Initialize Glyph Atlases Map
        // Maps Font Name -> GlyphAtlas instance
        this.glyphAtlases = new Map();
        // Initialize Post Processor
        if (typeof PostProcessor !== 'undefined') {
            this.postProcessor = new PostProcessor(config);
            this.postProcessor.canvas.id = 'shaderCanvas';
            this.postProcessor.canvas.style.position = 'absolute';
            this.postProcessor.canvas.style.top = '0';
            this.postProcessor.canvas.style.left = '0';
            this.postProcessor.canvas.style.zIndex = '2'; // Above 2D canvas
            this.postProcessor.canvas.style.display = 'none'; // Hidden by default
            // Insert after main canvas
            this.cvs.parentNode.insertBefore(this.postProcessor.canvas, this.cvs.nextSibling);
        }
        this.w = 0;
        this.h = 0;
        this.lastShaderSource = null;
        // Mouse Tracking for Shader
        this.mouseX = 0.5;
        this.mouseY = 0.5;
        this._setupMouseTracking();
        // Reusable object for tracer state to avoid allocation in hot loops
        this._tracerStateObj = { alpha: 0, phase: 'none' };
        // State Cache
        this._lastFont = null;
        this._lastFillStyle = null;
        this._lastShadowColor = null;
        this._lastShadowBlur = null;
        this._lastGlobalAlpha = null;
        this._lastBloomFont = null;
        this._lastBloomFillStyle = null;
        this._lastBloomGlobalAlpha = null;
    }
    _resetStateCache() {
        this._lastFont = null;
        this._lastFillStyle = null;
        this._lastShadowColor = null;
        this._lastShadowBlur = null;
        this._lastGlobalAlpha = null;
        this._lastBloomFont = null;
        this._lastBloomFillStyle = null;
        this._lastBloomGlobalAlpha = null;
    }
    _setCtxFont(font, bloomEnabled) {
        if (this._lastFont !== font) {
            this.ctx.font = font;
            this._lastFont = font;
        }
        if (bloomEnabled && this._lastBloomFont !== font) {
            this.bloomCtx.font = font;
            this._lastBloomFont = font;
        }
    }
    _setCtxFillStyle(style, bloomEnabled) {
        if (this._lastFillStyle !== style) {
            this.ctx.fillStyle = style;
            this._lastFillStyle = style;
        }
        if (bloomEnabled && this._lastBloomFillStyle !== style) {
            this.bloomCtx.fillStyle = style;
            this._lastBloomFillStyle = style;
        }
    }
    _setCtxShadow(color, blur) {
        if (this._lastShadowColor !== color) {
            this.ctx.shadowColor = color;
            this._lastShadowColor = color;
        }
        if (this._lastShadowBlur !== blur) {
            this.ctx.shadowBlur = blur;
            this._lastShadowBlur = blur;
        }
    }
    _setCtxGlobalAlpha(alpha, bloomEnabled) {
        if (this._lastGlobalAlpha !== alpha) {
            this.ctx.globalAlpha = alpha;
            this._lastGlobalAlpha = alpha;
        }
        if (bloomEnabled && this._lastBloomGlobalAlpha !== alpha) {
            this.bloomCtx.globalAlpha = alpha;
            this._lastBloomGlobalAlpha = alpha;
        }
    }
    _setupMouseTracking() {
        const updateMouse = (e) => {
            const rect = this.cvs.getBoundingClientRect();
            // Normalize to 0..1
            this.mouseX = (e.clientX - rect.left) / rect.width;
            this.mouseY = 1.0 - ((e.clientY - rect.top) / rect.height); // Flip Y to match WebGL coords
            // Clamp
            this.mouseX = Math.max(0, Math.min(1, this.mouseX));
            this.mouseY = Math.max(0, Math.min(1, this.mouseY));
        };
        window.addEventListener('mousemove', updateMouse);
        window.addEventListener('touchmove', (e) => {
            if(e.touches.length > 0) updateMouse(e.touches[0]);
        }, { passive: true });
    }
    resize() {
        const scale = this.config.state.resolution;
        this.w = window.innerWidth;
        this.h = window.innerHeight;
        // 1. Main Display Canvas
        this._resizeCanvas(this.cvs, this.w, this.h, scale);
        // Resize Post Processor
        if (this.postProcessor) {
            this.postProcessor.resize(this.w * scale, this.h * scale);
            this.postProcessor.canvas.style.width = `${this.w}px`;
            this.postProcessor.canvas.style.height = `${this.h}px`;
        }
        // 2. Bloom Canvas (1/4 size)
        this._resizeCanvas(this.bloomCvs, this.w, this.h, scale * 0.25);
        this.bloomCtx.scale(0.25, 0.25);
        // 3. Buffer Canvas (Layer A - Stream Shapes)
        this._resizeCanvas(this.bufferCvs, this.w, this.h, scale);
        // Apply global scale so drawing coordinates match main canvas
        this.bufferCtx.scale(scale * this.config.state.stretchX, scale * this.config.state.stretchY);
        // 4. Scratch Canvas (Layer B - Overlap Shapes) -> NOW FULL SCREEN
        this._resizeCanvas(this.scratchCvs, this.w, this.h, scale);
        // Apply global scale so drawing coordinates match main canvas
        this.scratchCtx.scale(scale * this.config.state.stretchX, scale * this.config.state.stretchY);
        // Allocate Frame Buffers
        if (!this.grid.chars) return;
        const size = this.grid.chars.length;
        this.frameAlphas = new Float32Array(size);
        this.frameChars = new Uint16Array(size);
        this.frameFlags = new Uint8Array(size);
        this.updateSmoothing();
    }
    _resizeCanvas(canvas, width, height, scale) {
        canvas.width = width * scale;
        canvas.height = height * scale;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
    }
    /**
     * Updates canvas smoothing filters for blur effects.
     * Ensures visual fidelity when smoothing is enabled in settings.
     */
    updateSmoothing() {
        const smoothing = this.config.state.smoothingEnabled ? this.config.state.smoothingAmount : 0;
        this.cvs.style.filter = `blur(${smoothing}px)`;
    }
    /**
     * Calculates the alpha and phase of the tracer based on its age and active state.
     * Optimized logic with early returns and simplified operations.
     * Uses a reusable output object to avoid GC.
     */
    _getTracerState(index, state, out) {
        // Reset defaults
        out.alpha = 0;
        out.phase = 'none';
        const age = this.grid.ages[index];
        const decay = this.grid.decays[index];
        if (age <= 0 || decay >= 2) return out;
        const type = this.grid.types[index];
        if (type !== CELL_TYPE.TRACER && type !== CELL_TYPE.ROTATOR) return out;
        const activeTime = age - 1;
        const attack = state.tracerAttackFrames;
        const hold = state.tracerHoldFrames;
        const release = state.tracerReleaseFrames;
        if (activeTime < attack) {
            out.alpha = (attack > 0) ? (activeTime / attack) : 1.0;
            out.phase = 'attack';
        } else if (activeTime < attack + hold) {
            out.alpha = 1.0;
            out.phase = 'hold';
        } else if (activeTime < attack + hold + release) {
            const relTime = activeTime - (attack + hold);
            out.alpha = 1.0 - (relTime / release);
            out.phase = 'release';
        }
        return out;
    }
    _updateAtlases(s, d) {
        if (!s.enableGlyphAtlas || typeof GlyphAtlas === 'undefined') return;
        const activeFonts = d.activeFonts || [];
        const activeNames = new Set(activeFonts.map(f => f.name));
        // Update or Create Atlases
        for (const font of activeFonts) {
            let atlas = this.glyphAtlases.get(font.name);
            if (!atlas) {
                atlas = new GlyphAtlas(this.config, font.name, font.chars);
                this.glyphAtlases.set(font.name, atlas);
            } else {
                // Update existing atlas properties in case chars changed
                atlas.fontName = font.name;
                atlas.customChars = font.chars;
            }
            atlas.update();
        }
        // Prune unused atlases
        for (const [name, atlas] of this.glyphAtlases) {
            if (!activeNames.has(name)) {
                this.glyphAtlases.delete(name);
            }
        }
    }
    render(frame) {
        if (!this.frameAlphas) return;
        const { state: s, derived: d } = this.config;
        const scale = s.resolution;
        const bloomEnabled = s.enableBloom;
        // Update Glyph Atlases
        this._updateAtlases(s, d);
        this._resetContext(this.ctx, s, scale);
        if (bloomEnabled) this.bloomCtx.clearRect(0, 0, this.w * scale, this.h * scale);
        this._applyMirrorEffect(this.ctx, s, scale);
        if (bloomEnabled) {
            this.bloomCtx.save();
            this.bloomCtx.scale(scale * s.stretchX, scale * s.stretchY);
            this._applyMirrorEffect(this.bloomCtx, s, scale);
        }
        this._drawGrid(d, s, frame, bloomEnabled);
        if (s.overlapEnabled) {
            this._drawOverlap(d, s, frame, bloomEnabled, scale);
        }
        if (bloomEnabled) this._applyBloom(s, scale);
        // --- Post Processing ---
        if (this.postProcessor && s.shaderEnabled) {
            // Check if shader source changed
            const currentShader = s.customShader;
            if (currentShader && currentShader !== this.lastShaderSource) {
                this.postProcessor.compileShader(currentShader);
                this.lastShaderSource = currentShader;
            }
            // Render to WebGL
            // We pass the 2D canvas as the texture source
            // Pass Mouse (vec2) and Parameter (float)
            const param = s.shaderParameter !== undefined ? s.shaderParameter : 0.5;
            this.postProcessor.render(this.cvs, performance.now() / 1000, this.mouseX, this.mouseY, param);
            // Show WebGL, Hide 2D
            if (this.postProcessor.canvas.style.display === 'none') {
                this.postProcessor.canvas.style.display = 'block';
                this.cvs.style.opacity = '0'; // Hide visual but keep active
            }
        } else {
            // Show 2D, Hide WebGL
            if (this.postProcessor && this.postProcessor.canvas.style.display !== 'none') {
                this.postProcessor.canvas.style.display = 'none';
                this.cvs.style.opacity = '1';
            }
        }
    }
    _drawOverlap(d, s, frame, bloomEnabled, scale) {
        // --- SETUP ---
        const ctxA = this.bufferCtx; // Layer A (Stream Shapes)
        const cvsA = this.bufferCvs;
        const ctxB = this.scratchCtx; // Layer B (Overlap Shapes)
        const cvsB = this.scratchCvs;
        // Clear both layers
        const clearW = this.w / s.stretchX; 
        const clearH = this.h / s.stretchY;
        ctxA.clearRect(0, 0, clearW, clearH);
        ctxB.clearRect(0, 0, clearW, clearH);
        // Constants
        const xOff = s.fontOffsetX;
        const yOff = s.fontOffsetY;
        const useAtlas = s.enableGlyphAtlas;
        if (!useAtlas) {
            ctxA.fillStyle = '#FFFFFF';
            ctxB.fillStyle = '#FFFFFF';
            ctxA.textBaseline = 'middle';
            ctxA.textAlign = 'center';
            ctxB.textBaseline = 'middle';
            ctxB.textAlign = 'center';
        }
        // --- PASS 1: DRAW SHAPES ---
        const activeFonts = d.activeFonts;
        for (const i of this.grid.activeIndices) {
            // 1. Filter Logic
            const style = this.grid.complexStyles.get(i);
            if (style && style.isEffect) continue;
            const overlapTarget = s.overlapTarget || 'stream';
            if (overlapTarget === 'stream') {
                const cellType = this.grid.types[i];
                if (cellType !== CELL_TYPE.TRACER && cellType !== CELL_TYPE.ROTATOR) continue;
            }
            let gridAlpha = this.grid.alphas[i];
            const tState = this._getTracerState(i, s, this._tracerStateObj);
            if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0;
            const override = this.effects.getOverride(i);
            if (override && typeof override.alpha === 'number') gridAlpha = override.alpha;
            if (gridAlpha <= 0.05) continue;
            const code = this.grid.overlapChars[i];
            if (code === 0) continue;
            // 2. Geometry
            const x = i % this.grid.cols;
            const y = Math.floor(i / this.grid.cols);
            const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
            const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
            let streamChar = this.grid.getChar(i);
            if (override && override.char) streamChar = override.char;
            const overlapChar = String.fromCharCode(code);
            // Determine font resources
            let atlas = null;
            let fontName = s.fontFamily;
            if (useAtlas) {
                const fontIndex = this.grid.getFont(i);
                const fontData = activeFonts[fontIndex] || activeFonts[0];
                atlas = this.glyphAtlases.get(fontData.name);
            } else {
                const fontIndex = this.grid.getFont(i);
                const fontData = activeFonts[fontIndex] || activeFonts[0];
                fontName = fontData.name;
            }
            // Calculate Effects (Dissolve/Size)
            const decay = this.grid.decays[i];
            let drawScale = 1.0;
            if (s.dissolveEnabled && decay >= 2) {
                 const prog = (decay - 2) / s.decayFadeDurationFrames;
                 const minRatio = s.dissolveMinSize / s.fontSize;
                 drawScale = 1.0 - (prog * (1.0 - minRatio));
                 drawScale = Math.max(0.1, drawScale);
            }
            ctxA.globalAlpha = 1.0; 
            ctxB.globalAlpha = gridAlpha; 
            // 3. Draw to Layer A (Stream Base)
            if (useAtlas && atlas) {
                const sprite = atlas.get(streamChar);
                if (sprite) {
                    ctxA.drawImage(atlas.canvas, 
                        sprite.x, sprite.y, sprite.w, sprite.h, 
                        px - (sprite.w * drawScale)/2, py - (sprite.h * drawScale)/2, 
                        sprite.w * drawScale, sprite.h * drawScale
                    );
                }
            } else {
                const fontSize = Math.max(1, s.fontSize * drawScale);
                const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${fontSize}px ${fontName}`;
                ctxA.font = font;
                ctxA.fillText(streamChar, px, py);
            }
            // 4. Draw to Layer B (Overlap Mask)
            if (useAtlas && atlas) {
                const sprite = atlas.get(overlapChar);
                if (sprite) {
                    ctxB.drawImage(atlas.canvas, 
                        sprite.x, sprite.y, sprite.w, sprite.h, 
                        px - (sprite.w * drawScale)/2, py - (sprite.h * drawScale)/2, 
                        sprite.w * drawScale, sprite.h * drawScale
                    );
                }
            } else {
                const fontSize = Math.max(1, s.fontSize * drawScale);
                const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${fontSize}px ${fontName}`;
                ctxB.font = font;
                ctxB.fillText(overlapChar, px, py);
            }
        }
        // --- PASS 2: COMPOSITE ---
        ctxA.save();
        ctxA.setTransform(1, 0, 0, 1, 0, 0); 
        ctxA.globalCompositeOperation = 'source-in';
        ctxA.globalAlpha = 1.0; 
        ctxA.drawImage(cvsB, 0, 0);
        ctxA.globalCompositeOperation = 'source-in';
        ctxA.fillStyle = s.overlapColor;
        ctxA.fillRect(0, 0, cvsA.width, cvsA.height);
        ctxA.restore(); 
        // --- PASS 3: FINAL DRAW ---
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.globalAlpha = 1.0;
        this.ctx.drawImage(cvsA, 0, 0);
        this.ctx.restore();
    }
    _resetContext(ctx, s, scale) {
        ctx.save();
        ctx.scale(scale * s.stretchX, scale * s.stretchY);
        ctx.fillStyle = `rgba(0,0,0,${s.clearAlpha})`;
        ctx.fillRect(0, 0, this.w / s.stretchX, this.h / s.stretchY);
    }
    _applyMirrorEffect(ctx, s, scale) {
        if (s.mirrorEnabled) {
            ctx.scale(-1, 1);
            ctx.translate(-(this.w / s.stretchX), 0);
        }
    }
    _applyBloom(s, scale) {
        if (this.bloomCvs.width === 0 || this.bloomCvs.height === 0) return;
        this.bloomCtx.restore();
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'lighter';
        this.ctx.filter = `blur(${s.bloomStrength * 4}px)`;
        this.ctx.globalAlpha = s.bloomOpacity;
        this.ctx.drawImage(this.bloomCvs, 0, 0, this.w * scale, this.h * scale);
        this.ctx.restore();
    }
    _drawGrid(d, s, frame, bloomEnabled) {
        this._resetStateCache(); // Reset cache at start of grid draw
        const fontBase = d.fontBaseStr;
        // Only set font if NOT using atlas for everything
        this._setCtxFont(fontBase, bloomEnabled);
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        if (bloomEnabled) {
            this.bloomCtx.textBaseline = 'middle';
            this.bloomCtx.textAlign = 'center';
        }
        const defaultColor = d.streamColorStr;
        let lastColor = defaultColor;
        this._setCtxFillStyle(defaultColor, bloomEnabled);
        const xOff = s.fontOffsetX;
        const yOff = s.fontOffsetY;
        const useActiveSet = !this.effects.hasActiveEffects();
        // Decide drawing mode once per frame
        const useAtlas = s.enableGlyphAtlas;
        const total = useActiveSet ? 0 : this.grid.cols * this.grid.rows;
        const activeFonts = d.activeFonts;
        if (useActiveSet) {
            for (const i of this.grid.activeIndices) {
                this._processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas, activeFonts);
            }
        } else {
            for (let i = 0; i < total; i++) {
                this._processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas, activeFonts);
            }
        }
        this._drawTracers(d, s, frame, bloomEnabled, xOff, yOff);
        this.ctx.restore();
    }
    _processCellRender(i, d, s, frame, bloomEnabled, fontBase, defaultColor, xOff, yOff, lastColor, useAtlas, activeFonts) {
            this._setCtxShadow('transparent', 0);
            const override = this.effects.getOverride(i);
            if (override && !override.blend) {
                this._drawOverride(i, override, d, s, bloomEnabled);
                return;
            }
            let gridAlpha = this.grid.alphas[i];
            if (gridAlpha <= 0.01) return;
            const tState = this._getTracerState(i, s, this._tracerStateObj);
            if (tState.phase === 'attack' || tState.phase === 'hold') gridAlpha = 0.0;
            if (gridAlpha <= 0.01) return;
            const x = i % this.grid.cols;
            const y = Math.floor(i / this.grid.cols);
            const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
            const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
            let color = defaultColor;
            let pIdx = this.grid.paletteIndices[i];
            if (pIdx >= d.paletteColorsStr.length) pIdx = 0;
            const paletteColor = d.paletteColorsStr[pIdx] || defaultColor;
            const style = this.grid.complexStyles.get(i);
            if (style) {
                color = this._getCellColor(style, frame);
            } else {
                color = paletteColor;
            }
            const canUseAtlas = useAtlas && (color === paletteColor);
            if (!canUseAtlas && color !== lastColor) {
                this._setCtxFillStyle(color, bloomEnabled);
                lastColor = color;
            }
            // Resolve Font
            const fontIdx = this.grid.getFont(i);
            const fontData = activeFonts[fontIdx] || activeFonts[0];
            const currentFontName = fontData.name;
            if (canUseAtlas) {
                 const atlas = this.glyphAtlases.get(currentFontName);
                 if (atlas) {
                     this._drawCellCharAtlas(i, px, py, gridAlpha, s, bloomEnabled, pIdx, atlas);
                 } else {
                     // Fallback if atlas missing
                     this._drawCellChar(i, px, py, gridAlpha, tState, d, s, bloomEnabled, currentFontName);
                 }
            } else {
                 this._drawCellChar(i, px, py, gridAlpha, tState, d, s, bloomEnabled, currentFontName);
            }
            if (override && override.blend) {
                this._drawOverride(i, override, d, s, bloomEnabled);
            }
    }
    _drawCellCharAtlas(i, px, py, alpha, s, bloomEnabled, pIdx, atlas) {
        const decay = this.grid.decays[i];
        const char = this.grid.getChar(i);
        const sprite = atlas.get(char);
        const yOffset = (pIdx || 0) * atlas.blockHeight;
        if (!sprite) return; 
        const rotProg = this.grid.rotatorProg[i];
        if (rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
             const p = rotProg / s.rotatorCrossfadeFrames;
             const next = this.grid.nextChars.get(i);
             const nextSprite = next ? atlas.get(next) : null;
             this._setCtxGlobalAlpha(alpha * (1 - p), bloomEnabled);
             this.ctx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
             if(bloomEnabled) {
                 this.bloomCtx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - sprite.w/2, py - sprite.h/2, sprite.w, sprite.h);
             }
             if (nextSprite) {
                 this._setCtxGlobalAlpha(alpha * p, bloomEnabled);
                 this.ctx.drawImage(atlas.canvas, nextSprite.x, nextSprite.y + yOffset, nextSprite.w, nextSprite.h, px - nextSprite.w/2, py - nextSprite.h/2, nextSprite.w, nextSprite.h);
                 if(bloomEnabled) {
                     this.bloomCtx.drawImage(atlas.canvas, nextSprite.x, nextSprite.y + yOffset, nextSprite.w, nextSprite.h, px - nextSprite.w/2, py - nextSprite.h/2, nextSprite.w, nextSprite.h);
                 }
             }
             return;
        }
        let scale = 1.0;
        if (s.dissolveEnabled && decay >= 2) {
             const prog = (decay - 2) / s.decayFadeDurationFrames;
             const minRatio = s.dissolveMinSize / s.fontSize;
             scale = 1.0 - (prog * (1.0 - minRatio));
             scale = Math.max(0.1, scale); 
             if (s.deteriorationEnabled) {
                 const off = s.deteriorationStrength * prog;
                 this._setCtxGlobalAlpha(alpha * 0.4 * prog, false); // Explicitly only ctx for deterioration? Or both? Original code: this.ctx.globalAlpha = ...
                 // Original only set this.ctx.globalAlpha. Bloom wasn't explicitly drawn for deterioration ghosting.
                 this.ctx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, (py - off) - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
                 this.ctx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, (py + off) - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
             }
        }
        this._setCtxGlobalAlpha(alpha, bloomEnabled);
        this.ctx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, py - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
        if (bloomEnabled) {
            this.bloomCtx.drawImage(atlas.canvas, sprite.x, sprite.y + yOffset, sprite.w, sprite.h, px - (sprite.w*scale)/2, py - (sprite.h*scale)/2, sprite.w*scale, sprite.h*scale);
        }
    }
    _getCellColor(style, frame) {
        if (style.glitter && Math.random() < 0.02) return '#ffffff';
        let h = style.h;
        if (style.cycle) h = (h + (frame * style.speed)) % 360;
        const rgb = Utils.hslToRgb(h | 0, style.s, style.l);
        return Utils.createRGBString(rgb);
    }
    _drawCellChar(i, px, py, alpha, tState, d, s, bloomEnabled, fontName) {
        const decay = this.grid.decays[i];
        const rotProg = this.grid.rotatorProg[i];
        const char = this.grid.getChar(i);
        // Use fontName passed in
        const fontSize = s.fontSize; // Could vary with dissolve
        const fontBase = `${s.italicEnabled ? 'italic ' : ''}${s.fontWeight} ${fontSize}px ${fontName}`;
        this._setCtxFont(fontBase, bloomEnabled);
        if (rotProg > 0 && s.rotatorCrossfadeFrames > 2) {
            const p = rotProg / s.rotatorCrossfadeFrames;
            this._setCtxGlobalAlpha(alpha * (1 - p), bloomEnabled);
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.fillText(char, px, py);
            }
            const next = this.grid.nextChars.get(i);
            if (next) {
                this._setCtxGlobalAlpha(alpha * p, bloomEnabled);
                this.ctx.fillText(next, px, py);
                if (bloomEnabled) {
                    this.bloomCtx.fillText(next, px, py);
                }
            }
        } else if (s.dissolveEnabled && decay >= 2) {
            const prog = (decay - 2) / s.decayFadeDurationFrames;
            const size = Math.max(1, s.fontSize - ((s.fontSize - s.dissolveMinSize) * prog));
            const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${size}px ${fontName}`;
            this._setCtxFont(font, false); // Bloom font handled via base or ignore for dissolve? Original updated this.ctx.font
            // Actually, original updated ctx.font. BloomCtx doesn't seem to be updated for dissolve font size in original logic explicitly unless bloomEnabled was true, but original logic:
            // this.ctx.font = font; ... if(bloomEnabled) this.bloomCtx.fillText...
            // Bloom context uses its current font. If we didn't update bloom font, it might be wrong.
            // Let's assume we should update bloom font if enabled.
            if(bloomEnabled) this.bloomCtx.font = font; 
            // Updating my helper to allow single context update is tricky.
            // I'll manually set for now or assume bloom follows.
            // _setCtxFont updates both if bloomEnabled is true.
            if (s.deteriorationEnabled) {
                const off = s.deteriorationStrength * prog;
                this._setCtxGlobalAlpha(alpha * 0.4 * prog, false);
                this.ctx.fillText(char, px, py - off);
                this.ctx.fillText(char, px, py + off);
            }
            this._setCtxGlobalAlpha(alpha, bloomEnabled);
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.fillText(char, px, py);
            }
        } else {
            this._setCtxGlobalAlpha(alpha, bloomEnabled);
            this.ctx.fillText(char, px, py);
            if (bloomEnabled) {
                this.bloomCtx.fillText(char, px, py);
            }
        }
    }
    _drawTracers(d, s, frame, bloomEnabled, xOff, yOff) {
        const tStr = d.tracerColorStr;
        this._setCtxShadow(tStr, s.tracerGlow);
        const activeFonts = d.activeFonts;
        for (const i of this.grid.activeIndices) {
            if (this.effects.getOverride(i)) continue;
            const tState = this._getTracerState(i, s, this._tracerStateObj);
            if (tState.alpha > 0.01) {
                const x = i % this.grid.cols;
                const y = Math.floor(i / this.grid.cols);
                const px = (x * d.cellWidth + d.cellWidth * 0.5) + xOff;
                const py = (y * d.cellHeight + d.cellHeight * 0.5) + yOff;
                // Font Setup
                const fontIdx = this.grid.getFont(i);
                const fontData = activeFonts[fontIdx] || activeFonts[0];
                const tFont = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${s.fontSize + s.tracerSizeIncrease}px ${fontData.name}`;
                this._setCtxFont(tFont, bloomEnabled);
                const style = this.grid.complexStyles.get(i);
                let cStr = tStr;
                if (style && style.isEffect) {
                    let h = style.h;
                    if (style.cycle) h = (h + (frame * style.speed)) % 360;
                    const tc = Utils.hslToRgb(h | 0, 100, 90);
                    cStr = Utils.createRGBString(tc);
                }
                this._setCtxFillStyle(cStr, bloomEnabled);
                // Shadow color tracks fill style for tracers usually? Original code set shadowColor = cStr
                // Yes: this.ctx.shadowColor = cStr;
                // But my helper _setCtxShadow handles color and blur together.
                // I need to update shadow color if it changed.
                if (this._lastShadowColor !== cStr) {
                    this.ctx.shadowColor = cStr;
                    this._lastShadowColor = cStr;
                }
                this._setCtxGlobalAlpha(tState.alpha, bloomEnabled);
                this.ctx.fillText(this.grid.getChar(i), px, py);
                if (bloomEnabled) {
                    this.bloomCtx.fillText(this.grid.getChar(i), px, py);
                }
            }
        }
    }
    _drawOverride(i, o, d, s, bloom) {
        const x = i % this.grid.cols;
        const y = Math.floor(i / this.grid.cols);
        const cx = (x * d.cellWidth) + s.fontOffsetX;
        const cy = (y * d.cellHeight) + s.fontOffsetY;
        // Geometry for solid background
        if (o.solid) {
            const bg = o.bgColor || '#000000';
            this._setCtxFillStyle(bg, false); // Backgrounds usually don't bloom? Original code didn't draw bg to bloomCtx.
            // Original: this.ctx.fillStyle = bg; ... fillRect
            const w = Math.ceil(d.cellWidth) + 1;
            const h = Math.ceil(d.cellHeight) + 1;
            this.ctx.fillRect(Math.floor(cx), Math.floor(cy), w, h);
        }
        if (o.char && o.alpha > 0.01) {
            const px = cx + (d.cellWidth * 0.5);
            const py = cy + (d.cellHeight * 0.5);
            const fontName = o.font || s.fontFamily;
            // FILLTEXT PATH (Unified)
            // Effects require dynamic colors/sizes not supported by simple atlas draw
            this._setCtxFillStyle(o.color, bloom);
            if (o.glow > 0) {
                this._setCtxShadow(o.color, o.glow);
            } else {
                this._setCtxShadow('transparent', 0);
            }
            const font = `${s.italicEnabled ? 'italic' : ''} ${s.fontWeight} ${s.fontSize + (o.size || 0)}px ${fontName}`;
            this._setCtxFont(font, bloom);
            this._setCtxGlobalAlpha(o.alpha, bloom);
            this.ctx.fillText(o.char, px, py);
            if (bloom) {
                this.bloomCtx.fillText(o.char, px, py);
            }
        }
    }
}
// --- GlyphAtlas.js ---
class GlyphAtlas {
    constructor(config, fontName = null, customChars = null) {
        this.config = config;
        this.fontName = fontName;
        this.customChars = customChars;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true });
        // Map character codes to their x/y coordinates in the atlas
        this.charMap = new Map();
        // Atlas dimensions and cell size
        this.cellSize = 0;
        this.atlasWidth = 0;
        this.atlasHeight = 0;
        this.blockHeight = 0; // Height of one color set
        // State tracking for updates
        this.currentFont = '';
        this.currentPalette = '';
        this.needsUpdate = true;
        // Pre-calculated half sizes for centering
        this.halfCell = 0;
    }
    /**
     * Initializes or updates the atlas if configuration has changed.
     */
    update() {
        const s = this.config.state;
        const d = this.config.derived;
        // Determine font and chars to use
        const fontFamily = this.fontName || s.fontFamily;
        const charList = this.customChars || Utils.CHARS;
        // Check if update is needed (font, color, or size change)
        const maxSize = s.fontSize + s.tracerSizeIncrease;
        const style = s.italicEnabled ? 'italic ' : '';
        const fontBase = `${style}${s.fontWeight} ${maxSize}px ${fontFamily}`;
        const paletteStr = d.paletteColorsStr.join(',');
        // Include overlap color and charList length/content in dependency check
        const fullConfigStr = paletteStr + '|' + s.overlapColor + '|' + charList.length + charList;
        if (this.currentFont === fontBase && 
            this.currentPalette === fullConfigStr && 
            !this.needsUpdate) {
            return;
        }
        this.currentFont = fontBase;
        this.currentPalette = fullConfigStr;
        this.needsUpdate = false;
        // Calculate cell dimensions (add padding for glow/blur)
        const padding = Math.max(s.tracerGlow, 10) * 2;
        this.cellSize = Math.ceil(maxSize + padding);
        this.halfCell = this.cellSize / 2;
        // Calculate atlas dimensions
        const cols = Math.ceil(Math.sqrt(charList.length));
        const rows = Math.ceil(charList.length / cols);
        this.atlasWidth = cols * this.cellSize;
        this.blockHeight = rows * this.cellSize; // Height of ONE color set
        // Total height = Palette Colors + 1 Overlap Color
        const colorsToDraw = [...d.paletteColorsStr, s.overlapColor];
        this.atlasHeight = this.blockHeight * colorsToDraw.length;
        // Resize canvas
        this.canvas.width = this.atlasWidth;
        this.canvas.height = this.atlasHeight;
        // Clear and set up context
        this.ctx.clearRect(0, 0, this.atlasWidth, this.atlasHeight);
        this.ctx.font = fontBase;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.charMap.clear();
        // Draw Characters for each color in the palette + overlap
        colorsToDraw.forEach((color, pIdx) => {
            this.ctx.fillStyle = color;
            const yOffset = pIdx * this.blockHeight;
            for (let i = 0; i < charList.length; i++) {
                const char = charList[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = col * this.cellSize + this.halfCell;
                const y = row * this.cellSize + this.halfCell + yOffset;
                this.ctx.fillText(char, x, y);
                // Store map ONLY for the first block (pIdx 0) as relative coords are same
                if (pIdx === 0) {
                    this.charMap.set(char, {
                        x: col * this.cellSize,
                        y: row * this.cellSize,
                        w: this.cellSize,
                        h: this.cellSize
                    });
                }
            }
        });
    }
    /**
     * Returns the source coordinates for a character.
     * @param {string} char 
     * @returns {Object|null} Source rect {x,y,w,h} or null
     */
    get(char) {
        return this.charMap.get(char);
    }
}
// --- PostProcessor.js ---
class PostProcessor {
    constructor(config) {
        this.config = config;
        this.gl = null;
        this.program = null;
        this.canvas = document.createElement('canvas'); // Offscreen WebGL canvas
        this.texture = null;
        this.positionBuffer = null;
        this.defaultFragmentShader = `
            precision mediump float;
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uParameter;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = texture2D(uTexture, vTexCoord);
            }
        `;
        this.vertexShaderSource = `
            attribute vec2 aPosition;
            varying vec2 vTexCoord;
            void main() {
                // Map -1..1 to 0..1 for tex coords (flip Y if needed)
                vTexCoord = (aPosition + 1.0) * 0.5;
                vTexCoord.y = 1.0 - vTexCoord.y; 
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        this._initWebGL();
    }
    _initWebGL() {
        this.gl = this.canvas.getContext('webgl', { alpha: false, preserveDrawingBuffer: true });
        if (!this.gl) {
            console.warn("WebGL not supported for Post Processing");
            return;
        }
        // Full screen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1
        ]);
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        this.texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.compileShader(this.config.get('customShader') || this.defaultFragmentShader);
    }
    compileShader(fragSource) {
        if (!this.gl) return;
        if (!fragSource) fragSource = this.defaultFragmentShader;
        const createShader = (type, source) => {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                console.warn(type === this.gl.VERTEX_SHADER ? 'Vertex Shader Error' : 'Fragment Shader Error', this.gl.getShaderInfoLog(shader));
                this.gl.deleteShader(shader);
                return null;
            }
            return shader;
        };
        const vs = createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        const fs = createShader(this.gl.FRAGMENT_SHADER, fragSource);
        if (!vs || !fs) return; // Compilation failed
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
            console.warn("Program Link Error", this.gl.getProgramInfoLog(prog));
            return;
        }
        this.program = prog;
    }
    resize(width, height) {
        if (!this.gl) return;
        this.canvas.width = width;
        this.canvas.height = height;
        this.gl.viewport(0, 0, width, height);
    }
    render(sourceCanvas, time, mouseX = 0, mouseY = 0, param = 0.5) {
        if (!this.gl || !this.program) return;
        this.gl.useProgram(this.program);
        // Bind Vertex Buffer
        const posLoc = this.gl.getAttribLocation(this.program, 'aPosition');
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(posLoc);
        this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);
        // Update Texture
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceCanvas);
        // Uniforms
        const uTex = this.gl.getUniformLocation(this.program, 'uTexture');
        this.gl.uniform1i(uTex, 0);
        const uRes = this.gl.getUniformLocation(this.program, 'uResolution');
        this.gl.uniform2f(uRes, this.canvas.width, this.canvas.height);
        const uTime = this.gl.getUniformLocation(this.program, 'uTime');
        this.gl.uniform1f(uTime, time);
        // NEW UNIFORMS
        const uMouse = this.gl.getUniformLocation(this.program, 'uMouse');
        if (uMouse) this.gl.uniform2f(uMouse, mouseX, mouseY);
        const uParam = this.gl.getUniformLocation(this.program, 'uParameter');
        if (uParam) this.gl.uniform1f(uParam, param);
        // Draw
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
}
// --- SimulationSystem.js ---
class SimulationSystem {
    constructor(grid, config) {
        this.grid = grid;
        this.config = config;
        this.activeStreams = [];
        this.lastStreamInColumn = new Array(grid.cols).fill(null);
        this.lastEraserInColumn = new Array(grid.cols).fill(null);
        this.modes = this._initializeModes(config);
        this.overlapInitialized = false;
        this._lastOverlapDensity = null;
        this.nextSpawnFrame = 0; // Track next spawn time
    }
    _initializeModes(config) {
        return {
            'STANDARD': new StandardMode(config),
            'STAR_POWER': new StarPowerMode(config),
            'RAINBOW': new RainbowMode(config)
        };
    }
    update(frame) {
        if (this.lastStreamInColumn.length !== this.grid.cols) {
            this._resetColumns();
        }
        this._manageStreams(frame);
        this._manageOverlapGrid(frame);
        this._updateCells(frame);
        // Clear locks for the next frame (locks are set during rendering)
        if (this.grid.cellLocks) {
            this.grid.cellLocks.fill(0);
        }
    }
    _manageOverlapGrid(frame) {
        if (!this.config.state.overlapEnabled) {
            // Reset initialization state when disabled
            if (this.overlapInitialized) {
                this.overlapInitialized = false;
                // Clear all overlap chars when disabled
                for(let i=0; i<this.grid.overlapChars.length; i++) {
                    this.grid.overlapChars[i] = 0;
                }
            }
            return;
        }
        const activeFonts = this.config.derived.activeFonts;
        const numFonts = activeFonts.length;
        const currentDensity = this.config.state.overlapDensity;
        // Helper to get random char for a cell
        const setOverlapChar = (i) => {
            let fIdx;
            if (this.grid.types[i] === CELL_TYPE.EMPTY) {
                // If empty, we can choose any active font
                fIdx = Math.floor(Math.random() * numFonts);
                this.grid.setFont(i, fIdx);
            } else {
                // If occupied, MUST use the existing font to match the stream/renderer
                fIdx = this.grid.getFont(i);
            }
            const fontData = activeFonts[fIdx] || activeFonts[0];
            const chars = fontData.chars;
            if (chars && chars.length > 0) {
                this.grid.overlapChars[i] = chars[Math.floor(Math.random() * chars.length)].charCodeAt(0);
            } else {
                this.grid.overlapChars[i] = 32; // Space if empty
            }
        };
        // Check if we need to reinitialize (density changed or first time)
        if (!this.overlapInitialized || this._lastOverlapDensity !== currentDensity) {
            for(let i=0; i<this.grid.overlapChars.length; i++) {
                if (Math.random() < currentDensity) {
                    setOverlapChar(i);
                } else {
                    this.grid.overlapChars[i] = 0; // Empty
                }
            }
            this.overlapInitialized = true;
            this._lastOverlapDensity = currentDensity;
        }
    }
    _resetColumns() {
        this.lastStreamInColumn = new Array(this.grid.cols).fill(null);
        this.lastEraserInColumn = new Array(this.grid.cols).fill(null);
        this.activeStreams = [];
        // Reset overlap initialization when grid resizes
        this.overlapInitialized = false;
    }
    _manageStreams(frame) {
        const { state: s, derived: d } = this.config;
        // Spawn Logic
        if (frame >= this.nextSpawnFrame) {
            this._spawnStreams(s, d);
            // Calculate next spawn time
            const baseInterval = Math.max(1, Math.floor(d.cycleDuration * s.releaseInterval));
            let nextDelay = baseInterval;
            // Apply Desync to spawn interval
            if (s.desyncIntensity > 0) {
                const variance = baseInterval * s.desyncIntensity * 2; // Up to 200% variance
                const offset = Utils.randomInt(-variance/2, variance/2);
                nextDelay = Math.max(1, baseInterval + offset);
            }
            this.nextSpawnFrame = frame + nextDelay;
        }
        // Processing Logic - Run every frame, individual streams handle their own timing
        this._processActiveStreams(frame);
    }
    _spawnStreams(s, d) {
        const columns = this._shuffleArray([...Array(this.grid.cols).keys()]);
        let streamCount = s.streamSpawnCount;
        let eraserCount = s.eraserSpawnCount;
        for (const col of columns) {
            if (streamCount <= 0 && eraserCount <= 0) break;
            const spawnIdx = this.grid.getIndex(col, 0);
            let isTopBlocked = false;
            if (spawnIdx !== -1) {
                // Global lock check (Effect freeze) - applies to everything
                if (this.grid.cellLocks && this.grid.cellLocks[spawnIdx] === 1) continue;
                // Check if top is occupied by active content
                if (this.grid.decays[spawnIdx] > 0) {
                    isTopBlocked = true;
                }
            }
            const lastStream = this.lastStreamInColumn[col];
            // Erasers can spawn even if top is blocked (they clear content).
            // Gap check prevents them from spawning on top of themselves.
            if (eraserCount > 0 && this._canSpawnEraser(col, s.minEraserGap, s.minGapTypes)) {
                this._spawnStreamAt(col, true);
                eraserCount--;
                continue; // Spawned eraser, move to next column
            } 
            // Tracers CANNOT spawn if top is blocked (collision).
            else if (!isTopBlocked && streamCount > 0 && this._canSpawnTracer(lastStream, s.minStreamGap, s.minGapTypes)) {
                this._spawnStreamAt(col, false);
                streamCount--;
                continue; // Spawned tracer, move to next column
            }
        }
    }
    _shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    _canSpawnTracer(lastStream, minGap, minGapTypes) {
        // If no last stream, or it's finished, we can spawn
        if (!lastStream || !lastStream.active) return true;
        // If last stream was an Eraser, check the Type Gap
        if (lastStream.isEraser) {
            return lastStream.y > minGapTypes;
        }
        // Otherwise (last was Tracer), respect the standard gap
        return lastStream.y > minGap;
    }
    _canSpawnEraser(col, minGap, minGapTypes) {
        const lastEraser = this.lastEraserInColumn[col];
        if (lastEraser && lastEraser.active && lastEraser.y <= minGap) return false;
        // Also check the absolute last stream (could be a tracer)
        const lastStream = this.lastStreamInColumn[col];
        if (lastStream && lastStream.active && !lastStream.isEraser) {
            if (lastStream.y <= minGapTypes) return false;
        }
        return true;
    }
    _processActiveStreams(frame) {
        for (let i = this.activeStreams.length - 1; i >= 0; i--) {
            const stream = this.activeStreams[i];
            if (!stream.active) {
                this.activeStreams.splice(i, 1);
                continue;
            }
            // Check if stream is currently frozen by an effect
            const headIdx = this.grid.getIndex(stream.x, Math.max(0, stream.y));
            if (headIdx !== -1 && this.grid.cellLocks && this.grid.cellLocks[headIdx] === 1) {
                continue;
            }
            if (stream.delay > 0) {
                stream.delay--;
                continue;
            }
            // Decrement tick timer for movement
            stream.tickTimer--;
            if (stream.tickTimer > 0) {
                continue; // Not time to move yet
            }
            // Reset timer
            stream.tickTimer = stream.tickInterval;
            // Eraser Random Drop-off
            if (stream.isEraser) {
                if (this.config.state.eraserStopChance > 0 && Math.random() < (this.config.state.eraserStopChance / 100)) {
                    stream.active = false;
                    continue;
                }
            } else {                    
                // Tracer Random Drop-Off
                if (this.config.state.tracerStopChance > 0 && Math.random() < (this.config.state.tracerStopChance / 100)) {
                    stream.active = false;
                    continue;
                }
                // Tracer Collision Detection
                // Check the cell we are about to move into (y+1)
                // Actually, we check if the *next* move would hit something.
                // If stream.y is currently at Y, next write is Y+1.
                const nextY = stream.y + 1;
                if (nextY < this.grid.rows) {
                    const nextIdx = this.grid.getIndex(stream.x, nextY);
                    // If next cell is occupied (decay > 0)
                    if (nextIdx !== -1 && this.grid.decays[nextIdx] > 0) {
                        // Collision! Stop stream.
                        // We don't write to nextY, effectively stopping "on top" of the existing block.
                        stream.active = false;
                        continue; 
                    }
                }
            } 
            stream.age++;
            if (stream.age >= stream.visibleLen) {
                this._handleStreamCompletion(stream);
                continue;
            }
            if (stream.y < stream.len) {
                stream.y++;
                this._writeHead(stream, frame);
            }
        }
    }
    _handleStreamCompletion(stream) {
        stream.active = false;
        if (!stream.isEraser) {
            this._spawnStreamAt(stream.x, true);
        }
    }
    _spawnStreamAt(x, forceEraser) {
        const s = this.config.state;
        const stream = this._initializeStream(x, forceEraser, s);
        this.modes[stream.mode].spawn(stream);
        this.activeStreams.push(stream);
        this.lastStreamInColumn[x] = stream;
        if (forceEraser) {
            this.lastEraserInColumn[x] = stream;
        }
    }
    _initializeStream(x, forceEraser, s) {
        // Pick a font for this stream
        const activeFonts = this.config.derived.activeFonts || [{name:'MatrixEmbedded', chars: Utils.CHARS}];
        const fontIdx = Math.floor(Math.random() * activeFonts.length);
        // Calculate individual speed
        // Base speed tick interval: 21 - s.streamSpeed
        // Higher streamSpeed = lower interval = faster
        const baseTick = Math.max(1, 21 - s.streamSpeed);
        let tickInterval = baseTick;
        if (s.desyncIntensity > 0) {
            // Variance: +/- 50% of baseTick * intensity
            // e.g. if tick=5, int=1.0, var= +/- 2.5. Range 2.5 to 7.5.
            const variance = baseTick * s.desyncIntensity * 0.8;
            const offset = (Math.random() * variance * 2) - variance;
            tickInterval = Math.max(1, baseTick + offset);
        }
        const baseStream = {
            x,
            y: -1,
            active: true,
            delay: 0,
            age: 0,
            len: 0,
            holes: new Set(),
            decayY: -1,
            decayStarted: false,
            visibleLen: 0,
            mode: 'STANDARD',
            baseHue: 0,
            isInverted: false,
            isEraser: forceEraser,
            pIdx: Math.floor(Math.random() * (this.config.derived.paletteColorsStr?.length || 1)),
            fontIndex: fontIdx,
            tickInterval: tickInterval, // How many frames per move
            tickTimer: 0 // Counter
        };
        if (forceEraser) {
            return this._initializeEraserStream(baseStream, s);
        } else {
            return this._initializeTracerStream(baseStream, s);
        }
    }
    _initializeEraserStream(stream, s) {
        stream.len = this.grid.rows + 5;
        stream.visibleLen = this.grid.rows + 20; // Default to run full screen length
        return stream;
    }
    _initializeTracerStream(stream, s) {
        // Tracers now run full screen length by default. 
        // "Length" is effectively controlled by Erasers or Drop-Off chance.
        stream.len = this.grid.rows + 10; 
        stream.visibleLen = this.grid.rows * 4; // Default to run full screen length
        stream.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
        for (let i = 0; i < stream.len; i++) {
            if (Math.random() < s.holeRate) stream.holes.add(i);
        }
        stream.holes.delete(0);
        if (s.starPowerEnabled && Math.random() < s.starPowerFreq / 100) {
            stream.mode = 'STAR_POWER';
        } else if (s.rainbowStreamEnabled && Math.random() < s.rainbowStreamChance) {
            stream.mode = 'RAINBOW';
        }
        return stream;
    }
    _writeHead(stream, frame) {
        const idx = this.grid.getIndex(stream.x, stream.y);
        if (idx === -1) return;
        if (stream.isEraser) {
            this._handleEraserHead(idx);
        } else {
            this._handleTracerHead(stream, idx, frame);
        }
    }
    _handleEraserHead(idx) {
        // If already fading, let it continue fading to respect current brightness
        if (this.grid.decays[idx] >= 2) return;
        if (this.grid.decays[idx] > 0 && this.grid.types[idx] !== CELL_TYPE.EMPTY) {
            this.grid.ages[idx] = 0;
            this.grid.decays[idx] = 2;
        } else {
            this._clearCell(idx);
        }
    }
    _handleTracerHead(stream, idx, frame) {
        const shouldWrite = stream.isInverted
            ? stream.holes.has(stream.y)
            : !stream.holes.has(stream.y);
        if (shouldWrite) {
            const { state: s, derived: d } = this.config;
            const cellType = s.rotatorEnabled && Math.random() < s.rotatorChance
                ? CELL_TYPE.ROTATOR
                : CELL_TYPE.TRACER;
            this.grid.types[idx] = cellType;
            this.grid.ages[idx] = 1;
            this.grid.decays[idx] = 1;
            this.grid.rotatorProg[idx] = 0;
            // Set font
            this.grid.setFont(idx, stream.fontIndex);
            if (Math.random() < s.paletteBias) {
                this.grid.paletteIndices[idx] = Math.floor(Math.random() * (d.paletteColorsStr?.length || 1));
            } else {
                this.grid.paletteIndices[idx] = stream.pIdx;
            }
            this.grid.activeIndices.add(idx);
            // Get char from active font set
            const activeFonts = this.config.derived.activeFonts;
            const fontData = activeFonts[stream.fontIndex] || activeFonts[0];
            const charSet = fontData.chars;
            const char = charSet[Math.floor(Math.random() * charSet.length)];
            this.grid.setChar(idx, char);
            if (s.overlapEnabled && Math.random() < s.overlapDensity) {
                // Use same charset for overlap to match font
                this.grid.overlapChars[idx] = charSet[Math.floor(Math.random() * charSet.length)].charCodeAt(0);
            }
            this.grid.brightness[idx] = s.variableBrightnessEnabled
                ? Utils.randomFloat(d.varianceMin, 1.0)
                : 1.0;
            this.grid.alphas[idx] = this.grid.brightness[idx];
            const style = this.modes[stream.mode].style(stream, frame, s);
            if (style) {
                this.grid.complexStyles.set(idx, style);
            } else {
                this.grid.complexStyles.delete(idx);
            }
        } else {
            this._clearCell(idx);
        }
    }
    _clearCell(idx) {
        this.grid.types[idx] = CELL_TYPE.EMPTY;
        this.grid.ages[idx] = 0;
        this.grid.decays[idx] = 0;
        this.grid.alphas[idx] = 0;
        this.grid.overlapChars[idx] = 0;
        this.grid.complexStyles.delete(idx);
        this.grid.nextChars.delete(idx);
        this.grid.activeIndices.delete(idx); // Improves performance
    }
    _updateCells(frame) {
        const { state: s, derived: d } = this.config;
        for (const idx of this.grid.activeIndices) {
            this._updateCell(idx, frame, s, d);
        }
    }
    _updateCell(idx, frame, s, d) {
        // Check if cell is locked by an effect (e.g. Pulse)
        if (this.grid.cellLocks && this.grid.cellLocks[idx] === 1) return;
        const decay = this.grid.decays[idx];
        if (decay === 0) return;
        let age = this.grid.ages[idx];
        if (age > 0) {
            age = this._incrementAge(age, d.maxState);
            this.grid.ages[idx] = age;
        }
        if (s.rotatorEnabled && this.grid.types[idx] === CELL_TYPE.ROTATOR) {
            this._handleRotator(idx, frame, s, d);
        }
        if (decay >= 2) {
            this.grid.decays[idx]++;
            const newDecay = this.grid.decays[idx];
            if (this._shouldDecay(idx, newDecay, s.decayFadeDurationFrames)) {
                this._clearCell(idx);
                return;
            }
            this.grid.alphas[idx] = this._calculateAlpha(idx, age, newDecay, s.decayFadeDurationFrames);
        } else {
            this.grid.alphas[idx] = this._calculateAlpha(idx, age, decay, s.decayFadeDurationFrames);
        }
    }
    _incrementAge(age, maxState) {
        return age < maxState ? age + 1 : 0;
    }
    _handleRotator(idx, frame, s, d) {
        const prog = this.grid.rotatorProg[idx];
        const decay = this.grid.decays[idx];
        if (prog > 0) {
            this._progressRotator(idx, prog, s.rotatorCrossfadeFrames);
        } else if (decay === 1 || (s.rotateDuringFade && decay > 1)) {
            this._cycleRotator(idx, frame, s.rotatorCrossfadeFrames, d.rotatorCycleFrames, s);
        }
    }
    _progressRotator(idx, prog, crossfadeFrames) {
        if (prog >= crossfadeFrames) {
            const nextChar = this.grid.nextChars.get(idx);
            if (nextChar) {
                this.grid.setChar(idx, nextChar);
                if (this.config.state.overlapEnabled) {
                    const nextOverlap = this.grid.nextOverlapChars.get(idx);
                    if (nextOverlap) {
                        this.grid.overlapChars[idx] = nextOverlap;
                        this.grid.noiseDirty = true;
                    }
                }
            }
            this.grid.rotatorProg[idx] = 0;
        } else {
            this.grid.rotatorProg[idx] = prog + 1;
        }
    }
    _cycleRotator(idx, frame, crossfadeFrames, cycleFrames, s) {
        let effectiveCycle = cycleFrames;
        if (s.rotatorDesyncEnabled) {
            // "Different speeds... with variance"
            // Use the pre-calculated random offset (0-255) to vary the cycle duration
            const variancePercent = s.rotatorDesyncVariance / 100; // 0.0 to 1.0
            const maxVariance = cycleFrames * variancePercent;
            // Map 0..255 to -1..1
            const offsetNorm = (this.grid.rotatorOffsets[idx] / 127.5) - 1.0;
            // Apply variance
            effectiveCycle = Math.max(1, Math.round(cycleFrames + (offsetNorm * maxVariance)));
        }
        if (frame % effectiveCycle === 0) {
            // Get correct font charset
            const fontIdx = this.grid.getFont(idx);
            const activeFonts = this.config.derived.activeFonts;
            const fontData = activeFonts[fontIdx] || activeFonts[0];
            const charSet = fontData.chars;
            if (crossfadeFrames <= 2) {
                this.grid.setChar(idx, this._getUniqueChar(this.grid.getChar(idx), charSet));
                if (this.config.state.overlapEnabled) {
                    const currentOverlap = String.fromCharCode(this.grid.overlapChars[idx]);
                    this.grid.overlapChars[idx] = this._getUniqueChar(currentOverlap, charSet).charCodeAt(0);
                }
            } else {
                this.grid.rotatorProg[idx] = 1;
                this.grid.nextChars.set(idx, this._getUniqueChar(this.grid.getChar(idx), charSet));
                if (this.config.state.overlapEnabled) {
                    const currentOverlap = String.fromCharCode(this.grid.overlapChars[idx]);
                    this.grid.nextOverlapChars.set(idx, this._getUniqueChar(currentOverlap, charSet).charCodeAt(0));
                }
            }
        }
    }
    _getUniqueChar(exclude, charSet) {
        if (!charSet) charSet = Utils.CHARS;
        if (charSet.length <= 1) return charSet[0];
        let char;
        let attempts = 0;
        do {
            char = charSet[Math.floor(Math.random() * charSet.length)];
            attempts++;
        } while (char === exclude && attempts < 10);
        return char;
    }
    _shouldDecay(idx, decay, fadeDurationFrames) {
        return decay > fadeDurationFrames + 2;
    }
    _calculateAlpha(idx, age, decay, fadeDurationFrames) {
        if (age > 0) {
            return 1.0;
        } else if (decay === 1) {
            return 0.95 * this.grid.brightness[idx];
        } else if (decay >= 2) {
            const ratio = (decay - 2) / fadeDurationFrames;
            return 0.95 * (1 - ratio) * this.grid.brightness[idx];
        }
        return 0;
    }
}
// --- StreamModes.js ---
class StreamMode {
    constructor(config) {
        this.config = config;
    }
    spawn(stream) {
        // Default implementation for spawning a stream
    }
    style(stream, frame, state) {
        // Default implementation for style (no special effects)
        return null;
    }
}
class StandardMode extends StreamMode {
    // Inherits default behavior with no specific changes
    style(stream, frame, state) {
        return null;
    }
}
class StarPowerMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        const hue = (state.starPowerRainbowMode === 'char')
            ? (frame + (stream.x * 10)) % 360 // Character-based hue
            : stream.baseHue; // Fixed hue based on baseHue
        return this._createStyle(hue, state.starPowerSaturation, state.starPowerIntensity, state.starPowerColorCycle, state.starPowerCycleSpeed, state.starPowerGlitter);
    }
    _createStyle(hue, saturation, lightness, cycle, speed, glitter) {
        return { h: hue, s: saturation, l: lightness, cycle, speed, glitter, isEffect: true };
    }
}
class RainbowMode extends StreamMode {
    spawn(stream) {
        stream.baseHue = Utils.randomInt(0, 360);
    }
    style(stream, frame, state) {
        return this._createStyle(stream.baseHue, 100, state.rainbowStreamIntensity);
    }
    _createStyle(hue, saturation, lightness) {
        return { h: hue, s: saturation, l: lightness, cycle: false, speed: 0, glitter: false, isEffect: true };
    }
}
    // =========================================================================
    // 5.0 SIMULATION SYSTEM 
    // =========================================================================
// --- CharacterSelectorModal.js ---
class CharacterSelectorModal {
    constructor(config, fontManager, notificationMgr) {
        this.config = config;
        this.fonts = fontManager;
        this.notifications = notificationMgr;
        this.dom = null;
        this.currentFont = null;
        // Canvas for glyph detection
        this.scanCanvas = document.createElement('canvas');
        this.scanCanvas.width = 20;
        this.scanCanvas.height = 20;
        this.scanCtx = this.scanCanvas.getContext('2d', { willReadFrequently: true });
    }
    show() {
        if (!this.dom) {
            this._createDOM();
        }
        this._refreshFontList();
        const currentFamily = this.config.get('fontFamily');
        const isKnown = this.fonts.loadedFonts.some(f => f.name === currentFamily) || currentFamily === 'MatrixEmbedded';
        this.currentFont = isKnown ? currentFamily : 'MatrixEmbedded';
        if (this.dom.fontSelect.querySelector(`option[value="${this.currentFont}"]`)) {
            this.dom.fontSelect.value = this.currentFont;
        } else {
             this.currentFont = 'MatrixEmbedded';
             this.dom.fontSelect.value = 'MatrixEmbedded';
        }
        this._loadFontSettings(this.currentFont);
        this.dom.overlay.classList.add('visible');
    }
    hide() {
        if (this.dom) {
            this.dom.overlay.classList.remove('visible');
        }
    }
    _createDOM() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        const content = document.createElement('div');
        content.className = 'modal-content';
        // Header
        const header = document.createElement('div');
        header.className = 'modal-header';
        header.innerHTML = '<h3 class="modal-title">Manage Characters</h3><div class="modal-close">×</div>';
        header.querySelector('.modal-close').onclick = () => this.hide();
        // Body
        const body = document.createElement('div');
        body.className = 'modal-body';
        // 1. Font Selector
        const fontRow = document.createElement('div');
        fontRow.innerHTML = '<label class="modal-label">Select Font to Edit</label>';
        this.fontSelect = document.createElement('select');
        this.fontSelect.onchange = (e) => this._loadFontSettings(e.target.value);
        fontRow.appendChild(this.fontSelect);
        body.appendChild(fontRow);
        // 2. Active Toggle
        const activeRow = document.createElement('div');
        activeRow.className = 'checkbox-row';
        activeRow.innerHTML = '<span>Include in Rain</span><input type="checkbox" id="fontActiveToggle">';
        activeRow.querySelector('input').onchange = (e) => this._updateSetting('active', e.target.checked);
        this.activeToggle = activeRow.querySelector('input');
        body.appendChild(activeRow);
        // 3. Custom Chars Toggle
        const customToggleRow = document.createElement('div');
        customToggleRow.className = 'checkbox-row';
        customToggleRow.innerHTML = '<span>Use Custom Characters</span><input type="checkbox" id="fontCustomToggle">';
        customToggleRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useCustomChars', e.target.checked);
            this._toggleInputs(e.target.checked);
        };
        this.customToggle = customToggleRow.querySelector('input');
        body.appendChild(customToggleRow);
        // 4. Use All Characters Toggle
        const useAllRow = document.createElement('div');
        useAllRow.className = 'checkbox-row';
        useAllRow.innerHTML = '<span>Auto-Detect All Characters</span><input type="checkbox" id="fontUseAllToggle">';
        useAllRow.querySelector('input').onchange = (e) => {
            this._updateSetting('useAllChars', e.target.checked);
            this._handleUseAll(e.target.checked);
        };
        this.useAllToggle = useAllRow.querySelector('input');
        body.appendChild(useAllRow);
        this.scanStatus = document.createElement('div');
        this.scanStatus.className = 'scan-status';
        body.appendChild(this.scanStatus);
        // 5. Visual Picker
        const pickerGroup = document.createElement('div');
        pickerGroup.innerHTML = '<label class="modal-label">Visual Selector</label><div class="modal-desc">Click characters to add/remove them. Empty boxes are unsupported by this font.</div>';
        this.charGrid = document.createElement('div');
        this.charGrid.className = 'char-grid-container';
        pickerGroup.appendChild(this.charGrid);
        body.appendChild(pickerGroup);
        // 6. Manual Input (Fallback)
        const inputGroup = document.createElement('div');
        inputGroup.innerHTML = '<label class="modal-label">Manual Input</label>';
        this.charInput = document.createElement('textarea');
        this.charInput.className = 'char-input';
        this.charInput.placeholder = 'Or paste characters here...';
        this.charInput.oninput = (e) => {
            this._updateSetting('customCharacters', e.target.value);
            this._updateGridSelection();
        };
        inputGroup.appendChild(this.charInput);
        body.appendChild(inputGroup);
        // Footer
        const footer = document.createElement('div');
        footer.className = 'modal-footer';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'action-btn btn-info';
        saveBtn.textContent = 'Done';
        saveBtn.style.width = 'auto';
        saveBtn.onclick = () => this.hide();
        footer.appendChild(saveBtn);
        content.append(header, body, footer);
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        this.dom = { overlay, fontSelect: this.fontSelect };
    }
    _refreshFontList() {
        this.fontSelect.innerHTML = '';
        const fonts = [
            { name: 'MatrixEmbedded', display: 'Matrix Custom Code (Default)' },
            ...this.fonts.loadedFonts.filter(f => !f.isEmbedded)
        ];
        fonts.forEach(f => {
            const opt = document.createElement('option');
            opt.value = f.name;
            opt.textContent = f.display || f.name;
            this.fontSelect.appendChild(opt);
        });
    }
    _loadFontSettings(fontName) {
        this.currentFont = fontName;
        const allSettings = this.config.get('fontSettings') || {};
        if (!allSettings[fontName]) {
             allSettings[fontName] = { active: false, useCustomChars: false, useAllChars: false, customCharacters: "" };
        }
        const settings = allSettings[fontName];
        this.activeToggle.checked = settings.active;
        this.customToggle.checked = settings.useCustomChars;
        this.useAllToggle.checked = settings.useAllChars;
        this.charInput.value = settings.customCharacters || "";
        this._toggleInputs(settings.useCustomChars);
        // If Use All is checked, run the scan logic visually but don't overwrite if not needed
        // Ideally we only run scan if useAllChars is TRUE.
        if (settings.useCustomChars) {
            if (settings.useAllChars) {
                this._handleUseAll(true); // Will re-scan and disable inputs
            } else {
                this._renderGrid(); // Just render grid for manual selection
            }
        }
    }
    _toggleInputs(enabled) {
        const opacity = enabled ? 1 : 0.5;
        this.useAllToggle.disabled = !enabled;
        this.useAllToggle.parentElement.style.opacity = opacity;
        // If "Use All" is checked, specific inputs are disabled regardless of "Use Custom"
        const allChecked = this.useAllToggle.checked;
        const manualEnabled = enabled && !allChecked;
        this.charInput.disabled = !manualEnabled;
        this.charInput.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.opacity = manualEnabled ? 1 : 0.5;
        this.charGrid.style.pointerEvents = manualEnabled ? 'auto' : 'none';
        if (enabled && !allChecked) {
            this._renderGrid();
        }
    }
    async _handleUseAll(checked) {
        if (!checked) {
            this._toggleInputs(true); // Re-enable manual inputs
            this.scanStatus.textContent = '';
            return;
        }
        this.charInput.disabled = true;
        this.charInput.style.opacity = 0.5;
        this.charGrid.style.opacity = 0.5;
        this.charGrid.style.pointerEvents = 'none';
        this.scanStatus.textContent = 'Scanning font for all valid glyphs...';
        // Yield to UI render
        await new Promise(r => setTimeout(r, 50));
        const validChars = this._scanForChars(this.currentFont);
        this.charInput.value = validChars;
        this._updateSetting('customCharacters', validChars);
        this.scanStatus.textContent = `Scan complete. Found ${validChars.length} characters.`;
        this._renderGrid(); // Visual confirmation
    }
    _scanForChars(fontName) {
        const ranges = [
            [33, 126], // Basic Latin
            [161, 255], // Latin-1
            [1024, 1279], // Cyrillic
            [913, 969], // Greek
            [5792, 5887], // Runic
            [12353, 12447], // Hiragana
            [12448, 12543], // Katakana
            [65377, 65439] // Halfwidth Katakana
        ];
        let valid = "";
        // Get "tofu" or empty signature
        const emptySig = this._getCharSignature(fontName, '\uFFFF');
        const spaceSig = this._getCharSignature(fontName, ' ');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(fontName, char);
                // If distinct from empty/tofu, it's valid
                if (sig && sig !== emptySig && sig !== spaceSig) {
                    valid += char;
                }
            }
        }
        return valid;
    }
    _getCharSignature(fontName, char) {
        this.scanCtx.clearRect(0, 0, 20, 20);
        this.scanCtx.font = `16px "${fontName}"`;
        this.scanCtx.textBaseline = 'middle';
        this.scanCtx.textAlign = 'center';
        this.scanCtx.fillStyle = '#fff';
        this.scanCtx.fillText(char, 10, 10);
        // Get pixel data hash-ish
        const data = this.scanCtx.getImageData(5, 5, 10, 10).data; // Sample center 10x10
        let sum = 0;
        for(let i=3; i<data.length; i+=4) { // check alpha only
            sum += data[i];
        }
        return sum; // simple sum signature
    }
    _renderGrid() {
        this.charGrid.innerHTML = '';
        // Define grid ranges (subset of scan ranges for visual sanity)
        const ranges = [
            [33, 126], // ASCII
            [12448, 12543] // Katakana
        ];
        const currentSet = new Set(this.charInput.value.split(''));
        const emptySig = this._getCharSignature(this.currentFont, '\uFFFF');
        for (const [start, end] of ranges) {
            for (let i = start; i <= end; i++) {
                const char = String.fromCharCode(i);
                const sig = this._getCharSignature(this.currentFont, char);
                // If valid glyph
                if (sig && sig !== emptySig) {
                    const el = document.createElement('div');
                    el.className = 'char-grid-item';
                    el.textContent = char;
                    el.style.fontFamily = this.currentFont;
                    if (currentSet.has(char)) el.classList.add('selected');
                    el.onclick = () => {
                        if (this.useAllToggle.checked) return; // Locked
                        this._toggleChar(char);
                        el.classList.toggle('selected');
                    };
                    this.charGrid.appendChild(el);
                }
            }
        }
    }
    _toggleChar(char) {
        let val = this.charInput.value;
        if (val.includes(char)) {
            val = val.replace(char, '');
        } else {
            val += char;
        }
        this.charInput.value = val;
        this._updateSetting('customCharacters', val);
    }
    _updateGridSelection() {
        const currentSet = new Set(this.charInput.value.split(''));
        Array.from(this.charGrid.children).forEach(el => {
            if (currentSet.has(el.textContent)) el.classList.add('selected');
            else el.classList.remove('selected');
        });
    }
    _updateSetting(key, value) {
        if (!this.currentFont) return;
        const allSettings = { ...this.config.get('fontSettings') };
        if (!allSettings[this.currentFont]) {
            allSettings[this.currentFont] = {};
        }
        allSettings[this.currentFont][key] = value;
        this.config.set('fontSettings', allSettings);
    }
}
// --- FontManager.js ---
class FontManager {
    constructor(config, notificationMgr) {
        this.config = config;
        this.notifications = notificationMgr;
        this.dbName = 'MatrixFontDB';
        this.storeName = 'fonts';
        this.db = null;
        this.loadedFonts = [];
        this.subscribers = [];
        this.embeddedFontName = 'MatrixEmbedded';
    }
    /**
     * Initialize the FontManager by injecting the embedded font and loading fonts from the database.
     */
    async init() {
        if (DEFAULT_FONT_DATA && DEFAULT_FONT_DATA.length > 50) {
            await this.injectEmbeddedFont();
        }
        try {
            await this._openDB();
            await this._loadFontsFromDB();
        } catch (error) {
            console.warn('Font DB Error:', error);
        }
    }
    /**
     * Add a subscription callback to be notified on font changes.
     * @param {Function} callback - The callback function to execute on changes.
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }
    /**
     * Ensures that a font has a corresponding entry in the global configuration settings.
     * @param {string} fontName - The name of the font.
     */
    _ensureFontConfig(fontName) {
        const settings = { ...this.config.get('fontSettings') };
        if (!settings[fontName]) {
            // Default settings for new fonts
            settings[fontName] = {
                active: false, 
                useCustomChars: false,
                customCharacters: ""
            };
            this.config.set('fontSettings', settings);
        }
    }
    /**
     * Notify all subscribers about font changes.
     * Executes the callback functions passed via subscribe.
     */
    _notify() {
        this.subscribers.forEach(callback => callback(this.loadedFonts));
    }
    /**
     * Inject the embedded default Matrix font if it hasn't already been loaded.
     */
    async injectEmbeddedFont() {
        const isFontInjected = this.loadedFonts.some(f => f.name === this.embeddedFontName);
        if (isFontInjected) return;
        await this._injectCSS(this.embeddedFontName, DEFAULT_FONT_DATA, "format('woff2')");
        this.loadedFonts.push({
            name: this.embeddedFontName,
            display: 'The Matrix Custom Code',
            isEmbedded: true,
        });
        // Ensure default font is active and configured
        const settings = { ...this.config.get('fontSettings') };
        if (!settings[this.embeddedFontName]) {
            settings[this.embeddedFontName] = {
                active: true,
                useCustomChars: false,
                customCharacters: ""
            };
            this.config.set('fontSettings', settings);
        }
    }
    /**
     * Inject a font into the document as a CSS @font-face rule.
     * @param {string} name - Font's name.
     * @param {string} url - The URL or source of the font data.
     * @param {string} format - The format of the font data (e.g., 'format("woff2")').
     */
    async _injectCSS(name, url, format) {
        const existingStyle = document.getElementById(`style-${name}`);
        if (existingStyle) existingStyle.remove();
        const style = document.createElement('style');
        style.id = `style-${name}`;
        style.textContent = `
            @font-face {
                font-family: '${name}';
                src: url('${url}') ${format};
            }
        `;
        document.head.appendChild(style);
        // Wait for the font to be loaded
        try {
            await document.fonts.load(`1em '${name}'`);
            return true; // Font loaded successfully
        } catch (e) {
            console.error(`Failed to load font ${name}:`, e);
            return false; // Font failed to load
        }
    }
    /**
     * Open or create the IndexedDB for storing font data.
     * @returns {Promise} Resolves when the database connection is successful.
     */
    async _openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'name' });
                }
            };
            request.onsuccess = event => {
                this.db = event.target.result;
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }
    /**
     * Load all fonts stored in the database into the application.
     * @returns {Promise} Resolves once fonts are loaded.
     */
    async _loadFontsFromDB() {
        return new Promise(resolve => {
            if (!this.db) return resolve();
            const transaction = this.db.transaction(this.storeName, 'readonly');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.getAll().onsuccess = async event => { // <-- Make this async
                const storedFonts = event.target.result;
                // Reset the font list, keeping only the embedded font.
                this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
                // Use Promise.all to await all font injections from DB
                await Promise.all(storedFonts.map(async font => {
                    this.loadedFonts.push(font);
                    this._ensureFontConfig(font.name); // Ensure config exists
                    const type = font.mimeType || font.data.type;
                    const format = this._getFormatFromType(type);
                    await this._injectCSS(font.name, URL.createObjectURL(font.data), format);
                }));
                this._notify();
                resolve();
            };
        });
    }
    /**
     * Determine the CSS format string for a given MIME type.
     * @param {string} mimeType - The MIME type of the font file.
     * @returns {string} The corresponding format string for @font-face.
     */
    _getFormatFromType(mimeType) {
        if (mimeType.includes('woff2')) return "format('woff2')";
        if (mimeType.includes('woff')) return "format('woff')";
        if (mimeType.includes('opentype') || mimeType.includes('otf')) return "format('opentype')";
        return "format('truetype')";
    }
    /**
     * Import a custom font into the database and inject it as a CSS @font-face.
     * @param {File} file - The font file to import.
     */
    importFont(file) {
        const reader = new FileReader();
        reader.onload = async event => {
            const arrayBuffer = event.target.result;
            const blob = new Blob([arrayBuffer], { type: file.type });
            let fontName;
            try {
                const hash = await Utils.computeSHA256(arrayBuffer);
                fontName = `CustomFont_${hash.substring(0, 16)}`;
            } catch (e) {
                console.warn("Hashing failed, falling back to timestamp", e);
                fontName = `CustomFont_${Date.now()}`;
            }
            const record = {
                name: fontName,
                display: file.name,
                data: blob,
                mimeType: file.type,
            };
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.put(record).onsuccess = () => {
                const format = this._getFormatFromType(file.type);
                this._injectCSS(fontName, URL.createObjectURL(blob), format);
                this.loadedFonts.push(record);
                // Ensure config and activate the new font
                this._ensureFontConfig(fontName);
                // Optionally auto-activate imported font?
                // const settings = { ...this.config.get('fontSettings') };
                // settings[fontName].active = true;
                // this.config.set('fontSettings', settings);
                this.config.set('fontFamily', fontName);
                this._notify();
                this.notifications.show(`Imported: ${file.name}`, 'success');
            };
            transaction.onerror = () => {
                this.notifications.show('Database Write Failed', 'error');
            };
        };
        reader.readAsArrayBuffer(file);
    }
    /**
     * Delete a font by its ID from the database and the DOM.
     * @param {string} id - The ID of the font to delete.
     * @returns {Promise} Resolves once the font is deleted.
     */
    deleteFont(id) {
        return new Promise(resolve => {
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.delete(id).onsuccess = () => {
                document.getElementById(`style-${id}`)?.remove();
                this.loadedFonts = this.loadedFonts.filter(font => font.name !== id);
                // Deactivate in config to prevent rendering issues
                const settings = { ...this.config.get('fontSettings') };
                if (settings[id]) {
                    settings[id].active = false;
                    this.config.set('fontSettings', settings);
                }
                if (this.config.state.fontFamily === id) {
                    this.config.set('fontFamily', this.config.defaults.fontFamily);
                }
                this._notify();
                resolve();
            };
        });
    }
    /**
     * Clear all fonts from the database and only keep embedded fonts.
     * @returns {Promise} Resolves once all fonts are deleted.
     */
    deleteAllFonts() {
        return new Promise(resolve => {
            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const objectStore = transaction.objectStore(this.storeName);
            objectStore.clear().onsuccess = () => {
                // Remove all non-embedded fonts.
                this.loadedFonts
                    .filter(font => !font.isEmbedded)
                    .forEach(font => document.getElementById(`style-${font.name}`)?.remove());
                // Keep only embedded fonts.
                this.loadedFonts = this.loadedFonts.filter(font => font.isEmbedded);
                this._notify();
                resolve();
            };
        });
    }
}
    // =========================================================================
    // 9.0 UI MANAGER
    // =========================================================================
// --- NotificationManager.js ---
class NotificationManager {
    constructor(config) {
        this.config = config;
        this.container = document.getElementById('toast-container') || this._createContainer();
    }
    /**
     * Creates and initializes the toast container if it doesn't exist.
     * @returns {HTMLElement} The toast container DOM element.
     */
    _createContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.setAttribute('aria-live', 'polite'); // Accessibility: Announce updates to screen readers.
        container.setAttribute('role', 'status'); // Accessibility: Define the type of content the container holds.
        document.body.appendChild(container);
        return container;
    }
    /**
     * Displays a notification with the specified message and type.
     * @param {string} message - The message to display in the notification.
     * @param {string} [type='info'] - The type of the notification ('info', 'success', 'error', etc.).
     * @param {number} [duration=3000] - The duration (in milliseconds) for the notification to be visible.
     */
    show(message, type = 'info', duration = 3000) {
        if (this.config && this.config.state && this.config.state.suppressToasts) return;
        // Create the notification element.
        const toast = this._createToast(message, type);
        // Ensure the container is attached.
        if (!document.body.contains(this.container)) {
            document.body.appendChild(this.container);
        }
        // Add the notification to the container and apply the "visible" class for animation.
        this.container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        // Set timers for hiding and removing the notification.
        this._scheduleToastRemoval(toast, duration);
    }
    /**
     * Creates an individual toast element.
     * @private
     * @param {string} message - The message to display.
     * @param {string} type - The type of the notification.
     * @returns {HTMLElement} The toast DOM element.
     */
    _createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast-msg toast-${type}`;
        toast.textContent = message;
        toast.setAttribute('role', 'alert'); // Accessibility: Specify that this is an alert message.
        return toast;
    }
    /**
     * Schedules the removal of the notification after the specified duration.
     * Handles smooth animation states before removing the DOM element.
     * @private
     * @param {HTMLElement} toast - The toast element to remove.
     * @param {number} duration - How long the toast remains visible.
     */
    _scheduleToastRemoval(toast, duration) {
        setTimeout(() => {
            // Trigger fade-out animation by removing the "visible" class.
            toast.classList.remove('visible');
            // Remove the toast element from the DOM after the animation completes.
            setTimeout(() => toast.remove(), 300); // Matches CSS animation transition time.
        }, duration);
    }
}
    // =========================================================================
    // 2.0 CONFIGURATION MANAGER 
    // =========================================================================
// --- UIManager.js ---
class UIManager {
    constructor(c, effects, fonts, notificationMgr, charSelector) {
        // Core dependencies and state
        this.c = c;
        this.effects = effects; // Renamed from this.eff for clarity, consistency
        this.fonts = fonts;
        this.notifications = notificationMgr;
        this.charSelector = charSelector;
        this.dom = this._initializeDOM();
        this.scrollState = { isDown: false, startX: 0, scrollLeft: 0, dragDistance: 0 };
        this.ignoreNextClick = false; // Retain existing logic for drag/click distinction
        this.isKeyBindingActive = false; // Flag to suspend global key inputs
        this.defs = this._generateDefinitions();
        // Event subscriptions
        this.c.subscribe((key, state) => this.refresh(key));
        this.fonts.subscribe(() => this.refresh('fontFamily'));
        // Initialization
        this.init();
    }
    /**
     * Establish initial DOM structure using expected selectors and IDs.
     * @private
     */
    _initializeDOM() {
        return {
            panel: document.getElementById('settingsPanel'),
            toggle: document.getElementById('menuToggle'),
            tabs: document.getElementById('navTabs'),
            content: document.getElementById('contentArea'),
            tooltip: document.getElementById('ui-tooltip') || this._createTooltip(),
            keyTrap: document.getElementById('ui-key-trap') || this._createKeyTrap(),
            track: null, // Initialized later in init
        };
    }
    /**
     * Create invisible input trap for key binding.
     * @private
     */
    _createKeyTrap() {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'ui-key-trap';
        // Ensure element is rendered but invisible/unobtrusive
        input.style.position = 'fixed';
        input.style.top = '0';
        input.style.left = '0';
        input.style.width = '1px';
        input.style.height = '1px';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        input.style.zIndex = '-1';
        input.setAttribute('aria-hidden', 'true');
        document.body.appendChild(input);
        return input;
    }
    /**
     * Create the tooltip element and attach to the DOM.
     * @private
     */
    _createTooltip() {
        const tooltip = document.createElement('div');
        tooltip.id = 'ui-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
    }
    /**
     * Generate all UI component definitions for settings dynamically.
     * This method orchestrates the gathering of definitions from category-specific methods.
     * @private
     */
    _generateDefinitions() {
        return [
            { cat: 'Global', type: 'accordion_header', label: 'Code Basics' },
            { cat: 'Global', id: 'streamPalette', type: 'color_list', label: 'Code Colors', max: 3 },
            { cat: 'Global', id: 'paletteBias', type: 'range', label: 'Color Mix', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'% Mix', description: "Left: Solid Streams. Right: Random Characters. Middle: Blend." },
            ...this._generateGlobalSettings(),
            // APPEARANCE TAB
            ...this._generateAppearanceSettings(),
            // BEHAVIOR TAB
            ...this._generateBehaviorSettings(),
            // FX TAB
            ...this._generateFXSettings(),
            // SYSTEM TAB
            ...this._generateSystemTab()
        ];
    }
    /**
     * Generates definitions for the 'Global' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateGlobalSettings() {
        return [
            { cat: 'Global', id: 'tracerColor', type: 'color', label: 'Tracer Color', description: "The head of the stream that writes the code to the screen" },
            { cat: 'Global', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, step: 1, unit: 'px' },
            { cat: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20, step: 1 },
            { cat: 'Global', id: 'showFpsCounter', type: 'checkbox', label: 'Show FPS Counter', description: "Displays the current frames-per-second in the top-left corner." },
            { cat: 'Global', type: 'accordion_header', label: 'Rendering Quality' },
            { cat: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
            { cat: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing', dep: '!shaderEnabled', description: 'Anti-aliasing is automatically disabled when a custom shader is in use.' },
            { cat: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: ['smoothingEnabled', '!shaderEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'Appearance' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateAppearanceSettings() {
        return [
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Customization' },
            { cat: 'Appearance', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this._getFonts() },
            { cat: 'Appearance', type: 'font_list' },
            { cat: 'Appearance', type: 'button', label: 'Manage Character Sets', action: 'manageCharacters', class: 'btn-info' },
            { cat: 'Appearance', type: 'button', label: 'Import Font File (.ttf/.otf)', action: 'importFont', class: 'btn-info' },
            { cat: 'Appearance', id: 'fontWeight', type: 'select', label: 'Weight', options: [{label:'Thin',value:'100'},{label:'Light',value:'300'},{label:'Normal',value:'normal'},{label:'Bold',value:'bold'},{label:'Heavy',value:'900'}] , description: "If font supported; Bold should work but light/thin may not, depending on the font."},
            { cat: 'Appearance', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
            { cat: 'Appearance', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Character Effects' }, // Main Accordion Header
            { cat: 'Appearance', type: 'accordion_subheader', label: 'General' },
            { cat: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'Allows for brightness variance when characters are written' },
            { cat: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Stream Trails' },
            { cat: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 180, unit:'fr' },
            { cat: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolving Stream Trails' }, 
            { cat: 'Appearance', id: 'dissolveMinSize', type: 'range', label: 'Dissolve Size', min: 1, max: 20, unit:'px', dep: 'dissolveEnabled', description: 'Higher numbers on smaller fonts will expand the trail instead of dissolve' },
            { cat: 'Appearance', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Trail Ghosting' },
            { cat: 'Appearance', id: 'deteriorationStrength', type: 'range', label: 'Ghosting Offset', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled' },
            { cat: 'Appearance', type: 'accordion_subheader', label: 'Character Overlap' },
            { cat: 'Appearance', id: 'overlapEnabled', type: 'checkbox', label: 'Enable Overlap' },
            { cat: 'Appearance', id: 'overlapColor', type: 'color', label: 'Overlap Color', dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapDensity', type: 'range', label: 'Overlap Density', min: 0.1, max: 1.0, step: 0.1, dep: 'overlapEnabled' },
            { cat: 'Appearance', id: 'overlapTarget', type: 'select', label: 'Overlap Target', options: [{label:'Streams Only',value:'stream'},{label:'All Characters',value:'all'}], dep: 'overlapEnabled' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Glow Effects' },
            { cat: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
            { cat: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
            { cat: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
            { cat: 'Appearance', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
            { cat: 'Appearance', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.05, max: 1.0, step: 0.05, invert: true, description: 'Adjusts the phosphor persistence effect. Higher values leave longer, smeary trails behind moving characters.' },
            { cat: 'Appearance', type: 'accordion_header', label: 'Grid Layout' },
            { cat: 'Appearance', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
            { cat: 'Appearance', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -20, max: 20, unit: 'px' },
            { cat: 'Appearance', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
            { cat: 'Appearance', id: 'stretchY', type: 'range', label: 'View Window Stretch Y', min: 0.5, max: 3.0, step: 0.1 },
        ];
    }
    /**
     * Generates definitions for the 'Behavior' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateBehaviorSettings() {
        return [
            { cat: 'Behavior', type: 'accordion_header', label: 'Streams' },
            { cat: 'Behavior', id: 'releaseInterval', type: 'range', label: 'Event Timer', description: "For synchronized events (like tracer release) this is the interval between events.", min: 1, max: 10, step: 1 },
            { cat: 'Behavior', id: 'desyncIntensity', type: 'range', label: 'Tracer Desync', min: 0, max: 1, step: 0.05, transform: v=>(v*100).toFixed(0)+'%', description: "Varies the speed and release timing of tracers. 0% is uniform sync." },
            { cat: 'Behavior', id: 'minStreamGap', type: 'range', label: 'Min Gap Between Streams', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minEraserGap', type: 'range', label: 'Min Gap Between Erasers', min: 2, max: 50, unit: 'px' },
            { cat: 'Behavior', id: 'minGapTypes', type: 'range', label: 'Min Gap Between Types', min: 1, max: 100, unit: 'px', description: "Minimum space between tracer types, preventing short streams" },
            { cat: 'Behavior', id: 'holeRate', type: 'range', label: 'Gaps in Code Stream', min: 0, max: 0.5, step: 0.01, transform: v=>(v*100).toFixed(0)+'%', description: 'Probability of missing data segments (empty spaces) appearing within a code stream.' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Tracers' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Tracers'},
            { cat: 'Behavior', id: 'streamSpawnCount', type: 'range', label: 'Tracer Release Count', min: 1, max: 20, step: 1, description: "Maximum number of tracers released per-cycle" },
            { cat: 'Behavior', id: 'tracerStopChance', type: 'range', label: 'Tracer Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for a tracer to randomly stop, leaving a hanging stream.'},
            { cat: 'Behavior', id: 'tracerAttackFrames', type: 'range', label: 'Fade In', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerHoldFrames', type: 'range', label: 'Hold', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out', min: 0, max: 20, unit: 'fr' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Erasers'},
            { cat: 'Behavior', id: 'eraserSpawnCount', type: 'range', label: 'Eraser Release Count', min: 0, max: 20, step: 1, description: "Invisible tracers that start erasing code" },
            { cat: 'Behavior', id: 'eraserStopChance', type: 'range', label: 'Eraser Drop-out', min: 0, max: 10, step: 1, transform: v=>v+'%', description: 'Chance for an eraser to randomly stop, leaving a hanging stream.' },
            { cat: 'Behavior', type: 'accordion_subheader', label: 'Inverted Tracers'},
            { cat: 'Behavior', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: "Tracers that only write occassional characters" },
            { cat: 'Behavior', id: 'invertedTracerChance', type: 'range', label: 'Inverted Frequency', min: 0.01, max: 0.20, step: 0.01, dep: 'invertedTracerEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Behavior', type: 'accordion_header', label: 'Rotators' },
            { cat: 'Behavior', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
            { cat: 'Behavior', id: 'rotatorChance', type: 'range', label: 'Rotator Chance', min: 0, max: 1.0, step: 0.01, dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: "Lock the rotator change to the cycles that move the tracers" },
            { cat: 'Behavior', id: 'rotatorSyncMultiplier', type: 'range', label: 'Sync Divider', min: 0.1, max: 1, step: 0.1, dep: ['rotatorEnabled','rotatorSyncToTracer'], transform: v => v + 'x' },
            { cat: 'Behavior', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer'] },
            { cat: 'Behavior', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotateDuringFade', type: 'checkbox', label: 'Rotate during fade', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncEnabled', type: 'checkbox', label: 'Desynchronize Rotators', dep: 'rotatorEnabled' },
            { cat: 'Behavior', id: 'rotatorDesyncVariance', type: 'range', label: 'Desync Variance', min: 0, max: 100, unit: '%', dep: ['rotatorEnabled', 'rotatorDesyncEnabled'] },
        ];
    }
    /**
     * Generates definitions for the 'FX' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateFXSettings() {
        return [
            { cat: 'Effects', type: 'header', label: 'Movie Effects' }, // Using header for main section
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Now', action: 'pulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
            { cat: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseDelaySeconds', type: 'range', label: 'Delay', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'pulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Preserve Tracer Glow', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseDimming', type: 'range', label: 'Initial Dim Amount', min: 0.0, max: 1.0, step: 0.05, dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'pulseEnabled', description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: 'pulseEnabled' },
            { cat: 'Effects', id: 'pulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'pulseEnabled', description: "Start at a full square" },
            { cat: 'Effects', id: 'pulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: 'pulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Clear Pulse' },
            { cat: 'Effects', type: 'button', label: 'Trigger Clear Pulse Now', action: 'clearpulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'clearPulseEnabled', type: 'checkbox', label: 'Enable Clear Pulse' },
            { cat: 'Effects', id: 'clearPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'clearPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseBlend', type: 'checkbox', label: 'Color Blend', dep: 'clearPulseEnabled', description: "Blend the outer edge (tracer color) to inner edge (code color)" },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseRandomPosition', type: 'checkbox', label: 'Random Start Location', dep: 'clearPulseEnabled' },
            { cat: 'Effects', id: 'clearPulseInstantStart', type: 'checkbox', label: 'Instant Start', dep: 'clearPulseEnabled', description: "Start at a full square" },
            { cat: 'Effects', id: 'clearPulseCircular', type: 'checkbox', label: 'Circular Pulse', dep: 'clearPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Pulse Storm' },
            { cat: 'Effects', type: 'button', label: 'Trigger Pulse Storm Now', action: 'minipulse', class: 'btn-warn' },
            { cat: 'Effects', id: 'miniPulseEnabled', type: 'checkbox', label: 'Enable Storms' },
            { cat: 'Effects', id: 'miniPulseFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, unit: 's', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseThickness', type: 'range', label: 'Wave Width', min: 10, max: 100, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpawnChance', type: 'range', label: 'Density', min: 0.01, max: 0.5, step: 0.01, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSpeed', type: 'range', label: 'Speed', min: 5, max: 50, dep: 'miniPulseEnabled' },
            { cat: 'Effects', id: 'miniPulseSize', type: 'range', label: 'Blast Size Max', min: 50, max: 400, unit: 'px', dep: 'miniPulseEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Deja Vu' },
            { cat: 'Effects', type: 'button', label: 'Trigger Deja Vu Now', action: 'dejavu', class: 'btn-warn' },
            { cat: 'Effects', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
            { cat: 'Effects', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuDurationSeconds', type: 'range', label: 'Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMinRectHeight', type: 'range', label: 'Minimum Thickness', min: 2, max: 5, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Maximum Thickness', min: 6, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuHoleBrightness', type: 'range', label: 'Intensity', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Enable Color Writing', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuIntensity', type: 'range', label: 'Flash Frequency', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Flash Length', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Length Variance', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Superman' },
            { cat: 'Effects', type: 'button', label: 'Trigger Superman', action: 'superman', class: 'btn-warn' },
            { cat: 'Effects', id: 'supermanEnabled', type: 'checkbox', label: 'Enable Superman Effects' },
            { cat: 'Effects', id: 'supermanFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanDurationSeconds', type: 'range', label: 'Duration', min: 0.5, max: 6.0, step: 0.1, unit: 's', dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanIncludeColors', type: 'checkbox', label: 'Additional Glow', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFadeSpeed', type: 'range', label: 'Fade Duration', min: 5, max: 60, dep: 'supermanEnabled', description: 'Higher values mean trails last longer.' },
            { cat: 'Effects', id: 'supermanGlow', type: 'range', label: 'Voltage Glow', min: 1, max: 10, dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanBoltThickness', type: 'range', label: 'Bolt Thickness', min: 1, max: 10, step: 1, dep: 'supermanEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'supermanEnabled' },
            { cat: 'Effects', id: 'supermanFlickerRate', type: 'range', label: 'Flicker Jitter', min: 1, max: 10, unit: 'fr', dep: 'supermanEnabled', description: 'Lower is faster electricity.' },
            { cat: 'Effects', id: 'supermanWidth', type: 'range', label: 'Scatter Height', min: 1, max: 10, dep: 'supermanEnabled', description: 'How vertically erratic the lightning path is.' },
            { cat: 'Effects', id: 'supermanSpawnSpeed', type: 'range', label: 'Bolt Speed', min: 10, max: 100, dep: 'supermanEnabled', description: 'Speed from left to right' },
            { cat: 'Effects', type: 'accordion_header', label: 'Boot/Crash' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Boot Sequence' },
            { cat: 'Effects', id: 'bootSequenceEnabled', type: 'checkbox', label: 'Start Code with Boot' },
            { cat: 'Effects', type: 'button', label: 'Trigger Boot Now', action: 'boot', class: 'btn-warn' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Crash Sequence' },
            { cat: 'Effects', id: 'crashEnabled', type: 'checkbox', label: 'Enable Crash', warning: "Photosensitivity Warning: Enabling this effect will cause pulsing lights and strobing effects that could be disruptive to those more sensitive to flashing lights. Please be aware of the impact this may have to those around you." },
            { cat: 'Effects', id: 'crashFrequencySeconds', type: 'range', label: 'Frequency', min: 60, max: 600, step: 10, unit: 's', dep: 'crashEnabled' },
            { cat: 'Effects', type: 'button', label: 'Trigger Crash Now', action: 'crash', class: 'btn-danger' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Macros' },
            { cat: 'Effects', id: 'runBothInOrder', type: 'checkbox', label: 'Run Both in Order', description: 'Automatically triggers the Crash sequence after the Boot sequence completes.' },
            { cat: 'Effects', type: 'button', label: 'Trigger Sequence Now', action: 'boot_crash_sequence', class: 'btn-warn' },
            { cat: 'Effects', type: 'header', label: 'Special Effects' }, // Header for Special Effects
            { cat: 'Effects', type: 'accordion_header', label: 'Star Power' },
            { cat: 'Effects', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power' },
            { cat: 'Effects', id: 'starPowerFreq', type: 'range', label: 'Frequency', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerRainbowMode', type: 'select', label: 'Color Mode', options: [{label:'Full Stream',value:'stream'}, {label:'Per Char',value:'char'}], dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerGlitter', type: 'checkbox', label: 'Glitter', dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Feel', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
            { cat: 'Effects', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams' },
            { cat: 'Effects', id: 'rainbowStreamChance', type: 'range', label: 'Frequency', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
            { cat: 'Effects', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },
            { cat: 'Effects', type: 'accordion_header', label: 'Firewall Anomaly' }, 
            { cat: 'Effects', type: 'button', label: 'Trigger Firewall Now', action: 'firewall', class: 'btn-info' },
            { cat: 'Effects', id: 'firewallEnabled', type: 'checkbox', label: 'Enable Firewall Effects' },
            { cat: 'Effects', id: 'firewallFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 300, step: 10, unit: 's', dep: 'firewallEnabled' },
            { cat: 'Effects', type: 'accordion_subheader', label: 'Look', dep: 'firewallEnabled' },
            { cat: 'Effects', id: 'firewallRandomColorEnabled', type: 'checkbox', label: 'Random Color', dep: 'firewallEnabled' },
            { cat: 'Effects', id: 'firewallColor', type: 'color', label: 'Firewall Color', dep: ['firewallEnabled', '!firewallRandomColorEnabled'] },
            { cat: 'Effects', id: 'firewallReverseDurationFrames', type: 'range', label: 'Reverse Duration', min: 5, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the code reverses before erasure.' },
            { cat: 'Effects', id: 'firewallEraseDurationFrames', type: 'range', label: 'Erase Flash Duration', min: 10, max: 100, unit: 'fr', dep: 'firewallEnabled', description: 'Frames the column flashes white/red before clearing.' },
            { cat: 'Effects', type: 'header', label: 'Post Processing' },
            { cat: 'Effects', type: 'accordion_header', label: 'Shader' },
            { cat: 'Effects', type: 'info_description', id: 'currentShaderNameDisplay', text: 'Loaded: No shader.' },
            { cat: 'Effects', id: 'shaderEnabled', type: 'checkbox', label: 'Enable Custom Shader' },
            { cat: 'Effects', id: 'shaderParameter', type: 'range', label: 'Shader Parameter', min: 0.0, max: 1.0, step: 0.01, dep: 'shaderEnabled', description: "A generic 0.0-1.0 value passed to the shader as 'uParameter'." },
            { cat: 'Effects', type: 'button', label: 'Import Fragment Shader (.glsl)', action: 'importShader', class: 'btn-info', dep: 'shaderEnabled' },
            { cat: 'Effects', type: 'info_description', text: 'Uniforms provided: uTexture (sampler2D), uTime (float), uResolution (vec2), uMouse (vec2), uParameter (float). Output to gl_FragColor.', dep: 'shaderEnabled' },
        ];
    }
    /**
     * Generates definitions for the 'System' settings category.
     * @private
     * @returns {Array<Object>} An array of UI control definition objects.
     */
    _generateSystemTab() {
        return [
            { cat: 'System', type: 'accordion_header', label: 'Configuration' },
            { cat: 'System', type: 'slot', idx: 0 },
            { cat: 'System', type: 'slot', idx: 1 },
            { cat: 'System', type: 'slot', idx: 2 },
            { cat: 'System', type: 'button', label: 'Export Config (JSON)', action: 'export', class: 'btn-info' },
            { cat: 'System', type: 'button', label: 'Import Config (JSON)', action: 'import', class: 'btn-info' },
            { cat: 'System', id: 'hideMenuIcon', type: 'checkbox', label: 'Hide Settings Icon', description: 'Hover your mouse over the top right or press the Toggle UI Panel keybind to show' },
            { cat: 'System', id: 'suppressToasts', type: 'checkbox', label: 'Suppress Toast Messages', description: 'Disable pop-up notifications at the bottom of the screen.' },
            { cat: 'System', type: 'accordion_header', label: 'Key Bindings' },
            { cat: 'System', type: 'info_description', text: 'Click a button to assign a new key. Press Backspace or Delete to clear.' },
            { cat: 'System', type: 'keybinder', id: 'BootSequence', label: 'Boot Animation' },
            { cat: 'System', type: 'keybinder', id: 'CrashSequence', label: 'Crash Animation' },
            { cat: 'System', type: 'keybinder', id: 'BootCrashSequence', label: 'Boot to Crash' },
            { cat: 'System', type: 'keybinder', id: 'Pulse', label: 'Pulse' },
            { cat: 'System', type: 'keybinder', id: 'ClearPulse', label: 'Clear Pulse' },
            { cat: 'System', type: 'keybinder', id: 'MiniPulse', label: 'Pulse Storm' },
            { cat: 'System', type: 'keybinder', id: 'DejaVu', label: 'Deja Vu' },
            { cat: 'System', type: 'keybinder', id: 'Superman', label: 'Superman' },
            { cat: 'System', type: 'keybinder', id: 'Firewall', label: 'Firewall' },
            { cat: 'System', type: 'keybinder', id: 'ToggleUI', label: 'Toggle UI Panel' },
            { cat: 'System', type: 'accordion_header', label: 'System Reset' },
            { cat: 'System', type: 'info_description', text: 'Clears the current font cache, and resets all font entries to default' },
            { cat: 'System', type: 'button', label: 'Clear Font Cache', action: 'clearCache', class: 'btn-warn' },
            // CAUTION separator - will be handled in renderControl
            { cat: 'System', type: 'header', label: 'CAUTION ZONE' }, // Use header for visual separation and text
            { cat: 'System', type: 'button', label: 'Factory Reset All', action: 'reset', class: 'btn-danger', caution: true },
            { cat: 'System', type: 'accordion_header', label: 'About' },
            { cat: 'System', type: 'about_content' },
            { cat: 'System', type: 'accordion_subheader', label: 'Frequently Asked Questions' },
            { cat: 'System', type: 'faq_item', question: 'What is this?', answer: 'This is a highly customizable Matrix Digital Rain simulation built with HTML5 Canvas and JavaScript.' },
            { cat: 'System', type: 'faq_item', question: 'How do I change the code?', answer: 'Use the settings panel on the right side of the screen to customize various aspects like colors, speeds, and effects.' },
            { cat: 'System', type: 'faq_item', question: 'Can I use my own font?', answer: 'Yes, go to the "Appearance" tab, under "Character Customization" you can import your own TTF or OTF font file.' },
            { cat: 'System', type: 'faq_item', question: 'Why is it sometimes slow?', answer: 'Performance depends on your device and settings. Try reducing "Resolution Scale" or disabling some effects under the "Effects" tab.' },
            { cat: 'System', type: 'faq_item', question: 'Is this more AI slop?', answer: 'Yes and no. LLM\'s were definitely used to make this, but the person who programmed it is a real person, and much of the code was hand-written, not just \'vibe coded\'. It\'s not perfect, but it\'s being slowly improved.' },
            { cat: 'System', type: 'faq_item', question: 'How do I leave feedback or suggestions on your app?', answer: 'Feel free to reach out via github! I\'m definitely open to ideas and suggestions.' }
        ];
    }
    /**
     * Initialize the events, tabs, and UI components.
     */
    init() {
        // Toggle button for the settings panel
        this.dom.toggle.onclick = () => this.togglePanel();
        // Create and populate tabs and content containers
        this._setupTabs();
        // Update footer version
        document.getElementById('globalStatus').textContent = `Matrix Code v${APP_VERSION}`;
        // Initialize File Input Handlers
        this._setupFileHandlers();
        // Handle tab dragging and horizontal scrolling
        this._setupTabScroll();
        // Refresh UI
        this.refresh('ALL');
    }
    /**
     * Toggles the settings panel visibility.
     */
    togglePanel() {
        const isOpen = this.dom.panel.classList.toggle('open');
        this.dom.panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
        this.dom.toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
    /**
     * Sets up the tabs and their corresponding content containers.
     * Creates category tabs and assigns content containers to each.
     * @private
     */
    _setupTabs() {
        this.dom.track = document.createElement('div'); // Initialize track here
        this.dom.track.id = 'tabTrack';
        this.dom.tabs.appendChild(this.dom.track);
        const categories = [...new Set(this.defs.map(def => def.cat))];
        const tabContentContainers = {}; // Mapping of category -> content container div
        // Create tabs and attach event handlers
        categories.forEach((category, index) => {
            const tabButton = this._createTabButton(category, index === 0);
            this.dom.track.appendChild(tabButton);
            // Create corresponding content container for the tab
            const contentContainer = this._createTabContentContainer(category, index === 0);
            this.dom.content.appendChild(contentContainer);
            tabContentContainers[category] = contentContainer;
        });
        // Populate tab content
        this._populateTabContent(tabContentContainers);
    }
    /**
     * Creates a tab button element for a category.
     * @private
     * @param {string} category - The category name for the tab.
     * @param {boolean} isActive - Whether the tab should be active by default.
     * @returns {HTMLElement} The created tab button element.
     */
    _createTabButton(category, isActive) {
        const button = document.createElement('button');
        button.className = `tab-btn ${isActive ? 'active' : ''}`;
        button.textContent = category;
        button.onclick = () => this._handleTabClick(category, button);
        return button;
    }
    /**
     * Handles when a tab is clicked and activates the corresponding tab content.
     * @private
     * @param {string} category - The category associated with the clicked tab.
     * @param {HTMLElement} button - The clicked tab button element.
     */
    _handleTabClick(category, button) {
        // Use this.scrollState.dragDistance for distinguishing drag from click
        if (this.scrollState.dragDistance > 3) {
            this.scrollState.dragDistance = 0; // Reset for next interaction
            return; 
        }
        // Deactivate all tabs and their content
        this.dom.tabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.dom.content.querySelectorAll('.tab-content-group').forEach(content => content.classList.remove('active'));
        // Activate selected tab and content
        button.classList.add('active');
        document.getElementById(`tab-content-${category}`).classList.add('active');
    }
    /**
     * Creates a tab content container for a given category.
     * @private
     * @param {string} category - The category name for the content container.
     * @param {boolean} isActive - Whether the content container should be active by default.
     * @returns {HTMLElement} The created tab content container element.
     */
    _createTabContentContainer(category, isActive) {
        const container = document.createElement('div');
        container.className = `tab-content-group ${isActive ? 'active' : ''}`;
        container.id = `tab-content-${category}`;
        return container;
    }
    /**
     * Populates tabs with content, including accordions and controls.
     * @private
     * @param {Object} tabContentContainers - A map of category names to their content container elements.
     */
    _populateTabContent(tabContentContainers) {
        let currentAccordionBody = null;
        let lastCat = null;
        this.defs.forEach(def => {
            const container = tabContentContainers[def.cat];
            if (!container) return;
            // Reset accordion context when switching tabs/categories
            if (def.cat !== lastCat) {
                currentAccordionBody = null;
                lastCat = def.cat;
            }
            // Handle Accordion Headers (Start new accordion)
            if (def.type === 'accordion_header') {
                currentAccordionBody = this._createAccordion(container, def.label);
                return;
            } 
            // Handle Accordion Subheaders
            else if (def.type === 'accordion_subheader') {
                if (currentAccordionBody) {
                    const el = this.renderControl(def);
                    if (el) currentAccordionBody.appendChild(el);
                }
                return;
            }
            // Handle Section Headers (Break out of accordion)
            // Exception: CAUTION ZONE remains inside for special handling below
            if (def.type === 'header' && def.label !== 'CAUTION ZONE') {
                currentAccordionBody = null;
                const el = this.renderControl(def);
                if (el) container.appendChild(el);
                return;
            }
            // Handle Controls
            if (currentAccordionBody) {
                // Special handling for CAUTION ZONE inside an accordion
                if (def.cat === 'System' && def.label === 'CAUTION ZONE' && def.type === 'header') {
                    const cautionZoneDiv = document.createElement('div');
                    cautionZoneDiv.className = 'caution-zone';
                    const headerEl = this.renderControl(def);
                    cautionZoneDiv.appendChild(headerEl);
                    currentAccordionBody.appendChild(cautionZoneDiv);
                } else {
                    if (def.caution) return; // Skip caution items here, handled separately
                    const controlElement = this.renderControl(def);
                    if (controlElement) currentAccordionBody.appendChild(controlElement);
                }
            } else {
                // Orphan controls (outside any accordion) - e.g. top level buttons or headers
                const controlElement = this.renderControl(def);
                if (controlElement) container.appendChild(controlElement);
            }
        });
        // Post-process: Insert Factory Reset into the created Caution Zone
        const factoryResetDef = this.defs.find(d => d.action === 'reset' && d.caution);
        if (factoryResetDef) {
            const cautionZoneDiv = this.dom.content.querySelector('.caution-zone');
            if (cautionZoneDiv) {
                const controlElement = this.renderControl(factoryResetDef);
                if (controlElement) cautionZoneDiv.appendChild(controlElement);
            }
        }
    }
    /**
     * Creates an accordion section with a header and a container for controls.
     * @private
     * @param {HTMLElement} tabContentGroup - The parent container for the accordion.
     * @param {string} label - The label for the accordion header.
     * @returns {HTMLElement} The body element of the created accordion where controls can be appended.
     */
    _createAccordion(tabContentGroup, label) {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.innerHTML = `
            ${label}
            <span class="accordion-icon">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </span>
        `;
        const body = document.createElement('div');
        body.className = 'accordion-content';
        header.onclick = () => this._toggleAccordion(header, body, tabContentGroup);
        accordionItem.appendChild(header);
        accordionItem.appendChild(body);
        tabContentGroup.appendChild(accordionItem);
        // Default open logic: REMOVED per user request
        // const accordionsInTab = Array.from(tabContentGroup.children).filter(child => child.classList.contains('accordion-item'));
        // if (accordionsInTab.length === 1) { 
        //     body.classList.add('open');
        //     header.classList.add('active');
        //     header.querySelector('.accordion-icon').classList.add('rotated');
        // }
        return body;
    }
    /**
     * Toggles the visibility of an accordion section and manages sibling accordions.
     * @private
     * @param {HTMLElement} header - The header element of the accordion.
     * @param {HTMLElement} body - The body element of the accordion.
     * @param {HTMLElement} group - The parent group containing all accordions (tabContentGroup).
     */
    _toggleAccordion(header, body, group) {
        const isOpen = body.classList.contains('open');
        // Close other accordions in the group
        group.querySelectorAll('.accordion-content').forEach(siblingBody => {
            siblingBody.classList.remove('open');
            siblingBody.previousElementSibling?.classList.remove('active');
            siblingBody.previousElementSibling?.querySelector('.accordion-icon')?.classList.remove('rotated');
        });
        // Toggle the current accordion
        if (isOpen) {
            body.classList.remove('open');
            header.classList.remove('active');
            header.querySelector('.accordion-icon')?.classList.remove('rotated');
        } else {
            body.classList.add('open');
            header.classList.add('active');
            header.querySelector('.accordion-icon')?.classList.add('rotated');
        }
    }
    /**
     * Setup input handlers for font and config import.
     * @private
     */
    _setupFileHandlers() {
        document.getElementById('importFile').onchange = e => this._handleConfigImport(e);
        document.getElementById('importFontFile').onchange = e => this._handleFontImport(e);
        // Add shader input
        const shaderInput = document.createElement('input');
        shaderInput.type = 'file';
        shaderInput.id = 'importShaderFile';
        shaderInput.accept = '.glsl,.frag,.txt';
        shaderInput.style.display = 'none';
        document.body.appendChild(shaderInput);
        shaderInput.onchange = e => this._handleShaderImport(e);
    }
    /**
     * Handles the import of a shader file.
     * @private
     */
    _handleShaderImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const source = ev.target.result;
            this.c.set('customShader', source);
            this.notifications.show('Shader Imported', 'success');
            event.target.value = '';
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a JSON configuration file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleConfigImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                // Merge loaded config with defaults to ensure all properties exist
                this.c.state = { ...this.c.defaults, ...data.state };
                // Handle Saved Presets
                if (data.savedPresets) {
                    this.c.slots = data.savedPresets;
                    this.c.saveSlots();
                }
                this.c.updateDerivedValues();
                this.c.save();
                this.c.notify('ALL');
                this.notifications.show('Configuration Loaded', 'success');
            } catch (error) {
                console.error("Error loading config:", error);
                this.notifications.show('Invalid Configuration File', 'error');
            }
            event.target.value = ''; // Reset input value to allow re-importing the same file
        };
        reader.readAsText(file);
    }
    /**
     * Handles the import of a custom font file.
     * @private
     * @param {Event} event - The change event from the file input.
     */
    _handleFontImport(event) {
        const file = event.target.files[0];
        if (file) this.fonts.importFont(file);
        event.target.value = ''; // Reset input value
    }
    /**
     * Set up drag and scroll functionality for tabs.
     * @private
     */
    _setupTabScroll() {
        const tabs = this.dom.tabs;
        tabs.addEventListener('mousedown', e => this._startDrag(e));
        tabs.addEventListener('mouseleave', () => this._stopDrag());
        tabs.addEventListener('mouseup', () => this._stopDrag());
        tabs.addEventListener('mousemove', e => this._doDrag(e));
        // Ensure overflow handling matches standard behavior for wheel support
        tabs.style.overflowX = 'auto'; 
        tabs.style.overscrollBehaviorX = 'contain';
        // Converts vertical mouse wheel scrolling into horizontal scrolling for the tabs
        tabs.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaX) >= Math.abs(e.deltaY)) {
                return;
            }
            if (e.deltaY !== 0) {
                // preventDefault stops the browser "back" gesture or vertical page scroll
                e.preventDefault(); 
                tabs.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }
    /**
     * Initiates the drag operation for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse down event.
     */
    _startDrag(e) {
        if (e.button !== 0) return; // Only respond to primary click (left mouse button)
        this.scrollState.isDown = true;
        this.scrollState.startX = e.pageX - this.dom.tabs.offsetLeft;
        this.scrollState.scrollLeft = this.dom.tabs.scrollLeft;
        this.scrollState.dragDistance = 0;
        this.ignoreNextClick = false; // Reset flag
        this.dom.tabs.style.cursor = 'grabbing';
    }
    /**
     * Stops the drag operation for tab scrolling.
     * @private
     */
    _stopDrag() {
        this.scrollState.isDown = false;
        this.dom.tabs.style.cursor = 'grab';
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Handles the drag movement for tab scrolling.
     * @private
     * @param {MouseEvent} e - The mouse move event.
     */
    _doDrag(e) {
        if (!this.scrollState.isDown) return;
        e.preventDefault(); // Prevent text highlighting during drag
        const x = e.pageX - this.dom.tabs.offsetLeft;
        const walk = (x - this.scrollState.startX) * 1.5; // Multiplier for faster scrolling
        this.dom.tabs.scrollLeft = this.scrollState.scrollLeft - walk;
        this.scrollState.dragDistance = Math.abs(x - this.scrollState.startX); // Update based on actual movement
        if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true; // Set flag if dragged enough to be considered a drag
    }
    /**
     * Retrieves the list of available fonts, including embedded and custom fonts.
     * @private
     * @returns {Array<Object>} An array of font objects suitable for select options.
     */
    _getFonts() {
        return [
            {label:'Gothic (Win)', value:'"MS Gothic", monospace'},
            {label:'Console', value:'Consolas, monaco, monospace'},
            ...this.fonts.loadedFonts.map(f => ({label:f.display, value:f.name, custom:true}))
        ];
    }
    /**
     * Updates the UI list of custom fonts (used in the font manager section).
     * @param {HTMLElement} el - The DOM element to populate with the font list.
     */
    updateFontList(el) {
        el.innerHTML = '';
        this.fonts.loadedFonts.filter(f => !f.isEmbedded).forEach(f => {
            const div = document.createElement('div');
            div.className = 'font-item';
            div.innerHTML = `<span class="font-name">${f.display}</span>`;
            const btn = document.createElement('div');
            btn.className = 'font-delete-btn';
            btn.innerHTML = '×';
            btn.onclick = () => { if(confirm('Delete font?')) this.fonts.deleteFont(f.name); };
            div.appendChild(btn);
            el.appendChild(div);
        });
    }
    /**
     * Displays a tooltip with a given text near a target element.
     * @param {string} text - The text to display in the tooltip.
     * @param {HTMLElement} target - The element relative to which the tooltip should be positioned.
     */
    showTooltip(text, target) {
        this.dom.tooltip.textContent = text;
        this.dom.tooltip.classList.add('visible');
        const rect = target.getBoundingClientRect();
        const tipRect = this.dom.tooltip.getBoundingClientRect();
        let top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        let left = rect.left - tipRect.width - 12; // Default to left of target
        // Adjust position if it goes off-screen
        if (top < 10) top = 10;
        if (left < 10) left = rect.right + 12; // Move to right if it's too far left
        this.dom.tooltip.style.top = `${top}px`;
        this.dom.tooltip.style.left = `${left}px`;
    }
    /**
     * Hides the currently displayed tooltip.
     */
    hideTooltip() {
        this.dom.tooltip.classList.remove('visible');
        // Reset dragDistance here to avoid blocking a subsequent immediate click after a very short drag
        this.scrollState.dragDistance = 0; 
    }
    /**
     * Updates the text/state of a specific keybinder button.
     * @param {string} id - The ID of the keybinding action (e.g., 'Pulse').
     */
    updateKeyBinderVisuals(id) {
        const btn = document.getElementById(`btn-key-${id}`);
        if (!btn) return;
        const def = this.defs.find(d => d.id === id);
        if (!def) return;
        const bindings = this.c.get('keyBindings') || {};
        const rawKey = bindings[id] || 'None';
        const displayKey = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
        btn.textContent = `${def.label}: [ ${displayKey} ]`;
        btn.className = 'action-btn btn-info'; // Reset class
    }
    /**
     * Creates a styled label group for a UI control, optionally including an info icon with a tooltip.
     * @param {Object} def - The definition object for the UI control.
     * @returns {HTMLElement} The created label group DOM element.
     */
    createLabelGroup(def) {
        const group = document.createElement('div');
        group.className = 'control-label-group';
        const text = document.createElement('span');
        text.textContent = def.label;
        group.appendChild(text);
        if (def.description) {
            const icon = document.createElement('span');
            icon.className = 'info-icon';
            icon.textContent = '?';
            const show = (e) => this.showTooltip(def.description, e.target);
            icon.onmouseenter = show;
            icon.onmouseleave = () => this.hideTooltip();
            // Handle touch events for mobile tooltips
            icon.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                if (this.dom.tooltip.classList.contains('visible')) { 
                    this.hideTooltip(); 
                } else { 
                    show(e); 
                    // Automatically hide tooltip after a short delay on touch devices
                    setTimeout(() => this.hideTooltip(), 3000); 
                } 
            });
            group.appendChild(icon);
        }
        return group;
    }
    /**
     * Renders the content of a color list control into the provided wrapper.
     * @private
     * @param {HTMLElement} wrapper - The container element.
     * @param {Object} def - The control definition.
     */
    _renderColorList(wrapper, def) {
        wrapper.innerHTML = '';
        const palette = this.c.get(def.id) || ["#00FF00"];
        palette.forEach((color, idx) => {
            const item = document.createElement('div');
            item.className = 'color-list-item';
            const cInput = document.createElement('input');
            cInput.type = 'color';
            cInput.value = color;
            // Optimisation: Update state directly on input to allow dragging without re-render
            cInput.oninput = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.state[def.id] = newP; // Direct state mutation
                this.c.updateDerivedValues(); // Force derived update for live preview
            };
            // Commit change on release
            cInput.onchange = e => {
                const newP = [...this.c.get(def.id)];
                newP[idx] = e.target.value;
                this.c.set(def.id, newP); // Triggers save and refresh
            };
            item.appendChild(cInput);
            if (palette.length > 1 && idx > 0) {
                const delBtn = document.createElement('div');
                delBtn.className = 'btn-icon-remove';
                delBtn.textContent = '×';
                delBtn.onclick = () => {
                    const newP = this.c.get(def.id).filter((_, i) => i !== idx);
                    this.c.set(def.id, newP);
                    this._renderColorList(wrapper, def);
                    this.refresh('streamPalette');
                };
                item.appendChild(delBtn);
            }
            wrapper.appendChild(item);
        });
        if (palette.length < (def.max || 3)) {
            const addBtn = document.createElement('div');
            addBtn.className = 'btn-icon-add';
            addBtn.textContent = '+';
            addBtn.onclick = () => {
                const newP = [...this.c.get(def.id), "#ffffff"];
                this.c.set(def.id, newP);
                this._renderColorList(wrapper, def);
                this.refresh('streamPalette');
            };
            wrapper.appendChild(addBtn);
        }
    }
    /**
     * Dynamically renders a UI control element based on its definition.
     * @param {Object} def - The definition object for the control.
     * @returns {HTMLElement|null} The created control element, or null if it's an accordion header.
     */
    renderControl(def) {
        if (def.type === 'accordion_header') { return null; }
        if (def.type === 'accordion_subheader') {
            const el = document.createElement('div');
            el.className = 'accordion-subheader';
            el.textContent = def.label;
            if(def.dep) el.setAttribute('data-dep', JSON.stringify(def.dep));
            return el;
        }
        if (def.type === 'header') {
            const el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; return el;
        }
        if (def.type === 'about_content') {
            const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
            const logoChar = Utils.getRandomKatakanaChar();
            const initialColor = this.c.get('streamColor');
            const initialSvgDataUrl = Utils.generateGlyphSVG(logoChar, initialColor, 48, this.c.get('fontFamily'));
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <img id="matrixLogo" src="${initialSvgDataUrl}" alt="Matrix Logo" style="height: 48px; width: 48px; margin-right: 10px;"/>
                    <h3 style="margin:0; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                </div>
                <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
            return div;
        }
        if (def.type === 'info_description') {
            const div = document.createElement('div');
            div.className = 'info-description';
            div.textContent = def.text;
            if (def.id) div.id = `in-${def.id}`;
            return div;
        }
        if (def.type === 'faq_item') {
            const container = document.createElement('div');
            container.className = 'faq-item';
            const question = document.createElement('div');
            question.className = 'faq-question';
            question.textContent = def.question;
            const answer = document.createElement('div');
            answer.className = 'faq-answer';
            answer.textContent = def.answer;
            container.appendChild(question);
            container.appendChild(answer);
            return container;
        }
        const row = document.createElement('div');
        if (def.type === 'button') {
            const btn = document.createElement('button'); btn.className = `action-btn ${def.class||'btn-info'}`; btn.textContent = def.label; btn.id = `btn-${def.action}`; btn.name = def.action; btn.onclick = () => this.handleAction(def.action); row.appendChild(btn);
        } else if (def.type === 'slot') {
            row.className = 'slot-container';
            const inp = document.createElement('input'); inp.className = 'slot-name-input'; inp.value = this.c.slots[def.idx].name; inp.id = `slot-input-${def.idx}`; inp.name = `slot_name_${def.idx}`; inp.onchange = e => this.c.renameSlot(def.idx, e.target.value);
            inp.onfocus = e => e.target.value = '';
            const grp = document.createElement('div'); grp.className = 'slot-btn-group';
            const save = document.createElement('button'); save.className = 'btn-icon'; save.textContent = 'SAVE'; save.id = `btn-save-${def.idx}`; save.onclick = () => { this.c.saveToSlot(def.idx); this.notifications.show(`Saved Slot ${def.idx+1}`, 'success'); };
            const load = document.createElement('button'); load.className = 'btn-icon'; load.textContent = 'LOAD'; load.id = `btn-load-${def.idx}`; load.onclick = () => { if(this.c.loadFromSlot(def.idx)) this.notifications.show(`Loaded Slot ${def.idx+1}`, 'success'); };
            grp.append(save, load); row.append(inp, grp);
        } else if (def.type === 'font_list') {
            row.className = 'font-manager-list'; row.id = 'fontListUI'; this.updateFontList(row);
        } else {
            row.className = def.type === 'checkbox' ? 'checkbox-row' : 'control-row';
            const labelGroup = this.createLabelGroup(def);
            if(def.type !== 'checkbox') { const hdr = document.createElement('div'); hdr.className = 'control-header'; hdr.appendChild(labelGroup); 
            if(!def.hideValue && def.type === 'range') { const valDisp = document.createElement('span'); valDisp.id = `val-${def.id}`; hdr.appendChild(valDisp); } row.appendChild(hdr); } 
                else { row.appendChild(labelGroup); }
            let inp;
            if(def.type === 'range') { 
                inp = document.createElement('input'); 
                inp.type = 'range'; 
                inp.min=def.min; 
                inp.max=def.max; 
                if(def.step) inp.step=def.step; 
                let isTouching = false;
                inp.value = def.invert ? (def.max+def.min)-this.c.get(def.id) : this.c.get(def.id);                            
                inp.oninput = e => { 
                    if (isTouching) return; // Block native updates during touch interaction
                    const v = parseFloat(e.target.value); 
                    let actual = def.invert ? (def.max+def.min)-v : v; 
                    // Dynamic precision based on step
                    const step = def.step || 1;
                    const decimals = (step.toString().split('.')[1] || '').length;
                    if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                    this.c.set(def.id, actual); 
                    const disp = document.getElementById(`val-${def.id}`); 
                    if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                }; 
                let startX = 0;
                let startY = 0;
                let startValue = 0;
                let isHorizontalDrag = false;
                inp.addEventListener('touchstart', e => {
                    isTouching = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(e.target.value);
                    isHorizontalDrag = false;
                    // Prevent "jump to tap" visually
                    requestAnimationFrame(() => {
                        inp.value = startValue;
                    });
                }, { passive: false });
                inp.addEventListener('touchmove', e => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    const dx = x - startX;
                    const dy = y - startY;
                    if (!isHorizontalDrag && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 5) {
                        isHorizontalDrag = true;
                    }
                    if (isHorizontalDrag) {
                        e.preventDefault(); 
                        const rect = inp.getBoundingClientRect();
                        const relativeX = Math.min(Math.max(0, x - rect.left), rect.width);
                        const percent = relativeX / rect.width;
                        const min = parseFloat(def.min);
                        const max = parseFloat(def.max);
                        let newVal = min + (percent * (max - min));
                        // Dynamic precision based on step
                        const step = parseFloat(def.step || 1);
                        newVal = Math.round(newVal / step) * step;
                        if (newVal < min) newVal = min;
                        if (newVal > max) newVal = max;
                        inp.value = newVal;
                        let actual = def.invert ? (max+min)-newVal : newVal; 
                        const decimals = (step.toString().split('.')[1] || '').length;
                        if (typeof actual === 'number') actual = parseFloat(actual.toFixed(decimals));
                        this.c.set(def.id, actual); 
                        const disp = document.getElementById(`val-${def.id}`); 
                        if(disp) disp.textContent = def.transform ? def.transform(actual) : actual + (def.unit || '');
                    }
                }, { passive: false });
                inp.addEventListener('touchend', () => {
                    isTouching = false;
                    isHorizontalDrag = false;
                });
            }
            else if(def.type === 'color') { 
                const w = document.createElement('div'); 
                w.className = 'color-wrapper'; 
                inp = document.createElement('input'); 
                inp.type = 'color'; 
                inp.value = this.c.get(def.id); 
                inp.id = `in-${def.id}`; 
                inp.name = def.id; 
                inp.oninput = e => { 
                    this.c.state[def.id] = e.target.value; 
                    this.c.updateDerivedValues(); // Force derived update for live preview
                }; 
                inp.onchange = e => { this.c.set(def.id, e.target.value); }; // Commit and refresh
                w.appendChild(inp); row.appendChild(w); 
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`; 
                return row; 
            }
            else if(def.type === 'color_list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'color-list-wrapper';
                wrapper.id = `in-${def.id}`;
                this._renderColorList(wrapper, def);
                row.appendChild(wrapper);
                if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); 
                if(def.id) row.id = `row-${def.id}`;
                return row;
            }
            else if(def.type === 'keybinder') {
                const btn = document.createElement('button');
                // Initial text setup
                const rawKey = (this.c.get('keyBindings') || {})[def.id] || 'None';
                const initialDisplay = rawKey === ' ' ? 'SPACE' : rawKey.toUpperCase();
                btn.className = 'action-btn btn-info';
                btn.id = `btn-key-${def.id}`;
                btn.textContent = `${def.label}: [ ${initialDisplay} ]`;
                btn.onclick = () => {
                    this.isKeyBindingActive = true; 
                    btn.textContent = `${def.label}: [ Press Key... ]`;
                    btn.classList.remove('btn-info');
                    btn.classList.add('btn-warn');
                    // Focus trap to isolate input from global listeners
                    this.dom.keyTrap.focus();
                    const handler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        let newKey = e.key;
                        // Handle special keys
                        if (newKey === 'Backspace' || newKey === 'Delete') {
                            newKey = null;
                        } else if (newKey.length === 1) {
                            newKey = newKey.toLowerCase();
                        }
                        // Save config
                        try {
                            const bindings = { ...this.c.get('keyBindings') };
                            if (newKey) {
                                bindings[def.id] = newKey;
                            } else {
                                delete bindings[def.id];
                            }
                            this.c.set('keyBindings', bindings); // Triggers refresh() -> updateKeyBinderVisuals()
                        } catch (err) {
                            console.error("Failed to save keybinding:", err);
                            btn.textContent = "Error Saving";
                        }
                        // Cleanup
                        this.dom.keyTrap.blur();
                        this.isKeyBindingActive = false;
                        // Force immediate visual update just in case refresh is delayed
                        this.updateKeyBinderVisuals(def.id);
                    };
                    this.dom.keyTrap.addEventListener('keydown', handler, { once: true });
                };
                row.appendChild(btn);
                return row;
            }
            else if(def.type === 'checkbox') { 
                inp = document.createElement('input'); 
                inp.type = 'checkbox'; 
                inp.checked = this.c.get(def.id); 
                inp.onchange = e => { 
                    if(e.target.checked && def.warning) alert(def.warning);
                    this.c.set(def.id, e.target.checked); 
                }; 
                row.onclick = e => { if(e.target !== inp) { inp.checked = !inp.checked; inp.dispatchEvent(new Event('change')); }}; 
            }
            else if(def.type === 'select') { inp = document.createElement('select'); (typeof def.options === 'function' ? def.options() : def.options).forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; if(o.custom) opt.className = 'custom-font-opt'; if(this.c.get(def.id) === o.value) opt.selected = true; inp.appendChild(opt); }); inp.onchange = e => this.c.set(def.id, e.target.value); }
            row.appendChild(inp);
            if(def.id) { inp.id = `in-${def.id}`; inp.name = def.id; }
            if(def.dep) row.setAttribute('data-dep', JSON.stringify(def.dep)); if(def.id) row.id = `row-${def.id}`;
        }
        return row;
    }
    /**
     * Handles UI actions triggered by buttons or other interactive elements.
     * @param {string} action - The action identifier.
     */
    handleAction(action) {
        if(action === 'reset' && confirm('Reset all settings?')) this.c.reset();
        if(action === 'clearCache' && confirm('Clear all custom fonts?')) this.fonts.deleteAllFonts().then(() => this.notifications.show('Cache Cleared', 'success'));
        if(action === 'export') Utils.downloadJson({version:APP_VERSION, state:this.c.state, savedPresets:this.c.slots}, `matrix_conf_v${APP_VERSION}.json`);
        if(action === 'import') document.getElementById('importFile').click();
        if(action === 'importFont') document.getElementById('importFontFile').click();
        if(action === 'importShader') document.getElementById('importShaderFile').click();
        if(action === 'manageCharacters') this.charSelector.show();
        if(action === 'boot') { if(this.effects.trigger('BootSequence')) this.notifications.show('Boot Sequence Initiated', 'success'); else this.notifications.show('Boot Sequence Active...', 'info'); }
        if(action === 'crash') { if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger'); else this.notifications.show('Crash Sequence Active...', 'info'); }
        if(action === 'boot_crash_sequence') {
            if(this.effects.trigger('BootSequence')) {
                this.notifications.show('Boot Sequence Initiated', 'success');
                setTimeout(() => {
                    if(this.effects.trigger('CrashSequence')) this.notifications.show('System Crash Initiated', 'danger');
                }, 4000);
            } else {
                this.notifications.show('Sequence Active...', 'info');
            }
        }
        if(action === 'pulse') { if(this.effects.trigger('Pulse')) this.notifications.show('Pulse Triggered', 'success'); else this.notifications.show('Pulse already active...', 'info'); }
        if(action === 'clearpulse') { if(this.effects.trigger('ClearPulse')) this.notifications.show('Clear Pulse Triggered', 'success'); else this.notifications.show('Clear Pulse active...', 'info'); }
        if(action === 'minipulse') { if(this.effects.trigger('MiniPulse')) this.notifications.show('Pulse Storm Triggered', 'success'); else this.notifications.show('Pulse Storm active...', 'info'); }
        if(action === 'dejavu') { if(this.effects.trigger('DejaVu')) this.notifications.show('Deja Vu Triggered', 'success'); else this.notifications.show('Deja Vu already active...', 'info'); }
        if(action === 'superman') { if(this.effects.trigger('Superman')) this.notifications.show('Neo is flying...', 'success'); else this.notifications.show('Superman active...', 'info'); }
        if(action === 'firewall') { if(this.effects.trigger('Firewall')) this.notifications.show('Firewall Breach Detected', 'danger'); else this.notifications.show('Firewall active...', 'info'); 
        }
    }
    /**
     * Refreshes the UI to reflect current configuration settings.
     * @param {string} key - The specific configuration key to refresh, or 'ALL' to refresh all controls.
     */
    refresh(key) {
        try {
            if(key === 'ALL') { 
                this.defs.forEach(d => { if(d.id) this.refresh(d.id); }); 
                this.refresh('fontFamily'); // Special refresh for font list
                this.dom.content.querySelectorAll('.accordion-content').forEach(accordionBody => {
                    const allDepRows = accordionBody.querySelectorAll('[data-dep]');
                    allDepRows.forEach(row => {
                        try {
                            const depRule = JSON.parse(row.getAttribute('data-dep')); 
                            const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                            let conditionsMet = true;
                            for (let rule of rules) { 
                                let target = rule; 
                                let expected = true; 
                                if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                                const actual = !!this.c.get(target); 
                                if (actual !== expected) { conditionsMet = false; break; } 
                            }
                            if(conditionsMet) row.classList.remove('control-disabled'); 
                            else row.classList.add('control-disabled');
                        } catch(e) { console.warn("Error processing dependency row:", e); }
                    });
                });
                return; 
            }
            if (key === 'keyBindings') {
                this.defs.filter(d => d.type === 'keybinder').forEach(d => this.refresh(d.id));
                return;
            }
            if(key === 'fontFamily') {
                const sel = document.getElementById('in-fontFamily');
                if(sel) { 
                    sel.innerHTML = ''; 
                    this._getFonts().forEach(o => { 
                        const opt = document.createElement('option'); 
                        opt.value = o.value; 
                        opt.textContent = o.label; 
                        if(o.custom) opt.className = 'custom-font-opt'; 
                        if(this.c.get('fontFamily') === o.value) opt.selected = true; 
                        sel.appendChild(opt); 
                    }); 
                }
                const list = document.getElementById('fontListUI'); 
                                if (list) this.updateFontList(list); 
                                // Update logo when font family changes, re-randomize char
                                const logo = document.getElementById('matrixLogo');
                                if (logo) {
                                    const randomChar = Utils.getRandomKatakanaChar();
                                    const currentColor = this.c.get('streamColor');
                                    logo.src = Utils.generateGlyphSVG(randomChar, currentColor, 48, this.c.get('fontFamily'));
                                }
                                const favicon = document.getElementById('favicon');
                                if (favicon) {
                                    const randomChar = Utils.getRandomKatakanaChar();
                                    const currentColor = this.c.get('streamColor');
                                    favicon.href = Utils.generateGlyphSVG(randomChar, currentColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                                }
                                return;
                            }
            if (key === 'streamColor') {
                const logo = document.getElementById('matrixLogo');
                if (logo) {
                    const randomChar = Utils.getRandomKatakanaChar(); // Re-randomize char on color change too
                    const currentColor = this.c.get('streamColor');
                    logo.src = Utils.generateGlyphSVG(randomChar, currentColor, 48, this.c.get('fontFamily'));
                }
                const favicon = document.getElementById('favicon');
                if (favicon) {
                    const randomChar = Utils.getRandomKatakanaChar();
                    const currentColor = this.c.get('streamColor');
                    favicon.href = Utils.generateGlyphSVG(randomChar, currentColor, 32, this.c.get('fontFamily')); // Use a smaller size for favicon
                }
            }
            if (key === 'customShader' || key === 'shaderEnabled' || key === 'ALL') {
                const shaderNameDisplay = document.getElementById('in-currentShaderNameDisplay');
                if (shaderNameDisplay) {
                    let name = 'No shader loaded.';
                    const customShaderSource = this.c.get('customShader');
                    const shaderEnabled = this.c.get('shaderEnabled');
                    if (shaderEnabled && customShaderSource) {
                        // 1. Try to find a name metadata tag in the first 500 chars
                        // Matches "// Name: My Shader" or "// Shader: My Shader" case-insensitive
                        const nameMatch = customShaderSource.substring(0, 500).match(/^\s*\/\/\s*(?:Name|Shader|Title):\s*(.+)$/im);
                        if (nameMatch && nameMatch[1]) {
                            name = nameMatch[1].trim();
                        } 
                        // 2. Fallback: Check if it's standard code
                        else if (customShaderSource.trim().startsWith('precision')) {
                            name = 'Custom Shader (No Name)';
                        }
                        // 3. Fallback: If it doesn't look like code (maybe it really is a path?)
                        else if (customShaderSource.length < 200 && (customShaderSource.includes('/') || customShaderSource.includes('\\'))) {
                             const parts = customShaderSource.split(/[\/\\]/);
                             name = parts[parts.length - 1];
                        }
                        else {
                             name = 'Custom Shader';
                        }
                    } else if (shaderEnabled) {
                         name = 'Unnamed/Default Shader'; 
                    }
                    shaderNameDisplay.textContent = `Loaded: ${name}`;
                }
            }
            if (key === 'streamPalette') {
                 const palette = this.c.get('streamPalette');
                 const biasRow = document.getElementById('row-paletteBias');
                 if (biasRow) {
                     if (palette && palette.length > 1) {
                         biasRow.classList.remove('control-disabled');
                     } else {
                         biasRow.classList.add('control-disabled');
                     }
                 }
                 // Re-render the list itself if needed? 
                 // Actually the _renderColorList calls refresh implicitly by updating DOM? 
                 // No, _renderColorList updates DOM directly. 
                 // But we need to update the Bias slider state.
            }
            if (key === 'hideMenuIcon' || key === 'ALL') {
                const shouldHide = this.c.get('hideMenuIcon');
                const toggleBtn = this.dom.toggle;
                // Clear any existing listeners/timeouts
                if (this._menuIconTimeout) clearTimeout(this._menuIconTimeout);
                if (this._menuMouseMoveHandler) {
                    document.removeEventListener('mousemove', this._menuMouseMoveHandler);
                    this._menuMouseMoveHandler = null;
                }
                if (shouldHide) {
                    toggleBtn.style.transition = 'opacity 0.5s ease-in-out, transform 0.3s ease';
                    const showIcon = () => {
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.pointerEvents = 'auto';
                        clearTimeout(this._menuIconTimeout);
                        // Hide again after 1s of no activity near it? 
                        // Or just 1s after showing? The prompt says "hide itself after one second".
                        this._menuIconTimeout = setTimeout(() => {
                            // Only hide if panel is CLOSED
                            if (!this.dom.panel.classList.contains('open')) {
                                toggleBtn.style.opacity = '0';
                                toggleBtn.style.pointerEvents = 'none';
                            }
                        }, 1000);
                    };
                    // Initial hide after delay
                    showIcon(); 
                    // Hot-zone detection
                    this._menuMouseMoveHandler = (e) => {
                        // Top right corner hot-zone (100x100px)
                        const isHotZone = (e.clientX > window.innerWidth - 100) && (e.clientY < 100);
                        if (isHotZone || this.dom.panel.classList.contains('open')) {
                            showIcon();
                        }
                    };
                    document.addEventListener('mousemove', this._menuMouseMoveHandler);
                } else {
                    // Reset to always visible
                    toggleBtn.style.opacity = '1';
                    toggleBtn.style.pointerEvents = 'auto';
                }
            }
            if(key) {
                // Keybinder Refresh Logic
                if (document.getElementById(`btn-key-${key}`)) {
                    this.updateKeyBinderVisuals(key);
                }
                const inp = document.getElementById(`in-${key}`);
                if(inp) { 
                    const def = this.defs.find(d=>d.id===key); 
                    if(def) { 
                        const val = this.c.get(key); 
                        if(def.type === 'checkbox') inp.checked = val; 
                        else if(def.type === 'color_list') this._renderColorList(inp, def);
                        else if(def.type === 'range') { 
                            inp.value = def.invert ? (def.max+def.min)-val : val; 
                            const disp = document.getElementById(`val-${key}`); 
                            if(disp) {
                                let displayVal = val;
                                if (!def.transform && typeof val === 'number') {
                                    const step = def.step || 1;
                                    const decimals = (step.toString().split('.')[1] || '').length;
                                    displayVal = parseFloat(val.toFixed(decimals));
                                }
                                disp.textContent = def.transform ? def.transform(val) : displayVal + (def.unit || ''); 
                            }
                        } else {
                            inp.value = val;
                        }
                    } 
                }
            }
            // Update dependents
            this.dom.content.querySelectorAll(`[data-dep*="${key}"]`).forEach(row => {
                try {
                    const depRule = JSON.parse(row.getAttribute('data-dep')); 
                    const rules = Array.isArray(depRule) ? depRule : [depRule]; 
                    let conditionsMet = true;
                    for (let rule of rules) { 
                        let target = rule; 
                        let expected = true; 
                        if (target.startsWith('!')) { target = target.substring(1); expected = false; } 
                        const actual = !!this.c.get(target); 
                        if (actual !== expected) { conditionsMet = false; break; } 
                    }
                    if(conditionsMet) row.classList.remove('control-disabled'); 
                    else row.classList.add('control-disabled');
                } catch(e) { console.warn("Error processing dependency row:", e); }
            });
        } catch(e) { console.warn("UI Refresh Error:", e); }
    }
}
    // =========================================================================
    // 10.0 MATRIX KERNEL
    // =========================================================================
// --- MatrixKernel.js ---
class MatrixKernel {
    constructor() {
        // Initialize core components
        this._initializeManagers();
        this._initializeEffects();
        // Frame handling and rendering variables
        this.frame = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.timestep = 1000 / 60;
        this._effectTimers = {}; // Initialize map for effect timers
        this._supermanTimer = 0; // Initialize Superman effect timer (will be managed in _effectTimers)
        this._setupResizeListener();
        this._setupInputListener();
        // FPS tracking variables
        this.lastFrameTime = 0; // Tracks time of the previous frame
        this.fpsHistory = []; // Used for simple FPS smoothing
        this.fpsDisplayElement = null; // Holds reference to the HTML element
        // Configuration subscription for dynamic updates
        this._setupConfigSubscriptions();
    }
    async initAsync() {
        // Asynchronous initialization steps
        await this._initializeRendererAndUI();
        // Perform the initial resize setup and start the loop
        this._resize();
        requestAnimationFrame((time) => this._loop(time));
        this.fpsDisplayElement = document.getElementById('fps-counter');
        // Trigger Boot Sequence on startup if enabled
        if (this.config.get('bootSequenceEnabled')) {
            // Short delay to ensure everything is ready
            setTimeout(() => {
                this.effectRegistry.trigger('BootSequence');
            }, 100);
        }
    }
    /**
     * Initializes core managers (Notification, Config, Grid, Simulation, EffectRegistry).
     * @private
     */
    _initializeManagers() {
        this.config = new ConfigurationManager();
        this.notifications = new NotificationManager(this.config);
        this.grid = new MatrixGrid(this.config);
        this.simulation = new SimulationSystem(this.grid, this.config);
        this.effectRegistry = new EffectRegistry(this.grid, this.config);
    }
    /**
     * Registers all active visual effects with the EffectRegistry.
     * @private
     */
    _initializeEffects() {
        const effects = [
            PulseEffect,
            ClearPulseEffect,
            MiniPulseEffect,
            DejaVuEffect,
            SupermanEffect,
            FirewallEffect,
            BootEffect,
            CrashEffect
        ];
        effects.forEach((EffectClass) => {
            if (EffectClass === CrashEffect || EffectClass === BootEffect) {
                this.effectRegistry.register(new EffectClass(this.grid, this.config, this.effectRegistry));
            } else {
                this.effectRegistry.register(new EffectClass(this.grid, this.config));
            }
        });
    }
    /**
     * Initializes the CanvasRenderer, FontManager, and UIManager.
     * @private
     */
    async _initializeRendererAndUI() {
        this.renderer = new CanvasRenderer('matrixCanvas', this.grid, this.config, this.effectRegistry);
        this.fontMgr = new FontManager(this.config, this.notifications);
        this.charSelector = new CharacterSelectorModal(this.config, this.fontMgr, this.notifications);
        this.ui = new UIManager(this.config, this.effectRegistry, this.fontMgr, this.notifications, this.charSelector);
        // Initialize font manager and await its completion
        await this.fontMgr.init();
        // Safety: Reset Shader State on Reload
        if (this.config.get('shaderEnabled')) {
            this.config.set('shaderEnabled', false);
            this.config.set('customShader', null);
            console.log("Resetting stuck shader state on init.");
        }
    }
    /**
     * Sets up a debounced window resize listener.
     * @private
     */
    _setupResizeListener() {
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this._resize(), 100); // Debounce resize events
        });
    }
    /**
     * Sets up the global input listener for key bindings.
     * @private
     */
    _setupInputListener() {
        window.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field or text area
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Ignore if in key binding mode (Double check flag)
            if (this.ui && this.ui.isKeyBindingActive) return;
            // Ignore if modifier keys are pressed (unless we want to support them later)
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            const bindings = this.config.state.keyBindings || {};
            const key = e.key.toLowerCase();
            for (const [action, boundKey] of Object.entries(bindings)) {
                if (boundKey && boundKey.toLowerCase() === key) {
                    if (action === 'ToggleUI') {
                        this.ui.togglePanel();
                    } else if (action === 'BootSequence' || action === 'CrashSequence') { 
                        this.effectRegistry.trigger(action);
                        this.notifications.show(`${action} Triggered`, 'success');
                    }
                    else {
                        if (this.effectRegistry.trigger(action)) {
                            this.notifications.show(`${action} Triggered`, 'success');
                        }
                    }
                    // Prevent default action only if we matched a binding
                    e.preventDefault();
                    return;
                }
            }
        });
    }
    /**
     * Sets up subscriptions to configuration changes that trigger UI or rendering updates.
     * @private
     */
    _setupConfigSubscriptions() {
        const resizeTriggers = new Set([
            'resolution',
            'stretchX',
            'stretchY',
            'fontSize',
            'horizontalSpacingFactor'
        ]);
        const smoothingTriggers = new Set([
            'smoothingEnabled',
            'smoothingAmount'
        ]);
        this.config.subscribe((key) => {
            // Resize the canvas and grid on resolution-related changes
            if (resizeTriggers.has(key) || key === 'ALL') {
                this._resize();
            }
            // Update renderer when smoothing settings change
            if (smoothingTriggers.has(key)) {
                this.renderer.updateSmoothing();
            }
            const autoEffects = [
                { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
                { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
                { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
                { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
                { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
                { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' },
                { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
            ];
            autoEffects.forEach(effect => {
                if ((key === effect.enabledKey && this.config.state[effect.enabledKey]) || key === 'ALL') {
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                } else if (key === effect.enabledKey && !this.config.state[effect.enabledKey]) {
                    // If an effect is specifically disabled, remove its timer
                    delete this._effectTimers[effect.effectName];
                }
            });
        });
    }
    /**
     * Resizes the grid and renderer dimensions based on current window size and configuration.
     * @private
     */
    _resize() {
        this.grid.resize(
            window.innerWidth / this.config.state.stretchX,
            window.innerHeight / this.config.state.stretchY
        );
        this.renderer.resize();
    }
    /**
     * The main animation loop, handling updates and rendering.
     * Uses a fixed timestep for consistent simulation speed.
     * @private
     * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
     */
    _loop(time) {
    // 1. Calculate Delta and FPS
    const now = performance.now();
    const deltaFPS = now - this.lastFrameTime;
    this.lastFrameTime = now;
    if (deltaFPS > 0 && this.config.state.showFpsCounter) {
        const fps = 1000 / deltaFPS;
        // Simple 30-frame smoothing
        this.fpsHistory.push(fps);
        if (this.fpsHistory.length > 30) {
            this.fpsHistory.shift();
        }
        const smoothedFps = this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            // 2. Update Display
            if (this.fpsDisplayElement) {
                this.fpsDisplayElement.textContent = `FPS: ${Math.round(smoothedFps)}`;
                this.fpsDisplayElement.style.display = 'block';
            }
        } else if (this.fpsDisplayElement) {
            // Hide the counter if the setting is disabled
            this.fpsDisplayElement.style.display = 'none';
        }
        // Start main rendering loop
        if (!this.lastTime) this.lastTime = time;
        const delta = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += delta;
        while (this.accumulator >= this.timestep) {
            this._updateFrame();
            this.accumulator -= this.timestep;
        }
        this.renderer.render(this.frame);
        requestAnimationFrame((nextTime) => this._loop(nextTime));
    }
    /**
     * Updates the simulation logic for a single frame.
     * @private
     */
    _updateFrame() {
        this.frame++;
        this.effectRegistry.update();
        this.simulation.update(this.frame);
        const autoEffects = [
            { enabledKey: 'pulseEnabled', frequencyKey: 'pulseFrequencySeconds', effectName: 'Pulse' },
            { enabledKey: 'clearPulseEnabled', frequencyKey: 'clearPulseFrequencySeconds', effectName: 'ClearPulse' },
            { enabledKey: 'miniPulseEnabled', frequencyKey: 'miniPulseFrequencySeconds', effectName: 'MiniPulse' },
            { enabledKey: 'dejaVuEnabled', frequencyKey: 'dejaVuFrequencySeconds', effectName: 'DejaVu' },
            { enabledKey: 'supermanEnabled', frequencyKey: 'supermanFrequencySeconds', effectName: 'Superman' },
            { enabledKey: 'firewallEnabled', frequencyKey: 'firewallFrequencySeconds', effectName: 'Firewall' },
            { enabledKey: 'crashEnabled', frequencyKey: 'crashFrequencySeconds', effectName: 'CrashSequence' }
        ];
        autoEffects.forEach(effect => {
            if (this.config.state[effect.enabledKey]) {
                if (!this._effectTimers[effect.effectName]) {
                    // Initialize timer with randomization if not already set
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5); // Up to 50% random offset
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
                this._effectTimers[effect.effectName]--;
                if (this._effectTimers[effect.effectName] <= 0) {
                    this.effectRegistry.trigger(effect.effectName);
                    // Reset timer with randomization
                    const minFrequencyFrames = this.config.state[effect.frequencyKey] * 60;
                    const randomOffsetFrames = Utils.randomInt(0, minFrequencyFrames * 0.5);
                    this._effectTimers[effect.effectName] = minFrequencyFrames + randomOffsetFrames;
                }
            } else {
                // If effect is disabled, ensure its timer is reset or cleared
                if (this._effectTimers[effect.effectName]) {
                    delete this._effectTimers[effect.effectName];
                }
            }
        });
    }
}
// Initialize the MatrixKernel on DOMContentLoaded
window.addEventListener('DOMContentLoaded', async () => {
    const kernel = new MatrixKernel();
    // Expose kernel and config globally for debugging/console access
    window.matrix = kernel;
    window.config = kernel.config;
    await kernel.initAsync();
    kernel.lastFrameTime = performance.now(); // Set initial time
});
</script>
    <script>
        // Auto-initialize if not already done by the classes
        // (MatrixKernel initializes itself on DOMContentLoaded)
    </script>
</body>
</html>