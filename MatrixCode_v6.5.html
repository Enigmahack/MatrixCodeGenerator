<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Digital Rain v6.5</title>
    <style>
    /* --- CSS VARIABLES & THEME --- */
    :root {
        --bg-color: #000;
        --panel-bg: rgba(10, 12, 16, 0.96); 
        --panel-border: rgba(34, 197, 94, 0.3);
        --text-main: #4ade80;
        --text-muted: #86efac;
        --accent: #22c55e;
        --accent-glow: rgba(34, 197, 94, 0.4);
        --danger: #ef4444;
        --info: #3b82f6;
        --warn: #f59e0b;
        --safe-top: env(safe-area-inset-top, 20px);
        --safe-right: env(safe-area-inset-right, 20px);
    }
    * { box-sizing: border-box; }
    body { 
        overflow: hidden; 
        background-color: var(--bg-color); 
        margin: 0; 
        font-family: 'Segoe UI', 'Roboto', monospace; 
        overscroll-behavior: none;
    }
    
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #matrixCanvas { z-index: 1; transition: filter 0.3s ease; }

    /* --- SETTINGS PANEL UI --- */
    #settingsPanel {
        position: fixed; top: 0; right: 0; height: 100vh; width: 340px;
        background-color: var(--panel-bg); 
        box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
        transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        display: flex; flex-direction: column;
        border-left: 1px solid var(--panel-border); 
        font-size: 0.9rem;
        color: var(--text-main);
    }
    #settingsPanel.open { transform: translateX(0); }
    
    #panelHeader { 
        padding: 1.25rem; 
        padding-top: max(1.25rem, var(--safe-top));
        border-bottom: 1px solid var(--panel-border);
        background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
    }
    #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }

    /* --- TABS NAVIGATION (CSS SCROLL SNAP) --- */
    #navTabs { 
        overflow-x: auto; 
        white-space: nowrap;
        background: rgba(0,0,0,0.3);
        border-bottom: 1px solid var(--panel-border);
        position: relative;
        width: 100%;
        /* Native Smooth Scrolling */
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        scroll-snap-type: x mandatory;
        scrollbar-width: none; /* Firefox */
    }
    #navTabs::-webkit-scrollbar { display: none; }
    
    #tabTrack {
        display: inline-flex;
        width: max-content;
    }

    .tab-btn { 
        flex: 0 0 auto; padding: 1rem 1.25rem; 
        text-align: center; color: var(--text-muted); 
        background: none; border: none; cursor: pointer; 
        transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
        border-bottom: 2px solid transparent;
        user-select: none;
        min-height: 48px;
        scroll-snap-align: start; /* Snap logic */
    }
    .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
    .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }

    /* --- CONTENT AREA --- */
    #contentArea { flex: 1; overflow-y: auto; padding: 1.5rem; -webkit-overflow-scrolling: touch; }
    
    .control-group { 
        display: none; 
        flex-direction: column; 
        gap: 1.5rem; 
        animation: fadeIn 0.3s ease; 
    }
    .control-group.active { display: flex; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    .control-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); transition: opacity 0.3s ease, filter 0.3s ease; }
    .control-row { width: 100%; transition: opacity 0.3s; }
    .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
    
    .section-header {
        margin-top: 1rem; margin-bottom: 0.25rem;
        font-size: 0.8rem; font-weight: 700; color: #fff;
        text-transform: uppercase; letter-spacing: 1.5px;
        border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px;
    }

    /* --- TOOLTIP UI --- */
    .control-label-group { display: flex; align-items: center; gap: 6px; flex: 1; }
    .info-icon {
        display: inline-flex; align-items: center; justify-content: center;
        width: 22px; height: 22px; 
        border-radius: 50%;
        border: 1px solid var(--text-muted); color: var(--text-muted);
        font-size: 12px; cursor: help; transition: all 0.2s;
        margin-left: 8px;
    }
    .info-icon:hover, .info-icon:active { border-color: var(--accent); color: var(--accent); background: rgba(34, 197, 94, 0.1); }

    #ui-tooltip {
        position: fixed; 
        background: #1f2937;
        border: 1px solid var(--accent);
        color: #fff;
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 0.8rem;
        line-height: 1.4;
        z-index: 10000; 
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s;
        max-width: 240px;
        box-shadow: 0 4px 25px rgba(0,0,0,0.6);
        visibility: hidden;
    }
    #ui-tooltip.visible { opacity: 1; visibility: visible; }

    /* --- TOAST NOTIFICATIONS --- */
    #toast-container {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        z-index: 10001; pointer-events: none;
        display: flex; flex-direction: column; gap: 10px; align-items: center;
    }
    .toast-msg {
        background: rgba(31, 41, 55, 0.95); border: 1px solid var(--accent);
        color: #fff; padding: 12px 24px; border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        font-size: 0.9rem; opacity: 0; transform: translateY(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex; align-items: center; gap: 10px;
    }
    .toast-msg.visible { opacity: 1; transform: translateY(0); }
    .toast-success { border-color: var(--accent); color: var(--text-main); }
    .toast-error { border-color: var(--danger); color: #fca5a5; }
    .toast-info { border-color: var(--info); color: #93c5fd; }


    /* Improved Range Slider with Hover */
    input[type="range"] { width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none; appearance: none; -webkit-appearance: none; padding: 0; margin: 0; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--accent); appearance: none; -webkit-appearance: none; transition: transform 0.1s; }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

    .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
    input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }

    .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
    input[type="checkbox"] { width: 40px; height: 20px; background: #374151; border-radius: 20px; position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none; }
    input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
    input[type="checkbox"]:checked { background: var(--accent); }
    input[type="checkbox"]:checked::after { transform: translateX(20px); }

    /* TOGGLE SWITCH UI */
    /* --- UPDATED TOGGLE SWITCH UI --- */
    .toggle-switch-container { 
        display: flex; 
        background: #1f2937; 
        border-radius: 20px; 
        border: 1px solid var(--panel-border); 
        position: relative; 
        cursor: pointer; 
        width: 100%; 
        height: 32px; 
        /* Removed padding here to handle positioning absolutely for precision */
    }
    .toggle-option { 
        flex: 1; 
        text-align: center; 
        font-size: 0.75rem; 
        font-weight: 600; 
        color: var(--text-muted); 
        z-index: 2; 
        line-height: 28px; 
        transition: color 0.3s; 
        user-select: none; 
        margin-top: 1px; /* Visual centering adjustment */
    }
    .toggle-option.selected { color: #fff; }
    
    .toggle-slider { 
        position: absolute; 
        top: 2px; 
        bottom: 2px; 
        width: calc(50% - 4px); 
        background: var(--accent); 
        border-radius: 18px; 
        z-index: 1; 
        transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        /* Shadow for depth */
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Precise positioning for perfect symmetry */
    .toggle-left { left: 2px; }
    .toggle-right { left: calc(50% + 2px); }

    select {
        width: 100%; padding: 0.5rem; background: #1f2937; color: var(--text-main);
        border: 1px solid var(--panel-border); border-radius: 4px;
        font-family: monospace; font-size: 0.9rem; outline: none;
    }
    select:focus { border-color: var(--accent); }
    
    option.custom-font-opt { color: #fcd34d; font-style: italic; background-color: #2a2d35; }

    .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
    .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
    .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
    .btn-info:hover { background: rgba(59, 130, 246, 0.4); }
    .btn-warn { background: rgba(245, 158, 11, 0.2); border-color: rgba(245, 158, 11, 0.5); color: #fcd34d; }
    .btn-warn:hover { background: rgba(245, 158, 11, 0.4); }
    .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }

    .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
    .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
    .slot-name-input:focus { outline: none; border-color: var(--accent); }
    .slot-btn-group { display: flex; gap: 0.25rem; }
    .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
    .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
    .btn-disabled { opacity: 0.3; cursor: not-allowed; }
    
    .font-manager-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
    .font-item { 
        display: flex; align-items: center; justify-content: space-between; 
        background: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); 
    }
    .font-name { font-size: 0.85rem; font-family: monospace; color: #fcd34d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .font-delete-btn {
        background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5;
        width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: all 0.2s;
    }
    .font-delete-btn:hover { background: rgba(239, 68, 68, 0.3); color: white; }

    #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
    .status-msg { font-size: 0.8rem; font-family: monospace; color: var(--text-muted); opacity: 0.6; }
    
    /* Updated Menu Toggle Positioning using Safe Area */
    #menuToggle { 
        position: fixed; 
        top: max(0.75rem, var(--safe-top)); 
        right: max(1.2rem, var(--safe-right)); 
        z-index: 30; width: 44px; height: 44px; 
        border-radius: 50%; color: var(--text-main); background: rgba(10, 12, 16, 0.6); 
        backdrop-filter: blur(4px); border: 1px solid var(--panel-border); 
        cursor: pointer; display: flex; align-items: center; justify-content: center; 
        transition: all 0.3s ease; 
    }
    #menuToggle:hover { background: var(--accent); color: #000; box-shadow: 0 0 20px var(--accent); transform: rotate(90deg); }

    @media (max-width: 600px) {
        #settingsPanel { width: 100%; max-width: 100%; border-left: none; }
    }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <canvas id="bloomCanvas" style="display:none;"></canvas>

    <button id="menuToggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.5.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5 3.5z"></path></svg>
    </button>
    <input type="file" id="importFile" accept=".json" style="display:none;" />
    <input type="file" id="importFontFile" accept=".ttf,.otf,.woff,.woff2" style="display:none;" />

    <div id="settingsPanel">
        <div id="panelHeader"><h2>Settings</h2></div>
        <div id="navTabs"></div>
        <div id="contentArea"></div>
        <div id="panelFooter"><div id="globalStatus" class="status-msg">Matrix Code v6.5</div></div>
    </div>

    <script>
        const APP_VERSION = "6.5";

        // --- 1. CORE UTILITIES ---
        const Utils = {
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomFloat: (min, max) => Math.random() * (max - min) + min,
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 255, b: 0 };
            },
            _colorCache: new Map(),
            getCachedHsl: (h, s, l) => {
                const key = `${h|0},${s},${l}`;
                let val = Utils._colorCache.get(key);
                if(!val) {
                    val = `hsl(${h}, ${s}%, ${l}%)`;
                    Utils._colorCache.set(key, val);
                    if(Utils._colorCache.size > 2000) Utils._colorCache.clear();
                }
                return val;
            },
            packRgb: (r, g, b) => { return (r << 16) | (g << 8) | b; },
            unpackRgb: (intVal) => { return { r: (intVal >> 16) & 0xFF, g: (intVal >> 8) & 0xFF, b: intVal & 0xFF }; },
            CHARS: '012345789Z:<=>"*+-._!|⽇゠ウエオカキクコサシスセソツテナニヌネハヒフホマミムメモヤラリワヲンワヲン',
            getRandomChar: () => Utils.CHARS.charAt(Math.floor(Math.random() * Utils.CHARS.length)),
            getUniqueChar: (exclude) => { let c; do { c = Utils.getRandomChar(); } while (c === exclude); return c; },
            downloadJson: (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }, 

            hslToRgb: (h, s, l) => {
                s /= 100; l /= 100;
                const k = n => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
                return { r: Math.round(255 * f(0)), g: Math.round(255 * f(8)), b: Math.round(255 * f(4)) };
            }

        };

        // --- 2. FONT MANAGER (IndexedDB + Embedded Support) ---
        class FontManager {
            constructor(config) {
                this.config = config;
                this.dbName = 'MatrixFontDB';
                this.storeName = 'fonts';
                this.db = null;
                this.subscribers = [];
                this.loadedFonts = [];
                this.embeddedFontName = 'MatrixEmbedded';
            }
            
            async init() {
                // 1. Inject Embedded Font immediately if available
                if(DEFAULT_FONT_DATA && DEFAULT_FONT_DATA.length > 50) {
                    this.injectEmbeddedFont();
                }

                try {
                    await this._openDB();
                    await this._loadFontsFromDB();
                } catch (e) {
                    console.error("Font Manager Init Failed", e);
                }
            }

            // New method for handling the Base64 constant
            injectEmbeddedFont() {
                const style = document.createElement('style');
                style.id = `style-${this.embeddedFontName}`;
                // No format() hint needed for data URIs usually, but we can assume woff2 based on instruction
                style.textContent = `
                    @font-face {
                        font-family: '${this.embeddedFontName}';
                        src: url('${DEFAULT_FONT_DATA}');
                    }
                `;
                document.head.appendChild(style);
                
                // Add to list so it appears in UI
                this.loadedFonts.push({ 
                    name: this.embeddedFontName, 
                    display: "The Matrix Custom Code", 
                    data: null, // No blob needed
                    isEmbedded: true 
                });
            }

            _openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.dbName, 1);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName, { keyPath: 'name' });
                        }
                    };
                    req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
                    req.onerror = (e) => reject(e);
                });
            }

            _loadFontsFromDB() {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not open");
                    const tx = this.db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const req = store.getAll();
                    req.onsuccess = () => {
                        // Merge DB results with existing embedded font
                        const dbFonts = req.result;
                        dbFonts.forEach(f => this.injectFont(f.name, f.data));
                        this.loadedFonts = [...this.loadedFonts, ...dbFonts];
                        this._notify();
                        resolve();
                    };
                    req.onerror = reject;
                });
            }

            subscribe(cb) { this.subscribers.push(cb); }
            _notify() { this.subscribers.forEach(cb => cb(this.loadedFonts)); }

            importFont(file, callback) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const blob = new Blob([e.target.result], {type: file.type});
                    const fontId = `CustomFont_${Date.now()}`;
                    const display = file.name;

                    const record = { name: fontId, display: display, data: blob };
                    
                    this._saveToDB(record).then(() => {
                        this.injectFont(fontId, blob);
                        this.loadedFonts.push(record);
                        this.config.set('fontFamily', fontId);
                        this._notify();
                        callback(true, `Imported: ${display}`);
                    }).catch(err => {
                        console.error(err);
                        callback(false, "Storage Failed (IDB Error)");
                    });
                };
                reader.onerror = () => callback(false, "Read Error");
                reader.readAsArrayBuffer(file);
            }

            deleteFont(fontId) {
                return new Promise((resolve, reject) => {
                   if(!this.db) return reject();
                   const tx = this.db.transaction(this.storeName, 'readwrite');
                   const store = tx.objectStore(this.storeName);
                   store.delete(fontId).onsuccess = () => {
                       this._cleanupFont(fontId);
                       resolve();
                   };
                });
            }
            
            deleteAllFonts() {
                return new Promise((resolve, reject) => {
                    if(!this.db) return reject("DB Closed");
                    const tx = this.db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const req = store.clear();
                    req.onsuccess = () => {
                        // Keep the embedded font, clear DB fonts
                        const fontsToClean = this.loadedFonts.filter(f => !f.isEmbedded);
                        this.loadedFonts = this.loadedFonts.filter(f => f.isEmbedded);
                        
                        fontsToClean.forEach(f => this._cleanupFont(f.name));
                        this._notify();
                        resolve();
                    };
                    req.onerror = (e) => reject(e);
                });
            }

            _cleanupFont(fontId) {
               const styleId = `style-${fontId}`;
               const el = document.getElementById(styleId);
               if(el) el.remove();
               
               this.loadedFonts = this.loadedFonts.filter(f => f.name !== fontId);
               
               if(this.config.state.fontFamily === fontId) {
                   // Fallback: If embedded exists, use it. Else default.
                   const fallback = (DEFAULT_FONT_DATA && DEFAULT_FONT_DATA.length > 50) ? this.embeddedFontName : this.config.defaults.fontFamily;
                   this.config.set('fontFamily', fallback);
               }
               this._notify();
            }

            _saveToDB(record) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const req = store.put(record);
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e);
                });
            }

            injectFont(name, dataBlob) {
                const url = URL.createObjectURL(dataBlob);
                
                // DETERMINE FORMAT BASED ON MIME TYPE
                // This fixes the hardcoded 'truetype' issue
                let formatHint = "format('truetype')";
                if(dataBlob.type.includes('woff2')) formatHint = "format('woff2')";
                else if(dataBlob.type.includes('woff')) formatHint = "format('woff')";
                else if(dataBlob.type.includes('opentype')) formatHint = "format('opentype')";

                const style = document.createElement('style');
                style.id = `style-${name}`;
                style.textContent = `
                    @font-face {
                        font-family: '${name}';
                        src: url('${url}') ${formatHint};
                    }
                `;
                document.head.appendChild(style);
            }

            getCustomFonts() {
                return this.loadedFonts.map(f => ({ label: f.display, value: f.name, isCustom: true }));
            }
        }

        // --- 3. CONFIGURATION MANAGER ---
        class ConfigurationManager {
            constructor() {
                this.storageKey = 'matrix_config_v6_5'; 
                this.slotsKey = 'matrix_slots_v6_5';
                
                // New defaults for version 6.5
                this.defaults = {
                    streamColor: "#4fcf64",
                    streamSpeed: 15,
                    trailGlow: 28,
                    clearAlpha: 0.6,
                    streamMinLength: 5,
                    streamMaxLength: 301,
                    holeRate: 0.15,
                    ttlMinFrames: 12,
                    ttlMaxFrames: 135,
                    decayFadeDurationFrames: 24,
                    variableBrightnessEnabled: true,
                    brightnessVariance: 20,
                    dissolveEnabled: true,
                    dissolveMinSize: 19,
                    deteriorationEnabled: true,      
                    deteriorationType: 'ghost',      
                    deteriorationStrength: 2,
                    
                    tracerColor: "#e5ffff",
                    tracerSizeIncrease: 1,
                    tracerGlow: 25,
                    tracerAttackFrames: 8,
                    tracerHoldFrames: 0,
                    tracerReleaseFrames: 6,
                    invertedTracerEnabled: true,
                    invertedTracerChance: 0.25,
                    randomStopEnabled: true,
                    randomStopChance: 0.02,
                    
                    rotatorEnabled: true,
                    rotatorChance: 0.13, 
                    rotatorSyncToTracer: true, 
                    rotatorSyncMultiplier: 0.5,
                    rotatorCycleFactor: 11, 
                    rotatorCrossfadeFrames: 6,
                    
                    pulseEnabled: true,
                    pulseFrequencySeconds: 180,
                    pulseDelayFrames: 60,
                    pulseDurationSeconds: 1.2,
                    pulsePreserveSpaces: true,
                    pulseRandomPosition: true,
                    pulseWidth: 100,       
                    pulseDimming: 0.1,
                    pulseIgnoreTracers: true,   
                    
                    dejaVuEnabled: true,
                    dejaVuAutoMode: true,
                    dejaVuFrequencySeconds: 300,
                    dejaVuDurationSeconds: 5,
                    dejaVuBarDurationFrames: 30,
                    dejaVuVarianceFrames: 60,
                    dejaVuIntensity: 0.06,
                    dejaVuHoleBrightness: 0.02,
                    dejaVuMinRectHeight: 1,
                    dejaVuMaxRectHeight: 10,
                    dejaVuRandomizeColors: true,

                    starPowerEnabled: false,
                    starPowerFreq: 100, 
                    starPowerRainbowMode: 'char',
                    starPowerColorCycle: false,
                    starPowerCycleSpeed: 14,
                    starPowerSaturation: 100,
                    starPowerIntensity: 51,
                    starPowerGlitter: false,

                    rainbowStreamEnabled: false,
                    rainbowStreamChance: 1, 
                    rainbowStreamIntensity: 50,

                    enableBloom: true,
                    bloomStrength: 3,
                    bloomOpacity: 0.6,
                    
                    resolution: 1.5,
                    smoothingEnabled: true,
                    smoothingAmount: 0.5,
                    stretchX: 1,
                    stretchY: 1.1, 
                    
                    // --- FONT SETTINGS ---
                    fontFamily: 'MatrixEmbedded',
                    fontSize: 24, 
                    fontWeight: 'normal', 
                    mirrorEnabled: false, 
                    fontOffsetY: 0,
                    fontOffsetX: 0,
                    italicEnabled: false,

                    horizontalSpacingFactor: 0.7, 
                    verticalSpacingFactor: 0.95
                };
                this.state = { ...this.defaults };
                this.derived = {};
                this.slots = this._loadSlots();
                this.subscribers = [];
                this.load();
                this.updateDerivedValues();
            }
            _loadSlots() { try { const s = localStorage.getItem(this.slotsKey); if (s) return JSON.parse(s); } catch (e) {} return Array(5).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null })); }
            saveSlots() { try { localStorage.setItem(this.slotsKey, JSON.stringify(this.slots)); } catch (e) {} }
            load() { 
                try { 
                    const s = localStorage.getItem(this.storageKey); 
                    if (s) {
                        const parsed = JSON.parse(s);
                        if(parsed.customFonts) {
                            delete parsed.customFonts;
                            setTimeout(() => this.save(), 100);
                        }
                        this.state = { ...this.defaults, ...parsed }; 
                    } 
                } catch (e) {} 
            }
            save() { 
                try { 
                    const toSave = { ...this.state };
                    if(toSave.customFonts) delete toSave.customFonts;
                    localStorage.setItem(this.storageKey, JSON.stringify(toSave)); 
                } catch (e) { console.error("Config Save Failed", e); } 
            }
            get(key) { return this.state[key]; }
            set(key, value) {
                this.state[key] = value;
                if (key === 'streamMinLength') this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
                if (key === 'streamMaxLength') this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
                this.updateDerivedValues(); this.save(); this.notify(key);
            }
            reset() { this.state = { ...this.defaults }; this.updateDerivedValues(); this.save(); this.notify('ALL'); }
            saveToSlot(i) { const data = typeof structuredClone === 'function' ? structuredClone(this.state) : JSON.parse(JSON.stringify(this.state)); this.slots[i] = { name: this.slots[i].name, data: data }; this.saveSlots(); }
            loadFromSlot(i) { if(!this.slots[i].data) return false; this.state = { ...this.defaults, ...this.slots[i].data }; this.updateDerivedValues(); this.save(); this.notify('ALL'); return true; }
            renameSlot(i, n) { this.slots[i].name = n; this.saveSlots(); }
            subscribe(cb) { this.subscribers.push(cb); }
            notify(k) { this.subscribers.forEach(cb => cb(k, this.state)); }
            
            updateDerivedValues() {
                const s = this.state;
                const cycleDur = 21 - s.streamSpeed;
                const hFactor = Math.max(0.5, s.horizontalSpacingFactor);
                const vFactor = Math.max(0.5, s.verticalSpacingFactor);
                
                const cW = s.fontSize * hFactor;
                const cH = s.fontSize * vFactor;

                const fontStyle = s.italicEnabled ? 'italic' : 'normal';
                
                let rotFrames;
                    if (s.rotatorSyncToTracer) {
                        // SYNC MODE:
                        // If stream drops every 20 frames (cycleDur), and multiplier is 4x:
                        // We need to rotate every 5 frames (20 / 4).
                        // We use Math.max(1, ...) to prevent dividing by zero or infinite speed.
                        rotFrames = Math.max(1, Math.floor(cycleDur / s.rotatorSyncMultiplier));
                    } else {
                        // MANUAL MODE (Original Logic):
                        rotFrames = Math.max(10, Math.round(60 - (s.rotatorCycleFactor * 2.5)));
                    }

                this.derived = {
                    cycleDuration: cycleDur,
                    safeAttack: Math.max(1, Math.min(s.tracerAttackFrames, cycleDur)),
                    safeRelease: Math.min(s.tracerReleaseFrames, cycleDur),
                    holdFrames: Math.max(0, s.tracerHoldFrames),
                    maxState: cycleDur + Math.max(0, s.tracerHoldFrames) + cycleDur,
                    rotatorCycleFrames: rotFrames,
                    cellWidth: cW, 
                    cellHeight: cH,
                    varianceMin: 1.0 - (s.brightnessVariance / 100),
                    streamRgb: Utils.hexToRgb(s.streamColor), 
                    tracerRgb: Utils.hexToRgb(s.tracerColor),
                    streamColorStr: `rgb(${Utils.hexToRgb(s.streamColor).r},${Utils.hexToRgb(s.streamColor).g},${Utils.hexToRgb(s.streamColor).b})`,
                    tracerColorStr: `rgb(${Utils.hexToRgb(s.tracerColor).r},${Utils.hexToRgb(s.tracerColor).g},${Utils.hexToRgb(s.tracerColor).b})`,
                    fontBaseStr: `${fontStyle} ${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`
                };
                Palette.update(s);
            }
        }

        // --- 4. DATA LAYER ---
        const Palette = {
            streamRgb: {r:0,g:255,b:0}, tracerRgb: {r:255,g:255,b:255},
            update: function(s) {
                this.streamRgb = Utils.hexToRgb(s.streamColor);
                this.tracerRgb = Utils.hexToRgb(s.tracerColor);
            }
        };

        const CELL_TYPE = { EMPTY: 0, TRAIL: 1, TRACER: 2, ROTATOR: 3 };

        class Cell {
            constructor() {
                this.char = Utils.getRandomChar();
                this.nextChar = ''; this.type = CELL_TYPE.EMPTY; 
                this.alpha = 0.0; this.brightness = 1.0;
                this.crossFadeAlpha = 0.0; this.age = 0; this.decay = 0;       
                this.rotatorProg = 0; this.override = null; this.style = null; 
            }
        }

        class Grid {
            constructor(c) { this.config = c; this.cols = 0; this.rows = 0; this.cells = []; }
            resize(w, h) {
                const d = this.config.derived;
                const nc = Math.max(1, Math.floor(w / d.cellWidth));
                const nr = Math.max(1, Math.floor(h / d.cellHeight));
                if (nc !== this.cols || nr !== this.rows) this.init(nc, nr);
            }
            init(c, r) {
                this.cols = c; this.rows = r;
                this.cells = Array(r).fill(null).map(() => Array(c).fill(null).map(() => new Cell()));
            }
            get(x, y) { return (y >= 0 && y < this.rows && x >= 0 && x < this.cols) ? this.cells[y][x] : null; }
        }

        // --- 5. SYSTEMS LAYER ---
        // --- A) STREAM STRATEGIES ---
        class StreamStrategy {
            spawn(st, config) { throw new Error("Method 'spawn' must be implemented."); }
            getCellStyle(st, frame, config) { return null; }
        }

        class StandardStrategy extends StreamStrategy {
            spawn(st, config) { 
                // Standard setup logic
            }
            getCellStyle(st, frame, config) { return null; }
        }

        class StarPowerStrategy extends StreamStrategy {
            spawn(st, config) {
                st.baseHue = Utils.randomInt(0, 360);
            }
            getCellStyle(st, frame, config) {
                const s = config.state;
                const isCharMode = s.starPowerRainbowMode === 'char';
                const hue = (isCharMode ? (frame + (st.x * 10)) % 360 : st.baseHue) | 0;
                return { h: hue, s: s.starPowerSaturation, l: s.starPowerIntensity, cycle: s.starPowerColorCycle, speed: s.starPowerCycleSpeed, glitter: s.starPowerGlitter };
            }
        }

        class RainbowStrategy extends StreamStrategy {
            spawn(st, config) {
                st.baseHue = Utils.randomInt(0, 360);
            }
            getCellStyle(st, frame, config) {
                const s = config.state;
                return { h: st.baseHue, s: 100, l: s.rainbowStreamIntensity, cycle: false, speed: 0, glitter: false };
            }
        }

        class StreamSystem {
            constructor(grid, config) {
                this.grid = grid; this.config = config;
                this.streams = []; this.releaseTimer = 0;
                // Cache strategies
                this.strategies = {
                    'STANDARD': new StandardStrategy(),
                    'STAR_POWER': new StarPowerStrategy(),
                    'RAINBOW': new RainbowStrategy()
                };
            }
            resize() {
                const newCols = this.grid.cols;
                if (this.streams.length < newCols) {
                    const diff = newCols - this.streams.length;
                    const newStreams = Array(diff).fill(null).map((_, i) => ({
                        x: this.streams.length + i, y: -1, active: false, delay: Utils.randomInt(0, 200),
                        len: 0, holes: new Set(), decayY: -1, decayStarted: false, age: 0, visibleLen: 0, isInverted: false,
                        mode: 'STANDARD', baseHue: 0 
                    }));
                    this.streams = [...this.streams, ...newStreams];
                } else if (this.streams.length > newCols) {
                    this.streams = this.streams.slice(0, newCols);
                }
                this.streams.forEach(st => {
                    if (st.x >= newCols) { st.active = false; st.x = Utils.randomInt(0, newCols - 1); st.y = -1; }
                });
            }
            update(frame) {
                this.resize(); 
                const s = this.config.state;
                const d = this.config.derived;
                if (this.releaseTimer <= 0) {
                    const available = this.streams.filter(st => !st.active && st.delay <= 0).sort(() => Math.random() - 0.5);
                    let count = 4; 
                    for (const st of available) {
                        if (count-- <= 0) break;
                        let clear = true;
                        for(let y=0; y < Math.min(this.grid.rows, 40); y++) {
                            if(this.grid.get(st.x, y).decay > 0) { clear = false; break; }
                        }
                        if (clear) this._activateStream(st, frame);
                        else st.delay = 20;
                    }
                    this.releaseTimer = d.cycleDuration * 4;
                } else this.releaseTimer--;
                this.streams.forEach(st => {
                    if (!st.active) { if (st.delay > 0) st.delay--; return; }
                    if (frame % d.cycleDuration === 0) {
                        st.age++;
                        if (st.age >= st.visibleLen && !st.decayStarted) {
                            st.decayY = (st.age - st.visibleLen) - 1; st.decayStarted = true;
                        }
                        if (!st.decayStarted && s.randomStopEnabled && Math.random() < s.randomStopChance) { st.len = st.y; }
                        if (st.y < st.len) { st.y++; this._writeHead(st, frame); }
                        if (st.decayStarted) {
                            st.decayY++; this._writeTail(st);
                            if (st.decayY >= this.grid.rows) { st.active = false; st.delay = Utils.randomInt(50, 150); }
                        }
                    }
                });
            }
            _activateStream(st, frame) {
                const s = this.config.state;
                st.len = Utils.randomInt(Math.min(s.streamMinLength, s.streamMaxLength), s.streamMaxLength);
                st.holes.clear();
                for(let i=0; i<st.len; i++) if(Math.random() < s.holeRate) st.holes.add(i);
                st.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
                st.visibleLen = Utils.randomInt(s.ttlMinFrames, s.ttlMaxFrames);
                st.age = 0; st.active = true; st.y = -1; st.decayY = -1; st.decayStarted = false;
                
                // Strategy Selection
                st.mode = 'STANDARD';
                if (s.starPowerEnabled && Math.random() < (s.starPowerFreq / 100)) st.mode = 'STAR_POWER';
                else if (s.rainbowStreamEnabled && Math.random() < Math.max(0.05, s.rainbowStreamChance)) st.mode = 'RAINBOW_STREAM';
                
                // Delegate specific init to strategy
                const strategy = this.strategies[st.mode === 'RAINBOW_STREAM' ? 'RAINBOW' : st.mode] || this.strategies['STANDARD'];
                strategy.spawn(st, this.config);

                let skip = 0;
                if(!st.isInverted) { while(skip < st.len && st.holes.has(skip)) skip++; }
                st.y -= skip; 
            }
            _writeHead(st, frame) {
                const y = st.y; 
                const cell = this.grid.get(st.x, y);
                if (cell) {
                    const draw = st.isInverted ? st.holes.has(st.y) : !st.holes.has(st.y);
                    if (draw) {
                        cell.type = (this.config.state.rotatorEnabled && Math.random() < this.config.state.rotatorChance) ? CELL_TYPE.ROTATOR : CELL_TYPE.TRACER;
                        cell.age = 1; cell.decay = 1; cell.rotatorProg = 0; 
                        cell.char = cell.nextChar || Utils.getRandomChar();
                        cell.nextChar = Utils.getUniqueChar(cell.char);
                        cell.brightness = this.config.state.variableBrightnessEnabled ? Utils.randomFloat(this.config.derived.varianceMin, 1.0) : 1.0;
                        
                        // Use Strategy for styling
                        const strategy = this.strategies[st.mode === 'RAINBOW_STREAM' ? 'RAINBOW' : st.mode] || this.strategies['STANDARD'];
                        cell.style = strategy.getCellStyle(st, frame, this.config);

                    } else {
                        cell.type = CELL_TYPE.EMPTY; cell.age = 0; cell.decay = 0; cell.rotatorProg = 0; cell.style = null;
                    }
                }
            }
            _writeTail(st) { const cell = this.grid.get(st.x, st.decayY); if (cell && cell.decay === 1) cell.decay = 2; }
        }

        class EffectSystem {
            constructor(grid, config) { 
                this.grid = grid; this.config = config; 
                this.pulse = new PulseEffect(grid, config);
                this.dejaVu = new DejaVuEffect(grid, config);
            }
            triggerPulse() { this.pulse.trigger(); }
            triggerDejaVu() { this.dejaVu.trigger(); }
            
            update(frame) {
                const s = this.config.state;
                const d = this.config.derived;
                this.pulse.update(); this.dejaVu.update();

                for(let y=0; y<this.grid.rows; y++) {
                    for(let x=0; x<this.grid.cols; x++) {
                        const c = this.grid.cells[y][x];
                        if (c.age > 0) { c.age++; if (c.age > d.maxState) c.age = 0; }
                        if (c.decay >= 2) { c.decay++; if (c.decay > s.decayFadeDurationFrames + 2) { c.decay = 0; c.type = CELL_TYPE.EMPTY; c.style = null; } }
                        
                        if (s.rotatorEnabled && c.type === CELL_TYPE.ROTATOR && c.age === 0 && c.decay > 0) {
                            const cyclePhase = frame % d.rotatorCycleFrames;
                            if (s.rotatorCrossfadeFrames <= 2) {
                                if (cyclePhase === 0 && c.decay <= 1) c.char = Utils.getUniqueChar(c.char);
                            } else {
                                const start = d.rotatorCycleFrames - s.rotatorCrossfadeFrames;
                                if (cyclePhase === start && c.rotatorProg === 0 && c.decay <= 1) {
                                    const safe = y===0 || this.grid.cells[y-1][x].decay < 2;
                                    if(safe) { c.rotatorProg = 1; c.nextChar = Utils.getUniqueChar(c.char); }
                                } 
                                else if (c.rotatorProg > 0) {
                                    c.rotatorProg++;
                                    if (c.rotatorProg > s.rotatorCrossfadeFrames) { c.char = c.nextChar; c.rotatorProg = 0; }
                                }
                            }
                        }
                        
                        let override = this.dejaVu.getOverride(x, y);
                        if (!override) override = this.pulse.getOverride(x, y);
                        c.override = override;
                        this._calculateVisuals(c, d, s);
                    }
                }
            }
            _calculateVisuals(c, d, s) {
                if(c.override) return; 
                c.alpha = 0; c.crossFadeAlpha = 0; 
                if (c.age > 0) {
                    const activeTime = c.age - 1;
                    const endPhase1 = d.cycleDuration; 
                    const endPhase2 = d.cycleDuration + d.holdFrames; 
                    if (activeTime < endPhase1) {
                        const startFade = endPhase1 - d.safeAttack;
                        if (activeTime >= startFade) c.alpha = (activeTime - startFade) / d.safeAttack;
                    } else if (activeTime < endPhase2) { c.alpha = 1.0; }
                    else {
                        const relTime = activeTime - endPhase2;
                        if (relTime < d.safeRelease) {
                            const progress = relTime / d.safeRelease;
                            c.alpha = 1.0 - progress; c.crossFadeAlpha = progress;    
                        } else { c.alpha = 0.0; c.crossFadeAlpha = 1.0; }
                    }
                } else if (c.decay === 1) { c.alpha = 0.95 * c.brightness; } 
                else if (c.decay >= 2) {
                    const p = (c.decay - 2) / s.decayFadeDurationFrames;
                    c.alpha = (0.95 * (1 - p)) * c.brightness;
                }
            }
        }

        class PulseEffect {
            constructor(g, c) { 
                this.g=g; this.c=c; this.active=false; this.state='IDLE'; this.origin={x:0,y:0}; this.radius=0; 
                
                this.snapChars = new Uint16Array(0); 
                this.snapColors = new Uint32Array(0); 
                this.snapAlphas = new Float32Array(0);
                this.snapFlags = new Uint8Array(0); 
                
                this.snapDims = {w:0, h:0}; this.autoTimer = c.state.pulseFrequencySeconds * 60; 
                this.maxDistPx = 0;
            }

            trigger() {
                if(this.active) return;
                const s = this.c.state; const d = this.c.derived; const total = this.g.cols * this.g.rows;
                
                if (this.snapChars.length !== total) {
                    this.snapChars = new Uint16Array(total); 
                    this.snapColors = new Uint32Array(total); 
                    this.snapAlphas = new Float32Array(total);
                    this.snapFlags = new Uint8Array(total); 
                }
                this.snapDims = {w: this.g.cols, h: this.g.rows};
                
                const attackEnd = d.cycleDuration; const holdEnd = d.cycleDuration + d.holdFrames;

                for(let y=0; y<this.g.rows; y++) {
                    for(let x=0; x<this.g.cols; x++) {
                        const idx = y * this.g.cols + x; 
                        const c = this.g.cells[y][x];
                        
                        let rgb = d.streamRgb;
                        let isTracer = false; 
                        
                        if (c.style) {
                            rgb = Utils.hslToRgb(c.style.h, c.style.s, c.style.l);
                            if(c.age > 0 && c.age < 10) isTracer = true; 
                        } else if(c.type === CELL_TYPE.TRACER || (c.type === CELL_TYPE.ROTATOR && c.age > 0)) {
                            const activeTime = c.age - 1;
                            if (activeTime >= attackEnd && activeTime < holdEnd) {
                                rgb = d.tracerRgb; 
                                isTracer = true; 
                            }
                        }

                        this.snapChars[idx] = c.char.charCodeAt(0);
                        this.snapColors[idx] = Utils.packRgb(rgb.r, rgb.g, rgb.b);
                        this.snapFlags[idx] = isTracer ? 1 : 0; 
                        
                        const isEmpty = (c.type === CELL_TYPE.EMPTY) || c.alpha < 0.05;
                        this.snapAlphas[idx] = isEmpty ? -1.0 : c.alpha;
                    }
                }

                this.origin = s.pulseRandomPosition ? 
                    {x:Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8), y:Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8)} : 
                    {x:Math.floor(this.g.cols/2), y:Math.floor(this.g.rows/2)};
                
                this.active = true; this.state = 'WAITING'; this.timer = s.pulseDelayFrames; 
                this.radius = 0;

                const cellW = d.cellWidth * s.stretchX;
                const cellH = d.cellHeight * s.stretchY;
                const distLeft = this.origin.x * cellW;
                const distRight = (this.g.cols - this.origin.x) * cellW;
                const distTop = this.origin.y * cellH;
                const distBottom = (this.g.rows - this.origin.y) * cellH;

                this.maxDistPx = Math.max(distLeft, distRight, distTop, distBottom);
                this.speed = (this.maxDistPx + 100) / Math.max(1, s.pulseDurationSeconds * 60);
            }

            update() {
                const s = this.c.state;
                if(!this.active && s.pulseEnabled) { if(this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; } }
                if(!this.active) return;
                
                if (this.snapDims.w !== this.g.cols || this.snapDims.h !== this.g.rows) { this.active = false; return; }
                
                if(this.state==='WAITING') { 
                    if(--this.timer<=0) this.state='EXPANDING'; 
                } else {
                    this.radius += this.speed; 
                    if(this.radius > this.maxDistPx + 100) { this.active = false; }
                }
            }

            getOverride(x, y) {
                if(!this.active) return null;
                const idx = y * this.g.cols + x;
                if (idx >= this.snapChars.length) return null;
                
                const s = this.c.state;
                const d = this.c.derived;
                const snAlpha = this.snapAlphas[idx];
                const isEmpty = snAlpha < 0;
                
                const charCode = this.snapChars[idx]; 
                const rgbPacked = this.snapColors[idx]; 
                const isTracer = this.snapFlags[idx] === 1;
                
                const rgb = Utils.unpackRgb(rgbPacked); 
                const charStr = String.fromCharCode(charCode);
                const blank = { char: ' ', color: {r:0,g:0,b:0}, alpha: 0, glow: 0 };
                const dimFactor = s.pulseDimming; 
                
                if(this.state === 'WAITING') {
                    // During wait, Tracers stay bright if ignored
                    if (isTracer && s.pulseIgnoreTracers) return { char: charStr, color: d.tracerRgb, alpha: 1.0, glow: s.tracerGlow };
                    return isEmpty ? blank : { char: charStr, color: rgb, alpha: snAlpha * dimFactor, glow: 0 };
                }

                // Calculate Distance regardless of stretching
                const cellVisualW = d.cellWidth * s.stretchX;
                const cellVisualH = d.cellHeight * s.stretchY;
                const dx = Math.abs(x - this.origin.x) * cellVisualW;
                const dy = Math.abs(y - this.origin.y) * cellVisualH;
                const distPx = Math.max(dx, dy);
                const waveWidth = s.pulseWidth * (s.resolution * 2); 

                // 1. BEHIND WAVE -> REVEAL LIVE CODE (Null)
                // This must happen first. If the wave passed, we don't care if it's a tracer.
                if (distPx <= this.radius - waveWidth) {
                    return null;
                }

                // 2. TRACER PRESERVATION
                // If it hasn't been revealed yet, and it's a tracer, keep it bright.
                if (isTracer && s.pulseIgnoreTracers) {
                    return { char: charStr, color: d.tracerRgb, alpha: 1.0, glow: s.tracerGlow };
                }

                // 3. AHEAD OF WAVE -> DIMMED FROZEN STATE
                if (distPx > this.radius) {
                    return isEmpty ? blank : { char: charStr, color: rgb, alpha: snAlpha * dimFactor, glow: 0 };
                } 
                // 4. INSIDE WAVE -> BRIGHT PULSE
                else {
                    if (isEmpty && s.pulsePreserveSpaces) return blank;
                    const relPos = (this.radius - distPx) / waveWidth;
                    const waveAlpha = 1.0 - (relPos * 0.5); 
                    // Note: If you want tracers to turn White inside the wave instead of staying their Color,
                    // The step 2 check above prevents that. If you want the Wave to wash over tracers white,
                    // move Step 2 below this block. Currently, Step 2 preserves Tracer Color through the wave.
                    return { char: charStr, color: d.tracerRgb, alpha: waveAlpha, glow: 30, size: 4 };
                }
            }
        }

        class DejaVuEffect {
            constructor(g, c) {
                this.g = g; this.c = c; this.active = false; this.eventTimer = 0;
                this.autoTimer = c.state.dejaVuFrequencySeconds * 60; this.bars = []; this.rowMap = null; 
            }
            trigger() {
                if(this.active) return;
                const s = this.c.state; this.active = true; this.eventTimer = s.dejaVuDurationSeconds * 60;
                this.bars = []; this.rowMap = new Uint8Array(this.g.rows);
            }
            update() {
                const s = this.c.state;
                if (!this.active && s.dejaVuEnabled && s.dejaVuAutoMode) { if (this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.dejaVuFrequencySeconds * 60; } }
                if (!this.active) return;
                if (this.eventTimer-- <= 0) { this.active = false; this.bars = []; this.rowMap = null; return; }
                
                if (!this.rowMap || this.rowMap.length !== this.g.rows) { this.rowMap = new Uint8Array(this.g.rows); } else { this.rowMap.fill(0); }
                
                if (Math.random() < s.dejaVuIntensity) {
                    const limit = Math.floor(this.g.rows * 0.5); 
                    const maxH = Math.min(limit, s.dejaVuMaxRectHeight);
                    const minH = Math.min(maxH, Math.max(1, s.dejaVuMinRectHeight));
                    const h = Utils.randomInt(minH, maxH);
                    const y = Utils.randomInt(0, Math.max(0, this.g.rows - h));
                    const dur = s.dejaVuBarDurationFrames + Utils.randomInt(-s.dejaVuVarianceFrames, s.dejaVuVarianceFrames);
                    this.bars.push({ y: y, height: h, age: 0, maxAge: Math.max(5, dur) });
                }
                
                for (let i = this.bars.length - 1; i >= 0; i--) {
                    const b = this.bars[i]; b.age++;
                    if (b.age >= b.maxAge) { this.bars.splice(i, 1); } else {
                        for (let r = b.y; r < b.y + b.height && r < this.g.rows; r++) { this.rowMap[r] = 1; }
                    }
                }
                
                if (this.rowMap) {
                    for (let y = 0; y < this.g.rows; y++) {
                        if (this.rowMap[y] === 1) {
                            for (let x = 0; x < this.g.cols; x++) { 
                                if (Math.random() < 0.1) { 
                                    const cell = this.g.cells[y][x];
                                    
                                    // 1. Kill the rotation timer. This prevents the renderer from 
                                    //    attempting to crossfade the new glitch char with the old history.
                                    cell.rotatorProg = 0;
                                    
                                    // 2. Rewrite the character (The Glitch)
                                    //    We set nextChar to match char to ensure visual stability.
                                    const newChar = Utils.getRandomChar();
                                    cell.char = newChar;
                                    cell.nextChar = newChar;

                                    // 3. Mutate Color (Sticky Logic)
                                    if (s.dejaVuRandomizeColors) {
                                        // Only apply color glitch once to prevent strobing
                                        if (cell.style && cell.style.glitched) continue;

                                        cell.style = { 
                                            h: Utils.randomInt(0, 360), 
                                            s: Utils.randomInt(80, 100), 
                                            l: Utils.randomInt(50, 90), 
                                            cycle: false, 
                                            speed: 0, 
                                            glitter: false,
                                            glitched: true 
                                        };
                                        cell.brightness = Utils.randomFloat(0.5, 1.0);
                                    }
                                } 
                            }
                        }
                    }
                }
            }
            getOverride(x, y) {
                if (!this.active || !this.rowMap || this.rowMap.length <= y) return null;
                if (this.rowMap[y] === 1) {
                    const s = this.c.state; const cell = this.g.cells[y][x];
                    let alpha = 1.0;
                    const isHole = (cell.type === CELL_TYPE.EMPTY || (cell.decay > 0 && cell.alpha < 0.1));
                    if (isHole) { alpha = s.dejaVuHoleBrightness; if (alpha <= 0.01) return null; }
                    return { char: cell.char, color: this.c.derived.tracerRgb, alpha: alpha, glow: 20 * alpha, size: 2 };
                }
                return null;
            }
        }

       class MatrixRenderer {
            constructor(canvasId, grid, config) {
                this.cvs = document.getElementById(canvasId);
                this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.bloomCvs = document.getElementById('bloomCanvas');
                this.bloomCtx = this.bloomCvs.getContext('2d', { alpha: true });
                this.grid = grid; this.config = config;
                this.resizeTimer = null; this.frameCount = 0;
                
                this._onResize = () => { clearTimeout(this.resizeTimer); this.resizeTimer = setTimeout(() => this.resize(), 100); };
                window.addEventListener('resize', this._onResize);
                
                this.config.subscribe((k, s) => {
                    if (k === 'smoothingEnabled' || k === 'smoothingAmount' || k === 'ALL') this.applyStyles();
                    if (k === 'resolution' || k === 'stretchX' || k === 'stretchY' || k === 'fontSize' || k === 'horizontalSpacingFactor' || k === 'verticalSpacingFactor') this.resize();
                });
                this.resize(); this.applyStyles();
            }
            
            dispose() {
                window.removeEventListener('resize', this._onResize);
            }

            applyStyles() {
                const s = this.config.state;
                const blur = s.smoothingEnabled ? `${s.smoothingAmount}px` : '0px';
                this.cvs.style.filter = `blur(${blur})`;
            }
            resize() {
                const s = this.config.state;
                this.w = window.innerWidth; this.h = window.innerHeight;
                const scale = s.resolution;
                this.cvs.width = this.w * scale; this.cvs.height = this.h * scale;
                this.cvs.style.width = this.w + "px"; this.cvs.style.height = this.h + "px";
                this.bloomCvs.width = (this.w * scale) * 0.25; this.bloomCvs.height = (this.h * scale) * 0.25; 
                this.bloomCtx.scale(0.25, 0.25);
                this.grid.resize(this.w / s.stretchX, this.h / s.stretchY);
            }

            _renderDeterioratedCell(ctx, cell, x, y, alpha, s, d, bloomCtx) {
                const decayProg = Math.min(1, (cell.decay - 1) / s.decayFadeDurationFrames);
                
                // 1. Calculate Shrink/Dissolve (Local Logic)
                let currentFont = d.fontBaseStr;
                
                if (s.dissolveEnabled && cell.decay >= 2) {
                    const targetSize = Math.max(1, s.dissolveMinSize); 
                    const reduction = s.fontSize - targetSize;
                    const sizeOffset = -(reduction * decayProg);
                    // Reconstruct font string for the new size
                    currentFont = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${Math.max(1, s.fontSize + sizeOffset)}px ${s.fontFamily}`;
                }

                ctx.save();
                ctx.font = currentFont;
                if(bloomCtx) { bloomCtx.save(); bloomCtx.font = currentFont; }

                // 2. Draw Ghosts (Background Layer) 
                // At start of decay (0%), ghostAlpha is 0 (Invisible). 
                // As it dies (100%), ghostAlpha increases. This prevents "Pop-in" brightness.
                const ghostAlpha = alpha * decayProg * 0.4; // 0.4 cap to keep it subtle
                const offsetAmount = s.deteriorationStrength * decayProg;

                if (ghostAlpha > 0.01) {
                    ctx.globalAlpha = ghostAlpha;
                    if (bloomCtx) bloomCtx.globalAlpha = ghostAlpha;

                    // Ghost 1 (Up)
                    ctx.fillText(cell.char, x, y - offsetAmount);
                    if (bloomCtx) bloomCtx.fillText(cell.char, x, y - offsetAmount);

                    // Ghost 2 (Down)
                    ctx.fillText(cell.char, x, y + offsetAmount);
                    if (bloomCtx) bloomCtx.fillText(cell.char, x, y + offsetAmount);
                }

                // 3. Draw Core (Foreground Layer)
                // Drawn LAST so it stays on top of the blur
                ctx.globalAlpha = alpha;
                if (bloomCtx) bloomCtx.globalAlpha = alpha;
                
                ctx.fillText(cell.char, x, y);
                if (bloomCtx) bloomCtx.fillText(cell.char, x, y);

                if(bloomCtx) bloomCtx.restore();
                ctx.restore();
            }

            render(frame) {
                this.frameCount = frame;
                const s = this.config.state;
                const d = this.config.derived;
                const bloom = s.enableBloom;
                const scale = s.resolution;
                
                this.ctx.save();
                this.ctx.scale(scale * s.stretchX, scale * s.stretchY);
                this.ctx.fillStyle = `rgba(0,0,0,${s.clearAlpha})`;
                this.ctx.fillRect(0, 0, this.w / s.stretchX, this.h / s.stretchY);
                if (bloom) this.bloomCtx.clearRect(0, 0, this.w * scale, this.h * scale);
                
                const fontBase = d.fontBaseStr;
                let currentFont = fontBase;
                this.ctx.font = fontBase; this.ctx.textBaseline = 'middle'; this.ctx.textAlign = 'center';
                
                this.ctx.save(); 
                
                if (s.mirrorEnabled) {
                    this.ctx.scale(-1, 1); 
                    this.ctx.translate(-(this.w / s.stretchX), 0); 
                }

                if (bloom) {
                    this.bloomCtx.font = fontBase; this.bloomCtx.textBaseline = 'middle'; this.bloomCtx.textAlign = 'center';
                    this.bloomCtx.save(); 
                    this.bloomCtx.scale(scale * s.stretchX, scale * s.stretchY); 
                    if(s.mirrorEnabled) {
                        this.bloomCtx.scale(-1, 1); 
                        this.bloomCtx.translate(-(this.w / s.stretchX), 0);
                    }
                }
                
                const defaultStreamColor = d.streamColorStr;
                this.ctx.fillStyle = defaultStreamColor; this.ctx.shadowBlur = 0; this.ctx.shadowColor = defaultStreamColor;
                if(bloom) this.bloomCtx.fillStyle = defaultStreamColor;

                let lastColor = defaultStreamColor;
                const yOffset = s.fontOffsetY || 0;
                const xOffset = s.fontOffsetX || 0;

                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (cell.override) continue; 
                        
                        const px = ((x * d.cellWidth + d.cellWidth * 0.5) + xOffset) | 0;
                        const py = ((y * d.cellHeight + d.cellHeight * 0.5) + yOffset) | 0;
                        
                        // Calculate base alpha and shrink offset (for standard rendering)
                        let sizeOffset = 0; let drawAlpha = 0;
                        if (cell.age > 0) { drawAlpha = cell.crossFadeAlpha * cell.brightness; } else if (cell.decay > 0) {
                            drawAlpha = cell.alpha;
                            if (s.dissolveEnabled && cell.decay >= 2) {
                               const prog = (cell.decay - 2) / s.decayFadeDurationFrames;
                               const targetSize = Math.max(1, s.dissolveMinSize); 
                               const reduction = s.fontSize - targetSize;
                               sizeOffset = -(reduction * prog);
                            }
                        }
                        
                        if (drawAlpha > 0.01) {
                            let currentColor = defaultStreamColor;
                            if (cell.style) {
                                if (cell.style.glitter && Math.random() < 0.02) {
                                    currentColor = '#ffffff';
                                } else {
                                    let h = cell.style.h;
                                    if (cell.style.cycle) { h = (h + (this.frameCount * cell.style.speed)) % 360; }
                                    currentColor = Utils.getCachedHsl(h | 0, cell.style.s, cell.style.l);
                                }
                            }

                            if (currentColor !== lastColor) {
                                this.ctx.fillStyle = currentColor; this.ctx.shadowColor = currentColor;
                                if (bloom) this.bloomCtx.fillStyle = currentColor;
                                lastColor = currentColor;
                            }

                            // 1. Check for Rotator Crossfade FIRST
                            if (cell.rotatorProg > 0 && s.rotatorCrossfadeFrames > 2) {
                                const p = cell.rotatorProg / s.rotatorCrossfadeFrames;
                                const aOld = drawAlpha * (1.0 - p);
                                const aNew = drawAlpha * p;
                                
                                if(currentFont !== fontBase) { this.ctx.font = fontBase; currentFont = fontBase; }
                                
                                this.ctx.globalAlpha = aOld; this.ctx.fillText(cell.char, px, py);
                                this.ctx.globalAlpha = aNew; this.ctx.fillText(cell.nextChar, px, py);
                                if(bloom) { this.bloomCtx.globalAlpha = drawAlpha; this.bloomCtx.fillText(p > 0.5 ? cell.nextChar : cell.char, px, py); }
                            }
                            // 2. Then check for Deterioration (Blur/Ghosting)
                            else if (cell.decay > 0 && s.deteriorationEnabled) {
                                // Pass 'd' (derived) so we can access fontBaseStr
                                this._renderDeterioratedCell(this.ctx, cell, px, py, drawAlpha, s, d, bloom ? this.bloomCtx : null);
                            } 
                            // 3. Fallback to Standard Render
                            else {
                                this.ctx.globalAlpha = drawAlpha;
                                if (Math.abs(sizeOffset) > 0.5) {
                                    const targetSize = Math.floor(Math.max(1, s.fontSize + sizeOffset));
                                    const tempFont = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${targetSize}px ${s.fontFamily}`;
                                    if(currentFont !== tempFont) { this.ctx.font = tempFont; currentFont = tempFont; }
                                    this.ctx.fillText(cell.char, px, py);
                                    if (bloom) { this.bloomCtx.globalAlpha = drawAlpha; this.bloomCtx.fillText(cell.char, px, py); }
                                    if(currentFont !== fontBase) { this.ctx.font = fontBase; currentFont = fontBase; }
                                } else {
                                    if(currentFont !== fontBase) { this.ctx.font = fontBase; currentFont = fontBase; }
                                    this.ctx.fillText(cell.char, px, py);
                                    if (bloom) { this.bloomCtx.globalAlpha = drawAlpha; this.bloomCtx.fillText(cell.char, px, py); }
                                }
                            }
                            // --- FIX END ---
                        }
                    }
                }
                
                const tStr = d.tracerColorStr;
                this.ctx.fillStyle = tStr; this.ctx.shadowBlur = s.tracerGlow; this.ctx.shadowColor = tStr;
                const tFont = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${s.fontSize + s.tracerSizeIncrease}px ${s.fontFamily}`;
                this.ctx.font = tFont; currentFont = tFont; 
                if(bloom) { this.bloomCtx.fillStyle = tStr; this.bloomCtx.font = tFont; }
                
                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (cell.override) continue; 
                        if (cell.age > 0 && cell.alpha > 0.01) { 
                            const px = ((x * d.cellWidth + d.cellWidth * 0.5) + xOffset) | 0;
                            const py = ((y * d.cellHeight + d.cellHeight * 0.5) + yOffset) | 0;
                            
                            let tColor = tStr;
                            if (cell.style && s.starPowerEnabled && cell.style.cycle) {
                                let h = (cell.style.h + (this.frameCount * cell.style.speed)) % 360;
                                tColor = Utils.getCachedHsl(h | 0, 100, 85); 
                                this.ctx.fillStyle = tColor; this.ctx.shadowColor = tColor; 
                                if (bloom) this.bloomCtx.fillStyle = tColor;
                            } else {
                                this.ctx.fillStyle = tStr; this.ctx.shadowColor = tStr;
                                if(bloom) this.bloomCtx.fillStyle = tStr;
                            }

                            this.ctx.globalAlpha = cell.alpha; this.ctx.fillText(cell.char, px, py);
                            if (bloom) { this.bloomCtx.globalAlpha = cell.alpha; this.bloomCtx.fillText(cell.char, px, py); }
                        }
                    }
                }
                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (!cell.override) continue;
                        const o = cell.override;
                        const px = ((x * d.cellWidth + d.cellWidth * 0.5) + xOffset) | 0;
                        const py = ((y * d.cellHeight + d.cellHeight * 0.5) + yOffset) | 0;
                        const c = o.color;
                        const fill = `rgb(${c.r},${c.g},${c.b})`;
                        this.ctx.fillStyle = fill; this.ctx.shadowBlur = o.glow || 0; this.ctx.shadowColor = fill;
                        const oFont = `${s.italicEnabled?'italic':''} ${s.fontWeight} ${s.fontSize + (o.size || 0)}px ${s.fontFamily}`;
                        if(currentFont !== oFont) { this.ctx.font = oFont; currentFont = oFont; }
                        const alpha = o.alpha !== undefined ? o.alpha : 1.0;
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillText(o.char, px, py);
                        if (bloom) {
                            this.bloomCtx.fillStyle = fill; this.bloomCtx.font = oFont;
                            this.bloomCtx.globalAlpha = alpha; this.bloomCtx.fillText(o.char, px, py);
                        }
                    }
                }
                this.ctx.globalAlpha = 1.0; this.ctx.restore(); this.ctx.restore(); 
                if (bloom) {
                    this.bloomCtx.restore(); this.ctx.save();
                    this.ctx.globalCompositeOperation = 'lighter';
                    this.ctx.filter = `blur(${s.bloomStrength * 4}px)`;
                    this.ctx.globalAlpha = s.bloomOpacity; 
                    this.ctx.drawImage(this.bloomCvs, 0, 0, this.w * scale, this.h * scale);
                    this.ctx.restore(); 
                }
                this.ctx.restore(); 
            }
        }
    

        // --- 6. UI MANAGER ---
        class UIManager {
            constructor(c, eff, fontMgr) {
                this.c = c; this.eff = eff; this.fontMgr = fontMgr;
                this.els = {
                    panel: document.getElementById('settingsPanel'), toggle: document.getElementById('menuToggle'),
                    tabs: document.getElementById('navTabs'), content: document.getElementById('contentArea'),
                    status: document.getElementById('globalStatus'), file: document.getElementById('importFile'),
                    fontFile: document.getElementById('importFontFile')
                };
                
                // PHYSICS STATE
                this.scrollState = { 
                    position: 0, 
                    velocity: 0, 
                    isDragging: false, 
                    startX: 0,
                    lastX: 0,
                    dragDistance: 0, 
                    isAnimating: false 
                };
                
                this.tooltip = null; this.toastContainer = null;
                this.ignoreNextClick = false;

                this.fontMgr.subscribe((fonts) => {
                    this.refresh('fontFamily', this.c.state); 
                    this.updateFontListUI(fonts);
                });

                this.getFontOptions = () => {
                    const bases = [
                        {label: 'Gothic (Win)', value: '"MS Gothic", monospace'},
                        {label: 'Console', value: 'Consolas, monaco, monospace'}
                    ];
                    const customs = this.fontMgr.getCustomFonts();
                    return [...bases, ...customs];
                };
                
               this.defs = [
                    // =========================================================
                    // TAB 1: GLOBAL (Most commonly changed)
                    // =========================================================
                    { category: 'Global', type: 'header', label: 'Main Look & Feel' },
                    { category: 'Global', id: 'streamColor', type: 'color', label: 'Code Color' },
                    { category: 'Global', id: 'streamSpeed', type: 'range', label: 'Flow Speed', min: 4, max: 20, description: 'Falling code speed control.' },
                    
                    { category: 'Global', type: 'header', label: 'Glow & Atmosphere' },
                    { category: 'Global', id: 'enableBloom', type: 'checkbox', label: 'Enable Code Glow' },
                    { category: 'Global', id: 'bloomStrength', type: 'range', label: 'Glow Radius', min: 1, max: 10, unit: 'px', dep: 'enableBloom' },
                    { category: 'Global', id: 'bloomOpacity', type: 'range', label: 'Glow Intensity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
                    { category: 'Global', id: 'clearAlpha', type: 'range', label: 'Burn-in', hideValue: true, min: 0.05, max: 1.0, step: 0.05, invert: true, description: 'Simulates old CRT monitors by holding the image on the display.' },
                    
                    { category: 'Global', type: 'header', label: 'Display & Quality' },
                    { category: 'Global', id: 'resolution', type: 'range', label: 'Resolution Scale', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x', description: 'Lower for performance, higher for sharpness.' },
                    { category: 'Global', id: 'smoothingEnabled', type: 'checkbox', label: 'Anti-Aliasing' },
                    { category: 'Global', id: 'smoothingAmount', type: 'range', label: 'Blur Amount', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: 'smoothingEnabled' },

                    // =========================================================
                    // TAB 2: GLYPHS (Code appearance)
                    // =========================================================
                    { category: 'Glyphs', type: 'header', label: 'Font Selection' },
                    { category: 'Glyphs', id: 'fontFamily', type: 'select', label: 'Font Family', options: () => this.getFontOptions() },
                    { category: 'Glyphs', type: 'font_manager_list' },
                    { category: 'Glyphs', id: 'btnImportFont', type: 'button', label: 'Import Font File (.ttf/.otf)', btnClass: 'btn-info', action: 'importFont' },
                    
                    { category: 'Glyphs', type: 'header', label: 'Character Styling' },
                    { category: 'Glyphs', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 80, unit: 'px' },
                    { category: 'Glyphs', id: 'fontWeight', type: 'select', label: 'Weight', options: [{label: 'Thin', value: '100'}, {label: 'Light', value: '300'}, 
                        {label: 'Normal', value: 'normal'}, {label: 'Bold', value: 'bold'}, {label: 'Heavy', value: '900'}] },
                    { category: 'Glyphs', id: 'italicEnabled', type: 'checkbox', label: 'Italicize' },
                    { category: 'Glyphs', id: 'mirrorEnabled', type: 'checkbox', label: 'Mirror / Flip Text', description: 'Flips the screen horizontally.' },
                    { category: 'Glyphs', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness', description: 'When written, individual characters may have a slightly different brightness.' },
                    { category: 'Glyphs', id: 'brightnessVariance', type: 'range', label: 'Brightness Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled', description: 'When written, the difference in % between the dimmest and brightest character.' },

                    { category: 'Glyphs', type: 'header', label: 'Grid & Spacing' },
                    { category: 'Glyphs', id: 'horizontalSpacingFactor', type: 'range', label: 'Column Gap', min: 0.5, max: 2.0, step: 0.05 },
                    { category: 'Glyphs', id: 'verticalSpacingFactor', type: 'range', label: 'Row Gap', min: 0.5, max: 2.0, step: 0.05 },
                    { category: 'Glyphs', id: 'fontOffsetX', type: 'range', label: 'Cell Offset X', min: -20, max: 20, unit: 'px' },
                    { category: 'Glyphs', id: 'fontOffsetY', type: 'range', label: 'Cell Offset Y', min: -20, max: 20, unit: 'px' },
                    { category: 'Glyphs', id: 'stretchX', type: 'range', label: 'View Window Stretch X', min: 0.5, max: 3.0, step: 0.1 },
                    { category: 'Glyphs', id: 'stretchY', type: 'range', label: 'View WIndow Stretch Y', min: 0.5, max: 3.0, step: 0.1 },

                    // =========================================================
                    // TAB 3: STREAMS (Physics and tweaks)
                    // =========================================================
                    { category: 'Streams', type: 'header', label: 'Stream Density' },
                    { category: 'Streams', id: 'streamMinLength', type: 'range', label: 'Min Length', min: 5, max: 100, unit: 'chars', description: 'The length in characters the shortest a code stream can be.' },
                    { category: 'Streams', id: 'streamMaxLength', type: 'range', label: 'Max Length', min: 20, max: 500, unit: 'chars', description: 'The length in characters the longest a code stream can be.' },
                    { category: 'Streams', id: 'holeRate', type: 'range', label: 'Gaps / Broken Code', min: 0, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%' },
                    
                    { category: 'Streams', type: 'header', label: 'Life Cycle' },
                    { category: 'Streams', id: 'ttlMinFrames', type: 'range', label: 'Min Life', min: 10, max: 400, unit: 'fr', description: 'The minimum duration in time a stream can live before being erased. ' },
                    { category: 'Streams', id: 'ttlMaxFrames', type: 'range', label: 'Max Life', min: 100, max: 600, unit: 'fr', description: 'The maximum duration in time a stream can live before being erased. ' },
                    
                    { category: 'Streams', type: 'header', label: 'Deterioration (Fading)' },
                    { category: 'Streams', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out Speed', min: 1, max: 120, unit:'fr', description: 'How long it takes for a stream to fade away.' },
                    { category: 'Streams', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolve (Shrink) Effect' }, 
                    { category: 'Streams', id: 'dissolveMinSize', type: 'range', label: 'Dissolve Target Size', min: 1, max: 20, unit:'px', dep: 'dissolveEnabled', 
                        description: 'When fading out, it will fade to this size. If your font is small, this can get larger as it fades.' },
                    { category: 'Streams', id: 'deteriorationEnabled', type: 'checkbox', label: 'Enable Ghosting', description: 'Makes the text fuzzy as it fades away.' },
                    { category: 'Streams', id: 'deteriorationStrength', type: 'range', label: 'Ghost Distance', min: 1, max: 10, unit: 'px', dep: 'deteriorationEnabled', description: 'How far the ghost text drifts from the center as it fades.' },

                    { category: 'Streams', type: 'header', label: 'Visual Variation' },
                    { category: 'Streams', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Inverted Tracers', description: 'Tracers that are invisible, and write only occasionally.'},
                    { category: 'Streams', id: 'invertedTracerChance', type: 'range', label: 'Inverted Tracer Likelihood', min: 0.05, max: 0.5, step: 0.05, dep: 'invertedTracerEnabled' },

                    // =========================================================
                    // TAB 4: MUTATORS (Specifics)
                    // =========================================================
                    { category: 'Mutators', type: 'header', label: 'Tracers (Writing Characters)' },
                    { category: 'Mutators', id: 'tracerColor', type: 'color', label: 'Tracer Color' },
                    { category: 'Mutators', id: 'tracerGlow', type: 'range', label: 'Tracer Glow', min: 0, max: 50, unit:'px' },
                    { category: 'Mutators', id: 'tracerSizeIncrease', type: 'range', label: 'Size Boost', min: 0, max: 20, unit:'px', description: 'When writing, how much larger the tracer is compared to the font size.' },
                    { category: 'Mutators', id: 'randomStopEnabled', type: 'checkbox', label: 'Random Fallout', description:'Tracers that will immediately stop writing and disappear.' },
                    { category: 'Mutators', id: 'randomStopChance', type: 'range', label: 'Pause Likelihood', min: 0.01, max: 0.2, step: 0.01, dep: 'randomStopEnabled' },

                    { category: 'Mutators', type: 'header', label: 'Rotators (Changing Chars)' },
                    { category: 'Mutators', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
                    { category: 'Mutators', id: 'rotatorChance', type: 'range', label: 'Spawn Chance', min: 0, max: 0.2, step: 0.01, dep: 'rotatorEnabled' },
                    { category: 'Mutators', id: 'rotatorSyncToTracer', type: 'checkbox', label: 'Sync to Tracer cycles', dep: 'rotatorEnabled', description: 'Locks rotation changes to tracer movements.' },
                    { 
                        category: 'Mutators', 
                        id: 'rotatorSyncMultiplier', 
                        type: 'range', 
                        label: 'Sync Divider', 
                        min: .1, 
                        max: 1, 
                        step: .1, 
                        dep: ['rotatorEnabled','rotatorSyncToTracer'], 
                        transform: v => v + 'x', 
                        description: 'How many times the tracer steps to a new cell before a tracer rotates. Better use at higher speeds.'
                    },
                    { category: 'Mutators', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 20, dep: ['rotatorEnabled', '!rotatorSyncToTracer']},
                    { category: 'Mutators', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Crossfade Smoothness', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },

                    // =========================================================
                    // TAB 5: GLYPH-FX (Special, fun things)
                    // =========================================================
                    { category: 'Glyph-FX', type: 'header', label: 'Star Power' },
                    { category: 'Glyph-FX', id: 'starPowerEnabled', type: 'checkbox', label: 'Enable Star Power', description:'Gives the lead tracer "Star Power" as it writes.'},
                    { category: 'Glyph-FX', id: 'starPowerFreq', type: 'range', label: 'Spawn Rate', min: 5, max: 100, dep: 'starPowerEnabled', unit:'%' },
                    { category: 'Glyph-FX', id: 'starPowerRainbowMode', type: 'toggle', label: 'Color Mode', description:'The color changes and cycling are set as a group, or per-character.', 
                        options: { left: {label:'Full Stream', value:'stream'}, right: {label:'Per Char', value:'char'} }, dep: 'starPowerEnabled' },
                    { category: 'Glyph-FX', id: 'starPowerColorCycle', type: 'checkbox', label: 'Cycle Colors', dep: 'starPowerEnabled' },
                    { category: 'Glyph-FX', id: 'starPowerCycleSpeed', type: 'range', label: 'Cycle Speed', min: 1, max: 20, dep: 'starPowerEnabled' },
                    { category: 'Glyph-FX', id: 'starPowerGlitter', type: 'checkbox', label: 'Glitter / Sparkle', dep: 'starPowerEnabled' },
                    { category: 'Glyph-FX', id: 'starPowerSaturation', type: 'range', label: 'Saturation', min: 0, max: 100, unit:'%', dep: 'starPowerEnabled' },
                    { category: 'Glyph-FX', id: 'starPowerIntensity', type: 'range', label: 'Intensity', min: 10, max: 90, unit:'%', dep: 'starPowerEnabled' },

                    { category: 'Glyph-FX', type: 'header', label: 'Rainbow Streams' },
                    { category: 'Glyph-FX', id: 'rainbowStreamEnabled', type: 'checkbox', label: 'Enable Rainbow Streams', description:'Spawns streams of random colors.' },
                    { category: 'Glyph-FX', id: 'rainbowStreamChance', type: 'range', label: 'Spawn Chance', min: 0.05, max: 1.0, step: 0.05, dep: 'rainbowStreamEnabled', transform: v=>(v*100).toFixed(0)+'%' },
                    { category: 'Glyph-FX', id: 'rainbowStreamIntensity', type: 'range', label: 'Brightness', min: 10, max: 90, unit: '%', dep: 'rainbowStreamEnabled' },

                    // =========================================================
                    // TAB 6: EVENTS (Special FX)
                    // =========================================================
                    { category: 'Events', type: 'header', label: 'Pulse Wave' },
                    { category: 'Events', id: 'btnManPulse', type: 'button', label: 'Trigger Pulse Now', btnClass: 'btn-warn', action: 'triggerPulse' },
                    { category: 'Events', id: 'pulseEnabled', type: 'checkbox', label: 'Enable Pulses' },
                    { category: 'Events', id: 'pulseFrequencySeconds', type: 'range', label: 'Frequency', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Events', id: 'pulseDurationSeconds', type: 'range', label: 'Duration', min: 0.1, max: 5, step: 0.1, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Events', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Origin', dep: 'pulseEnabled' },
                    { category: 'Events', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled', description:'Keeps the spaces when pulsing.' },
                    { category: 'Events', id: 'pulseWidth', type: 'range', label: 'Wave Width', min: 10, max: 400, step: 10, unit:'px', dep: 'pulseEnabled', description: 'Thickness of the expanding white square.' },
                    { category: 'Events', id: 'pulseDimming', type: 'range', label: 'Background Dimming', min: 0.0, max: 1.0, step: 0.05, dep: 'pulseEnabled', description: 'How dark the frozen code becomes before the wave hits (0 = Invisible, 1 = Full Brightness).' },
                    { category: 'Events', id: 'pulseIgnoreTracers', type: 'checkbox', label: 'Keep Tracer Glow', dep: 'pulseEnabled', dep: 'pulseEnabled', description: 'Tracers remain fully illuminated during the pulse wave.' },

                    { category: 'Events', type: 'header', label: 'Deja Vu' },
                    { category: 'Events', id: 'btnManDejaVu', type: 'button', label: 'Trigger Deja Vu Now', btnClass: 'btn-warn', action: 'triggerDejaVu' },
                    { category: 'Events', id: 'dejaVuEnabled', type: 'checkbox', label: 'Enable Deja Vu' },
                    // { category: 'Events', id: 'dejaVuAutoMode', type: 'checkbox', label: 'Random Timer', dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuFrequencySeconds', type: 'range', label: 'Frequency', min: 30, max: 600, step: 10, unit: 's', dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuIntensity', type: 'range', label: 'Intensity', min: 0.01, max: 0.1, step: 0.01, dep: 'dejaVuEnabled', description:'How many strip-writers will be spawned at a time' },
                    { category: 'Events', id: 'dejaVuDurationSeconds', type: 'range', label: 'Total Duration', min: 1, max: 10, step: 0.1, unit: 's', dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuBarDurationFrames', type: 'range', label: 'Average Flash Duration', min: 10, max: 60, unit: 'fr', dep: 'dejaVuEnabled' ,description:'The typical time the individual flash remains on screen.'},
                    { category: 'Events', id: 'dejaVuVarianceFrames', type: 'range', label: 'Flash Duration Range', min: 0, max: 120, unit: 'fr', dep: 'dejaVuEnabled', description:'The duration a flash could be shorter or longer.' },
                    { category: 'Events', id: 'dejaVuMinRectHeight', type: 'range', label: 'Min Strip Height', min: 1, max: 20, unit: 'rows', dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuMaxRectHeight', type: 'range', label: 'Max Strip Height', min: 5, max: 50, unit: 'rows', dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuHoleBrightness', type: 'range', label: 'Hole Brightness', min: 0, max: 1, step: 0.01, dep: 'dejaVuEnabled' },
                    { category: 'Events', id: 'dejaVuRandomizeColors', type: 'checkbox', label: 'Include Colors', dep: 'dejaVuEnabled', description: 'When glitching, randomize the color and brightness of the characters.' },

                    // =========================================================
                    // TAB 7: SYSTEM (Utility)
                    // =========================================================
                    { category: 'System', type: 'header', label: 'Save Slots' },
                    { category: 'System', id: 'slot0', type: 'slot', index: 0 },
                    { category: 'System', id: 'slot1', type: 'slot', index: 1 },
                    { category: 'System', id: 'slot2', type: 'slot', index: 2 },

                    { category: 'System', type: 'header', label: 'Data Management' },
                    { category: 'System', id: 'btnExport', type: 'button', label: 'Export Config (JSON)', btnClass: 'btn-info', action: 'export' },
                    { category: 'System', id: 'btnImport', type: 'button', label: 'Import Config (JSON)', btnClass: 'btn-info', action: 'import' },
                    { category: 'System', id: 'btnClearCache', type: 'button', label: 'Clear Font Cache', btnClass: 'btn-warn', action: 'clearCache' },
                    
                    { category: 'System', type: 'header', label: 'CAUTION ZONE' },
                    { category: 'System', id: 'btnForceReset', type: 'button', label: 'Factory Reset All', btnClass: 'btn-danger', action: 'reset' },
                    
                    { category: 'About', type: 'about_content' }
                ];
                this.init();
            }

            init() {
                this.els.toggle.addEventListener('click', () => this.els.panel.classList.toggle('open'));
                this.els.file.addEventListener('change', (e) => this.handleImport(e));
                this.els.fontFile.addEventListener('change', (e) => {
                    const f = e.target.files[0];
                    if(!f) return;
                    this.fontMgr.importFont(f, (success, msg) => {
                        this.showStatus(msg, success ? 'success' : 'error');
                        e.target.value = '';
                    });
                });

                this.c.subscribe((k, s) => this.refresh(k, s));
                
                this.tabTrack = document.createElement('div');
                this.tabTrack.id = 'tabTrack';
                this.els.tabs.appendChild(this.tabTrack);
                this.tooltip = document.createElement('div'); this.tooltip.id = 'ui-tooltip'; document.body.appendChild(this.tooltip);
                this.toastContainer = document.createElement('div'); this.toastContainer.id = 'toast-container'; document.body.appendChild(this.toastContainer);

                // --- SLIDING DRAWER PHYSICS (Gel Damping) ---
                const startDrag = (x) => {
                    this.scrollState.isDragging = true;
                    this.scrollState.startX = x;
                    this.scrollState.lastX = x;
                    this.scrollState.velocity = 0;
                    this.scrollState.dragDistance = 0; 
                    this.scrollState.isAnimating = false;
                    this.ignoreNextClick = false;
                };

                const moveDrag = (x) => {
                    if (!this.scrollState.isDragging) return;
                    const delta = this.scrollState.lastX - x;
                    this.scrollState.lastX = x;
                    this.scrollState.velocity = delta;
                    
                    this.scrollState.dragDistance += Math.abs(delta);
                    if (this.scrollState.dragDistance > 3) this.ignoreNextClick = true;

                    // Hard Stop Clamp during Drag (No flex)
                    const trackWidth = this.tabTrack.scrollWidth;
                    const containerWidth = this.els.tabs.clientWidth;
                    const maxScroll = Math.max(0, trackWidth - containerWidth);
                    
                    this.scrollState.position += delta;
                    this.scrollState.position = Math.max(0, Math.min(this.scrollState.position, maxScroll));
                    
                    this.tabTrack.style.transform = `translateX(${-this.scrollState.position}px)`;
                };

                const endDrag = () => {
                    this.scrollState.isDragging = false;
                    this.startPhysicsAnimation();
                };

                this.els.tabs.addEventListener('mousedown', (e) => { e.preventDefault(); startDrag(e.clientX); });
                this.els.tabs.addEventListener('mousemove', (e) => { e.preventDefault(); moveDrag(e.clientX); });
                this.els.tabs.addEventListener('mouseup', endDrag);
                this.els.tabs.addEventListener('mouseleave', () => { if(this.scrollState.isDragging) endDrag(); });

                this.els.tabs.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientX), {passive:true});
                this.els.tabs.addEventListener('touchmove', (e) => moveDrag(e.touches[0].clientX), {passive:false});
                this.els.tabs.addEventListener('touchend', endDrag);

                this.els.tabs.addEventListener('wheel', (e) => {
                    if (e.deltaY !== 0) {
                        e.preventDefault();
                        this.scrollState.velocity += e.deltaY * 0.5;
                        this.startPhysicsAnimation();
                    }
                }, { passive: false });

                this.buildUI();

                // Sync initial state for all UI dependencies
                this.defs.forEach(d => {
                    if(d.id) this.refresh(d.id, this.c.state);
                });
            }

            startPhysicsAnimation() {
                if (this.scrollState.isAnimating) return;
                this.scrollState.isAnimating = true;
                this.updateScrollPhysics();
            }

            updateScrollPhysics() {
                if(this.scrollState.isDragging) { this.scrollState.isAnimating = false; return; }
                
                const s = this.scrollState;
                const trackWidth = this.tabTrack.scrollWidth;
                const containerWidth = this.els.tabs.clientWidth;
                const maxScroll = Math.max(0, trackWidth - containerWidth);
                
                // 1. Regular Friction
                s.velocity *= 0.95;

                // 2. "GEL" Damping Logic (Soft approach to edges)
                const GEL_ZONE = 60; // Pixels from edge where "gel" activates
                
                // Approaching Start (0) from right
                if (s.position < GEL_ZONE && s.velocity < 0) {
                    const factor = s.position / GEL_ZONE; // 0.0 (at edge) to 1.0 (start of zone)
                    // The closer to edge, the higher the friction (lower multiplier)
                    s.velocity *= (0.5 + (0.4 * factor)); 
                }
                // Approaching End (maxScroll) from left
                else if (s.position > maxScroll - GEL_ZONE && s.velocity > 0) {
                    const dist = maxScroll - s.position;
                    const factor = dist / GEL_ZONE;
                    s.velocity *= (0.5 + (0.4 * factor));
                }

                s.position += s.velocity;

                // 3. HARD STOP (No Rebound, No Flex)
                let hitWall = false;
                if (s.position < 0) {
                    s.position = 0;
                    s.velocity = 0;
                    hitWall = true;
                } else if (s.position > maxScroll) {
                    s.position = maxScroll;
                    s.velocity = 0;
                    hitWall = true;
                }

                this.tabTrack.style.transform = `translateX(${-s.position}px)`;

                if ((Math.abs(s.velocity) < 0.1) || hitWall) {
                    s.isAnimating = false;
                    s.velocity = 0;
                } else {
                    requestAnimationFrame(() => this.updateScrollPhysics());
                }
            }

            switchTab(cat, btn) {
                if (this.ignoreNextClick) return; 

                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.control-group').forEach(g => g.classList.remove('active'));
                btn.classList.add('active'); document.getElementById(`group-${cat}`).classList.add('active');
            }
            
            // --- Helper methods --- 
            showTooltip(text, target) {
                this.tooltip.textContent = text; this.tooltip.classList.add('visible');
                const rect = target.getBoundingClientRect(); const tipRect = this.tooltip.getBoundingClientRect();
                let top = rect.top + (rect.height / 2) - (tipRect.height / 2); let left = rect.left - tipRect.width - 12; 
                if (top < 10) top = 10; if (left < 10) left = rect.right + 12; 
                this.tooltip.style.top = `${top}px`; this.tooltip.style.left = `${left}px`;
            }
            hideTooltip() { this.tooltip.classList.remove('visible'); }

            createLabel(def) {
                const group = document.createElement('div'); group.className = 'control-label-group';
                const text = document.createElement('span'); text.textContent = def.label; group.appendChild(text);
                if (def.description) {
                    const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = '?';
                    icon.onmouseenter = (e) => this.showTooltip(def.description, e.target); icon.onmouseleave = () => this.hideTooltip();
                    icon.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if (this.tooltip.classList.contains('visible')) { this.hideTooltip(); } else { this.showTooltip(def.description, e.target); setTimeout(() => this.hideTooltip(), 3000); } });
                    group.appendChild(icon);
                }
                return group;
            }

            buildUI() {
                const cats = [...new Set(this.defs.map(d => d.category))];
                cats.forEach((cat, i) => {
                    const btn = document.createElement('button'); btn.className = `tab-btn ${i===0?'active':''}`; btn.textContent = cat;
                    btn.onclick = () => this.switchTab(cat, btn); this.tabTrack.appendChild(btn);
                    const group = document.createElement('div'); group.className = `control-group ${i===0?'active':''}`; group.id = `group-${cat}`;
                    this.defs.filter(d => d.category === cat).forEach(def => {
                        let el;
                        if(def.type === 'header') { el = document.createElement('div'); el.className = 'section-header'; el.textContent = def.label; }
                        else if(def.type === 'range') el = this.renderRange(def);
                        else if(def.type === 'color') el = this.renderColor(def);
                        else if(def.type === 'checkbox') el = this.renderCheckbox(def);
                        else if(def.type === 'toggle') el = this.renderToggle(def);
                        else if(def.type === 'slot') el = this.renderSlot(def);
                        else if(def.type === 'select') el = this.renderSelect(def);
                        else if(def.type === 'font_manager_list') el = this.renderFontManagerList();
                        else if(def.type === 'button') {
                            el = document.createElement('button'); el.className = `action-btn ${def.btnClass}`; el.textContent = def.label;
                            el.onclick = () => this.handleAction(def.action);
                        }
                        else if(def.type === 'about_content') el = this.renderAbout();
                        if(el) group.appendChild(el);
                    });
                    this.els.content.appendChild(group);
                });
            }

            renderAbout() {
                const div = document.createElement('div'); div.style.padding = '1rem'; div.style.textAlign = 'center'; div.style.color = '#86efac';
                div.innerHTML = `<h3 style="margin-top:0; margin-bottom: 1rem; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3><div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;"><p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p><p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p></div><p style="font-size:0.9rem;"><a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">github.com/enigmahack</a></p>`;
                return div;
            }
            
            renderSelect(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.appendChild(this.createLabel(def)); wrapper.appendChild(header);
                const select = document.createElement('select'); select.id = `in-${def.id}`;
                this._populateSelect(select, def);
                select.onchange = (e) => { this.c.set(def.id, e.target.value); }; wrapper.appendChild(select); return wrapper;
            }

            _populateSelect(select, def) {
                select.innerHTML = '';
                const opts = typeof def.options === 'function' ? def.options() : def.options;
                opts.forEach(opt => {
                    const option = document.createElement('option'); 
                    option.value = opt.value; 
                    option.textContent = opt.label;
                    if(opt.isCustom) option.className = 'custom-font-opt';
                    if (this.c.get(def.id) === opt.value) option.selected = true;
                    select.appendChild(option);
                });
            }

            renderFontManagerList() {
                const container = document.createElement('div');
                container.className = 'font-manager-list';
                container.id = 'fontManagerList';
                this.updateFontListUI(this.fontMgr.loadedFonts, container);
                return container;
            }

            updateFontListUI(fonts, container = document.getElementById('fontManagerList')) {
                if(!container) return;
                container.innerHTML = '';
                const deletableFonts = fonts.filter(f => !f.isEmbedded);
                if(deletableFonts.length === 0) return; 
                
                const header = document.createElement('div');
                header.className = 'control-header';
                header.style.marginTop = '0.5rem';
                header.textContent = 'Installed Custom Fonts';
                container.appendChild(header);

                deletableFonts.forEach(f => {
                    const item = document.createElement('div'); item.className = 'font-item';
                    const name = document.createElement('div'); name.className = 'font-name'; name.textContent = f.display;
                    const delBtn = document.createElement('div'); delBtn.className = 'font-delete-btn';
                    delBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
                    
                    delBtn.onclick = () => {
                        if(confirm(`Delete font "${f.display}"?`)) {
                            this.fontMgr.deleteFont(f.name).then(() => this.showStatus('Font Deleted', 'success'));
                        }
                    };
                    
                    item.append(name, delBtn);
                    container.appendChild(item);
                });
            }

            renderRange(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.appendChild(this.createLabel(def));
                
                // NEW: Only create the display span if hideValue is NOT true
                let valDisp = null;
                if (!def.hideValue) {
                    valDisp = document.createElement('span'); 
                    valDisp.id = `val-${def.id}`; 
                    header.appendChild(valDisp); 
                }
                wrapper.appendChild(header);
                
                const input = document.createElement('input'); 
                input.type = 'range'; 
                input.id = `in-${def.id}`; 
                input.min = def.min; 
                input.max = def.max; 
                if(def.step) input.step = def.step;
                
                // INVERT LOGIC: Calculate Initial UI Position
                const currentVal = this.c.get(def.id);
                input.value = def.invert ? (def.max + def.min) - currentVal : currentVal;

                input.oninput = (e) => { 
                    let uiVal = parseFloat(e.target.value);
                    
                    // INVERT LOGIC: Calculate State Value from UI Position
                    let actualVal = def.invert ? (def.max + def.min) - uiVal : uiVal;
                    
                    // Precision fix
                    if(def.step && def.step < 1) {
                        const decimals = def.step.toString().split('.')[1]?.length || 2;
                        actualVal = parseFloat(actualVal.toFixed(decimals));
                    }

                    this.c.set(def.id, actualVal); 
                    
                    // NEW: Only update display if it exists
                    if(valDisp) this.updateDisp(def, actualVal, valDisp);
                }; 
                
                wrapper.appendChild(input); 
                
                // NEW: Only update display if it exists
                if(valDisp) this.updateDisp(def, this.c.get(def.id), valDisp); 
                
                return wrapper;
            }
            
            renderColor(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const flex = document.createElement('div'); flex.className = 'color-wrapper';
                const input = document.createElement('input'); input.type = 'color'; input.id = `in-${def.id}`; input.value = this.c.get(def.id); input.oninput = (e) => this.c.set(def.id, e.target.value);
                const labelContainer = document.createElement('div'); labelContainer.style.flex = "1"; labelContainer.appendChild(this.createLabel(def));
                flex.append(input, labelContainer); wrapper.appendChild(flex); return wrapper;
            }
            
            renderCheckbox(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'checkbox-row';
                const labelGroup = document.createElement('div'); labelGroup.appendChild(this.createLabel(def));
                const input = document.createElement('input'); input.type = 'checkbox'; input.id = `in-${def.id}`; input.checked = this.c.get(def.id);
                input.onclick = (e) => e.stopPropagation(); input.onchange = (e) => this.c.set(def.id, e.target.checked);
                wrapper.onclick = () => { input.checked = !input.checked; input.dispatchEvent(new Event('change')); }; wrapper.append(labelGroup, input); return wrapper;
            }
            
            renderToggle(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.appendChild(this.createLabel(def)); wrapper.appendChild(header);
                const container = document.createElement('div'); container.className = 'toggle-switch-container';
                const slider = document.createElement('div'); slider.className = 'toggle-slider';
                const optLeft = document.createElement('div'); optLeft.className = 'toggle-option'; optLeft.textContent = def.options.left.label;
                const optRight = document.createElement('div'); optRight.className = 'toggle-option'; optRight.textContent = def.options.right.label;
                
                const currentVal = this.c.get(def.id); const isRight = currentVal === def.options.right.value;
                if(isRight) { slider.classList.add('toggle-right'); optRight.classList.add('selected'); } 
                else { slider.classList.add('toggle-left'); optLeft.classList.add('selected'); }
                
                container.onclick = () => { const newVal = this.c.get(def.id) === def.options.left.value ? def.options.right.value : def.options.left.value; this.c.set(def.id, newVal); };
                container.id = `toggle-${def.id}`; container.dataset.leftVal = def.options.left.value; container.dataset.rightVal = def.options.right.value;
                container.append(slider, optLeft, optRight); wrapper.appendChild(container); return wrapper;
            }

            renderSlot(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.textContent = `Save Slot ${def.index + 1}`; wrapper.appendChild(header);
                const container = document.createElement('div'); container.className = 'slot-container';
                const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.className = 'slot-name-input'; nameInput.value = this.c.slots[def.index].name; nameInput.onchange = (e) => this.c.renameSlot(def.index, e.target.value);
                const btnGroup = document.createElement('div'); btnGroup.className = 'slot-btn-group';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn-icon btn-save'; saveBtn.textContent = 'SAVE'; saveBtn.onclick = () => { this.c.saveToSlot(def.index); this.refresh('ALL', this.c.state); this.showStatus(`Saved ${this.c.slots[def.index].name}`, 'success'); };
                const loadBtn = document.createElement('button'); const isEmpty = !this.c.slots[def.index].data; loadBtn.className = `btn-icon btn-load ${isEmpty ? 'btn-disabled' : ''}`; loadBtn.textContent = 'LOAD'; loadBtn.disabled = isEmpty; loadBtn.onclick = () => { if(this.c.loadFromSlot(def.index)) this.showStatus(`Loaded ${this.c.slots[def.index].name}`, 'success'); };
                btnGroup.append(saveBtn, loadBtn); container.append(nameInput, btnGroup); wrapper.appendChild(container); return wrapper;
            }
            updateDisp(def, val, el) { if(el) el.textContent = def.transform ? def.transform(val) : val + (def.unit || ''); }
            
            refresh(key, state) {
                // 1. Rebuild UI if 'ALL' is passed
                if (key === 'ALL') {
                    this.els.content.innerHTML = ''; this.els.tabs.innerHTML = ''; 
                    this.els.tabs.appendChild(this.tabTrack); this.tabTrack.innerHTML = ''; 
                    this.buildUI(); return;
                }

                // 2. Update the specific input value (Standard UI update)
                const def = this.defs.find(d => d.id === key);
                if(def && !['button', 'slot', 'about_content', 'header'].includes(def.type)) {
                    if (def.type === 'toggle') {
                        const container = document.getElementById(`toggle-${key}`);
                        if(container) {
                            const slider = container.querySelector('.toggle-slider'); 
                            const opts = container.querySelectorAll('.toggle-option');
                            const val = state[key];
                            const isRight = val === container.dataset.rightVal;
                            slider.className = `toggle-slider ${isRight ? 'toggle-right' : 'toggle-left'}`;
                            opts[0].classList.toggle('selected', !isRight);
                            opts[1].classList.toggle('selected', isRight);
                        }
                    } else if (def.type === 'select') {
                        const select = document.getElementById(`in-${key}`);
                        if(select) { this._populateSelect(select, def); select.value = state[key]; }
                    } else {
                        const input = document.getElementById(`in-${key}`);
                        if(input) { 
                            if(def.type === 'checkbox') input.checked = state[key]; 
                            else input.value = def.invert ? (def.max + def.min) - state[key] : state[key];
                        }
                        const disp = document.getElementById(`val-${key}`); 
                        if(disp) this.updateDisp(def, state[key], disp);
                    }
                }

                // 3. LOGIC GATE DEPENDENCY HANDLER
                this.defs.forEach(d => {
                    if(d.dep) {
                        const wrap = document.getElementById(`in-${d.id}`)?.closest('.control-row, .checkbox-row') || document.getElementById(`toggle-${d.id}`)?.closest('.control-row');
                        
                        if (wrap) { 
                            // Convert single string dependency to array for uniform handling
                            const deps = Array.isArray(d.dep) ? d.dep : [d.dep];
                            let conditionsMet = true;

                            for (const rule of deps) {
                                let targetKey = rule;
                                let expected = true;

                                // Handle "NOT" operator (e.g. "!rotatorSync")
                                if (targetKey.startsWith('!')) {
                                    targetKey = targetKey.substring(1);
                                    expected = false;
                                }

                                // Check state
                                if (!!state[targetKey] !== expected) {
                                    conditionsMet = false;
                                    break; // Logic Gate Failed
                                }
                            }

                            // Apply State
                            if (conditionsMet) wrap.classList.remove('control-disabled'); 
                            else wrap.classList.add('control-disabled'); 
                        }
                    }
                });
            }

            handleAction(a) {
                if(a==='reset' && confirm("Reset all?")) this.c.reset();
                if(a==='clearCache' && confirm("Clear all custom fonts from storage?")) {
                    this.fontMgr.deleteAllFonts().then(() => this.showStatus('Cache Cleared', 'success'));
                }
                if(a==='export') Utils.downloadJson({version:APP_VERSION, state:this.c.state}, 'matrix_config.json');
                if(a==='import') this.els.file.click();
                if(a==='importFont') this.els.fontFile.click();
                if(a==='triggerPulse') { this.eff.triggerPulse(); this.showStatus('Pulse Triggered', 'info'); } 
                if(a==='triggerDejaVu') { this.eff.triggerDejaVu(); this.showStatus('Deja Vu Triggered', 'warn'); }
            }
            handleImport(e) { const f=e.target.files[0]; if(!f)return; const r=new FileReader(); r.onload=ev=>{ try { const d=JSON.parse(ev.target.result); this.c.state = {...this.c.defaults, ...d.state}; this.c.updateDerivedValues(); this.c.save(); this.c.notify('ALL'); this.showStatus('Imported', 'success'); } catch(e){this.showStatus('Error', 'error');}}; r.readAsText(f); }
            
            showStatus(msg, type) { 
                const toast = document.createElement('div'); toast.className = `toast-msg toast-${type}`; toast.textContent = msg;
                this.toastContainer.appendChild(toast); requestAnimationFrame(() => toast.classList.add('visible'));
                setTimeout(() => { toast.classList.remove('visible'); setTimeout(() => toast.remove(), 300); }, 3000);
            }
        }

        // --- 7. MAIN LOOP & BOOTSTRAP ---
        class MatrixEngine {
            constructor() {
                this.config = new ConfigurationManager();
                this.fontMgr = new FontManager(this.config);
                this.grid = new Grid(this.config);
                this.streamSys = new StreamSystem(this.grid, this.config);
                this.effectSys = new EffectSystem(this.grid, this.config);
                this.renderer = new MatrixRenderer('matrixCanvas', this.grid, this.config);
                this.ui = new UIManager(this.config, this.effectSys, this.fontMgr);
                
                this.fontMgr.init(); // Initialize IDB and load fonts
                
                this.frame = 0; this.lastTime = 0; this.accumulator = 0; this.timestep = 1000 / 60; 
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            loop(currentTime) {
                if (!this.lastTime) this.lastTime = currentTime;
                const deltaTime = currentTime - this.lastTime; this.lastTime = currentTime;
                this.accumulator += deltaTime; if(this.accumulator > 250) this.accumulator = 250;
                while (this.accumulator >= this.timestep) {
                    this.frame++; this.streamSys.update(this.frame); this.effectSys.update(this.frame);
                    this.accumulator -= this.timestep;
                }
                this.renderer.render(this.frame); 
                requestAnimationFrame(this.loop);
            }
        }

        window.addEventListener('DOMContentLoaded', () => new MatrixEngine());

        // Moving to the end to keep the rest of the code clear. 
        const DEFAULT_FONT_DATA = "data:font/woff2;base64,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"; 
    </script>
</body>

</html>
