<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Digital Rain v5.1.1</title>
    <style>
        /* --- CSS VARIABLES & THEME --- 
           Centralized colors allow for easy theming. 
           --bg-color: The deep black background.
           --text-main: The standard Matrix green.
           --panel-bg: The semi-transparent glass effect for the settings panel.
        */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(10, 12, 16, 0.90);
            --panel-border: rgba(34, 197, 94, 0.3);
            --text-main: #4ade80;
            --text-muted: #86efac;
            --accent: #22c55e;
            --accent-glow: rgba(34, 197, 94, 0.4);
            --danger: #ef4444;
            --info: #3b82f6;
        }
        * { box-sizing: border-box; }
        body { overflow: hidden; background-color: var(--bg-color); margin: 0; font-family: 'Segoe UI', 'Roboto', monospace; }
        
        /* --- CANVAS LAYOUT ---
           We use two canvases. #matrixCanvas is the main display.
           #bloomCanvas is hidden; it is used as an off-screen buffer to generate
           the glowing blur effect without expensive CSS filters on the main element.
        */
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #matrixCanvas { z-index: 1; transition: filter 0.3s ease; }

        /* --- SETTINGS PANEL UI --- */
        #settingsPanel {
            position: fixed; top: 0; right: 0; height: 100vh; width: 340px;
            background-color: var(--panel-bg); 
            backdrop-filter: blur(12px);
            box-shadow: -10px 0 30px rgba(0,0,0,0.8); z-index: 20;
            transform: translateX(100%); /* Hidden by default (off-screen right) */
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex; flex-direction: column;
            border-left: 1px solid var(--panel-border); 
            font-size: 0.9rem;
            color: var(--text-main);
        }
        #settingsPanel.open { transform: translateX(0); } /* Slide in */
        
        #panelHeader { 
            padding: 1.25rem; 
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(90deg, rgba(34,197,94,0.1) 0%, transparent 100%);
        }
        #panelHeader h2 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent-glow); }

        /* --- TABS NAVIGATION --- */
        #navTabs { 
            display: flex; overflow-x: auto; 
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            scrollbar-width: thin;
        }
        
        .tab-btn { 
            flex: 0 0 auto; padding: 1rem 1.25rem; 
            text-align: center; color: var(--text-muted); 
            background: none; border: none; cursor: pointer; 
            transition: all 0.2s; font-size: 0.8rem; font-weight: 600;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { color: var(--text-main); border-bottom-color: var(--accent); background: rgba(34,197,94,0.1); }

        /* --- CONTENT AREA --- */
        #contentArea { flex: 1; overflow-y: auto; padding: 1.5rem; }
        
        .control-group { 
            display: none; 
            flex-direction: column; 
            gap: 1.5rem; 
            animation: fadeIn 0.3s ease; 
        }
        .control-group.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* UX: Disabled State 
           Instead of hiding controls when a dependency (like "Enable Pulse") is off,
           we fade them out using opacity and disable pointer events. 
           This lets the user see what options are available if they were to enable the feature.
        */
        .control-disabled {
            opacity: 0.3;
            pointer-events: none;
            filter: grayscale(1);
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .control-row { width: 100%; transition: opacity 0.3s; }
        .control-header { display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: var(--text-muted); }
        
        /* Custom Range Sliders */
        input[type="range"] { 
            width: 100%; height: 6px; background: #1f2937; border-radius: 3px; outline: none;
            appearance: none; -webkit-appearance: none; padding: 0; margin: 0;
        }
        input[type="range"]::-webkit-slider-thumb { 
            width: 16px; height: 16px; background: var(--accent); border-radius: 50%; 
            cursor: pointer; box-shadow: 0 0 10px var(--accent);
            appearance: none; -webkit-appearance: none;
        }

        .color-wrapper { display: flex; align-items: center; gap: 10px; min-height: 40px; }
        input[type="color"] { border: none; width: 40px; height: 40px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; appearance: none; -webkit-appearance: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--panel-border); border-radius: 50%; }

        .checkbox-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; min-height: 40px; transition: opacity 0.3s; }
        input[type="checkbox"] { 
            width: 40px; height: 20px; background: #374151; border-radius: 20px; 
            position: relative; transition: 0.3s; cursor: pointer; appearance: none; -webkit-appearance: none;
        }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(20px); }

        .action-btn { width: 100%; padding: 0.75rem; border-radius: 6px; font-weight: 600; cursor: pointer; color: white; border: 1px solid transparent; background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transition: all 0.2s; }
        .action-btn:hover { background: rgba(34, 197, 94, 0.4); }
        .btn-info { background: rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.5); }
        .btn-info:hover { background: rgba(59, 130, 246, 0.4); }
        .btn-danger { background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.5); color: #fca5a5; }

        .slot-container { display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .slot-name-input { flex: 1; background: transparent; border: none; border-bottom: 1px solid #374151; color: var(--text-main); padding: 0.25rem; font-family: monospace; font-size: 0.9rem; min-width: 0; }
        .slot-name-input:focus { outline: none; border-color: var(--accent); }
        .slot-btn-group { display: flex; gap: 0.25rem; }
        .btn-icon { padding: 0.4rem 0.8rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; background: rgba(255,255,255,0.05); color: #ccc; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: white; }
        .btn-disabled { opacity: 0.3; cursor: not-allowed; }

        #panelFooter { padding: 1rem; border-top: 1px solid var(--panel-border); text-align: center; }
        .status-msg { font-size: 0.8rem; font-family: monospace; }
        
        /* Settings Toggle Button (Floating Cog) */
        #menuToggle { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 30; width: 44px; height: 44px; border-radius: 50%; color: var(--text-main); background: rgba(10, 12, 16, 0.6); backdrop-filter: blur(4px); border: 1px solid var(--panel-border); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        #menuToggle:hover { background: var(--accent); color: #000; box-shadow: 0 0 20px var(--accent); transform: rotate(90deg); }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <canvas id="bloomCanvas" style="display:none;"></canvas>

    <button id="menuToggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.5.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path>
        </svg>
    </button>
    <input type="file" id="importFile" accept=".json" style="display:none;" />

    <div id="settingsPanel">
        <div id="panelHeader"><h2>Settings</h2></div>
        <div id="navTabs"></div>
        <div id="contentArea"></div>
        <div id="panelFooter"><div id="globalStatus" class="status-msg"></div></div>
    </div>

    <script>
        const APP_VERSION = "5.1.1";
        
        // --- 1. CORE UTILITIES & CONSTANTS ---
        const Utils = {
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomFloat: (min, max) => Math.random() * (max - min) + min,
            // Helper to convert HTML hex color (#RRGGBB) to object {r,g,b} for canvas manipulation
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 255, b: 0 };
            },
            // The "Matrix" character set: Katakana, numbers, and some operators.
            CHARS: 'カサタナハヤラワキシチニヒミリウクヌフムケセテメオコソホヲ01245789:+=<>.*',
            getRandomChar: () => Utils.CHARS.charAt(Math.floor(Math.random() * Utils.CHARS.length)),
            // Returns a character guaranteed not to be the same as the one passed in
            getUniqueChar: (exclude) => { let c; do { c = Utils.getRandomChar(); } while (c === exclude); return c; },
            // Utility for exporting configuration to a .json file
            downloadJson: (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
        };

        // --- 2. CONFIGURATION MANAGER ---
        // Handles state management, derived calculations (for performance), and local storage.
        class ConfigurationManager {
            constructor() {
                this.storageKey = 'matrix_config_v5_1'; // Key for localStorage persistence
                this.slotsKey = 'matrix_slots_v5';      // Key for user save slots
                
                // FACTORY DEFAULTS (V5.1)
                this.defaults = {
                    streamColor: "#01cb23",
                    streamSpeed: 16, // Range: 4-20. Used to calculate frame skipping.
                    trailGlow: 28,
                    clearAlpha: 0.9, // How much the screen fades per frame (0.9 = slow fade/long trails)
                    streamMinLength: 10,
                    streamMaxLength: 125,
                    holeRate: 0.15, // Probability of a gap in the stream
                    ttlMinFrames: 12,
                    ttlMaxFrames: 110,
                    decayFadeDurationFrames: 34,
                    variableBrightnessEnabled: true,
                    brightnessVariance: 20,
                    
                    // Dissolve Effect
                    dissolveEnabled: true,
                    dissolveMinSize: 18, // Smallest pixel size characters shrink to
                    
                    // Tracer (The leading white character)
                    tracerColor: "#ffffff",
                    tracerSizeIncrease: 2, // Pixel boost for the lead char
                    tracerGlow: 25,
                    tracerAttackFrames: 8,  // Frames to fade in
                    tracerHoldFrames: 0,    // Frames to stay solid
                    tracerReleaseFrames: 6, // Frames to fade out to green
                    invertedTracerEnabled: true, // Tracers that exist in the empty space (black on black)
                    invertedTracerChance: 0.25,
                    
                    // Random Stop (Streams that stop mid-air)
                    randomStopEnabled: true,
                    randomStopChance: 0.02,
                    
                    // Rotators (Characters that cycle through values)
                    rotatorEnabled: true,
                    rotatorChance: 0.14,
                    rotatorCycleFactor: 18, // Speed of rotation
                    rotatorCrossfadeFrames: 8, // Smoothness of character change
                    
                    // Pulse Effect
                    pulseEnabled: true,
                    pulseFrequencySeconds: 180,
                    pulseDelayFrames: 60,
                    pulseDurationSeconds: 1.5,
                    pulsePreserveSpaces: true,
                    pulseRandomPosition: false,
                    
                    // Appearance & Post-Processing
                    enableBloom: true,
                    bloomStrength: 2,
                    bloomOpacity: 0.55,
                    resolution: 1, // 1.0 = Native, 0.5 = Low Res
                    smoothingEnabled: true,
                    smoothingAmount: 0.6, // CSS Blur amount
                    fontSize: 22,
                    cellSpacingFactor: 1.05, // Vertical gap
                    horizontalSpacingFactor: 1.15 // Horizontal gap
                };
                this.state = { ...this.defaults };
                this.derived = {}; // Computed values cached for performance
                this.slots = this._loadSlots();
                this.subscribers = [];
                this.load();
                this.updateDerivedValues();
            }

            // Storage helpers
            _loadSlots() { try { const s = localStorage.getItem(this.slotsKey); if (s) return JSON.parse(s); } catch (e) {} return Array(5).fill(null).map((_, i) => ({ name: `Save Slot ${i + 1}`, data: null })); }
            saveSlots() { try { localStorage.setItem(this.slotsKey, JSON.stringify(this.slots)); } catch (e) {} }
            load() { try { const s = localStorage.getItem(this.storageKey); if (s) this.state = { ...this.defaults, ...JSON.parse(s) }; } catch (e) {} }
            save() { try { localStorage.setItem(this.storageKey, JSON.stringify(this.state)); } catch (e) {} }
            get(key) { return this.state[key]; }
            
            set(key, value) {
                this.state[key] = value;
                // Validation logic for interdependent sliders
                if (key === 'streamMinLength') this.state.streamMaxLength = Math.max(this.state.streamMaxLength, value);
                if (key === 'streamMaxLength') this.state.streamMinLength = Math.min(this.state.streamMinLength, value);
                this.updateDerivedValues(); this.save(); this.notify(key);
            }
            reset() { this.state = { ...this.defaults }; this.updateDerivedValues(); this.save(); this.notify('ALL'); }
            
            saveToSlot(i) { 
                const data = typeof structuredClone === 'function' ? structuredClone(this.state) : JSON.parse(JSON.stringify(this.state));
                this.slots[i] = { name: this.slots[i].name, data: data }; 
                this.saveSlots(); 
            }
            loadFromSlot(i) { if(!this.slots[i].data) return false; this.state = { ...this.defaults, ...this.slots[i].data }; this.updateDerivedValues(); this.save(); this.notify('ALL'); return true; }
            renameSlot(i, n) { this.slots[i].name = n; this.saveSlots(); }
            subscribe(cb) { this.subscribers.push(cb); }
            notify(k) { this.subscribers.forEach(cb => cb(k, this.state)); }
            
            // Pre-calculate heavy math here so the Render Loop doesn't have to.
            updateDerivedValues() {
                const s = this.state;
                // cycleDur: High speed (20) = Low duration (1 frame). Low speed (4) = High duration (17 frames).
                const cycleDur = 21 - s.streamSpeed; 
                this.derived = {
                    cycleDuration: cycleDur,
                    // Clamp attack to ensure we don't divide by zero in render loop
                    safeAttack: Math.max(1, Math.min(s.tracerAttackFrames, cycleDur)),
                    safeRelease: Math.min(s.tracerReleaseFrames, cycleDur),
                    holdFrames: Math.max(0, s.tracerHoldFrames),
                    maxState: cycleDur + Math.max(0, s.tracerHoldFrames) + cycleDur,
                    rotatorCycleFrames: Math.max(10, Math.round(60 - (s.rotatorCycleFactor * 2.5))),
                    cellWidth: s.fontSize / s.horizontalSpacingFactor, 
                    cellHeight: (s.fontSize / s.horizontalSpacingFactor) * s.cellSpacingFactor,
                    varianceMin: 1.0 - (s.brightnessVariance / 100),
                    streamRgb: Utils.hexToRgb(s.streamColor), 
                    tracerRgb: Utils.hexToRgb(s.tracerColor)
                };
                Palette.update(s);
            }
        }

        // --- 3. DATA LAYER ---
        const Palette = {
            streamRgb: {r:0,g:255,b:0}, tracerRgb: {r:255,g:255,b:255},
            update: function(s) {
                this.streamRgb = Utils.hexToRgb(s.streamColor);
                this.tracerRgb = Utils.hexToRgb(s.tracerColor);
            }
        };

        // Enum for cell behavior states
        const CELL_TYPE = { EMPTY: 0, TRAIL: 1, TRACER: 2, ROTATOR: 3 };

        // A single character on the grid
        class Cell {
            constructor() {
                this.char = Utils.getRandomChar();
                this.nextChar = ''; // Used for Rotator transitions
                this.type = CELL_TYPE.EMPTY; 
                this.alpha = 0.0;     
                this.brightness = 1.0;
                this.crossFadeAlpha = 0.0; 
                this.age = 0;         // How long since the "Head" passed this cell
                this.decay = 0;       // 0 = Active, 1 = Start Fading, 2+ = Fading Out
                this.rotatorProg = 0; // Animation progress for character flipping
                this.override = null; // Used by Pulse Effect to overwrite visual state
            }
        }

        // The 2D Representation of the screen
        class Grid {
            constructor(c) { this.config = c; this.cols = 0; this.rows = 0; this.cells = []; }
            resize(w, h) {
                const d = this.config.derived;
                const nc = Math.max(1, Math.floor(w / d.cellWidth));
                const nr = Math.max(1, Math.floor(h / d.cellHeight));
                if (nc !== this.cols || nr !== this.rows) this.init(nc, nr);
            }
            init(c, r) {
                this.cols = c; this.rows = r;
                this.cells = Array(r).fill(null).map(() => Array(c).fill(null).map(() => new Cell()));
            }
            get(x, y) { return (y >= 0 && y < this.rows && x >= 0 && x < this.cols) ? this.cells[y][x] : null; }
        }

        // --- 4. SYSTEMS LAYER (LOGIC) ---

        // Manages the falling vertical lines ("Streams")
        class StreamSystem {
            constructor(grid, config) {
                this.grid = grid; this.config = config;
                this.streams = [];
                this.releaseTimer = 0;
            }
            
            resize() {
                if (this.streams.length !== this.grid.cols) {
                    this.streams = Array(this.grid.cols).fill(null).map((_, i) => ({
                        x: i, y: -1, active: false, delay: Utils.randomInt(0, 200),
                        len: 0, holes: new Set(), decayY: -1, decayStarted: false, 
                        age: 0, visibleLen: 0, isInverted: false
                    }));
                }
            }

            update(frame) {
                this.resize(); 
                const s = this.config.state;
                const d = this.config.derived;

                // Release new streams logic
                if (this.releaseTimer <= 0) {
                    const available = this.streams.filter(st => !st.active && st.delay <= 0).sort(() => Math.random() - 0.5);
                    // Magic Number: 4. Caps how many new streams can start per frame to prevent clumping.
                    let count = 4; 
                    for (const st of available) {
                        if (count-- <= 0) break;
                        let clear = true;
                        // Look ahead to ensure we don't overlap an existing fading stream
                        for(let y=0; y < Math.min(this.grid.rows, 40); y++) {
                            if(this.grid.get(st.x, y).decay > 0) { clear = false; break; }
                        }
                        
                        if (clear) this._activateStream(st);
                        else st.delay = 20;
                    }
                    this.releaseTimer = d.cycleDuration * 4;
                } else this.releaseTimer--;

                // Process active streams
                this.streams.forEach(st => {
                    if (!st.active) { if (st.delay > 0) st.delay--; return; }
                    
                    // Only move based on cycle duration (speed control)
                    if (frame % d.cycleDuration === 0) {
                        st.age++;
                        // Check if stream exceeded its visible life (TTL)
                        if (st.age >= st.visibleLen && !st.decayStarted) {
                            st.decayY = (st.age - st.visibleLen) - 1;
                            st.decayStarted = true;
                        }

                        // LOGIC: Random Stop
                        // If triggered, the head stops moving (len capped), but the tail continues to catch up.
                        if (!st.decayStarted && s.randomStopEnabled && Math.random() < s.randomStopChance) {
                             st.len = st.y; 
                        }

                        // Move Head
                        if (st.y < st.len) { 
                            st.y++;
                            this._writeHead(st);
                        }
                        // Move Tail (Decay)
                        if (st.decayStarted) {
                            st.decayY++;
                            this._writeTail(st);
                            // Deactivate if tail falls off screen
                            if (st.decayY >= this.grid.rows) {
                                st.active = false;
                                st.delay = Utils.randomInt(50, 150);
                            }
                        }
                    }
                });
            }

            _activateStream(st) {
                const s = this.config.state;
                st.len = Utils.randomInt(Math.min(s.streamMinLength, s.streamMaxLength), s.streamMaxLength);
                st.holes.clear();
                // Pre-calculate holes (gaps in the stream)
                for(let i=0; i<st.len; i++) if(Math.random() < s.holeRate) st.holes.add(i);
                st.isInverted = s.invertedTracerEnabled && Math.random() < s.invertedTracerChance;
                st.visibleLen = Utils.randomInt(s.ttlMinFrames, s.ttlMaxFrames);
                
                st.age = 0; st.active = true; st.y = -1; st.decayY = -1; st.decayStarted = false;
                
                let skip = 0;
                if(!st.isInverted) {
                    while(skip < st.len && st.holes.has(skip)) skip++;
                }
                st.y -= skip; 
            }

            // Determines what kind of cell to write at the head of the stream
            _writeHead(st) {
                const y = st.y; 
                const cell = this.grid.get(st.x, y);
                if (cell) {
                    const draw = st.isInverted ? st.holes.has(st.y) : !st.holes.has(st.y);
                    if (draw) {
                        // Determine if this cell will be a standard Tracer or a Rotator
                        cell.type = (this.config.state.rotatorEnabled && Math.random() < this.config.state.rotatorChance) ? CELL_TYPE.ROTATOR : CELL_TYPE.TRACER;
                        cell.age = 1; 
                        cell.decay = 1; 
                        cell.rotatorProg = 0; 
                        
                        cell.char = cell.nextChar || Utils.getRandomChar();
                        cell.nextChar = Utils.getUniqueChar(cell.char);
                        
                        cell.brightness = this.config.state.variableBrightnessEnabled 
                            ? Utils.randomFloat(this.config.derived.varianceMin, 1.0) 
                            : 1.0;
                    } else {
                        cell.type = CELL_TYPE.EMPTY;
                        cell.age = 0;
                        cell.decay = 0;
                        cell.rotatorProg = 0; 
                    }
                }
            }

            // Handles the tail end (turning active cells into decaying trails)
            _writeTail(st) {
                const cell = this.grid.get(st.x, st.decayY);
                if (cell && cell.decay === 1) cell.decay = 2; // 2 means "Start Fading Out"
            }
        }

        // Manages effects on existing cells (Aging, Rotations, Pulse overrides)
        class EffectSystem {
            constructor(grid, config) { 
                this.grid = grid; this.config = config; 
                this.pulse = new PulseEffect(grid, config);
            }
            
            triggerPulse() { this.pulse.trigger(); }

            update(frame) {
                const s = this.config.state;
                const d = this.config.derived;
                
                this.pulse.update();

                for(let y=0; y<this.grid.rows; y++) {
                    for(let x=0; x<this.grid.cols; x++) {
                        const c = this.grid.cells[y][x];
                        
                        // Increment Age (used for Tracer animation lifecycle)
                        if (c.age > 0) {
                            c.age++;
                            if (c.age > d.maxState) c.age = 0; 
                        }

                        // Handle Decay (The fading tail)
                        if (c.decay >= 2) {
                            c.decay++;
                            if (c.decay > s.decayFadeDurationFrames + 2) {
                                c.decay = 0; 
                                c.type = CELL_TYPE.EMPTY; 
                            }
                        }

                        // Handle Rotators (Cycling characters)
                        if (s.rotatorEnabled && c.type === CELL_TYPE.ROTATOR && c.age === 0 && c.decay > 0) {
                            const cyclePhase = frame % d.rotatorCycleFrames;
                            
                            // Instant Snap logic (if fade speed is very fast)
                            if (s.rotatorCrossfadeFrames <= 2) {
                                if (cyclePhase === 0) c.char = Utils.getUniqueChar(c.char);
                            } 
                            // Crossfade logic
                            else {
                                const start = d.rotatorCycleFrames - s.rotatorCrossfadeFrames;
                                if (cyclePhase === start && c.rotatorProg === 0) {
                                    const safe = y===0 || this.grid.cells[y-1][x].decay < 2;
                                    if(safe) {
                                        c.rotatorProg = 1;
                                        c.nextChar = Utils.getUniqueChar(c.char);
                                    }
                                } 
                                else if (c.rotatorProg > 0) {
                                    c.rotatorProg++;
                                    if (c.rotatorProg > s.rotatorCrossfadeFrames) {
                                        c.char = c.nextChar;
                                        c.rotatorProg = 0;
                                    }
                                }
                            }
                        }

                        c.override = this.pulse.getOverride(x, y);
                        this._calculateVisuals(c, d, s);
                    }
                }
            }

            // Calculates Alpha and Fade state based on Age/Decay
            _calculateVisuals(c, d, s) {
                if(c.override) return; 
                c.alpha = 0; 
                c.crossFadeAlpha = 0; 

                if (c.age > 0) {
                    // --- TRACER LIFECYCLE ENVELOPE ---
                    // 1. Attack (Fade In White) -> 2. Hold (Stay White) -> 3. Release (Fade White out, Green in)
                    const activeTime = c.age - 1;
                    const endPhase1 = d.cycleDuration; 
                    const endPhase2 = d.cycleDuration + d.holdFrames; 
                    
                    if (activeTime < endPhase1) {
                        const startFade = endPhase1 - d.safeAttack;
                        if (activeTime >= startFade) c.alpha = (activeTime - startFade) / d.safeAttack;
                    }
                    else if (activeTime < endPhase2) {
                        c.alpha = 1.0;
                    }
                    else {
                        const relTime = activeTime - endPhase2;
                        if (relTime < d.safeRelease) {
                            const progress = relTime / d.safeRelease;
                            c.alpha = 1.0 - progress;       // White fades out
                            c.crossFadeAlpha = progress;    // Green fades in
                        } else {
                            c.alpha = 0.0;
                            c.crossFadeAlpha = 1.0;
                        }
                    }
                }
                else if (c.decay === 1) {
                    // Just turned into a trail
                    c.alpha = 0.95 * c.brightness;
                } else if (c.decay >= 2) {
                    // Fading out
                    const p = (c.decay - 2) / s.decayFadeDurationFrames;
                    c.alpha = (0.95 * (1 - p)) * c.brightness;
                }
            }
        }

        // --- PULSE EFFECT ---
        // Handles the "Shockwave" logic
        class PulseEffect {
            constructor(g, c) { 
                this.g=g; this.c=c; this.active=false; this.state='IDLE'; this.origin={x:0,y:0}; this.radius=0; this.snap=[]; 
                this.autoTimer = c.state.pulseFrequencySeconds * 60; 
            }
            
            trigger() {
                if(this.active) return;
                const s = this.c.state;
                const d = this.c.derived;
                
                const attackEnd = d.cycleDuration;
                const holdEnd = d.cycleDuration + d.holdFrames;

                // Create a "Snapshot" of the current grid state.
                // The pulse essentially draws this snapshot over the live grid.
                this.snap = this.g.cells.map(row => row.map(c => {
                    let rgb = d.streamRgb;
                    if(c.type === CELL_TYPE.TRACER || (c.type === CELL_TYPE.ROTATOR && c.age > 0)) {
                        const activeTime = c.age - 1;
                        if (activeTime >= attackEnd && activeTime < holdEnd) {
                            rgb = d.tracerRgb; 
                        }
                    }
                    return { char: c.char, rgb: rgb, alpha: c.alpha, empty: (c.type === CELL_TYPE.EMPTY) || c.alpha < 0.05 };
                }));
                
                this.origin = s.pulseRandomPosition ? {x:Utils.randomInt(this.g.cols*0.2, this.g.cols*0.8), y:Utils.randomInt(this.g.rows*0.2, this.g.rows*0.8)} : {x:Math.floor(this.g.cols/2), y:Math.floor(this.g.rows/2)};
                
                this.active = true; 
                this.state = 'WAITING'; 
                this.timer = s.pulseDelayFrames; 
                this.radius = 0;
                
                const maxDist = Math.max(Math.abs(this.origin.x), Math.abs(this.origin.y), Math.abs(this.g.cols-this.origin.x), Math.abs(this.g.rows-this.origin.y));
                this.speed = (maxDist + 5) / Math.max(1, s.pulseDurationSeconds * 60);
            }

            update() {
                const s = this.c.state;
                // Auto-trigger timer logic
                if(!this.active && s.pulseEnabled) {
                    if(this.autoTimer-- <= 0) { this.trigger(); this.autoTimer = s.pulseFrequencySeconds * 60; }
                }
                if(!this.active) return;
                
                // Safety: If window resized, kill the pulse to avoid index errors
                if (this.snap.length !== this.g.rows || (this.snap.length > 0 && this.snap[0].length !== this.g.cols)) {
                    this.active = false;
                    this.snap = [];
                    return;
                }
                
                if(this.state==='WAITING') { 
                    if(--this.timer<=0) this.state='EXPANDING'; 
                } else {
                    this.radius += this.speed;
                    if(this.radius > Math.max(this.g.cols, this.g.rows)*1.5) { 
                        this.active = false; 
                        this.snap = []; 
                    }
                }
            }

            getOverride(x, y) {
                if(!this.active) return null;
                if(!this.snap[y] || !this.snap[y][x]) return null;

                const sn = this.snap[y][x];
                const blank = { char: ' ', color: {r:0,g:0,b:0}, alpha: 0, glow: 0 };
                const dimFactor = 0.2; // How dark the "Frozen" area looks

                if(this.state === 'WAITING') {
                    return sn.empty ? blank : { char: sn.char, color: sn.rgb, alpha: sn.alpha * dimFactor, glow: 0 };
                }

                const d = Math.max(Math.abs(x - this.origin.x), Math.abs(y - this.origin.y));
                
                // Area outside shockwave (Frozen)
                if (d > this.radius) {
                    return sn.empty ? blank : { char: sn.char, color: sn.rgb, alpha: sn.alpha * dimFactor, glow: 0 };
                } 
                // The Shockwave edge (Bright white)
                else if (d > this.radius - 6) {
                    if (sn.empty && this.c.state.pulsePreserveSpaces) return blank;
                    return { char: sn.char, color: this.c.derived.tracerRgb, alpha: 1.0, glow: 30, size: 4 };
                }
                else {
                    return null; // Inside shockwave returns to normal matrix
                }
            }
        }

        // --- 5. RENDER SYSTEM ---
        class MatrixRenderer {
            constructor(canvasId, grid, config) {
                this.cvs = document.getElementById(canvasId);
                this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.bloomCvs = document.getElementById('bloomCanvas');
                this.bloomCtx = this.bloomCvs.getContext('2d', { alpha: true });
                this.grid = grid; this.config = config;
                
                // Debounced Resize: Prevents lag when dragging window
                this.resizeTimer = null;
                window.addEventListener('resize', () => {
                    clearTimeout(this.resizeTimer);
                    this.resizeTimer = setTimeout(() => this.resize(), 100);
                });
                
                // React to config changes
                this.config.subscribe((k, s) => {
                    if (k === 'smoothingEnabled' || k === 'smoothingAmount' || k === 'ALL') {
                        this.applyStyles();
                    }
                    if (k === 'resolution') this.resize();
                });

                this.resize();
                this.applyStyles();
            }

            applyStyles() {
                const s = this.config.state;
                const blur = s.smoothingEnabled ? `${s.smoothingAmount}px` : '0px';
                this.cvs.style.filter = `blur(${blur})`;
            }

            resize() {
                const s = this.config.state;
                this.w = window.innerWidth; this.h = window.innerHeight;
                const scale = s.resolution;
                this.cvs.width = this.w * scale; 
                this.cvs.height = this.h * scale;
                this.cvs.style.width = this.w + "px";
                this.cvs.style.height = this.h + "px";
                
                // OPTIMIZATION: Bloom canvas is 1/4 size. 
                // Bloom is inherently blurry, so we don't need full res. saves massive FPS.
                this.bloomCvs.width = (this.w * scale) * 0.25; 
                this.bloomCvs.height = (this.h * scale) * 0.25; 
                
                // Permanent 0.25 scale for bloom context
                this.bloomCtx.scale(0.25, 0.25);
                
                this.grid.resize(this.w, this.h);
            }

            render() {
                const s = this.config.state;
                const d = this.config.derived;
                const bloom = s.enableBloom;
                const scale = s.resolution;

                // 1. Save Global State (and apply resolution scale)
                this.ctx.save();
                this.ctx.scale(scale, scale);

                // 2. Clear Screen (with trail fade)
                this.ctx.fillStyle = `rgba(0,0,0,${s.clearAlpha})`;
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                // Clear bloom fully (no trails on bloom)
                if (bloom) this.bloomCtx.clearRect(0, 0, this.w * scale, this.h * scale);

                const fontBase = `bold ${s.fontSize}px 'Segoe UI', monospace`;
                let currentFont = fontBase;
                
                this.ctx.font = fontBase;
                this.ctx.textBaseline = 'middle'; this.ctx.textAlign = 'center';
                
                // 3. Setup Mirror Transformation (Flipping horizontally)
                this.ctx.save(); 
                this.ctx.scale(-1, 1); 
                this.ctx.translate(-this.w, 0);
                
                if (bloom) {
                    this.bloomCtx.font = fontBase;
                    this.bloomCtx.textBaseline = 'middle'; this.bloomCtx.textAlign = 'center';
                    this.bloomCtx.save(); 
                    this.bloomCtx.scale(scale, scale); 
                    this.bloomCtx.scale(-1, 1); 
                    this.bloomCtx.translate(-this.w, 0);
                }

                // --- BATCH 1: TRAILS & DISSOLVE EFFECT ---
                // Optimization: Group all "Green" drawing commands
                const cStr = `rgb(${Palette.streamRgb.r},${Palette.streamRgb.g},${Palette.streamRgb.b})`;
                this.ctx.fillStyle = cStr;
                this.ctx.shadowBlur = 0; // Disable glow for trails (Expensive!)
                this.ctx.shadowColor = cStr;
                if(bloom) this.bloomCtx.fillStyle = cStr;

                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (cell.override) continue; 

                        const px = (x * d.cellWidth + d.cellWidth * 0.5) | 0;
                        const py = (y * d.cellHeight + d.cellHeight * 0.5) | 0;

                        let sizeOffset = 0;
                        let drawAlpha = 0;

                        // Determine Alpha
                        if (cell.age > 0) {
                            drawAlpha = cell.crossFadeAlpha * cell.brightness; // Fading in from White
                        } else if (cell.decay > 0) {
                            drawAlpha = cell.alpha;
                            // Dissolve Logic: Shrinking font size
                            if (s.dissolveEnabled && cell.decay >= 2) {
                               const prog = (cell.decay - 2) / s.decayFadeDurationFrames;
                               const targetSize = Math.max(1, s.dissolveMinSize); 
                               const reduction = s.fontSize - targetSize;
                               sizeOffset = -(reduction * prog);
                            }
                        }

                        if (drawAlpha > 0.01) {
                            // Rotator Drawing (Crossfading two chars)
                            if (cell.rotatorProg > 0 && s.rotatorCrossfadeFrames > 2) {
                                const p = cell.rotatorProg / s.rotatorCrossfadeFrames;
                                const aOld = drawAlpha * Math.cos(p * Math.PI / 2);
                                const aNew = drawAlpha * Math.sin(p * Math.PI / 2);

                                this.ctx.globalAlpha = aOld;
                                this.ctx.fillText(cell.char, px, py);
                                
                                this.ctx.globalAlpha = aNew;
                                this.ctx.fillText(cell.nextChar, px, py);

                                if(bloom) { 
                                    // Fix: Explicitly set bloom alpha to prevent state leak
                                    this.bloomCtx.globalAlpha = drawAlpha;
                                    this.bloomCtx.fillText(p > 0.5 ? cell.nextChar : cell.char, px, py); 
                                }
                            } else {
                                // Standard Character Drawing
                                this.ctx.globalAlpha = drawAlpha;
                                
                                // Handle Dynamic Font Sizing (Dissolve)
                                if (Math.abs(sizeOffset) > 0.5) {
                                    const tempFont = `bold ${Math.max(1, s.fontSize + sizeOffset)}px 'Segoe UI', monospace`;
                                    if(currentFont !== tempFont) { this.ctx.font = tempFont; currentFont = tempFont; }
                                    this.ctx.fillText(cell.char, px, py);
                                    
                                    if (bloom) {
                                        this.bloomCtx.globalAlpha = drawAlpha; 
                                        this.bloomCtx.fillText(cell.char, px, py);
                                    }
                                    
                                    // Restore font
                                    if(currentFont !== fontBase) { this.ctx.font = fontBase; currentFont = fontBase; }
                                } else {
                                    // Ensure standard font
                                    if(currentFont !== fontBase) { this.ctx.font = fontBase; currentFont = fontBase; }
                                    this.ctx.fillText(cell.char, px, py);
                                    
                                    if (bloom) {
                                        this.bloomCtx.globalAlpha = drawAlpha;
                                        this.bloomCtx.fillText(cell.char, px, py);
                                    }
                                }
                            }
                        }
                    }
                }

                // --- BATCH 2: TRACERS ---
                // Optimization: Group all "White" drawing commands
                const tStr = `rgb(${Palette.tracerRgb.r},${Palette.tracerRgb.g},${Palette.tracerRgb.b})`;
                this.ctx.fillStyle = tStr;
                this.ctx.shadowBlur = s.tracerGlow; // Enable glow ONLY for tracers
                this.ctx.shadowColor = tStr;
                const tFont = `bold ${s.fontSize + s.tracerSizeIncrease}px 'Segoe UI', monospace`;
                this.ctx.font = tFont; 
                currentFont = tFont; 

                if(bloom) { this.bloomCtx.fillStyle = tStr; this.bloomCtx.font = tFont; }

                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (cell.override) continue; 
                        
                        if (cell.age > 0 && cell.alpha > 0.01) { 
                            const px = (x * d.cellWidth + d.cellWidth * 0.5) | 0;
                            const py = (y * d.cellHeight + d.cellHeight * 0.5) | 0;

                            this.ctx.globalAlpha = cell.alpha;
                            this.ctx.fillText(cell.char, px, py);
                            
                            if (bloom) {
                                this.bloomCtx.globalAlpha = cell.alpha;
                                this.bloomCtx.fillText(cell.char, px, py);
                            }
                        }
                    }
                }

                // --- BATCH 3: OVERRIDES (PULSE) ---
                for (let y = 0; y < this.grid.rows; y++) {
                    for (let x = 0; x < this.grid.cols; x++) {
                        const cell = this.grid.cells[y][x];
                        if (!cell.override) continue;
                        
                        const o = cell.override;
                        const px = (x * d.cellWidth + d.cellWidth * 0.5) | 0;
                        const py = (y * d.cellHeight + d.cellHeight * 0.5) | 0;
                        
                        const c = o.color;
                        const fill = `rgb(${c.r},${c.g},${c.b})`;
                        
                        this.ctx.fillStyle = fill;
                        this.ctx.shadowBlur = 0;
                        this.ctx.shadowColor = fill;
                        
                        const oFont = `bold ${s.fontSize + (o.size || 0)}px monospace`;
                        if(currentFont !== oFont) { this.ctx.font = oFont; currentFont = oFont; }

                        const alpha = o.alpha !== undefined ? o.alpha : 1.0;
                        this.ctx.globalAlpha = alpha;
                        
                        this.ctx.fillText(o.char, px, py);
                        if (bloom) {
                            this.bloomCtx.fillStyle = fill;
                            this.bloomCtx.font = oFont;
                            this.bloomCtx.globalAlpha = alpha;
                            this.bloomCtx.fillText(o.char, px, py);
                        }
                    }
                }

                // 4. Cleanup Mirror State
                this.ctx.globalAlpha = 1.0;
                this.ctx.restore(); 

                // 5. Apply Bloom (Composite)
                if (bloom) {
                    this.bloomCtx.restore();
                    this.ctx.save();
                    this.ctx.globalCompositeOperation = 'lighter'; // Additive blending
                    this.ctx.filter = `blur(${s.bloomStrength * 4}px)`; // Heavy blur
                    this.ctx.globalAlpha = s.bloomOpacity; 
                    
                    // Draw the bloom canvas back onto the main canvas
                    this.ctx.drawImage(this.bloomCvs, 0, 0, this.w, this.h);
                    
                    this.ctx.restore(); 
                }
                
                // 6. FINAL RESTORE
                // Crucial: Restores the context before the resolution scale was applied.
                // Prevents the "infinite shrinking/growing" bug on resize.
                this.ctx.restore(); 
            }
        }

        // --- 6. UI MANAGER ---
        // Handles building and interacting with the Settings Panel HTML
        class UIManager {
            constructor(c, eff) {
                this.c = c; this.eff = eff;
                this.els = {
                    panel: document.getElementById('settingsPanel'), toggle: document.getElementById('menuToggle'),
                    tabs: document.getElementById('navTabs'), content: document.getElementById('contentArea'),
                    status: document.getElementById('globalStatus'), file: document.getElementById('importFile')
                };
                // Definition of all UI controls
                this.defs = [
                    { category: 'Appearance', id: 'streamColor', type: 'color', label: 'Stream Color' },
                    { category: 'Appearance', id: 'streamSpeed', type: 'range', label: 'Stream Speed', min: 4, max: 20 },
                    { category: 'Appearance', id: 'ttlMinFrames', type: 'range', label: 'Min Length (Frames)', min: 10, max: 400, unit: 'fr' },
                    { category: 'Appearance', id: 'ttlMaxFrames', type: 'range', label: 'Max Length (Frames)', min: 100, max: 600, unit: 'fr' },
                    { category: 'Appearance', id: 'decayFadeDurationFrames', type: 'range', label: 'Stream Fade Out', min: 1, max: 120, unit:'fr' },
                    { category: 'Appearance', id: 'holeRate', type: 'range', label: 'Stream Emptiness %', min: 0, max: 0.5, step: 0.05, transform: v=>(v*100).toFixed(0)+'%' },
                    { category: 'Appearance', id: 'variableBrightnessEnabled', type: 'checkbox', label: 'Variable Brightness' },
                    { category: 'Appearance', id: 'brightnessVariance', type: 'range', label: 'Variance', min: 0, max: 90, unit: '%', dep: 'variableBrightnessEnabled' },
                    { category: 'Appearance', id: 'dissolveEnabled', type: 'checkbox', label: 'Dissolve Effect' }, 
                    { category: 'Appearance', id: 'dissolveMinSize', type: 'range', label: 'Min Size', min: 1, max: 20, unit:'px', dep: 'dissolveEnabled' },
                    { category: 'Appearance', id: 'enableBloom', type: 'checkbox', label: 'Upscaling Bloom' },
                    { category: 'Appearance', id: 'bloomStrength', type: 'range', label: 'Bloom Blur', min: 0, max: 10, unit: 'px', dep: 'enableBloom' },
                    { category: 'Appearance', id: 'bloomOpacity', type: 'range', label: 'Bloom Opacity', min: 0, max: 1, step: 0.05, dep: 'enableBloom' },
                    
                    { category: 'Tracers', id: 'tracerColor', type: 'color', label: 'Tracer Color' },
                    { category: 'Tracers', id: 'tracerGlow', type: 'range', label: 'Glow Intensity', min: 0, max: 50, unit:'px' },
                    { category: 'Tracers', id: 'tracerSizeIncrease', type: 'range', label: 'Size Boost', min: 0, max: 20, unit:'px' },
                    { category: 'Tracers', id: 'tracerAttackFrames', type: 'range', label: 'Fade In (Attack)', min: 1, max: 20, unit: 'fr' },
                    { category: 'Tracers', id: 'tracerHoldFrames', type: 'range', label: 'Hold (Sustain)', min: 0, max: 60, unit: 'fr' },
                    { category: 'Tracers', id: 'tracerReleaseFrames', type: 'range', label: 'Fade Out (Release)', min: 1, max: 20, unit: 'fr' },
                    { category: 'Tracers', id: 'invertedTracerEnabled', type: 'checkbox', label: 'Hidden Tracers' },
                    { category: 'Tracers', id: 'invertedTracerChance', type: 'range', label: 'Hidden Chance', min: 0.05, max: 0.5, step: 0.05, dep: 'invertedTracerEnabled' },
                    { category: 'Tracers', id: 'randomStopEnabled', type: 'checkbox', label: 'Random Stop' },
                    { category: 'Tracers', id: 'randomStopChance', type: 'range', label: 'Stop Chance', min: 0.01, max: 0.2, step: 0.01, dep: 'randomStopEnabled' },

                    { category: 'Post-FX', id: 'resolution', type: 'range', label: 'Resolution (Scale)', min: 0.5, max: 2.0, step: 0.1, transform: v=>v+'x' },
                    { category: 'Post-FX', id: 'smoothingEnabled', type: 'checkbox', label: 'Edge Smoothing' },
                    { category: 'Post-FX', id: 'smoothingAmount', type: 'range', label: 'Smoothness', min: 0.1, max: 2.0, step: 0.1, unit: 'px', dep: 'smoothingEnabled' },

                    { category: 'Rotators', id: 'rotatorEnabled', type: 'checkbox', label: 'Enable Rotators' },
                    { category: 'Rotators', id: 'rotatorChance', type: 'range', label: 'Frequency', min: 0, max: 0.2, step: 0.01, dep: 'rotatorEnabled' },
                    { category: 'Rotators', id: 'rotatorCycleFactor', type: 'range', label: 'Rotation Speed', min: 1, max: 40, dep: 'rotatorEnabled' },
                    { category: 'Rotators', id: 'rotatorCrossfadeFrames', type: 'range', label: 'Fade Speed', min: 1, max: 9, unit: 'fr', dep: 'rotatorEnabled' },
                    
                    { category: 'Effects', id: 'pulseEnabled', type: 'checkbox', label: 'Pulse Effect' },
                    { category: 'Effects', id: 'pulseRandomPosition', type: 'checkbox', label: 'Random Position', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'pulseFrequencySeconds', type: 'range', label: 'Auto Pulse Freq', min: 15, max: 300, step: 5, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'pulseDurationSeconds', type: 'range', label: 'Pulse Duration', min: 0.5, max: 5, step: 0.5, unit: 's', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'pulsePreserveSpaces', type: 'checkbox', label: 'Preserve Spaces', dep: 'pulseEnabled' },
                    { category: 'Effects', id: 'btnManualPulse', type: 'button', label: 'Trigger Pulse', btnClass: 'action-btn', action: 'triggerPulse' }, 
                    
                    { category: 'Layout', id: 'fontSize', type: 'range', label: 'Font Size', min: 10, max: 60, unit: 'px', onUpdate: 'layout' },
                    { category: 'Layout', id: 'horizontalSpacingFactor', type: 'range', label: 'H-Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout' },
                    { category: 'Layout', id: 'cellSpacingFactor', type: 'range', label: 'V-Spacing', min: 0.5, max: 2, step: 0.05, onUpdate: 'layout' },
                    { category: 'Layout', id: 'streamMinLength', type: 'range', label: 'Min Stream', min: 10, max: 300, unit: 'rows' },
                    { category: 'Layout', id: 'streamMaxLength', type: 'range', label: 'Max Stream', min: 50, max: 500, unit: 'rows' },
                    
                    { category: 'System', id: 'slot0', type: 'slot', index: 0 },
                    { category: 'System', id: 'slot1', type: 'slot', index: 1 },
                    { category: 'System', id: 'slot2', type: 'slot', index: 2 },
                    { category: 'System', id: 'btnExport', type: 'button', label: 'Export JSON', btnClass: 'btn-info', action: 'export' },
                    { category: 'System', id: 'btnImport', type: 'button', label: 'Import JSON', btnClass: 'btn-info', action: 'import' },
                    { category: 'System', id: 'btnForceReset', type: 'button', label: 'Factory Reset', btnClass: 'btn-danger', action: 'reset' },

                    { category: 'About', type: 'about_content' }
                ];
                this.init();
            }

            init() {
                this.els.toggle.addEventListener('click', () => this.els.panel.classList.toggle('open'));
                this.els.file.addEventListener('change', (e) => this.handleImport(e));
                this.c.subscribe((k, s) => this.refresh(k, s));
                this.els.tabs.addEventListener('wheel', (e) => { if (e.deltaY !== 0) { e.preventDefault(); this.els.tabs.scrollLeft += e.deltaY; }});
                this.buildUI();
            }

            buildUI() {
                const cats = [...new Set(this.defs.map(d => d.category))];
                cats.forEach((cat, i) => {
                    const btn = document.createElement('button');
                    btn.className = `tab-btn ${i===0?'active':''}`;
                    btn.textContent = cat;
                    btn.onclick = () => this.switchTab(cat, btn);
                    this.els.tabs.appendChild(btn);

                    const group = document.createElement('div');
                    group.className = `control-group ${i===0?'active':''}`;
                    group.id = `group-${cat}`;
                    
                    this.defs.filter(d => d.category === cat).forEach(def => {
                        let el;
                        if(def.type === 'range') el = this.renderRange(def);
                        else if(def.type === 'color') el = this.renderColor(def);
                        else if(def.type === 'checkbox') el = this.renderCheckbox(def);
                        else if(def.type === 'slot') el = this.renderSlot(def);
                        else if(def.type === 'button') {
                            el = document.createElement('button');
                            el.className = `action-btn ${def.btnClass}`;
                            el.textContent = def.label;
                            el.onclick = () => this.handleAction(def.action);
                        }
                        else if(def.type === 'about_content') {
                            el = this.renderAbout();
                        }

                        if(el) group.appendChild(el);
                    });
                    if(cat==='Layout') {
                        const b = document.createElement('button'); b.className='action-btn btn-info'; b.textContent='Apply Layout'; b.onclick=()=>window.dispatchEvent(new Event('resize')); group.appendChild(b);
                    }
                    this.els.content.appendChild(group);
                });
            }

            renderAbout() {
                const div = document.createElement('div');
                div.style.padding = '1rem';
                div.style.textAlign = 'center';
                div.style.color = '#86efac';
                div.innerHTML = `
                    <h3 style="margin-top:0; margin-bottom: 1rem; color:#fff; font-size: 1.1rem; letter-spacing:1px;">Matrix Digital Rain</h3>
                    <div style="background:rgba(255,255,255,0.05); padding:1rem; border-radius:8px; margin-bottom:1.5rem;">
                        <p style="margin:0.5rem 0;"><strong>Version:</strong> ${APP_VERSION}</p>
                        <p style="margin:0.5rem 0;"><strong>Created:</strong> November 2025</p>
                    </div>
                    <p style="font-size:0.9rem;">
                        <a href="https://github.com/enigmahack" target="_blank" style="color:#22c55e; text-decoration:none; border-bottom:1px solid #22c55e; padding-bottom:2px; transition:all 0.2s;">
                            github.com/enigmahack
                        </a>
                    </p>
                    <div style="margin-top:2rem; font-size:0.75rem; color:#6b7280; font-style:italic;">
                        Bringing you The Matrix Code <br> In your browser.
                    </div>
                `;
                return div;
            }

            switchTab(cat, btn) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.control-group').forEach(g => g.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`group-${cat}`).classList.add('active');
            }
            renderRange(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.innerHTML = `<span>${def.label}</span><span id="val-${def.id}"></span>`; wrapper.appendChild(header);
                const input = document.createElement('input'); input.type = 'range'; input.id = `in-${def.id}`; input.min = def.min; input.max = def.max; if(def.step) input.step = def.step; input.value = this.c.get(def.id);
                input.oninput = (e) => { this.c.set(def.id, parseFloat(e.target.value)); };
                wrapper.appendChild(input); this.updateDisp(def, input.value, wrapper.querySelector(`#val-${def.id}`)); return wrapper;
            }
            renderColor(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const flex = document.createElement('div'); flex.className = 'color-wrapper';
                const input = document.createElement('input'); input.type = 'color'; input.id = `in-${def.id}`; input.value = this.c.get(def.id); input.oninput = (e) => this.c.set(def.id, e.target.value);
                const label = document.createElement('label'); label.textContent = def.label; label.style.flex = "1"; flex.append(input, label); wrapper.appendChild(flex); return wrapper;
            }
            renderCheckbox(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'checkbox-row';
                const labelGroup = document.createElement('div'); const label = document.createElement('div'); label.textContent = def.label; labelGroup.appendChild(label);
                const input = document.createElement('input'); input.type = 'checkbox'; input.id = `in-${def.id}`; input.checked = this.c.get(def.id);
                input.onclick = (e) => e.stopPropagation(); input.onchange = (e) => this.c.set(def.id, e.target.checked);
                wrapper.onclick = () => { input.checked = !input.checked; input.dispatchEvent(new Event('change')); }; wrapper.append(labelGroup, input); return wrapper;
            }
            renderSlot(def) {
                const wrapper = document.createElement('div'); wrapper.className = 'control-row';
                const header = document.createElement('div'); header.className = 'control-header'; header.textContent = `Save Slot ${def.index + 1}`; wrapper.appendChild(header);
                const container = document.createElement('div'); container.className = 'slot-container';
                const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.className = 'slot-name-input'; nameInput.value = this.c.slots[def.index].name; nameInput.onchange = (e) => this.c.renameSlot(def.index, e.target.value);
                const btnGroup = document.createElement('div'); btnGroup.className = 'slot-btn-group';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn-icon btn-save'; saveBtn.textContent = 'SAVE'; saveBtn.onclick = () => { this.c.saveToSlot(def.index); this.refresh('ALL', this.c.state); this.showStatus(`Saved ${this.c.slots[def.index].name}`, 'success'); };
                const loadBtn = document.createElement('button'); const isEmpty = !this.c.slots[def.index].data; loadBtn.className = `btn-icon btn-load ${isEmpty ? 'btn-disabled' : ''}`; loadBtn.textContent = 'LOAD'; loadBtn.disabled = isEmpty; loadBtn.onclick = () => { if(this.c.loadFromSlot(def.index)) this.showStatus(`Loaded ${this.c.slots[def.index].name}`, 'success'); };
                btnGroup.append(saveBtn, loadBtn); container.append(nameInput, btnGroup); wrapper.appendChild(container); return wrapper;
            }
            updateDisp(def, val, el) { if(el) el.textContent = def.transform ? def.transform(val) : val + (def.unit || ''); }
            refresh(key, state) {
                if(key === 'ALL') { this.els.content.innerHTML=''; this.els.tabs.innerHTML=''; this.buildUI(); return; }
                const def = this.defs.find(d => d.id === key);
                if(def && def.type !== 'button' && def.type !== 'slot' && def.type !== 'about_content') {
                    const input = document.getElementById(`in-${key}`);
                    if(input) { if(def.type === 'checkbox') input.checked = state[key]; else input.value = state[key]; }
                    const disp = document.getElementById(`val-${key}`);
                    this.updateDisp(def, state[key], disp);
                }
                
                // Logic: Fade disabled controls
                this.defs.forEach(d => {
                    if(d.dep === key) {
                        const wrap = document.getElementById(`in-${d.id}`)?.closest('.control-row, .checkbox-row');
                        if(wrap) {
                            if (state[key]) wrap.classList.remove('control-disabled');
                            else wrap.classList.add('control-disabled');
                        }
                    }
                });
            }

            handleAction(a) {
                if(a==='reset' && confirm("Reset all?")) this.c.reset();
                if(a==='export') Utils.downloadJson({version:APP_VERSION, state:this.c.state}, 'matrix_config.json');
                if(a==='import') this.els.file.click();
                if(a==='triggerPulse') { this.eff.triggerPulse(); this.showStatus('Pulse Triggered', 'info'); } 
            }
            handleImport(e) { const f=e.target.files[0]; if(!f)return; const r=new FileReader(); r.onload=ev=>{ try { const d=JSON.parse(ev.target.result); this.c.state = {...this.c.defaults, ...d.state}; this.c.updateDerivedValues(); this.c.save(); this.c.notify('ALL'); this.showStatus('Imported', 'success'); } catch(e){this.showStatus('Error', 'error');}}; r.readAsText(f); }
            showStatus(msg, type) { this.els.status.textContent=msg; this.els.status.style.color = type==='error'?'#ef4444':'#4ade80'; setTimeout(()=>this.els.status.textContent='',3000); }
        }

        // --- 7. MAIN LOOP & BOOTSTRAP ---
        class MatrixEngine {
            constructor() {
                // Initialize all subsystems
                this.config = new ConfigurationManager();
                this.grid = new Grid(this.config);
                this.streamSys = new StreamSystem(this.grid, this.config);
                this.effectSys = new EffectSystem(this.grid, this.config);
                this.renderer = new MatrixRenderer('matrixCanvas', this.grid, this.config);
                this.ui = new UIManager(this.config, this.effectSys);
                
                this.frame = 0;
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            // The central heart-beat of the application
            loop() {
                this.frame++;
                this.streamSys.update(this.frame);
                this.effectSys.update(this.frame);
                this.renderer.render(); // Draw the result
                requestAnimationFrame(this.loop);
            }
        }

        // Start the engine when the DOM is ready
        window.addEventListener('DOMContentLoaded', () => new MatrixEngine());

    </script>
</body>
</html>